{"id": 36, "filename": "LeetCode_36_trap.java", "content": "import java.util.Arrays;\n\npublic class TrapWater {\n    public static int trapWater(int[] height) {\n        // Preconditions\n        assert height instanceof int[] : \"height should be an array\";\n        assert Arrays.stream(height).allMatch(h -> h >= 0) : \"All elements in height should be non-negative\";\n        assert height.length >= 1 : \"height should contain at least one element\";\n        assert Arrays.stream(height).allMatch(h -> h <= 105) : \"All elements in height should be between 0 and 105\";\n        assert height.length <= 20000 : \"The length of height should be at most 20000\";\n\n        int n = height.length;\n        int left = 0, right = n - 1;\n        int maxLeft = 0, maxRight = 0;\n        int water = 0;\n\n        while (left < right) {\n            if (height[left] <= height[right]) {\n                maxLeft = Math.max(maxLeft, height[left]);\n                water += maxLeft - height[left];\n                left++;\n            } else {\n                maxRight = Math.max(maxRight, height[right]);\n                water += maxRight - height[right];\n                right--;\n            }\n        }\n\n        // Postconditions\n        assert water >= 0 : \"The trapped water should be non-negative\";\n        assert water == 0 || Arrays.stream(height).allMatch(h -> h == height[0]) : \"If all heights are the same, no water should be trapped\";\n        assert water == 0 || height.length <= 2 : \"If there are fewer than 3 elements, no water can be trapped\";\n        assert height.length >= 1 : \"There should be at least one height value to process\";\n\n        return water;\n    }\n\n    public static void main(String[] args) {\n        // Unit tests\n        assert trapWater(new int[]{1, 0, 1, 0, 1}) == 2;\n        assert trapWater(new int[]{6, 5, 4, 3, 2, 1, 2, 3, 4, 5, 6}) == 25;\n        assert trapWater(new int[]{1, 2, 3, 4, 5, 0, 5, 4, 3, 2, 1}) == 5;\n        // Add more unit tests here\n    }\n}"}
{"id": 75, "filename": "LeetCode_75_largestRectangleArea.java", "content": "import java.util.Stack;\n\npublic class LargestRectangleArea {\n\n    public static int largestRectangleArea(int[] heights) {\n        if (heights == null || heights.length == 0) {\n            return 0;\n        }\n\n        Stack<Integer> stack = new Stack<>();\n        int maxArea = 0;\n        int i = 0;\n        for (i = 0; i <= heights.length; i++) {\n            int h = (i == heights.length) ? 0 : heights[i];\n            while (!stack.isEmpty() && heights[stack.peek()] > h) {\n                int height = heights[stack.pop()];\n                int width = stack.isEmpty() ? i : i - stack.peek() - 1;\n                maxArea = Math.max(maxArea, height * width);\n            }\n            stack.push(i);\n        }\n\n        return maxArea;\n    }\n\n    public static void main(String[] args) {\n        int[] heights1 = {2, 1, 5, 6, 2, 3};\n        int[] heights2 = {2, 4};\n\n        System.out.println(largestRectangleArea(heights1)); // Output: 10\n        System.out.println(largestRectangleArea(heights2)); // Output: 4\n    }\n}"}
{"id": 91, "filename": "LeetCode_91_numDistinct.java", "content": "public class DistinctSubsequences {\n    public int numDistinct(String s, String t) {\n        assert s != null : \"s should not be null\";\n        assert t != null : \"t should not be null\";\n        assert s.length() >= 0 && s.length() <= 1000 : \"Length of s should be between 0 and 1000\";\n        assert t.length() >= 0 && t.length() <= 1000 : \"Length of t should be between 0 and 1000\";\n        assert s.matches(\"[a-zA-Z]+\") : \"s should only contain English letters\";\n        assert t.matches(\"[a-zA-Z]+\") : \"t should only contain English letters\";\n\n        int m = s.length(), n = t.length();\n        int[][] dp = new int[m + 1][n + 1];\n\n        for (int i = 0; i <= m; i++) {\n            dp[i][0] = 1;\n        }\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n\n        int result = dp[m][n];\n\n        assert result >= 0 : \"The number of distinct subsequences cannot be negative\";\n        assert s.length() < t.length() ? result == 0 : true : \"If s is shorter than t, result should be 0\";\n        assert !(t.isEmpty()) ? result <= Math.pow(2, s.length()) : true : \"The result should be at most 2^len(s) if t is empty\";\n        assert t.isEmpty() ? result == 1 : true : \"If t is an empty string, the result should be 1\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        DistinctSubsequences distinctSubsequences = new DistinctSubsequences();\n        distinctSubsequences.testCheck();\n    }\n\n    public void testCheck() {\n        assert numDistinct(\"abc\", \"abcabc\") == 0;\n        assert numDistinct(\"xyz\", \"xy\") == 1;\n        assert numDistinct(\"xyz\", \"x\") == 1;\n        assert numDistinct(\"xyz\", \"yz\") == 1;\n        assert numDistinct(\"xyz\", \"x\") == 1;\n        assert numDistinct(\"xyz\", \"y\") == 1;\n        assert numDistinct(\"abcabc\", \"ab\") == 3;\n        assert numDistinct(\"abcabc\", \"bc\") == 3;\n        assert numDistinct(\"rabbbit\", \"rabbit\") == 3;\n        assert numDistinct(\"aaaaaa\", \"aa\") == 15;\n        assert numDistinct(\"abcabcabcabcabcabc\", \"abcabcabcabcabcabc\") == 1;\n        assert numDistinct(\"xyz\", \"xy\") == 1;\n        assert numDistinct(\"\", \"\") == 1;\n        assert numDistinct(\"xyz\", \"xz\") == 1;\n        assert numDistinct(\"a\", \"\") == 1;\n        assert numDistinct(\"abcabc\", \"abcabca\") == 0;\n        assert numDistinct(\"xyz\", \"w\") == 0;\n        assert numDistinct(\"xyz\", \"y\") == 1;\n        assert numDistinct(\"xyz\", \"xyz\") == 1;\n        assert numDistinct(\"abcabcabcabcabcabc\", \"abcabcabcabcabcabca\") == 0;\n        assert numDistinct(\"babgbag\", \"bag\") == 5;\n        assert numDistinct(\"abcabcabcabcabcabc\", \"a\") == 6;\n        assert numDistinct(\"abcabcabcabcabcabc\", \"abcabcabcabcabcabc\") == 1;\n        assert numDistinct(\"xyz\", \"z\") == 1;\n        assert numDistinct(\"abcabc\", \"abcabc\") == 1;\n        assert numDistinct(\"abcde\", \"ace\") == 1;\n        assert numDistinct(\"a\", \"\") == 1;\n        assert numDistinct(\"abcabcabcabcabcabc\", \"a\") == 6;\n        assert numDistinct(\"abcabc\", \"abcabca\") == 0;\n        assert numDistinct(\"abcabcabcabcabcabc\", \"abcabcabcabcabcabca\") == 0;\n        assert numDistinct(\"xyz\", \"w\") == 0;\n        assert numDistinct(\"xyz\", \"xz\") == 1;\n        assert numDistinct(\"abcabc\", \"bc\") == 3;\n        assert numDistinct(\"abcabc\", \"b\") == 2;\n        assert numDistinct(\"xyz\", \"z\") == 1;\n        assert numDistinct(\"babgbag\", \"bag\") == 5;\n        assert numDistinct(\"abcabc\", \"a\") == 2;\n        assert numDistinct(\"abcabc\", \"c\") == 2;\n        assert numDistinct(\"\", \"\") == 1;\n        assert numDistinct(\"abcde\", \"ace\") == 1;\n        assert numDistinct(\"abcabc\", \"a\") == 2;\n        assert numDistinct(\"rabbbit\", \"rabbit\") == 3;\n        assert numDistinct(\"xyz\", \"xyz\") == 1;\n        assert numDistinct(\"abc\", \"abcabc\") == 0;\n    }\n\n}"}
{"id": 150, "filename": "LeetCode_150_findWords.java", "content": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<String> findWords(char[][] board, String[] words) {\n        // Preconditions\n        assert board != null && board.length > 0 : \"Board must not be null and should have non-zero dimensions\";\n        assert words != null && words.length > 0 : \"Words must not be null and should have elements\";\n        int m = board.length;\n        int n = board[0].length;\n        assert 1 <= m && m <= 12 && 1 <= n && n <= 12 : \"Board dimensions must be between 1 and 12\";\n\n        List<String> res = new ArrayList<>();\n\n        for (String word : words) {\n            if (exist(board, word)) {\n                res.add(word);\n            }\n        }\n\n        // Postconditions\n        assert res != null : \"The result should not be null\";\n        assert res.size() <= words.length : \"The result length should not exceed the input words length\";\n        assert res.stream().allMatch(s -> s.length() <= 10) : \"Each word in the result should have a valid length\";\n        assert res.size() == (new HashSet<>(res)).size() : \"All words in the result should be unique\";\n\n        return res;\n    }\n\n    private boolean exist(char[][] board, String word) {\n        if (board == null || board.length == 0) {\n            return false;\n        }\n\n        int m = board.length;\n        int n = board[0].length;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dfs(board, word, 0, i, j)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean dfs(char[][] board, String word, int index, int i, int j) {\n        if (index == word.length()) {\n            return true;\n        }\n\n        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] != word.charAt(index)) {\n            return false;\n        }\n\n        char temp = board[i][j];\n        board[i][j] = '#';\n\n        boolean found = dfs(board, word, index + 1, i - 1, j) || dfs(board, word, index + 1, i + 1, j) ||\n                       dfs(board, word, index + 1, i, j - 1) || dfs(board, word, index + 1, i, j + 1);\n\n        board[i][j] = temp;\n\n        return found;\n    }\n}\n\n// Unit tests\npublic class Main {\n    public static void main(String[] args) {\n        check(Solution::findWords);\n    }\n\n    private static void check(Function<char[][], String[], List<String>> candidate) {\n        assert candidate.apply(new char[][]{{'a', 'b'}, {'c', 'd'}}, new String[]{\"ac\", \"bd\"}).equals(List.of(\"ac\", \"bd\"));\n        assert candidate.apply(new char[][]{{'a', 'b'}, {'c', 'd'}}, new String[]{\"abcd\"}).isEmpty();\n        assert candidate.apply(new char[][]{{'o', 'a', 'b', 'n'}, {'o', 't', 'a', 'e'}, {'a', 'h', 'k', 'r'}, {'a', 'f', 'l', 'v'}}, new String[]{\"oa\", \"oaa\"}).equals(List.of(\"oa\", \"oaa\"));\n        assert candidate.apply(new char[][]{{'a'}}, new String[]{\"a\"}).equals(List.of(\"a\"));\n        assert candidate.apply(new char[][]{{'a', 'a', 'a'}, {'a', 'a', 'a'}, {'a', 'a', 'a'}}, new String[]{\"aaa\", \"aaaa\", \"aaaaa\"}).equals(List.of(\"aaa\", \"aaaa\", \"aaaaa\"));\n        assert candidate.apply(new char[][]{{'a', 'b', 'c'}, {'d', 'e', 'f'}, {'g', 'h', 'i'}}, new String[]{\"a\", \"e\", \"i\"}).equals(List.of(\"a\", \"e\", \"i\"));\n        assert candidate.apply(new char[][]{{'a', 'b', 'c'}, {'d', 'e', 'f'}, {'g', 'h', 'i'}}, new String[]{\"adg\", \"beh\", \"cfi\"}).equals(List.of(\"adg\", \"beh\", \"cfi\"));\n        assert candidate.apply(new char[][]{{'a', 'b'}, {'c', 'd'}}, new String[]{\"abcb\"}).isEmpty();\n    }\n\n}"}
{"id": 224, "filename": "LeetCode_224_countSmaller.java", "content": "import java.util.*;\n\npublic class CountSmaller {\n\n    public static List<Integer> countSmaller(List<Integer> nums) {\n        // Preconditions\n        assert nums instanceof List : \"Input must be a list\";\n        assert nums.stream().allMatch(num -> num instanceof Integer) : \"All elements in the list must be integers\";\n        assert nums.size() >= 1 && nums.size() <= 105 : \"List length must be between 1 and 105\";\n        assert nums.stream().allMatch(num -> num >= -104 && num <= 104) : \"Each integer must be between -104 and 104\";\n\n        List<Integer> counts = new ArrayList<>(Collections.nCopies(nums.size(), 0));\n        mergeSort(nums, counts);\n\n        // Postconditions\n        assert counts instanceof List : \"The output must be a list\";\n        assert counts.stream().allMatch(c -> c instanceof Integer) : \"All elements in the output list must be integers\";\n        assert counts.size() == nums.size() : \"The output list must have the same length as the input list\";\n        assert counts.stream().allMatch(c -> c >= 0) : \"All elements in the output list must be non-negative integers\";\n\n        return counts;\n    }\n\n    private static void mergeSort(List<Integer> nums, List<Integer> counts) {\n        List<Integer> indices = new ArrayList<>();\n        for (int i = 0; i < nums.size(); i++) {\n            indices.add(i);\n        }\n        mergeSortHelper(nums, counts, indices);\n    }\n\n    private static List<Integer> mergeSortHelper(List<Integer> nums, List<Integer> counts, List<Integer> indices) {\n        if (indices.size() <= 1) {\n            return indices;\n        }\n        int mid = indices.size() / 2;\n        List<Integer> left = mergeSortHelper(nums, counts, new ArrayList<>(indices.subList(0, mid)));\n        List<Integer> right = mergeSortHelper(nums, counts, new ArrayList<>(indices.subList(mid, indices.size())));\n        return merge(nums, counts, indices, left, right);\n    }\n\n    private static List<Integer> merge(List<Integer> nums, List<Integer> counts, List<Integer> indices, List<Integer> left, List<Integer> right) {\n        List<Integer> merged = new ArrayList<>();\n        int count = 0;\n        while (!left.isEmpty() && !right.isEmpty()) {\n            if (nums.get(left.get(0)) <= nums.get(right.get(0))) {\n                counts.set(left.get(0), counts.get(left.get(0)) + count);\n                merged.add(left.remove(0));\n            } else {\n                count += left.size();\n                merged.add(right.remove(0));\n            }\n        }\n        for (int i : left) {\n            counts.set(i, counts.get(i) + count);\n        }\n        return new ArrayList<>(merged);\n    }\n\n    public static void main(String[] args) {\n        List<Integer> input = new ArrayList<>(Arrays.asList(5, 2, 6, 1));\n        List<Integer> result = countSmaller(input);\n        System.out.println(result); // Output: [2, 1, 1, 0]\n    }\n}"}
{"id": 239, "filename": "LeetCode_239_findItinerary.java", "content": "import java.util.*;\n\npublic class Solution {\n\n    public List<String> findItinerary(List<List<String>> tickets) {\n        assert tickets instanceof List : \"Input tickets should be a list of lists\";\n        assert tickets.stream().allMatch(ticket -> ticket instanceof List && ticket.size() == 2) : \"Each ticket must be a list of two elements\";\n        assert tickets.stream().allMatch(ticket -> ticket.get(0) instanceof String && ticket.get(1) instanceof String) : \"All elements in tickets must be strings\";\n        assert tickets.stream().allMatch(ticket -> ticket.get(0).length() == 3 && ticket.get(1).length() == 3) : \"Airport codes must be three characters long\";\n        assert tickets.stream().allMatch(ticket -> !ticket.get(0).equals(ticket.get(1))) : \"Departure and arrival airports must be different\";\n\n        Map<String, List<String>> flights = new HashMap<>();\n        List<String> itinerary = new ArrayList<>();\n\n        for(List<String> ticket : tickets) {\n            flights.computeIfAbsent(ticket.get(0), k -> new ArrayList<>()).add(ticket.get(1));\n            flights.get(ticket.get(0)).sort(Comparator.reverseOrder());\n        }\n\n        dfs(\"JFK\", flights, itinerary);\n\n        List<String> result = new ArrayList<>(itinerary);\n        Collections.reverse(result);\n\n        assert result instanceof List : \"The output must be a list\";\n        assert result.stream().allMatch(airport -> airport instanceof String) : \"All elements in the output list must be strings\";\n        assert result.get(0).equals(\"JFK\") : \"The itinerary must start with 'JFK'\";\n        assert result.size() == tickets.size() + 1 : \"The itinerary should include all flights plus the starting point\";\n        \n        for(int i = 0; i < result.size() - 1; i++) {\n            assert tickets.contains(Arrays.asList(result.get(i), result.get(i + 1))) : \"The pair [\" + result.get(i) + \", \" + result.get(i + 1) + \"] must be in the list of tickets\";\n        }\n\n        return result;\n    }\n\n    private void dfs(String airport, Map<String, List<String>> flights, List<String> itinerary) {\n        while(flights.containsKey(airport) && !flights.get(airport).isEmpty()) {\n            dfs(flights.get(airport).remove(flights.get(airport).size() - 1), flights, itinerary);\n        }\n        itinerary.add(airport);\n    }\n\n    // Unit tests\n    public void check(Function<List<List<String>>, List<String>> candidate) {\n        assert candidate.apply(Arrays.asList(Arrays.asList(\"MUC\", \"LHR\"), Arrays.asList(\"JFK\", \"MUC\"), Arrays.asList(\"SFO\", \"SJC\"), Arrays.asList(\"LHR\", \"SFO\"))).equals(Arrays.asList(\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"));\n        // Add more assertion checks here as needed\n    }\n\n    public void testCheck() {\n        check(this::findItinerary);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.testCheck();\n    }\n}"}
{"id": 255, "filename": "LeetCode_255_max_envelopes.java", "content": "import java.util.Arrays;\n\npublic class RussianDollEnvelopes {\n\n    public int maxEnvelopes(int[][] envelopes) {\n        assert envelopes != null : \"Input must not be null\";\n        assert envelopes.length >= 1 : \"There must be at least one envelope\";\n\n        Arrays.sort(envelopes, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\n        \n        int[] dp = new int[envelopes.length];\n        int len = 0;\n        \n        for (int[] envelope : envelopes) {\n            int index = Arrays.binarySearch(dp, 0, len, envelope[1]);\n            if (index < 0) {\n                index = -(index + 1);\n            }\n            dp[index] = envelope[1];\n            if (index == len) {\n                len++;\n            }\n        }\n        \n        return len;\n    }\n\n    public static void main(String[] args) {\n        RussianDollEnvelopes rde = new RussianDollEnvelopes();\n        int[][] envelopes1 = {{5, 4}, {6, 4}, {6, 7}, {2, 3}, {1, 2}};\n        System.out.println(rde.maxEnvelopes(envelopes1)); // Output: 4\n        int[][] envelopes2 = {{1, 1}, {1, 1}, {1, 1}};\n        System.out.println(rde.maxEnvelopes(envelopes2)); // Output: 1\n        // Add more test cases as needed\n    }\n}"}
{"id": 343, "filename": "LeetCode_343_getMaxRepetitions.java", "content": "public class Main {\n\n    public static int getMaxRepetitions(String s1, int n1, String s2, int n2) {\n        assert s1 instanceof String : \"s1 must be a string\";\n        assert s2 instanceof String : \"s2 must be a string\";\n        assert n1 instanceof Integer && n1 >= 0 : \"n1 must be a positive integer\";\n        assert n2 instanceof Integer && n2 >= 0 : \"n2 must be a positive integer\";\n        assert s1.length() >= 1 && s1.length() <= 100 : \"Length of s1 must be between 1 and 100\";\n        assert s2.length() >= 1 && s2.length() <= 100 : \"Length of s2 must be between 1 and 100\";\n\n        int count1 = 0, count2 = 0, i = 0, j = 0;\n        while (count1 < n1) {\n            if (s1.charAt(i) == s2.charAt(j)) {\n                j++;\n                if (j == s2.length()) {\n                    j = 0;\n                    count2++;\n                }\n            }\n            i++;\n            if (i == s1.length()) {\n                i = 0;\n                count1++;\n            }\n        }\n        int result = count2 / n2;\n\n        assert result instanceof Integer : \"Result must be an integer\";\n        assert result >= 0 : \"Result must be non-negative\";\n        assert result <= n1 * s1.length() / (n2 * s2.length()) : \"Result must be less than or equal to the ratio of lengths and counts\";\n        if (s1.equals(s2) && n1 == n2) {\n            assert result == 1 : \"If s1 equals s2 and n1 equals n2, the result should be 1\";\n        }\n        if (n1 == 0 || n2 == 0) {\n            assert result == 0 : \"If either n1 or n2 is 0, the result should be 0\";\n        }\n        if (s2.chars().anyMatch(c -> s1.indexOf(c) == -1)) {\n            assert result == 0 : \"If s2 contains characters not in s1, the result should be 0\";\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        assert getMaxRepetitions(\"abcdabcdabcdabcdabcdabcd\", 1, \"abcdabcd\", 3) == 1;\n        assert getMaxRepetitions(\"abcd\", 1, \"ab\", 2) == 0;\n        // Add more test cases here as needed\n    }\n}"}
{"id": 364, "filename": "LeetCode_364_find_min_step.java", "content": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class ZumaGame {\n\n    public static int findMinStep(String board, String hand) {\n        assert board != null : \"Board must not be null.\";\n        assert hand != null : \"Hand must not be null.\";\n        assert board.length() >= 1 && board.length() <= 16 : \"Board length must be between 1 and 16.\";\n        assert board.matches(\"[RYBGW]+\") : \"Board contains invalid characters.\";\n        assert hand.matches(\"[RYBGW]+\") : \"Hand contains invalid characters.\";\n\n        Map<Character, Integer> handCount = new HashMap<>();\n        for (char c : hand.toCharArray()) {\n            handCount.put(c, handCount.getOrDefault(c, 0) + 1);\n        }\n\n        Map<String, Integer> memo = new HashMap<>();\n        int result = findMinStepHelper(board, memo, handCount);\n\n        assert result >= -1 : \"Result must be greater than or equal to -1.\";\n        if (board.isEmpty()) {\n            assert result == 0 : \"If the board is initially empty, the result should be 0.\";\n        }\n        if (result == -1) {\n            assert !board.isEmpty() : \"If the result is -1, there should still be balls left on the board.\";\n        }\n\n        return result;\n    }\n\n    private static int findMinStepHelper(String board, Map<String, Integer> memo, Map<Character, Integer> hand) {\n        if (board.isEmpty()) {\n            return 0;\n        }\n        if (memo.containsKey(board)) {\n            return memo.get(board);\n        }\n\n        int result = Integer.MAX_VALUE;\n        int i = 0;\n        while (i < board.length()) {\n            int j = i;\n            while (j < board.length() && board.charAt(i) == board.charAt(j)) {\n                j++;\n            }\n\n            char color = board.charAt(i);\n            int required = 3 - (j - i);\n            if (hand.getOrDefault(color, 0) >= required) {\n                hand.put(color, hand.get(color) - required);\n                String nextBoard = board.substring(0, i) + board.substring(j);\n                int tmp = findMinStepHelper(nextBoard, memo, hand);\n                if (tmp != -1) {\n                    result = Math.min(result, tmp + required);\n                }\n                hand.put(color, hand.get(color) + required);\n            }\n            i = j;\n        }\n\n        memo.put(board, result == Integer.MAX_VALUE ? -1 : result);\n        return memo.get(board);\n    }\n\n    public static void main(String[] args) {\n        assert findMinStep(\"WRRBBW\", \"RB\") == -1 : \"Test 1 failed\";\n        assert findMinStep(\"WWRRBBWW\", \"WRBRW\") == 2 : \"Test 2 failed\";\n        assert findMinStep(\"G\", \"GGGGG\") == 2 : \"Test 3 failed\";\n    }\n}"}
{"id": 376, "filename": "LeetCode_376_findMaximizedCapital.java", "content": "import java.util.PriorityQueue;\nimport java.util.Arrays;\n\npublic class MaximizeCapital {\n\n    public static int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {\n        // Preconditions\n        assert k >= 0 : \"k must be a non-negative integer\";\n        assert w >= 0 : \"w must be a non-negative integer\";\n        assert Arrays.stream(profits).allMatch(p -> p >= 0) : \"All profits must be non-negative integers\";\n        assert Arrays.stream(capital).allMatch(c -> c >= 0) : \"All capital requirements must be non-negative integers\";\n        assert profits.length == capital.length : \"profits and capital must have the same length\";\n\n        int n = profits.length;\n        int[] indices = new int[n];\n        for (int i = 0; i < n; i++) {\n            indices[i] = i;\n        }\n\n        Arrays.sort(indices, (a, b) -> Integer.compare(capital[b], capital[a]));\n\n        PriorityQueue<Integer> profitHeap = new PriorityQueue<>((a, b) -> Integer.compare(profits[b], profits[a]));\n\n        int idx = 0;\n        while (k > 0) {\n            while (idx < n && capital[indices[idx]] <= w) {\n                profitHeap.offer(indices[idx++]);\n            }\n            if (profitHeap.isEmpty()) break;\n            w += profits[profitHeap.poll()];\n            k--;\n        }\n\n        // Postconditions\n        int result = w;\n        assert result >= 0 : \"Result must be non-negative\";\n        assert result <= w + Arrays.stream(profits).sum() : \"Result cannot exceed initial capital plus total profits\";\n        if (k == 0 || profits.length == 0 || capital.length == 0)\n            assert result == w : \"If no projects can be done, result should equal initial capital\";\n        if (Arrays.stream(capital).allMatch(c -> c > w))\n            assert result == w : \"If all projects require more capital than available, result should equal initial capital\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] profits = {1, 2, 3};\n        int[] capital1 = {0, 1, 1};\n        int[] capital2 = {0, 1, 2};\n\n        System.out.println(findMaximizedCapital(2, 0, profits, capital1));  // Output: 4\n        System.out.println(findMaximizedCapital(3, 0, profits, capital2));  // Output: 6\n    }\n}"}
{"id": 385, "filename": "LeetCode_385_find_rotate_steps.java", "content": "public class Solution {\n\n    public int findRotateSteps(String ring, String key) {\n        if (ring == null || key == null || ring.isEmpty() || key.isEmpty()) {\n            throw new IllegalArgumentException(\"Ring and key must not be null or empty\");\n        }\n\n        int n = ring.length();\n        int m = key.length();\n        int[][] dp = new int[m + 1][n];\n\n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j] = Integer.MAX_VALUE;\n                for (int k = 0; k < n; k++) {\n                    if (ring.charAt(k) == key.charAt(i)) {\n                        int diff = Math.abs(j - k);\n                        int step = Math.min(diff, n - diff);\n                        dp[i][j] = Math.min(dp[i][j], step + dp[i + 1][k]);\n                    }\n                }\n            }\n        }\n\n        int result = dp[0][0] + m;\n\n        if (!(result >= m && result >= key.length() && result <= ring.length() * key.length())) {\n            throw new IllegalStateException(\"Result does not meet the necessary conditions\");\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.findRotateSteps(\"godding\", \"gd\")); // Output: 4\n        System.out.println(solution.findRotateSteps(\"godding\", \"godding\")); // Output: 13\n    }\n}"}
{"id": 387, "filename": "LeetCode_387_find_min_moves.java", "content": "import java.util.Arrays;\n\npublic class MinMoves {\n\n    public static int findMinMoves(int[] machines) {\n        // Preconditions\n        for (int x : machines) {\n            assert (x instanceof Integer) : \"machines must be an array of integers\";\n        }\n        assert (machines.length >= 0 && machines.length <= Math.pow(10, 4)) : \"machines length must be between 0 and 10^4\";\n\n        int n = machines.length;\n        int totalDresses = Arrays.stream(machines).sum();\n\n        if (totalDresses % n != 0) {\n            return -1;\n        }\n\n        int average = totalDresses / n;\n        int moves = 0;\n        int imbalance = 0;\n\n        for (int i = 0; i < n; i++) {\n            imbalance += machines[i] - average;\n            moves = Math.max(moves, Math.abs(imbalance), machines[i] - average);\n        }\n\n        int result = moves;\n\n        // Postconditions\n        assert (result instanceof Integer) : \"The result should be an integer\";\n        if (result == -1) {\n            assert (totalDresses % n != 0) : \"Result is -1 only when total dresses are not evenly divisible by number of machines\";\n        } else {\n            assert (result >= 0) : \"The number of moves cannot be negative\";\n            assert (result >= Math.max(machines) - average) : \"The number of moves must be at least the maximum dresses minus the average\";\n            assert (Arrays.stream(machines).sum() == totalDresses) : \"The total number of dresses should remain unchanged\";\n            int sumImbalances = Arrays.stream(machines).map(x -> Math.abs(x - average)).sum();\n            assert (result <= sumImbalances) : \"The number of moves should not exceed the sum of all imbalances\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] test1 = {1, 0, 5};\n        int[] test2 = {0, 3, 0};\n        int[] test3 = {0, 2, 0};\n\n        System.out.println(findMinMoves(test1)); // Output: 3\n        System.out.println(findMinMoves(test2)); // Output: 2\n        System.out.println(findMinMoves(test3)); // Output: -1\n    }\n}"}
{"id": 479, "filename": "LeetCode_479_findKthNumber.java", "content": "public class Main {\n\n    public static void main(String[] args) {\n        assert findKthNumber(7, 8, 58) == 56;\n        assert findKthNumber(1, 10, 1) == 1;\n        assert findKthNumber(3, 2, 6) == 6;\n        assert findKthNumber(30000, 30000, 1) == 1;\n        assert findKthNumber(1, 1, 1) == 1;\n        assert findKthNumber(2, 2, 4) == 4;\n        assert findKthNumber(3, 3, 1) == 1;\n        assert findKthNumber(7, 8, 56) == 56;\n        assert findKthNumber(7, 8, 57) == 56;\n        assert findKthNumber(2, 3, 1) == 1;\n        assert findKthNumber(1, 30000, 30000) == 30000;\n        assert findKthNumber(6, 6, 36) == 36;\n        assert findKthNumber(10, 10, 100) == 100;\n        assert findKthNumber(7, 7, 49) == 49;\n        assert findKthNumber(5, 5, 1) == 1;\n        assert findKthNumber(2, 1, 1) == 1;\n        assert findKthNumber(1, 2, 1) == 1;\n        assert findKthNumber(3, 3, 2) == 2;\n        assert findKthNumber(2, 3, 2) == 2;\n        assert findKthNumber(1, 2, 2) == 2;\n        assert findKthNumber(2, 2, 2) == 2;\n        assert findKthNumber(7, 7, 45) == 35;\n        assert findKthNumber(7, 8, 59) == 56;\n        assert findKthNumber(10, 10, 1) == 1;\n        assert findKthNumber(2, 3, 6) == 6;\n        assert findKthNumber(10, 1, 10) == 10;\n        assert findKthNumber(1, 10, 10) == 10;\n        assert findKthNumber(2, 1, 2) == 2;\n        assert findKthNumber(30000, 1, 30000) == 30000;\n        assert findKthNumber(3, 3, 5) == 3;\n        assert findKthNumber(5, 5, 25) == 25;\n        assert findKthNumber(2, 3, 7) == 6;\n        assert findKthNumber(7, 7, 48) == 42;\n        assert findKthNumber(3, 3, 9) == 9;\n    }\n\n    public static int findKthNumber(int m, int n, int k) {\n        assert m > 0 && n > 0 : \"m and n must be positive integers\";\n        assert m <= 30000 && n <= 30000 : \"m and n should not exceed 30,000\";\n\n        int low = 1, high = m * n;\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            int count = 0;\n            for (int i = 1; i <= m; i++) {\n                count += Math.min(mid / i, n);\n            }\n            if (count < k) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n\n        int result = low;\n\n        assert result >= 1 && result <= m * n : \"Result should be within the range of the multiplication table\";\n        assert sumMin(m, n, result) >= k : \"Count of elements less than or equal to result should be at least k\";\n\n        return result;\n    }\n\n    private static int sumMin(int m, int n, int result) {\n        int sum = 0;\n        for (int i = 1; i <= m; i++) {\n            sum += Math.min(result / i, n);\n        }\n        return sum;\n    }\n}"}
{"id": 505, "filename": "LeetCode_505_fallingSquares.java", "content": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> fallingSquares(List<List<Integer>> positions) {\n        List<Integer> ans = new ArrayList<>();\n        List<int[]> intervals = new ArrayList<>();\n\n        for (List<Integer> p : positions) {\n            int L = p.get(0);\n            int size = p.get(1);\n            int R = L + size;\n            int h = size;\n            for (int[] pair : intervals) {\n                int h2 = pair[0];\n                int R2 = pair[1];\n                if (R2 > L && R > R2) {\n                    h = Math.max(h, size + h2);\n                }\n            }\n\n            int maxHeight = intervals.stream().map(pair -> pair[0]).max(Integer::compare).orElse(0);\n            ans.add(Math.max(maxHeight, h));\n            intervals.add(new int[]{h, R});\n        }\n\n        List<Integer> result = ans;\n\n        return result;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.check(List.of(List.of(1, 2), List.of(5, 3), List.of(3, 1)));\n        solution.check(List.of(List.of(1, 2), List.of(2, 2), List.of(3, 2)));\n        solution.check(List.of(List.of(1, 2), List.of(2, 2), List.of(2, 1)));\n        solution.check(List.of(List.of(1, 1)));\n        solution.check(List.of(List.of(1, 2), List.of(5, 3), List.of(3, 1)));\n        solution.check(List.of(List.of(1, 2), List.of(3, 2), List.of(5, 2)));\n        solution.check(List.of(List.of(1, 2), List.of(2, 2), List.of(1, 2)));\n        solution.check(List.of(List.of(100, 100), List.of(200, 100)));\n    }\n}"}
{"id": 514, "filename": "LeetCode_514_smallestDistancePair.java", "content": "import java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n    public static int smallestDistancePair(List<Integer> nums, int k) {\n        // Assertions\n        assert nums != null && nums.stream().allMatch(x -> x != null && x instanceof Integer) : \"nums must be a list of integers\";\n        assert nums.stream().allMatch(x -> x >= 0 && x <= Math.pow(10, 6)) : \"Each number in nums must be between 0 and 10^6\";\n        \n        // Convert List<Integer> to int[]\n        int[] arr = new int[nums.size()];\n        for (int i = 0; i < nums.size(); i++) {\n            arr[i] = nums.get(i);\n        }\n\n        // Sort the array\n        Arrays.sort(arr);\n        int low = 0;\n        int high = arr[arr.length - 1] - arr[0];\n\n        while (low < high) {\n            int mid = (low + high) / 2;\n            int count = 0;\n            int left = 0;\n\n            for (int right = 0; right < arr.length; right++) {\n                while (arr[right] - arr[left] > mid) {\n                    left++;\n                }\n                count += (right - left);\n            }\n\n            if (count < k) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n\n        int result = low;\n\n        // Postconditions\n        assert result >= 0 && result <= arr[arr.length - 1] - arr[0] : \"The result must be a valid distance in the range of nums\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Unit tests\n        assert smallestDistancePair(List.of(3, 1, 3, 4), 1) == 0;\n        assert smallestDistancePair(List.of(1, 2, 3, 4, 5, 6, 7), 5) == 1;\n        assert smallestDistancePair(List.of(1, 3, 1), 1) == 0;\n        // Add more test cases here as needed\n    }\n}"}
{"id": 520, "filename": "LeetCode_520_countOfAtoms.java", "content": "import java.util.*;\n\npublic class Main {\n    public static String countOfAtoms(String formula) {\n        // Assertions\n        assert formula instanceof String : \"formula must be a string\";\n        assert formula.chars().allMatch(c -> Character.isLetterOrDigit(c) || c == '(' || c == ')' || c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9') : \"formula must consist of valid characters\";\n        assert formula.chars().filter(Character::isAlphabetic).allMatch(Character::isUpperCase) : \"invalid use of lowercase letters\";\n\n        int[] i = new int[]{0};\n        Map<String, Integer> counts = parse(formula, i);\n        List<String> ans = new ArrayList<>();\n        counts.entrySet().stream()\n            .sorted(Map.Entry.comparingByKey())\n            .forEach(entry -> {\n                ans.add(entry.getKey());\n                if (entry.getValue() > 1) {\n                    ans.add(String.valueOf(entry.getValue()));\n                }\n            });\n\n        // Postconditions\n        String result = String.join(\"\", ans);\n        assert result instanceof String : \"The result must be a string\";\n        assert result.matches(\"((\\\\d+)?[A-Z]\\\\d*)*\") : \"Element counts must be in the correct position\";\n        assert result.length() <= formula.length() * 2 : \"Result length should not exceed twice the input length\";\n\n        return result;\n    }\n\n    private static Map<String, Integer> parse(String formula, int[] i) {\n        Map<String, Integer> counts = new HashMap<>();\n        while (i[0] < formula.length()) {\n            if (formula.charAt(i[0]) == '(') {\n                i[0]++;\n                Map<String, Integer> temp = parse(formula, i);\n                int count = 0;\n                while (i[0] < formula.length() && Character.isDigit(formula.charAt(i[0]))) {\n                    count = count * 10 + Character.getNumericValue(formula.charAt(i[0]));\n                    i[0]++;\n                }\n                if (count == 0) {\n                    count = 1;\n                }\n                for (Map.Entry<String, Integer> entry : temp.entrySet()) {\n                    counts.merge(entry.getKey(), entry.getValue() * count, Integer::sum);\n                }\n            } else if (formula.charAt(i[0]) == ')') {\n                i[0]++;\n                return counts;\n            } else {\n                StringBuilder nameBuilder = new StringBuilder().append(formula.charAt(i[0]));\n                i[0]++;\n                while (i[0] < formula.length() && Character.isLowerCase(formula.charAt(i[0]))) {\n                    nameBuilder.append(formula.charAt(i[0]));\n                    i[0]++;\n                }\n                String name = nameBuilder.toString();\n                int count = 0;\n                while (i[0] < formula.length() && Character.isDigit(formula.charAt(i[0]))) {\n                    count = count * 10 + Character.getNumericValue(formula.charAt(i[0]));\n                    i[0]++;\n                }\n                if (count == 0) {\n                    count = 1;\n                }\n                counts.merge(name, count, Integer::sum);\n            }\n        }\n        return counts;\n    }\n\n    public static void main(String[] args) {\n        // Unit tests\n        assert countOfAtoms(\"K4(ON(SO3)2)2\").equals(\"K4N2O14S4\");\n        assert countOfAtoms(\"Mg(OH)2\").equals(\"H2MgO2\");\n        assert countOfAtoms(\"H2O\").equals(\"H2O\");\n    }\n}"}
{"id": 558, "filename": "LeetCode_558_minSwapsCouples.java", "content": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class CouplesSeating {\n\n    public static int minSwapsCouples(int[] row) {\n        // Preconditions\n        assert row != null && row.length % 2 == 0 : \"Invalid input row\";\n        assert row.length / 2 >= 2 && row.length / 2 <= 30 : \"Number of couples should be between 2 and 30\";\n        assert checkUniqueElements(row) : \"All elements in row must be unique\";\n        assert checkValidRange(row) : \"All elements in row must be within the valid range\";\n\n        int n = row.length / 2;\n        int swaps = 0;\n        Map<Integer, Integer> position = new HashMap<>();\n        for (int i = 0; i < row.length; i++) {\n            position.put(row[i], i);\n        }\n\n        for (int i = 0; i < row.length; i += 2) {\n            int couple = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;\n            if (row[i + 1] != couple) {\n                int temp = row[i + 1];\n                row[i + 1] = row[position.get(couple)];\n                row[position.get(couple)] = temp;\n                position.put(row[i + 1], position.get(couple));\n                position.put(couple, i + 1);\n                swaps++;\n            }\n        }\n\n        // Postconditions\n        assert swaps >= 0 : \"The number of swaps cannot be negative\";\n        assert swaps <= row.length / 2 : \"The number of swaps should not exceed half the length of the row\";\n        assert checkUniqueElements(row) : \"Elements in row should remain unique after swaps\";\n\n        return swaps;\n    }\n\n    private static boolean checkUniqueElements(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = i + 1; j < arr.length; j++) {\n                if (arr[i] == arr[j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private static boolean checkValidRange(int[] arr) {\n        for (int num : arr) {\n            if (num < 0 || num >= arr.length) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int[] row1 = {0, 2, 1, 3};\n        System.out.println(\"Output for row1: \" + minSwapsCouples(row1));\n\n        int[] row2 = {3, 2, 0, 1};\n        System.out.println(\"Output for row2: \" + minSwapsCouples(row2));\n    }\n}"}
{"id": 625, "filename": "LeetCode_625_rectangleArea.java", "content": "import java.util.*;\n\npublic class Solution {\n    \n    public int rectangleArea(int[][] rectangles) {\n        assert rectangles instanceof int[][], \"rectangles must be a 2D array\";\n        assert rectangles.length >= 1 && rectangles.length <= 200, \"The number of rectangles must be between 1 and 200\";\n        for (int[] rect : rectangles) {\n            assert rect.length == 4, \"Each rectangle must contain 4 elements\";\n            assert rect[0] >= 0 && rect[1] >= 0 && rect[2] >= 0 && rect[3] >= 0, \"Coordinates must be non-negative\";\n            assert rect[0] <= rect[2] && rect[1] <= rect[3], \"Rectangles must be axis-aligned\";\n        }\n\n        long mod = (long) Math.pow(10, 9) + 7;\n        Set<Integer> X = new HashSet<>();\n        Set<Integer> Y = new HashSet<>();\n        for (int[] rect : rectangles) {\n            X.add(rect[0]);\n            X.add(rect[2]);\n            Y.add(rect[1]);\n            Y.add(rect[3]);\n        }\n        List<Integer> sortedX = new ArrayList<>(X);\n        List<Integer> sortedY = new ArrayList<>(Y);\n        int[][] cnt = new int[sortedX.size() - 1][sortedY.size() - 1];\n\n        for (int[] rect : rectangles) {\n            int x1_idx = sortedX.indexOf(rect[0]);\n            int x2_idx = sortedX.indexOf(rect[2]) - 1;\n            int y1_idx = sortedY.indexOf(rect[1]);\n            int y2_idx = sortedY.indexOf(rect[3]) - 1;\n            for (int i = x1_idx; i <= x2_idx; i++) {\n                for (int j = y1_idx; j <= y2_idx; j++) {\n                    cnt[i][j] = 1;\n                }\n            }\n        }\n\n        long totalArea = 0;\n        for (int i = 0; i < sortedX.size() - 1; i++) {\n            for (int j = 0; j < sortedY.size() - 1; j++) {\n                if (cnt[i][j] == 1) {\n                    totalArea = (totalArea + (long) (sortedX.get(i + 1) - sortedX.get(i)) * (long) (sortedY.get(j + 1) - sortedY.get(j)) % mod) % mod;\n                }\n            }\n        }\n\n        assert totalArea >= 0, \"The area cannot be negative\";\n        assert totalArea < mod, \"The area should be less than 10^9 + 7\";\n\n        return (int) totalArea;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.test_check();\n    }\n\n    public void test_check() {\n        assert rectangleArea(new int[][]{{0,0,1,1}, {1,1,2,2}}) == 2;\n        assert rectangleArea(new int[][]{{0,0,2,2}, {0,2,2,4}, {2,0,4,2}, {2,2,4,4}}) == 16;\n        assert rectangleArea(new int[][]{{0,0,1,1}, {0,0,1,1}}) == 1;\n        assert rectangleArea(new int[][]{{0,0,1000000000,1000000000}}) == 49;\n        // Add more test cases here\n    }\n}"}
{"id": 631, "filename": "LeetCode_631_consecutive_numbers_sum.java", "content": "public class ConsecutiveNumbersSum {\n\n    public static int consecutiveNumbersSum(int n) {\n        // Assertions\n        assert n > 0 : \"Input must be a positive integer\";\n        assert n <= Math.pow(10, 9) : \"Input must be less than or equal to 10^9\";\n\n        int count = 0;\n        int i = 1;\n        while (i * (i - 1) / 2 < n) {\n            if ((n - i * (i - 1) / 2) % i == 0) {\n                count++;\n            }\n            i++;\n        }\n        \n        // Postconditions\n        assert count >= 1 : \"There must be at least one way to express the number as a sum of consecutive integers\";\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        check(ConsecutiveNumbersSum::consecutiveNumbersSum);\n    }\n\n    public static void check(Function<Integer, Integer> candidate) {\n        assert candidate.apply(674) == 2;\n        assert candidate.apply(1) == 1;\n        assert candidate.apply(21) == 4;\n        // Add more test cases here...\n    }\n}"}
{"id": 710, "filename": "LeetCode_710_numMusicPlaylists.java", "content": "public class MusicPlaylists {\n\n    public static int numMusicPlaylists(int n, int goal, int k) {\n        assert n > 0 : \"n must be a positive integer\";\n        assert goal > 0 : \"goal must be a positive integer\";\n        assert n <= 100 : \"n must be less than or equal to 100\";\n\n        int MOD = 1000000007;\n        int[][] dp = new int[goal + 1][n + 1];\n        dp[0][0] = 1;\n        for (int i = 1; i <= goal; i++) {\n            for (int j = 1; j <= n; j++) {\n                dp[i][j] = (int) ((long) (dp[i - 1][j - 1] * (n - (j - 1)) % MOD + dp[i - 1][j] * Math.max(0, j - k) % MOD) % MOD);\n            }\n        }\n\n        int result = dp[goal][n];\n\n        // Postconditions\n        assert result >= 0 : \"The result must be non-negative\";\n        assert result < MOD : \"The result must be less than MOD\";\n        for (int i = 0; i <= goal; i++) {\n            for (int j = 0; j <= n; j++) {\n                assert dp[i][j] >= 0 : \"All values in dp should be non-negative\";\n            }\n        }\n        assert dp[goal][n] == result : \"Final result must match the dp[goal][n]\";\n        int sum = 0;\n        for (int j = 0; j <= n; j++) {\n            sum += dp[goal][j];\n        }\n        assert sum >= result : \"The sum of dp[goal] should be greater than or equal to the result\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        check(MusicPlaylists::numMusicPlaylists);\n    }\n\n    public static void check(Function<Integer, Integer, Integer, Integer> candidate) {\n        assert candidate.apply(6, 6, 1) == 720;\n        assert candidate.apply(3, 3, 1) == 6;\n        assert candidate.apply(2, 2, 1) == 2;\n        assert candidate.apply(10, 1, 3) == 0;\n        assert candidate.apply(4, 4, 1) == 24;\n        assert candidate.apply(10, 10, 1) == 3628800;\n        // Add more assertions as needed\n    }\n}"}
{"id": 730, "filename": "LeetCode_730_distinctSubseqII.java", "content": "public class DistinctSubsequences {\n\n    public int distinctSubseqII(String s) {\n        assert s != null : \"Input must not be null\";\n        assert s.length() >= 1 && s.length() <= 2000 : \"String length must be between 1 and 2000\";\n        assert s.toLowerCase().equals(s) : \"String must consist of lowercase English letters\";\n\n        int mod = 1000000007;\n        int n = s.length();\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        int[] last = new int[26];\n        for (int i = 0; i < 26; i++) {\n            last[i] = -1;\n        }\n\n        for (int i = 1; i <= n; i++) {\n            dp[i] = (2 * dp[i - 1]) % mod;\n            if (last[s.charAt(i - 1) - 'a'] != -1) {\n                dp[i] = (dp[i] - dp[last[s.charAt(i - 1) - 'a']] + mod) % mod;\n            }\n            last[s.charAt(i - 1) - 'a'] = i - 1;\n        }\n\n        dp[n] = (dp[n] - 1 + mod) % mod;\n        int result = dp[n];\n\n        assert result >= 0 : \"The result must be non-negative\";\n        assert result < mod : \"The result must be less than mod\";\n        assert dp.length == n + 1 : \"The dp array must have a length of n + 1\";\n        for (int x : dp) {\n            assert x >= 0 && x < mod : \"All dp values must be non-negative and less than mod\";\n        }\n        assert dp[0] == 1 : \"The base case dp[0] must be 1\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        DistinctSubsequences ds = new DistinctSubsequences();\n        ds.testDistinctSubseqII();\n    }\n\n    public void testDistinctSubseqII() {\n        assert distinctSubseqII(\"ab\") == 3;\n        assert distinctSubseqII(\"abcdefghijklm\") == 8191;\n        assert distinctSubseqII(\"abcd\") == 15;\n        assert distinctSubseqII(\"abcdefghi\") == 511;\n        assert distinctSubseqII(\"aaa\") == 3;\n        assert distinctSubseqII(\"abcde\") == 31;\n        assert distinctSubseqII(\"abc\") == 7;\n        assert distinctSubseqII(\"aaa\") == 3;\n        assert distinctSubseqII(\"ba\") == 3;\n        assert distinctSubseqII(\"aba\") == 6;\n        assert distinctSubseqII(\"abcdefg\") == 127;\n        assert distinctSubseqII(\"abcdefghijklmnopqrstuvwx\") == 16777215;\n        assert distinctSubseqII(\"abcdefghij\") == 1023;\n    }\n}"}
{"id": 746, "filename": "LeetCode_746_min_k_bit_flips.java", "content": "import java.util.Arrays;\n\npublic class Solution {\n    public int minKBitFlips(int[] nums, int k) {\n        assert nums != null && nums.length > 0 && nums.length <= 100000: \"nums should be a non-empty array with length between 1 and 100000.\";\n        assert k >= 1 && k <= nums.length: \"k should be between 1 and the length of nums.\";\n        int n = nums.length;\n        int[] flipped = new int[n];\n        int flips = 0, ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (i >= k) {\n                flips -= flipped[i - k];\n            }\n            if ((flips + nums[i]) % 2 == 0) {\n                if (i + k > n) {\n                    return -1;\n                }\n                flipped[i] = 1;\n                flips++;\n                ans++;\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        assert solution.minKBitFlips(new int[]{0, 1, 0}, 1) == 2;\n        assert solution.minKBitFlips(new int[]{1, 1, 0}, 2) == -1;\n        assert solution.minKBitFlips(new int[]{0, 0, 0, 1, 0, 1, 1, 0}, 3) == 3;\n        // Add more test cases if needed\n    }\n}"}
{"id": 747, "filename": "LeetCode_747_numSquarefulPerms.java", "content": "import java.util.*;\n\npublic class Main {\n\n    public static int numSquarefulPerms(int[] nums) {\n        // Preconditions\n        assert nums != null && nums.length > 0 : \"nums should not be empty.\";\n        for (int x : nums) {\n            assert 0 <= x && x <= Math.pow(10, 9) : \"Each element in nums should be between 0 and 10^9.\";\n        }\n\n        Set<Integer> keySet = new HashSet<>();\n        for (int num : nums) {\n            keySet.add(num);\n        }\n\n        Map<Integer, Integer> counter = new HashMap<>();\n        for (int num : nums) {\n            counter.put(num, counter.getOrDefault(num, 0) + 1);\n        }\n\n        int result = dfs(nums, 0, counter);\n\n        // Postconditions\n        assert result >= 0 : \"The result should be non-negative.\";\n        assert result <= nums.length * nums.length : \"The result should not exceed len(nums) * len(nums).\";\n        assert result <= Math.pow(2, nums.length) : \"The result should not exceed 2^len(nums).\";\n\n        return result;\n    }\n\n    private static int dfs(int[] nums, int idx, Map<Integer, Integer> counter) {\n        if (idx == nums.length) {\n            return 1;\n        }\n\n        int count = 0;\n        for (int key : counter.keySet()) {\n            if (counter.get(key) > 0 && (idx == 0 || isSquare(nums[idx - 1] + key))) {\n                counter.put(key, counter.get(key) - 1);\n                nums[idx] = key;\n                count += dfs(nums, idx + 1, counter);\n                counter.put(key, counter.get(key) + 1);\n            }\n        }\n\n        return count;\n    }\n\n    private static boolean isSquare(int n) {\n        return (int) Math.sqrt(n) * (int) Math.sqrt(n) == n;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {1, 17, 8};\n        int result = numSquarefulPerms(nums);\n        System.out.println(result);\n    }\n\n}"}
{"id": 766, "filename": "LeetCode_766_odd_even_jumps.java", "content": "import java.util.*;\n\npublic class OddEvenJumps {\n\n    public int oddEvenJumps(int[] arr) {\n        if (arr == null || arr.length == 0) {\n            throw new IllegalArgumentException(\"arr should not be empty.\");\n        }\n\n        int n = arr.length;\n        boolean[] canReachOdd = new boolean[n];\n        boolean[] canReachEven = new boolean[n];\n        canReachOdd[n - 1] = canReachEven[n - 1] = true;\n\n        TreeMap<Integer, Integer> indexMap = new TreeMap<>();\n        indexMap.put(arr[n - 1], n - 1);\n\n        int goodIndices = 1;\n        for (int i = n - 2; i >= 0; i--) {\n            Integer oddJump = indexMap.ceilingKey(arr[i]);\n            Integer evenJump = indexMap.floorKey(arr[i]);\n\n            if (oddJump != null) {\n                canReachOdd[i] = canReachEven[indexMap.get(oddJump)];\n            }\n            if (evenJump != null) {\n                canReachEven[i] = canReachOdd[indexMap.get(evenJump)];\n            }\n\n            if (canReachOdd[i]) {\n                goodIndices++;\n            }\n\n            indexMap.put(arr[i], i);\n        }\n\n        return goodIndices;\n    }\n\n    public static void main(String[] args) {\n        OddEvenJumps oej = new OddEvenJumps();\n\n        // Unit tests\n        assert oej.oddEvenJumps(new int[]{1, 3, 2}) == 2;\n        assert oej.oddEvenJumps(new int[]{1, 2}) == 2;\n        assert oej.oddEvenJumps(new int[]{4, 3, 2, 1}) == 1;\n        assert oej.oddEvenJumps(new int[]{3, 2, 1}) == 1;\n        assert oej.oddEvenJumps(new int[]{1, 1, 1, 1, 1}) == 5;\n        // Add more test cases as needed\n    }\n}"}
{"id": 846, "filename": "LeetCode_846_last_substring.java", "content": "public class LastSubstring {\n    public static String lastSubstring(String s) {\n        // Preconditions\n        assert s != null && !s.isEmpty() && s.chars().allMatch(Character::isLowerCase), \"Input must be a non-empty string containing only lowercase English letters.\";\n\n        int i = 0, j = 1, k = 0, n = s.length();\n        while (j + k < n) {\n            if (s.charAt(i + k) == s.charAt(j + k)) {\n                k++;\n            } else if (s.charAt(i + k) < s.charAt(j + k)) {\n                i = j;\n                j++;\n                k = 0;\n            } else {\n                j++;\n                k = 0;\n            }\n        }\n\n        String result = s.substring(i);\n\n        // Postconditions\n        assert result != null && !result.isEmpty() && result.chars().allMatch(Character::isLowerCase), \"Output must be a non-empty string containing only lowercase English letters.\";\n        assert result.length() <= s.length(), \"The length of the output must be less than or equal to the input string.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        check(LastSubstring::lastSubstring);\n    }\n\n    private static void check(Function<String, String> candidate) {\n        assert candidate.apply(\"cba\").equals(\"cba\");\n        assert candidate.apply(\"a\".repeat(10000)).equals(\"a\".repeat(10000));\n        assert candidate.apply(\"abcbabcd\").equals(\"d\");\n        assert candidate.apply(\"c\").equals(\"c\");\n        assert candidate.apply(\"bacdab\").equals(\"dab\");\n        // Add more test assertions similarly\n    }\n}"}
{"id": 866, "filename": "LeetCode_866_lastSubstring.java", "content": "public class Main {\n\n    public static String lastSubstring(String s) {\n        assert s != null && s instanceof String : \"Input must be a string.\";\n        assert s.length() >= 1 && s.length() <= 4 * Math.pow(10, 5) : \"The length of the string must be between 1 and 400,000.\";\n        assert s.matches(\"[a-z]+\") : \"The string must contain only lowercase English letters.\";\n\n        int maxIndex = 0;\n        int curIndex = 1;\n        while (curIndex < s.length()) {\n            int i = 0;\n            while (curIndex + i < s.length() && s.charAt(maxIndex + i) == s.charAt(curIndex + i)) {\n                i++;\n            }\n            if (curIndex + i == s.length()) {\n                break;\n            }\n            if (s.charAt(maxIndex + i) < s.charAt(curIndex + i)) {\n                maxIndex = curIndex;\n            }\n            curIndex++;\n        }\n        String result = s.substring(maxIndex);\n\n        assert result != null && result instanceof String : \"Output must be a string.\";\n        assert result.length() > 0 : \"The output string must not be empty.\";\n        assert result.matches(\"[a-z]+\") : \"The output must contain only lowercase English letters.\";\n        assert result.length() <= s.length() : \"The length of the output must be less than or equal to the input string.\";\n        assert result.equals(max(s.substring(i) for i in range(s.length()))) : \"The output must be the lexicographically largest substring.\";\n\n        return result;\n    }\n\n    public static String max(String[] strings) {\n        String max = strings[0];\n        for (int i = 1; i < strings.length; i++) {\n            if (strings[i].compareTo(max) > 0) {\n                max = strings[i];\n            }\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        check(Main::lastSubstring);\n    }\n\n    public static void check(Function<String, String> candidate) {\n        assert candidate.apply(\"bbbbaaaaaaaaf\").equals(\"f\");\n        assert candidate.apply(\"abab\").equals(\"bab\");\n        assert candidate.apply(\"data\").equals(\"ta\");\n        assert candidate.apply(\"coding\").equals(\"oding\");\n        assert candidate.apply(\"ecbacbac\").equals(\"ecbacbac\");\n        assert candidate.apply(\"bbaaaaaaaaaf\").equals(\"f\");\n        assert candidate.apply(\"cat\").equals(\"t\");\n        assert candidate.apply(\"abcab\").equals(\"cab\");\n        assert candidate.apply(\"zabcz\").equals(\"zabcz\");\n        assert candidate.apply(\"abcdefg\").equals(\"g\");\n        assert candidate.apply(\"abcdef\").equals(\"f\");\n        assert candidate.apply(\"aaaaaaaaa\").equals(\"aaaaaaaaa\");\n        assert candidate.apply(\"qpqpqpq\").equals(\"qpqpqpq\");\n        assert candidate.apply(\"a\").equals(\"a\");\n        assert candidate.apply(\"qqqqqq\").equals(\"qqqqqq\");\n        assert candidate.apply(\"qpqpqpqp\").equals(\"qpqpqpqp\");\n        assert candidate.apply(\"qpqpqp\").equals(\"qpqpqp\");\n        assert candidate.apply(\"abababab\").equals(\"bababab\");\n        assert candidate.apply(\"helloworld\").equals(\"world\");\n        assert candidate.apply(\"hbhbhbhbhbhbhbhb\").equals(\"hbhbhbhbhbhbhbhb\");\n        assert candidate.apply(\"aaaaaaaaaaf\").equals(\"f\");\n        assert candidate.apply(\"aaab\").equals(\"b\");\n        assert candidate.apply(\"python\").equals(\"ython\");\n        assert candidate.apply(\"leetcode\").equals(\"tcode\");\n        assert candidate.apply(\"abcabc\").equals(\"cabc\");\n        assert candidate.apply(\"aaa\").equals(\"aaa\");\n        assert candidate.apply(\"hello\").equals(\"o\");\n        assert candidate.apply(\"aaaaaaab\").equals(\"b\");\n        assert candidate.apply(\"aa\").equals(\"aa\");\n        assert candidate.apply(\"eee\").equals(\"eee\");\n        assert candidate.apply(\"cbda\").equals(\"da\");\n        assert candidate.apply(\"banana\").equals(\"nana\");\n        assert candidate.apply(\"bbbbaaaaaaaaaf\").equals(\"f\");\n        assert candidate.apply(\"zzzzz\").equals(\"zzzzz\");\n    }\n}"}
{"id": 876, "filename": "LeetCode_876_find_num_of_valid_words.java", "content": "import java.util.*;\n\npublic class Solution {\n\n    public List<Integer> find_num_of_valid_words(List<String> words, List<String> puzzles) {\n        List<Integer> result = new ArrayList<>();\n\n        for (String puzzle : puzzles) {\n            int count = 0;\n            HashSet<Character> puzzleSet = new HashSet<>();\n            for (char c : puzzle.toCharArray()) {\n                puzzleSet.add(c);\n            }\n\n            for (String word : words) {\n                if (puzzle.charAt(0) == word.charAt(0)) {\n                    boolean isValid = true;\n                    for (int i = 0; i < word.length(); i++) {\n                        if (!puzzleSet.contains(word.charAt(i))) {\n                            isValid = false;\n                            break;\n                        }\n                    }\n                    if (isValid) {\n                        count++;\n                    }\n                }\n            }\n            result.add(count);\n        }\n        return result;\n    }\n\n    // Unit tests\n \n    public void check(Solution solution) {\n        assert solution.find_num_of_valid_words(Arrays.asList(\"a\", \"b\", \"c\", \"d\"), Arrays.asList(\"abcd\", \"dcba\", \"badc\", \"cdab\", \"e\")).equals(Arrays.asList(1, 1, 1, 1, 0));\n        assert solution.find_num_of_valid_words(Arrays.asList(\"apple\", \"pleas\", \"please\"), Arrays.asList(\"aelwxyz\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\")).equals(Arrays.asList(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0));\n        assert solution.find_num_of_valid_words(Arrays.asList(\"ab\", \"cd\", \"ef\", \"gh\"), Arrays.asList(\"abcdefg\", \"abcdefgh\", \"badcfehg\", \"hgfedcba\")).equals(Arrays.asList(1, 1, 1, 1));\n        assert solution.find_num_of_valid_words(Arrays.asList(\"aaaa\", \"asas\", \"able\", \"ability\", \"actt\", \"actor\", \"access\"), Arrays.asList(\"aboveyz\")).equals(Arrays.asList(1));\n        assert solution.find_num_of_valid_words(Arrays.asList(\"aaaa\", \"asas\", \"able\", \"ability\", \"actt\", \"actor\", \"access\"), Arrays.asList(\"aboveyz\", \"abrodyz\", \"abslute\", \"absoryz\", \"actresz\", \"gaswxyz\")).equals(Arrays.asList(1, 1, 3, 2, 4, 0));\n        assert solution.find_num_of_valid_words(Arrays.asList(\"apple\", \"pleas\", \"please\"), Arrays.asList(\"aelwxyz\", \"aelpxyz\", \"aelpsxy\", \"saelpxy\", \"xaelpsy\")).equals(Arrays.asList(0, 1, 3, 2, 0));\n        assert solution.find_num_of_valid_words(Arrays.asList(\"apple\", \"pleas\", \"please\"), Arrays.asList(\"aelwxyz\")).equals(Arrays.asList(0));\n        assert solution.find_num_of_valid_words(Arrays.asList(\"apple\"), Arrays.asList(\"apple\", \"pleas\", \"please\")).equals(Arrays.asList(1, 1, 1));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.check(solution);\n    }\n}"}
{"id": 914, "filename": "LeetCode_914_jobScheduling.java", "content": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class JobSchedulingMaxProfit {\n    \n    public static int jobScheduling(List<Integer> startTime, List<Integer> endTime, List<Integer> profit) {\n        assert startTime instanceof List && endTime instanceof List && profit instanceof List : \"Input must be lists.\";\n        assert startTime.size() == endTime.size() && endTime.size() == profit.size() : \"All input lists must have the same length.\";\n        \n        List<int[]> jobs = new ArrayList<>();\n        for (int i = 0; i < endTime.size(); i++) {\n            jobs.add(new int[]{endTime.get(i), startTime.get(i), profit.get(i)});\n        }\n        \n        Collections.sort(jobs, (a, b) -> Integer.compare(a[0], b[0]));\n        \n        List<Integer> dp = new ArrayList<>();\n        dp.add(jobs.get(0)[2]);\n        \n        for (int i = 1; i < jobs.size(); i++) {\n            int l = latestNonConflict(jobs, i);\n            dp.add(Math.max(dp.get(dp.size() - 1), (l == -1 ? 0 : dp.get(l)) + jobs.get(i)[2]));\n        }\n        \n        int result = dp.get(dp.size() - 1);\n        assert result >= 0 && result <= profit.stream().mapToInt(Integer::intValue).sum() : \"The result must be a valid profit value.\";\n        \n        return result;\n    }\n    \n    private static int latestNonConflict(List<int[]> jobs, int index) {\n        int startTimeToFind = jobs.get(index)[1];\n        int i = 0;\n        for (int[] job : jobs) {\n            if (job[0] <= startTimeToFind) {\n                i++;\n            }\n        }\n        return i == 0 ? -1 : i - 1;\n    }\n    \n    public static void main(String[] args) {\n        List<Integer> startTime = List.of(1, 2, 3, 3);\n        List<Integer> endTime = List.of(3, 4, 5, 6);\n        List<Integer> profit = List.of(50, 10, 40, 70);\n        System.out.println(jobScheduling(startTime, endTime, profit)); // Output: 120\n    }\n}"}
{"id": 929, "filename": "LeetCode_929_maxValueAfterReverse.java", "content": "import java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int result = maxValueAfterReverse(new int[]{2, 4, 9, 24, 2, 1, 10});\n        System.out.println(result);\n    }\n\n    public static int maxValueAfterReverse(int[] nums) {\n        // Input Validation\n        assert nums != null : \"Input must not be null.\";\n        assert nums.length >= 1 && nums.length <= 3 * Math.pow(10, 4) : \"Length of nums must be between 1 and 3 * 10^4.\";\n        for (int num : nums) assert num >= -Math.pow(10, 5) && num <= Math.pow(10, 5) : \"Elements in nums must be between -10^5 and 10^5.\";\n\n        int total = 0, diff = 0;\n        int min2 = Integer.MAX_VALUE, max2 = Integer.MIN_VALUE;\n\n        for (int i = 0; i < nums.length - 1; i++) {\n            total += Math.abs(nums[i] - nums[i + 1]);\n            min2 = Math.min(min2, Math.max(nums[i], nums[i + 1]));\n            max2 = Math.max(max2, Math.min(nums[i], nums[i + 1]));\n            diff = Math.max(diff, Math.abs(nums[i + 1] - nums[0]) - Math.abs(nums[i + 1] - nums[i]));\n            diff = Math.max(diff, Math.abs(nums[i] - nums[nums.length - 1]) - Math.abs(nums[i] - nums[i + 1]));\n        }\n\n        int result = total + Math.max(diff, 2 * (max2 - min2));\n\n        // Postconditions\n        assert result >= total : \"The result must be greater than or equal to the original total value.\";\n\n        return result;\n    }\n}"}
{"id": 960, "filename": "LeetCode_960_shortestPath.java", "content": "import java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class ShortestPath {\n\n    public int shortestPath(int[][] grid, int k) {\n        assert grid != null && grid.length > 0 && grid[0].length > 0 : \"Grid must be a non-empty 2D array.\";\n        \n        int m = grid.length;\n        int n = grid[0].length;\n        boolean[][][] visited = new boolean[m][n][k + 1];\n        Queue<int[]> queue = new ArrayDeque<>();\n        int[][] moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        int steps = 0;\n\n        queue.offer(new int[]{0, 0, 0, k});\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int[] current = queue.poll();\n                int x = current[0];\n                int y = current[1];\n                steps = current[2];\n                int remainingK = current[3];\n\n                if (x == m - 1 && y == n - 1) {\n                    return steps;\n                }\n\n                for (int[] move : moves) {\n                    int newX = x + move[0];\n                    int newY = y + move[1];\n\n                    if (newX >= 0 && newX < m && newY >= 0 && newY < n) {\n                        int newK = remainingK - grid[newX][newY];\n                        if (newK >= 0 && !visited[newX][newY][newK]) {\n                            visited[newX][newY][newK] = true;\n                            queue.offer(new int[]{newX, newY, steps + 1, newK});\n                        }\n                    }\n                }\n            }\n            steps++;\n        }\n\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        ShortestPath sp = new ShortestPath();\n        // Add test cases here\n    }\n}"}
{"id": 1010, "filename": "LeetCode_1010_tilingRectangle.java", "content": "public class TilingRectangle {\n    public static int tilingRectangle(int n, int m) {\n        if (n > m) {\n            int temp = n;\n            n = m;\n            m = temp;\n        }\n        if (n == 1) {\n            return m;\n        }\n        if (n == m) {\n            return 1;\n        }\n\n        int res = Integer.MAX_VALUE;\n        for (int a = 1; a <= n / 2; a++) {\n            res = Math.min(res, tilingRectangle(a, m) + tilingRectangle(n - a, m));\n        }\n\n        for (int b = 1; b <= m / 2; b++) {\n            res = Math.min(res, tilingRectangle(n, b) + tilingRectangle(n, m - b));\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        assert tilingRectangle(2, 3) == 3;\n        assert tilingRectangle(1, 4) == 4;\n        // Add more test cases\n    }\n}"}
{"id": 1015, "filename": "LeetCode_1015_maxHeight.java", "content": "import java.util.*;\n\npublic class CuboidStacking {\n    // Global set to store unique failed assertions\n    static Set<String> failedAssertions = new HashSet<>();\n\n    public static int maxHeight(int[][] cuboids) {\n        // Precondition checks\n        try {\n            assert cuboids != null && cuboids.length > 0 && cuboids.length <= 100 &&\n                   Arrays.stream(cuboids).allMatch(cuboid -> cuboid.length == 3), \"Invalid cuboids input.\";\n        } catch (AssertionError e) {\n            failedAssertions.add(\"Precondition 1 failed: \" + e.getMessage());\n        }\n\n        try {\n            assert Arrays.stream(cuboids).allMatch(cuboid ->\n                    Arrays.stream(cuboid).allMatch(dim -> dim > 0)), \"All dimensions must be positive integers.\";\n        } catch (AssertionError e) {\n            failedAssertions.add(\"Precondition 2 failed: \" + e.getMessage());\n        }\n\n        // Main logic\n        Arrays.sort(cuboids, Comparator.comparing((int[] a) -> a[0]).thenComparing(a -> a[1]).thenComparingInt(a -> a[2]));\n        int n = cuboids.length;\n        int[] dp = new int[n];\n        int ans = 0;\n\n        for (int i = 0; i < n; i++) {\n            dp[i] = cuboids[i][2];\n            for (int j = 0; j < i; j++) {\n                if (cuboids[j][0] <= cuboids[i][0] && cuboids[j][1] <= cuboids[i][1] && cuboids[j][2] <= cuboids[i][2]) {\n                    dp[i] = Math.max(dp[i], dp[j] + cuboids[i][2]);\n                }\n            }\n            ans = Math.max(ans, dp[i]);\n        }\n\n        // Postcondition checks\n        try {\n            assert ans > 0, \"The result must be a positive integer.\";\n        } catch (AssertionError e) {\n            failedAssertions.add(\"Postcondition 1 failed: \" + e.getMessage());\n        }\n\n        try {\n            assert Arrays.stream(dp).allMatch(d -> d >= cuboids[d][2]), \"Each dp value should be at least the height of the corresponding cuboid.\";\n        } catch (AssertionError e) {\n            failedAssertions.add(\"Postcondition 2 failed: \" + e.getMessage());\n        }\n\n        return ans;\n    }\n\n    // Unit tests\n    public static void check(CuboidStacking instance) {\n        assert instance.maxHeight(new int[][]{{1, 1, 1}}) == 1;\n        assert instance.maxHeight(new int[][]{{1, 1, 1},{1, 1, 1},{1, 1, 1},{1, 1, 1}}) == 4;\n        assert instance.maxHeight(new int[][]{{1, 1, 1},{2, 2, 2}}) == 3;\n        // Add more test cases here\n    }\n\n    public static void main(String[] args) {\n        CuboidStacking instance = new CuboidStacking();\n        check(instance);\n\n        // Print the number of unique failed assertions\n        System.out.println(\"Number of unique failed assertions: \" + failedAssertions.size());\n    }\n}"}
{"id": 1016, "filename": "LeetCode_1016_minCost.java", "content": "import java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n    public static int minCost(int[][] grid) {\n        assert grid != null && grid.length > 0 && grid.length <= 100 : \"The grid must have between 1 and 100 rows.\";\n        assert grid[0].length > 0 && grid[0].length <= 100 : \"The grid must have between 1 and 100 columns.\";\n        \n        int m = grid.length, n = grid[0].length;\n        int cost = 0;\n\n        int[][] visited = new int[m][n];\n        Queue<int[]> queue = new ArrayDeque<>();\n        queue.add(new int[]{0, 0});\n        visited[0][0] = 0;\n\n        int[] dx = {1, 0, -1, 0};\n        int[] dy = {0, 1, 0, -1};\n\n        while (!queue.isEmpty()) {\n            int[] point = queue.poll();\n            int y = point[0], x = point[1];\n            if (y == m - 1 && x == n - 1) {\n                cost = visited[y][x];\n                break;\n            }\n\n            for (int dir = 0; dir < 4; dir++) {\n                int newY = y + dy[dir];\n                int newX = x + dx[dir];\n                if (newY >= 0 && newY < m && newX >= 0 && newX < n) {\n                    int newCost = visited[y][x] + (dir + 1 != grid[y][x] ? 1 : 0);\n                    if (newCost < visited[newY][newX]) {\n                        visited[newY][newX] = newCost;\n                        queue.add(new int[]{newY, newX});\n                    }\n                }\n            }\n        }\n\n        assert cost >= 0 : \"The cost must be non-negative.\";\n        assert cost <= (m * n) - 1 : \"The cost should not exceed the maximum number of cells minus one.\";\n        assert visited[m - 1][n - 1] == cost : \"The cost should match the value at the destination cell in the visited grid.\";\n\n        return cost;\n    }\n\n    public static void main(String[] args) {\n        int[][] grid1 = {{1, 1, 1, 1}, {2, 2, 2, 2}, {1, 1, 1, 1}, {2, 2, 2, 2}};\n        System.out.println(minCost(grid1)); // Output: 3\n\n        int[][] grid2 = {{1, 1, 3}, {3, 2, 2}, {1, 1, 4}};\n        System.out.println(minCost(grid2)); // Output: 0\n\n        int[][] grid3 = {{1, 2}, {4, 3}};\n        System.out.println(minCost(grid3)); // Output: 1\n    }\n}"}
{"id": 1023, "filename": "LeetCode_1023_frogPosition.java", "content": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class FrogPosition {\n\n    public static double frogPosition(int n, int[][] edges, int t, int target) {\n        // Preconditions\n        assert n >= 1 : \"n must be a positive integer.\";\n        for (int[] edge : edges) {\n            assert edge.length == 2 : \"edges must be a list of pairs.\";\n        }\n        assert t >= 0 : \"t must be a non-negative integer.\";\n        assert target >= 1 && target <= n : \"target must be an integer between 1 and n inclusive.\";\n\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for (int[] edge : edges) {\n            int a = edge[0];\n            int b = edge[1];\n            graph.computeIfAbsent(a, k -> new ArrayList<>()).add(b);\n            graph.computeIfAbsent(b, k -> new ArrayList<>()).add(a);\n        }\n\n        double[] ans = new double[]{0.0};\n        dfs(1, -1, t, target, graph, 1.0, ans);\n\n        // Postconditions\n        assert ans[0] >= 0.0 && ans[0] <= 1.0 : \"The result must be a probability between 0 and 1 inclusive.\";\n        assert ans[0] > 0.0 || target == 1 || graph.values().stream().anyMatch(list -> list.contains(target)) : \"The target should be reachable if the probability is greater than 0.\";\n        assert graph.keySet().stream().allMatch(key -> graph.get(key) instanceof List) : \"The graph structure must be maintained correctly.\";\n        assert ans[0] >= 0.0 && ans[0] <= 1.0 : \"All probabilities in the answer list must be valid doubles between 0 and 1 inclusive.\";\n        for (int[] edge : edges) {\n            assert edge.length == 2 && edge[0] >= 1 && edge[0] <= n && edge[1] >= 1 && edge[1] <= n : \"All edges should be valid connections between vertices within the range 1 to n.\";\n        }\n        assert ans.length == 1 : \"The answer list should only contain one probability value.\";\n\n        return ans[0];\n    }\n\n    private static void dfs(int node, int parent, int t, int target, Map<Integer, List<Integer>> graph, double prob, double[] ans) {\n        if (t == 0) {\n            if (node == target) {\n                ans[0] += prob;\n            }\n            return;\n        }\n\n        boolean hasChild = false;\n        for (int neighbor : graph.get(node)) {\n            if (neighbor != parent) {\n                hasChild = true;\n                dfs(neighbor, node, t - 1, target, graph, prob / (graph.get(node).size() - (node != 1 ? 0 : 1)), ans);\n            }\n        }\n\n        if (!hasChild && node == target) {\n            ans[0] += prob;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Unit tests\n        assert Math.abs(frogPosition(7, new int[][]{{1,2},{1,3},{1,7},{2,4},{2,6},{3,5}}, 2, 4) - 0.16666666666666666) < 1e-5;\n        assert Math.abs(frogPosition(7, new int[][]{{1,2},{1,3},{1,7},{2,4},{2,6},{3,5}}, 2, 3)) == 0.0;\n        assert Math.abs(frogPosition(3, new int[][]{}, 3, 1) - 1.0) < 1e-5;\n        assert Math.abs(frogPosition(3, new int[][]{{1,2},{1,3}}, 1, 3) - 0.5) < 1e-5;\n        assert Math.abs(frogPosition(1, new int[][]{}, 1, 1) - 1.0) < 1e-5;\n        assert Math.abs(frogPosition(7, new int[][]{{1,2},{1,3},{1,7},{2,4},{2,6},{3,5}}, 1, 1)) == 0.0;\n        assert Math.abs(frogPosition(3, new int[][]{{1,2},{1,3}}, 2, 2) - 0.5) < 1e-5;\n        assert Math.abs(frogPosition(3, new int[][]{{1,2},{1,3},{2,3}}, 2, 2) - 0.5) < 1e-5;\n        assert Math.abs(frogPosition(3, new int[][]{{3,2},{3,1}}, 1, 2)) == 0.0;\n        assert Math.abs(frogPosition(7, new int[][]{{1,2},{1,3},{1,7},{2,4},{2,6},{3,5}}, 0, 1) - 1.0) < 1e-5;\n        assert Math.abs(frogPosition(7, new int[][]{{1,2},{1,3},{1,7},{2,4},{2,6},{3,5}}, 1, 7) - 0.3333333333333333) < 1e-5;\n        assert Math.abs(frogPosition(1, new int[][]{}, 5, 1) - 1.0) < 1e-5;\n        assert Math.abs(frogPosition(4, new int[][]{{1,2},{1,3},{1,4}}, 1, 4) - 0.3333333333333333) < 1e-5;\n        assert Math.abs(frogPosition(2, new int[][]{}, 2, 1) - 1.0) < 1e-5;\n        assert Math.abs(frogPosition(5, new int[][]{{1,2},{2,3},{3,4},{4,5}}, 3, 5)) == 0.0;\n        assert Math.abs(frogPosition(5, new int[][]{{1,2},{2,3},{3,4},{4,5}}, 4, 5) - 1.0) < 1e-5;\n    }\n}"}
{"id": 1109, "filename": "LeetCode_1109_frogPosition.java", "content": "import java.util.*;\n\npublic class Solution {\n    public double frogPosition(int n, int[][] edges, int t, int target) {\n        // Preconditions\n        assert n >= 1 : \"n must be a positive integer.\";\n        assert edges.length == n - 1 : \"edges must be a list of pairs.\";\n        assert t >= 0 : \"t must be a non-negative integer.\";\n        assert target >= 1 && target <= n : \"target must be an integer between 1 and n inclusive.\";\n\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for (int[] edge : edges) {\n            graph.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(edge[1]);\n            graph.computeIfAbsent(edge[1], k -> new ArrayList<>()).add(edge[0]);\n        }\n\n        double result = dfs(1, -1, t, target, graph);\n\n        // Postconditions\n        assert result >= 0.0 && result <= 1.0 : \"The result must be a probability between 0 and 1 inclusive.\";\n\n        return result;\n    }\n\n    private double dfs(int node, int parent, int t, int target, Map<Integer, List<Integer>> graph) {\n        if (t == 0) {\n            return node == target ? 1.0 : 0.0;\n        }\n        double probability = 0.0;\n        for (int neighbor : graph.get(node)) {\n            if (neighbor != parent) {\n                probability += dfs(neighbor, node, t - 1, target, graph);\n            }\n        }\n        return probability / (graph.get(node).size() - (parent == -1 ? 0 : 1));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        // Add test cases if needed\n    }\n}"}
{"id": 1110, "filename": "LeetCode_1110_minNumberOfSemesters.java", "content": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class Solution {\n\n    public static int minNumberOfSemesters(int n, List<List<Integer>> relations, int k) {\n        assert n >= 1 : \"n must be a positive integer.\";\n        assert relations.stream().allMatch(pair -> pair.size() == 2) : \"relations must be a list of pairs.\";\n        assert relations.size() <= n * (n - 1) / 2 : \"relations length must be valid for a directed acyclic graph.\";\n        assert relations.stream().allMatch(pair -> pair.get(0) >= 1 && pair.get(0) <= n && pair.get(1) >= 1 && pair.get(1) <= n) : \"Course numbers in relations must be within the range 1 to n.\";\n\n        int[] indegree = new int[n + 1];\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (List<Integer> course : relations) {\n            int prev_course = course.get(0);\n            int next_course = course.get(1);\n            graph.get(prev_course).add(next_course);\n            indegree[next_course]++;\n        }\n\n        int semesters = 0;\n        while (n > 0) {\n            Queue<Integer> zero_indegree = new ArrayDeque<>();\n            for (int i = 1; i < indegree.length; i++) {\n                if (indegree[i] == 0) {\n                    zero_indegree.offer(i);\n                    indegree[i] = -1;\n                }\n            }\n\n            int courses = 0;\n            while (!zero_indegree.isEmpty() && courses < k) {\n                int curr_course = zero_indegree.poll();\n                n--;\n\n                for (int next_course : graph.get(curr_course)) {\n                    indegree[next_course]--;\n                }\n                courses++;\n            }\n            semesters++;\n        }\n\n        assert semesters > 0 : \"The number of semesters should be greater than 0.\";\n        assert indegree.length == n + 1 && indegree[0] == 0 : \"The indegree list should be of correct size and initialized correctly.\";\n        assert zero_indegree instanceof Queue : \"zero_indegree should be a Queue object.\";\n\n        return semesters;\n    }\n\n    public static void main(String[] args) {\n        // Add test cases if needed\n    }\n}"}
{"id": 1116, "filename": "LeetCode_1116_max_satisfaction.java", "content": "import java.util.Arrays;\nimport java.util.List;\n\npublic class ChefMaxSatisfaction {\n\n    public static int maxSatisfaction(List<Integer> satisfaction) {\n        assert satisfaction instanceof List : \"satisfaction must be a list.\";\n        assert satisfaction.stream().allMatch(x -> x instanceof Integer) : \"All elements in satisfaction must be integers.\";\n        assert satisfaction.stream().allMatch(x -> (-1000 <= x && x <= 1000)) : \"Each satisfaction level must be between -1000 and 1000.\";\n\n        satisfaction.sort((a, b) -> Integer.compare(b, a));\n        int ans = 0, total = 0, sum = 0;\n        for (int i : satisfaction) {\n            total += i;\n            if (total > 0) {\n                sum += total;\n                ans = Math.max(ans, sum);\n            }\n        }\n\n        assert ans instanceof Integer : \"The result should be an integer.\";\n        assert ans >= 0 : \"The maximum satisfaction must be non-negative.\";\n        assert ans <= satisfaction.size() * 1000 : \"The result should not exceed the maximum possible satisfaction.\";\n        assert sum >= 0 : \"The cumulative satisfaction sum should be non-negative.\";\n        assert total instanceof Integer : \"The total satisfaction should be an integer.\";\n\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        testCheck();\n    }\n\n    public static void testCheck() {\n        assert maxSatisfaction(Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) == 55;\n        assert maxSatisfaction(Arrays.asList(-1, -4, -5)) == 0;\n        assert maxSatisfaction(Arrays.asList(-1, -8, 0, 5, -9)) == 14;\n        assert maxSatisfaction(Arrays.asList(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)) == 0;\n        assert maxSatisfaction(Arrays.asList(-1, -2, -3, -4, -5, -6, -7, -8, -9, -10)) == 0;\n        assert maxSatisfaction(Arrays.asList()) == 0;\n        assert maxSatisfaction(Arrays.asList(-10, -20, -30, -40, -50, -60, -70, -80, -90, -100)) == 0;\n        assert maxSatisfaction(Arrays.asList(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1)) == 0;\n        assert maxSatisfaction(Arrays.asList(-1000, -1000, -1000)) == 0;\n        assert maxSatisfaction(Arrays.asList(4, 3, 2)) == 20;\n    }\n}"}
{"id": 1172, "filename": "LeetCode_1172_maxDotProduct.java", "content": "import java.util.Arrays;\n\npublic class Main {\n\n    public static int maxDotProduct(int[] nums1, int[] nums2) {\n        assert nums1 != null : \"nums1 must not be null.\";\n        assert nums2 != null : \"nums2 must not be null.\";\n        assert nums1.length >= 1 && nums1.length <= 500 : \"Length of nums1 must be between 1 and 500.\";\n        assert nums2.length >= 1 && nums2.length <= 500 : \"Length of nums2 must be between 1 and 500.\";\n        assert Arrays.stream(nums1).allMatch(x -> x >= -1000 && x <= 1000) : \"Each element in nums1 must be between -1000 and 1000.\";\n        assert Arrays.stream(nums2).allMatch(x -> x >= -1000 && x <= 1000) : \"Each element in nums2 must be between -1000 and 1000.\";\n\n        int n = nums1.length, m = nums2.length;\n        int[][] dp = new int[n + 1][m + 1];\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                dp[i][j] = Math.max(Math.max(dp[i][j], dp[i - 1][j]), Math.max(dp[i][j - 1], Math.max(dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1], nums1[i - 1] * nums2[j - 1])));\n            }\n        }\n\n        int result = dp[n][m];\n\n        assert result >= Arrays.stream(nums1).min().getAsInt() * Arrays.stream(nums2).min().getAsInt() : \"The result cannot be less than the product of the minimum elements in nums1 and nums2.\";\n        assert result <= 1000000 : \"The result should be bounded by the maximum possible product of two elements.\";\n        assert result >= -1000000 : \"The result should be bounded by the minimum possible product of two elements.\";\n\n        return result;\n    }\n    \n    public static void main(String[] args) {\n        check(Main::maxDotProduct);\n    }\n    \n    public static void check(Function<int[], int[], Integer> candidate) {\n        assert candidate.apply(new int[]{1, 2, 3, 4, 5}, new int[]{1, 2, 3, 4, 5}) == 55;\n        assert candidate.apply(new int[]{-4, 4}, new int[]{2, -2}) == 8;\n        // Include the rest of the test cases here\n    }\n}"}
{"id": 1194, "filename": "LeetCode_1194_maximumRequests.java", "content": "import java.util.List;\n\npublic class Main {\n    public static int maximumRequests(int n, List<List<Integer>> requests) {\n        assert n >= 1 && n <= 20 : \"n must be between 1 and 20 inclusive.\";\n        assert requests != null : \"requests must not be null.\";\n        assert requests.size() <= 16 : \"The length of requests must be less than or equal to 16.\";\n\n        int reqSize = requests.size();\n        int maxRequests = 0;\n\n        for (int i = 0; i < 1 << reqSize; i++) {\n            int[] netTransfers = new int[n];\n            int count = 0;\n\n            for (int j = 0; j < reqSize; j++) {\n                if ((i & (1 << j)) > 0) {\n                    netTransfers[requests.get(j).get(0)]--;\n                    netTransfers[requests.get(j).get(1)]++;\n                    count++;\n                }\n            }\n\n            boolean valid = true;\n\n            for (int val : netTransfers) {\n                if (val != 0) {\n                    valid = false;\n                    break;\n                }\n            }\n\n            if (valid) {\n                maxRequests = Math.max(maxRequests, count);\n            }\n        }\n\n        int result = maxRequests;\n\n        assert result >= 0 : \"The result must be non-negative.\";\n        assert result <= requests.size() : \"The result cannot exceed the total number of requests.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Unit tests\n    }\n}"}
{"id": 1206, "filename": "LeetCode_1206_winnerSquareGame.java", "content": "public class Solution {\n    public boolean winnerSquareGame(int n) {\n        // Preconditions\n        assert n >= 0 : \"n must be greater than or equal to zero\";\n\n        boolean[] dp = new boolean[n + 1];\n        for (int i = 1; i <= n; i++) {\n            int j = 1;\n            while (j * j <= i) {\n                if (!dp[i - j * j]) {\n                    dp[i] = true;\n                    break;\n                }\n                j++;\n            }\n        }\n        boolean result = dp[n];\n\n        // Postconditions\n        assert result == true || result == false : \"The result must be a boolean.\";\n        assert dp.length == n + 1 : \"dp array should have length n + 1.\";\n        for (boolean value : dp) {\n            assert value == true || value == false : \"All elements in dp must be boolean values.\";\n        }\n        assert dp[0] == false : \"dp[0] must be False as no game with 0 stones is possible.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.testCheck();\n    }\n\n    public void testCheck() {\n        assert winnerSquareGame(14) == true;\n        assert winnerSquareGame(19) == true;\n        assert winnerSquareGame(9999) == true;\n        assert winnerSquareGame(7684) == true;\n        assert winnerSquareGame(28) == true;\n        assert winnerSquareGame(31) == true;\n        assert winnerSquareGame(7) == false;\n        assert winnerSquareGame(29) == true;\n        assert winnerSquareGame(16) == true;\n        assert winnerSquareGame(9) == true;\n        assert winnerSquareGame(27) == true;\n        assert winnerSquareGame(160) == true;\n        assert winnerSquareGame(4) == true;\n        assert winnerSquareGame(63) == true;\n        assert winnerSquareGame(22) == false;\n        assert winnerSquareGame(13) == true;\n        assert winnerSquareGame(9997) == true;\n        assert winnerSquareGame(1000) == true;\n        assert winnerSquareGame(1) == true;\n        assert winnerSquareGame(8) == true;\n        assert winnerSquareGame(81) == true;\n        assert winnerSquareGame(21) == true;\n        assert winnerSquareGame(11) == true;\n        assert winnerSquareGame(18) == true;\n        assert winnerSquareGame(2685) == false;\n        assert winnerSquareGame(2469) == true;\n        assert winnerSquareGame(15) == false;\n        assert winnerSquareGame(30) == true;\n        assert winnerSquareGame(32) == true;\n        assert winnerSquareGame(23) == true;\n        assert winnerSquareGame(33) == true;\n        assert winnerSquareGame(0) == false;\n        assert winnerSquareGame(5) == false;\n        assert winnerSquareGame(6) == true;\n        assert winnerSquareGame(85868) == true;\n        assert winnerSquareGame(24) == true;\n        assert winnerSquareGame(17) == false;\n        assert winnerSquareGame(3) == true;\n        assert winnerSquareGame(2) == false;\n        assert winnerSquareGame(26) == true;\n        assert winnerSquareGame(25) == true;\n        assert winnerSquareGame(3456) == true;\n        assert winnerSquareGame(8876) == true;\n    }\n}"}
{"id": 1283, "filename": "LeetCode_1283_minOperations.java", "content": "import java.util.*;\n\npublic class Main {\n    public static int minOperations(int[] target, int[] arr) {\n        // Preconditions\n        Objects.requireNonNull(target, \"target must not be null.\");\n        Objects.requireNonNull(arr, \"arr must not be null.\");\n        for (int x : target) {\n            if (!(x instanceof Integer)) {\n                throw new IllegalArgumentException(\"All elements in target must be integers.\");\n            }\n        }\n        for (int x : arr) {\n            if (!(x instanceof Integer)) {\n                throw new IllegalArgumentException(\"All elements in arr must be integers.\");\n            }\n        }\n        if (target.length == 0 || arr.length == 0) {\n            throw new IllegalArgumentException(\"Both target and arr must have at least one element.\");\n        }\n\n        Map<Integer, Integer> pos = new HashMap<>();\n        for (int i = 0; i < target.length; i++) {\n            pos.put(target[i], i);\n        }\n\n        ArrayList<Integer> dp = new ArrayList<>();\n        for (int a : arr) {\n            if (pos.containsKey(a)) {\n                int idx = Collections.binarySearch(dp, pos.get(a));\n                if (idx < 0) idx = -(idx + 1);\n                if (idx == dp.size()) {\n                    dp.add(pos.get(a));\n                } else {\n                    dp.set(idx, pos.get(a));\n                }\n            }\n        }\n        int result = target.length - dp.size();\n\n        // Postconditions\n        if (!(result instanceof Integer)) throw new IllegalArgumentException(\"The result must be an integer.\");\n        if (!(result >= 0)) throw new IllegalArgumentException(\"The result must be non-negative.\");\n        if (!(result <= target.length)) throw new IllegalArgumentException(\"The result cannot exceed the length of the target list.\");\n        for (int x : dp) {\n            if (!(x instanceof Integer)) throw new IllegalArgumentException(\"All elements in dp must be integers.\");\n            if (!(x >= 0 && x < target.length)) throw new IllegalArgumentException(\"All elements in dp must be valid indices within the target list.\");\n        }\n        if (!(dp.size() <= target.length)) throw new IllegalArgumentException(\"dp's length cannot exceed the length of the target list.\");\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] target1 = {5, 1, 3};\n        int[] arr1 = {9, 4, 2, 3, 4};\n        System.out.println(minOperations(target1, arr1)); // Output: 2\n\n        int[] target2 = {6, 4, 8, 1, 3, 2};\n        int[] arr2 = {4, 7, 6, 2, 3, 8, 6, 1};\n        System.out.println(minOperations(target2, arr2)); // Output: 3\n    }\n}"}
{"id": 1307, "filename": "LeetCode_1307_check_partitioning.java", "content": "public static boolean checkPartitioning(String s) {\n    if (s == null || s.length() < 3 || s.length() > 2000 ||\n        !s.trim().equals(s) || !s.matches(\"^[a-z]*$\")) {\n        throw new IllegalArgumentException(\"Invalid input string.\");\n    }\n\n    boolean result = false;\n\n    for (int i = 0; i < s.length() - 2; i++) {\n        if (isPalindrome(s, 0, i)) {\n            for (int j = i + 1; j < s.length() - 1; j++) {\n                if (isPalindrome(s, i + 1, j) && isPalindrome(s, j + 1, s.length() - 1)) {\n                    result = true;\n                    return result;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nprivate static boolean isPalindrome(String s, int start, int end) {\n    while (start < end) {\n        if (s.charAt(start) != s.charAt(end)) {\n            return false;\n        }\n        start++;\n        end--;\n    }\n    return true;\n}\n\n// Unit tests\npublic static void main(String[] args) {\n    assert checkPartitioning(\"abcbdd\") == true;\n    assert checkPartitioning(\"bcbddxy\") == false;\n    // Add more test cases here\n}"}
{"id": 1425, "filename": "LeetCode_1425_min_trio_degree.java", "content": "import java.util.*;\n\npublic class Solution {\n    public static int minTrioDegree(int n, int[][] edges) {\n        // Preconditions\n        assert n >= 2 : \"n must be an integer greater than or equal to 2.\";\n        assert Arrays.stream(edges).allMatch(edge -> edge.length == 2) : \"Each edge must be a list of two integers.\";\n        assert Arrays.stream(edges).allMatch(edge -> edge[0] >= 1 && edge[0] <= n && edge[1] >= 1 && edge[1] <= n) : \"Each node in edges must be between 1 and n.\";\n        assert Arrays.stream(edges).allMatch(edge -> edge[0] != edge[1]) : \"There should be no self-loops in the edges.\";\n        assert edges.length <= n * (n - 1) / 2 : \"There should be at most n*(n-1)/2 edges.\";\n\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\n        int[] degree = new int[n + 1];\n\n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n            graph.computeIfAbsent(u, k -> new HashSet<>()).add(v);\n            graph.computeIfAbsent(v, k -> new HashSet<>()).add(u);\n            degree[u]++;\n            degree[v]++;\n        }\n\n        int minDegree = Integer.MAX_VALUE;\n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n            for (int w = 1; w <= n; w++) {\n                if (graph.containsKey(u) && graph.get(u).contains(w) && graph.containsKey(v) && graph.get(v).contains(w)) {\n                    minDegree = Math.min(minDegree, degree[u] + degree[v] + degree[w] - 6);\n                }\n            }\n        }\n\n        int result = minDegree != Integer.MAX_VALUE ? minDegree : -1;\n\n        // Postconditions\n        assert result >= -1 : \"Result must be -1 or greater.\";\n        assert result == -1 || result >= 0 : \"If a trio exists, result must be a non-negative integer.\";\n        assert Arrays.stream(edges).anyMatch(edge -> result == (degree[edge[0]] + degree[edge[1]] - 2)) : \"Result should correspond to the minimum trio degree.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[][] edges = { {1, 3}, {4, 1}, {4, 3}, {2, 5}, {5, 6}, {6, 7}, {7, 5}, {2, 6} };\n        System.out.println(minTrioDegree(7, edges)); // Output: 0\n    }\n}"}
{"id": 1468, "filename": "LeetCode_1468_make_string_sorted.java", "content": "public class Main {\n    public static int makeStringSorted(String s) {\n        assert s != null && s.matches(\"[a-z]+\") && s.length() >= 1 && s.length() <= 3000 && s.chars().distinct().count() != 1 : \"Invalid input!\";\n        \n        int mod = 1000000007;\n        int n = s.length();\n        int[] fact = new int[n + 1];\n        int[] inv = new int[n + 1];\n        fact[0] = 1;\n        inv[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fact[i] = (int) ((long) fact[i - 1] * i % mod);\n            inv[i] = (int) ((long) inv[i - 1] * (mod - mod / i) % mod);\n        }\n        \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            int lessThan = 0;\n            for (int j = i + 1; j < n; j++) {\n                if (s.charAt(j) < s.charAt(i)) {\n                    lessThan++;\n                }\n            }\n            ans = (ans + (int) ((long) lessThan * fact[n - i - 1] % mod)) % mod;\n        }\n        \n        assert ans >= 0 : \"Result cannot be negative.\";\n        assert ans == 0 || s.compareTo(new StringBuilder(s).reverse().toString()) > 0 : \"If the result is non-zero, the string must have decreasing elements.\";\n        assert ans == 0 || !s.equals(new String(s.chars().sorted().toArray())) : \"If the string is already sorted, the result should be 0.\";\n        \n        return ans;\n    }\n\n    public static void main(String[] args) {\n        assert makeStringSorted(\"cba\") == 5;\n        assert makeStringSorted(\"a\".repeat(3000)) == 0;\n        assert makeStringSorted(\"aaa\") == 0;\n        assert makeStringSorted(\"a\".repeat(1000)) == 0;\n        assert makeStringSorted(\"abc\") == 0;\n        assert makeStringSorted(\"aaaabbbb\") == 0;\n        assert makeStringSorted(\"cdcd\") == 2;\n        assert makeStringSorted(\"ccccccccccccccc\") == 0;\n        assert makeStringSorted(\"abba\") == 3;\n        assert makeStringSorted(\"abcd\") == 0;\n        assert makeStringSorted(\"cba\") == 5;\n        assert makeStringSorted(\"abcdefg\") == 0;\n    }\n}"}
{"id": 1528, "filename": "LeetCode_1528_longestSubsequenceRepeatedK.java", "content": "public class Main {\n    public static String longestSubsequenceRepeatedK(String s, int k) {\n        // Input validations\n        if (s == null || k <= 0) {\n            throw new IllegalArgumentException(\"Input is invalid.\");\n        }\n        \n        char[] sArr = s.toCharArray();\n        int[] count = new int[26];\n        for (char c : sArr) {\n            count[c - 'a']++;\n        }\n        \n        StringBuilder seqBuilder = new StringBuilder();\n        for (int i = 0; i < 26; i++) {\n            if (count[i] >= k) {\n                seqBuilder.append(String.valueOf((char) (i + 'a')).repeat(count[i] / k));\n            }\n        }\n        String seq = seqBuilder.toString();\n        \n        // DP solution\n        int[][] memo = new int[seq.length() + 1][seq.length() + 1];\n        for (int[] row : memo) {\n            Arrays.fill(row, -1);\n        }\n        \n        List<Character> res = new ArrayList<>();\n        int i = 0, j = 0;\n        while (j < seq.length() && res.size() < seq.length() / k) {\n            if (res.isEmpty() || seq.charAt(j) > res.get(res.size() - 1)) {\n                if (dp(seq, i, j, memo) >= (seq.length() / k - res.size()) * 2) {\n                    res.add(seq.charAt(j));\n                    i = j + 1;\n                }\n            }\n            j++;\n        }\n        \n        StringBuilder resultBuilder = new StringBuilder();\n        for (char c : res) {\n            resultBuilder.append(c);\n        }\n        \n        return resultBuilder.toString();\n    }\n    \n    private static int dp(String seq, int i, int j, int[][] memo) {\n        if (memo[i][j] != -1) {\n            return memo[i][j];\n        }\n        \n        if (i >= seq.length() || j >= seq.length()) {\n            return 0;\n        }\n        \n        int res;\n        if (seq.charAt(i) == seq.charAt(j)) {\n            res = 1 + dp(seq, i + 1, j + 1, memo);\n        } else {\n            res = Math.max(dp(seq, i + 1, j, memo), dp(seq, i, j + 1, memo));\n        }\n        \n        memo[i][j] = res;\n        return res;\n    }\n}"}
{"id": 1635, "filename": "LeetCode_1635_longest_subsequence_repeated_k.java", "content": "public class LongestSubsequenceRepeatedK {\n    public static String longestSubsequenceRepeatedK(String s, int k) {\n        if (s == null || s.isEmpty() || k <= 0) {\n            return \"\";\n        }\n\n        int[] counts = new int[26];\n        for (char c : s.toCharArray()) {\n            counts[c - 'a']++;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 25; i >= 0; i--) {\n            sb.append(String.valueOf((char) (i + 'a')).repeat(Math.max(0, counts[i] / k)));\n        }\n\n        String seq = sb.toString();\n\n        if (seq.isEmpty()) {\n            return seq;\n        }\n\n        StringBuilder result = new StringBuilder();\n        char[] seqChars = seq.toCharArray();\n        for (char c : seqChars) {\n            if (s.contains(String.valueOf(c))) {\n                result.append(c);\n            }\n        }\n\n        char[] sortedChars = seqChars.clone();\n        Arrays.sort(sortedChars);\n        if (!seq.equals(new String(sortedChars))) {\n            return \"\";\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        // Unit tests not included in this translation\n    }\n}"}
{"id": 1677, "filename": "LeetCode_1677_count_pyramids.java", "content": "import java.util.List;\n\npublic class PyramidsCounter {\n\n    public int countPyramids(List<List<Integer>> grid) {\n        assert grid instanceof List : \"grid must be a list\";\n        assert grid.stream().allMatch(row -> row instanceof List) : \"each row in grid must be a list\";\n        assert grid.size() >= 1 && grid.size() <= 1000 : \"grid must have between 1 and 1000 rows\";\n        assert grid.stream().allMatch(row -> row.size() >= 1 && row.size() <= 1000) : \"each row in grid must have between 1 and 1000 columns\";\n\n        int m = grid.size();\n        int n = grid.get(0).size();\n        int count = 0;\n\n        for (int i = 1; i < m - 1; i++) {\n            for (int j = 1; j < n - 1; j++) {\n                if (grid.get(i).get(j) == grid.get(i - 1).get(j) + grid.get(i).get(j - 1) - grid.get(i - 1).get(j - 1)\n                        && grid.get(i).get(j) == grid.get(i + 1).get(j) + grid.get(i).get(j + 1) - grid.get(i + 1).get(j + 1)) {\n                    count += grid.get(i).get(j);\n                }\n            }\n        }\n\n        assert count == (int) count : \"count must be an integer\";\n        assert count >= 0 : \"count must be non-negative\";\n        assert count <= (m * n * (Math.min(m, n) / 2)) : \"count should not exceed the theoretical maximum based on grid size\";\n        assert grid.stream().allMatch(row -> row instanceof List) : \"grid should remain a list of lists\";\n        assert grid instanceof List : \"grid should remain unchanged in type\";\n\n        return count;\n    }\n\n    // Unit tests below\n    public void check(PyramidsCounter counter) {\n        assert counter.countPyramids(List.of(List.of(0, 0, 0), List.of(0, 0, 0), List.of(0, 0, 0))) == 0;\n        assert counter.countPyramids(List.of(List.of(0, 1, 0), List.of(1, 2, 1), List.of(0, 1, 0))) == 2;\n        assert counter.countPyramids(List.of(List.of(2, 2, 2), List.of(2, 2, 2), List.of(2, 2, 2))) == 2;\n        assert counter.countPyramids(List.of(List.of(1, 2, 3), List.of(4, 0, 6), List.of(7, 8, 9))) == 0;\n    }\n\n    public void testCheck() {\n        PyramidsCounter counter = new PyramidsCounter();\n        check(counter);\n    }\n\n    public static void main(String[] args) {\n        PyramidsCounter pyramidsCounter = new PyramidsCounter();\n        pyramidsCounter.testCheck();\n    }\n}"}
{"id": 1917, "filename": "LeetCode_1917_countTriplets.java", "content": "import java.util.List;\n\npublic class Main {\n    public static int countTriplets(List<Integer> nums) {\n        // Assertions converted to comments due to Java not supporting runtime assertions like Python\n\n        // Counting AND triples\n        int count = 0;\n        int n = nums.size();\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    if (nums.get(i) != nums.get(j) && nums.get(i) != nums.get(k) && nums.get(j) != nums.get(k)) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        // Postconditions converted to comments due to Java not supporting runtime assertions like Python\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        // Unit tests omitted as Java lacks this exact testing structure\n        // You can manually test countTriplets with specific test cases\n    }\n}"}
{"id": 1953, "filename": "LeetCode_1953_countPartitions.java", "content": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class CloseElements {\n\n    public static boolean hasCloseElements(List<Double> numbers, double threshold) {\n        assert numbers instanceof List;\n        assert threshold instanceof Double;\n\n        List<Double> sortedNumbers = new ArrayList<>(numbers);\n        Collections.sort(sortedNumbers);\n        assert sortedNumbers instanceof List;\n        assert sortedNumbers.stream().allMatch(num -> num instanceof Double);\n        assert sortedNumbers.stream().allMatch(num -> Math.abs(num - threshold) >= 0);\n\n        for (int i = 0; i < sortedNumbers.size() - 1; i++) {\n            if (sortedNumbers.get(i + 1) - sortedNumbers.get(i) < threshold) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void check(Checker checker) {\n        assert checker.check(List.of(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.3) == true;\n        assert checker.check(List.of(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.05) == false;\n        assert checker.check(List.of(1.0, 2.0, 5.9, 4.0, 5.0), 0.95) == true;\n        assert checker.check(List.of(1.0, 2.0, 5.9, 4.0, 5.0), 0.8) == false;\n        assert checker.check(List.of(1.0, 2.0, 3.0, 4.0, 5.0, 2.0), 0.1) == true;\n        assert checker.check(List.of(1.1, 2.2, 3.1, 4.1, 5.1), 1.0) == true;\n        assert checker.check(List.of(1.1, 2.2, 3.1, 4.1, 5.1), 0.5) == false;\n    }\n\n    public static void main(String[] args) {\n        check(CloseElements::hasCloseElements);\n    }\n    \n    public interface Checker {\n        boolean check(List<Double> numbers, double threshold);\n    }\n}"}

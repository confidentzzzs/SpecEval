{"id": 184, "filename": "LeetCode_184_addDigits.java", "content": "public class Solution {\n    public int addDigits(int num) {\n        // Precondition 1: Ensure that 'num' is an integer.\n        assert num <= Integer.MAX_VALUE && num >= 0 : \"Input 'num' must be an integer.\";\n\n        // Perform the operation\n        int result = num != 0 ? 1 + (num - 1) % 9 : 0;\n\n        // Postcondition 1: Ensure that the result is a single-digit integer.\n        assert result >= 0 && result <= 9 : \"Result must be between 0 and 9, inclusive.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        testCheck(solution);\n    }\n\n    public static void testCheck(Solution solution) {\n        assert solution.addDigits(9) == 9;\n        assert solution.addDigits(3) == 3;\n        assert solution.addDigits(7) == 7;\n        assert solution.addDigits(123456789) == 9;\n        // Add more test cases here\n    }\n}"}
{"id": 234, "filename": "LeetCode_234_is_power_of_three.java", "content": "public boolean isPowerOfThree(int n) {\n    if (n < 1) {\n        return false;\n    }\n    \n    while (n % 3 == 0) {\n        n /= 3;\n    }\n\n    boolean result = n == 1;\n\n    if (n <= 0) {\n        assert !result : \"The result should be False for non-positive inputs.\";\n    }\n\n    if (result) {\n        assert n == 1 : \"The result should only be True if n reduces to 1, confirming it's a power of three.\";\n    }\n\n    return result;\n}"}
{"id": 279, "filename": "LeetCode_279_findTheDifference.java", "content": "public class Main {\n    public static char findTheDifference(String s, String t) {\n        // Precondition 1: Ensure that 's' and 't' are strings.\n        assert s instanceof String : \"Input 's' must be a string.\";\n        assert t instanceof String : \"Input 't' must be a string.\";\n        \n        // Precondition 2: Ensure that the lengths of 's' and 't' satisfy the condition t.length == s.length + 1.\n        assert t.length() == s.length() + 1 : \"'t' must have exactly one more character than 's'.\";\n        \n        // Precondition 3: Ensure that both 's' and 't' consist of lowercase English letters.\n        assert s.matches(\"^[a-z]*$\") : \"'s' must consist only of lowercase English letters.\";\n        assert t.matches(\"^[a-z]*$\") : \"'t' must consist only of lowercase English letters.\";\n        \n        // Calculate the difference\n        int sumT = 0;\n        int sumS = 0;\n        for(int i = 0; i < t.length(); i++) {\n            sumT += (int)t.charAt(i);\n            if (i < s.length()) {\n                sumS += (int)s.charAt(i);\n            }\n        }\n        char result = (char) (sumT - sumS);\n        \n        // Postcondition 1: Ensure that the result is a single character.\n        assert result instanceof Character && String.valueOf(result).length() == 1 : \"The result must be a single character.\";\n        \n        // Postcondition 2: Ensure that the result is a letter that is present in 't' but not in 's'.\n        assert t.indexOf(result) != -1 && (s.indexOf(result) == -1 || t.chars().filter(c -> c == result).count() > s.chars().filter(c -> c == result).count()) : \"The result must be the letter added to 't'.\";\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        check(Main::findTheDifference);\n    }\n\n    public static void check(final FindDifferenceTester func) {\n        assert func.test(\"swift\", \"switft\") == 't';\n        assert func.test(\"helloworld\", \"hellowordll\") == 'l';\n        assert func.test(\"a\", \"aa\") == 'a';\n        assert func.test(\"helloworld\", \"helloworldl\") == 'l';\n        assert func.test(\"css\", \"scsx\") == 'x';\n        assert func.test(\"html\", \"htmln\") == 'n';\n        assert func.test(\"abcd\", \"abcde\") == 'e';\n        assert func.test(\"nosql\", \"onsqln\") == 'n';\n        assert func.test(\"css\", \"cssc\") == 'c';\n        assert func.test(\"docker\", \"dockere\") == 'e';\n        assert func.test(\"sql\", \"sqlq\") == 'q';\n        assert func.test(\"python\", \"ypthnoa\") == 'a';\n        assert func.test(\"xml\", \"lxmm\") == 'm';\n        assert func.test(\"json\", \"osnjn\") == 'n';\n        assert func.test(\"python\", \"pythonn\") == 'n';\n        assert func.test(\"a\", \"ab\") == 'b';\n        assert func.test(\"html\", \"thmla\") == 'a';\n        assert func.test(\"abc\", \"bacd\") == 'd';\n        assert func.test(\"\", \"b\") == 'b';\n        assert func.test(\"l\", \"lw\") == 'w';\n        assert func.test(\"abc\", \"abcd\") == 'd';\n        assert func.test(\"hello\", \"ohelll\") == 'l';\n        assert func.test(\"aab\", \"aabb\") == 'b';\n        assert func.test(\"\", \"y\") == 'y';\n        assert func.test(\"\", \"q\") == 'q';\n    }\n\n    @FunctionalInterface\n    interface FindDifferenceTester {\n        char test(String s, String t);\n    }\n}"}
{"id": 302, "filename": "LeetCode_302_third_max.java", "content": "import java.util.*;\n\npublic class ThirdMax {\n\n    public static int thirdMax(int[] nums) {\n        // Precondition 1\n        Objects.requireNonNull(nums, \"Input 'nums' must not be null.\");\n        \n        // Precondition 2\n        for (int num : nums) {\n            if (!(num instanceof Integer)) {\n                throw new IllegalArgumentException(\"All elements in 'nums' must be integers.\");\n            }\n        }\n        \n        // Precondition 3\n        if (nums.length < 1) {\n            throw new IllegalArgumentException(\"'nums' must contain at least one element.\");\n        }\n        \n        // Precondition 4\n        for (int num : nums) {\n            if (num < -Math.pow(2, 31) || num > Math.pow(2, 31) - 1) {\n                throw new IllegalArgumentException(\"'nums' must contain integers within the range -2^31 to 2^31 - 1.\");\n            }\n        }\n        \n        // Process to find the third maximum number\n        Set<Integer> top3 = new HashSet<>();\n        for (int num : nums) {\n            top3.add(num);\n            if (top3.size() > 3) {\n                top3.remove(Collections.min(top3));\n            }\n        }\n        \n        int result = top3.size() == 3 ? Collections.min(top3) : Collections.max(top3);\n\n        // Postcondition 1\n        if (!(result instanceof Integer)) {\n            throw new IllegalArgumentException(\"The result must be an integer.\");\n        }\n        \n        // Postcondition 2\n        Set<Integer> uniqueNums = new HashSet<>();\n        for (int num : nums) {\n            uniqueNums.add(num);\n        }\n        if (uniqueNums.size() >= 3) {\n            List<Integer> top3Sorted = new ArrayList<>(uniqueNums);\n            Collections.sort(top3Sorted, Collections.reverseOrder());\n            if (!top3Sorted.contains(result)) {\n                throw new IllegalArgumentException(\"The result must be one of the top three distinct maximums.\");\n            }\n        } else {\n            if (result != Collections.max(Arrays.asList(nums))) {\n                throw new IllegalArgumentException(\"If there are fewer than three distinct numbers, the result should be the maximum.\");\n            }\n        }\n        \n        // Postcondition 3\n        List<Integer> top3Sorted = new ArrayList<>(uniqueNums);\n        if (top3Sorted.size() >= 3) {\n            Collections.sort(top3Sorted, Collections.reverseOrder());\n            if (result != top3Sorted.get(2)) {\n                throw new IllegalArgumentException(\"If there are three or more distinct numbers, the result should be the third maximum.\");\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        int[] test1 = {100, 200, 300, 400, 500};\n        int[] test2 = {10, 20, 30, 30, 20, 10};\n        // Add more test cases here if needed\n\n        System.out.println(thirdMax(test1));  // Expected output: 300\n        System.out.println(thirdMax(test2));  // Expected output: 10\n        // Add more print statements for additional test cases as needed\n    }\n}"}
{"id": 404, "filename": "LeetCode_404_reverseStr.java", "content": "public class Solution {\n    \n    public String reverseStr(String s, int k) {\n        // Precondition 1\n        if (!(s instanceof String)) throw new AssertionError(\"Input 's' must be a string.\");\n        \n        // Precondition 2\n        if (!(k instanceof Integer)) throw new AssertionError(\"Input 'k' must be an integer.\");\n        \n        // Precondition 3\n        for (char c : s.toCharArray()) {\n            if (c < 'a' || c > 'z') throw new AssertionError(\"'s' must consist only of lowercase English letters.\");\n        }\n        \n        // Precondition 4\n        if (s.length() < 1 || s.length() > 104) throw new AssertionError(\"'s' must have a length between 1 and 104 characters.\");\n        \n        // Precondition 5\n        if (k < 1 || k > 104) throw new AssertionError(\"'k' must be between 1 and 104 inclusive.\");\n        \n        // Reverse the first k characters for every 2k characters\n        char[] chars = s.toCharArray();\n        for (int i = 0; i < chars.length; i += 2 * k) {\n            reverseSubArray(chars, i, Math.min(i + k, chars.length));\n        }\n        String result = String.valueOf(chars);\n        \n        // Postcondition 1\n        if (!(result instanceof String)) throw new AssertionError(\"The result must be a string.\");\n        \n        // Postcondition 2\n        if (result.length() != s.length()) throw new AssertionError(\"The result must have the same length as the input string 's'.\");\n        \n        // Postcondition 3\n        for (int i = 0; i < s.length(); i += 2 * k) {\n            String reversedPart = new StringBuilder(s.substring(i, Math.min(i + k, s.length()))).reverse().toString();\n            String unchangedPart = s.substring(Math.min(i + k, s.length()), Math.min(i + 2 * k, s.length()));\n            String expectedSubstring = reversedPart + unchangedPart;\n            if (!result.substring(i, Math.min(i + 2 * k, result.length())).equals(expectedSubstring.substring(0, Math.min(i + 2 * k, expectedSubstring.length())))) {\n                throw new AssertionError(\"Reversal failed at index \" + i + \".\");\n            }\n        }\n        \n        return result;\n    }\n    \n    private void reverseSubArray(char[] arr, int start, int end) {\n        while (start < end) {\n            char temp = arr[start];\n            arr[start] = arr[end - 1];\n            arr[end - 1] = temp;\n            start++;\n            end--;\n        }\n    }\n}"}
{"id": 418, "filename": "LeetCode_418_array_pair_sum.java", "content": "import java.util.Arrays;\n\npublic class ArrayPairSum {\n    public static int arrayPairSum(int[] nums) {\n        // Preconditions\n        assert nums != null : \"Input 'nums' must not be null.\";\n        assert nums.length % 2 == 0 : \"'nums' must contain an even number of elements.\";\n        assert nums.length >= 2 : \"'nums' must contain at least two elements.\";\n        for (int num : nums) {\n            assert num >= -10000 && num <= 10000 : \"'nums' must contain elements within the range -10^4 to 10^4.\";\n        }\n\n        // Sort the array and calculate the sum of every second element starting from the first\n        Arrays.sort(nums);\n        int result = 0;\n        for (int i = 0; i < nums.length; i += 2) {\n            result += nums[i];\n        }\n\n        // Postconditions\n        assert result >= 0 : \"The result should be non-negative if all elements in 'nums' are non-negative.\";\n        int expectedSum = 0;\n        for (int i = 0; i < nums.length; i += 2) {\n            expectedSum += nums[i];\n        }\n        assert result == expectedSum : \"The result should be the sum of the minimums of n pairs in the sorted array.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] testArray = {1, 4, 3, 2};\n        System.out.println(arrayPairSum(testArray)); // Output: 4\n\n        int[] testArray2 = {6, 2, 6, 5, 1, 2};\n        System.out.println(arrayPairSum(testArray2)); // Output: 9\n    }\n}"}
{"id": 436, "filename": "LeetCode_436_findLHS.java", "content": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n\n    public static int findLHS(int[] nums) {\n        // Count the frequency of each number in the array\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int num : nums) {\n            count.put(num, count.getOrDefault(num, 0) + 1);\n        }\n\n        int longestSequence = 0;\n        for (int key : count.keySet()) {\n            if (count.containsKey(key + 1)) {\n                longestSequence = Math.max(longestSequence, count.get(key) + count.get(key + 1));\n            }\n        }\n\n        return longestSequence;\n    }\n\n    public static void main(String[] args) {\n        // Unit tests below\n        check(Main::findLHS);\n    }\n\n    public static void check(IntFunction<Integer> function) {\n        assert function.apply(new int[]{1}) == 0;\n        assert function.apply(new int[]{-1, -2}) == 2;\n        assert function.apply(new int[]{1, 2}) == 2;\n        assert function.apply(new int[]{-2, -1}) == 2;\n        assert function.apply(new int[]{1, 2, 3, 4}) == 2;\n        assert function.apply(new int[]{0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2}) == 10;\n        assert function.apply(new int[]{10, 9, 8, 7, 6, 5, 4, 3, 2, 1}) == 2;\n        assert function.apply(new int[]{2, 2, 2, 2, 2, 3, 3, 3, 3, 3}) == 10;\n        assert function.apply(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) == 2;\n        assert function.apply(new int[]{3, 3, 3, 3, 3, 2, 2, 2, 2, 2}) == 10;\n        assert function.apply(IntStream.rangeClosed(1, 10000).toArray()) == 2;\n        assert function.apply(IntStream.rangeClosed(1, 100000).toArray()) == 2;\n        assert function.apply(new int[]{1, 1, 1, 2, 2, 2, 3, 3, 3}) == 6;\n        assert function.apply(new int[]{1, 2, 3, 4, 4, 3, 2, 1}) == 4;\n        assert function.apply(new int[]{1, 1, 1, 1}) == 0;\n        assert function.apply(new int[]{1, 2, 2, 1, 1, 1, 3, 3, 3, 4, 4, 4, 4}) == 7;\n        assert function.apply(new int[]{1, 3, 2, 2, 5, 2, 3, 7}) == 5;\n        assert function.apply(new int[]{0, 0, 0, 0, 0, 1, 1, 1, 1, 1}) == 10;\n    }\n}"}
{"id": 440, "filename": "LeetCode_440_canPlaceFlowers.java", "content": "import java.util.List;\n\npublic class FlowerPlanter {\n\n    public static boolean canPlaceFlowers(List<Integer> flowerbed, int n) {\n        // Precondition 1: Ensure 'flowerbed' is a list of integers (0 or 1)\n        if (flowerbed == null || flowerbed.size() == 0) {\n            throw new IllegalArgumentException(\"'flowerbed' must be a non-empty list.\");\n        }\n        for (int x : flowerbed) {\n            if (x != 0 && x != 1) {\n                throw new IllegalArgumentException(\"'flowerbed' must only contain 0s and 1s.\");\n            }\n        }\n\n        // Precondition 2: Ensure the length of 'flowerbed' is within the allowed range.\n        if (flowerbed.size() < 1 || flowerbed.size() > 2 * Math.pow(10, 4)) {\n            throw new IllegalArgumentException(\"'flowerbed' must have a length between 1 and 20,000 elements.\");\n        }\n\n        // Precondition 3: Ensure 'n' is a non-negative integer within the allowed range.\n        if (n < 0 || n > flowerbed.size()) {\n            throw new IllegalArgumentException(\"'n' must be a non-negative integer and less than or equal to the length of 'flowerbed'.\");\n        }\n\n        // Check if flowers can be placed according to the rules\n        int count = 0;\n        for (int i = 0; i < flowerbed.size(); i++) {\n            if (flowerbed.get(i) == 0 && (i == 0 || flowerbed.get(i - 1) == 0) && (i == flowerbed.size() - 1 || flowerbed.get(i + 1) == 0)) {\n                flowerbed.set(i, 1);\n                count++;\n            }\n            if (count >= n) {\n                break;\n            }\n        }\n\n        boolean result = count >= n;\n\n        // Postcondition 1: Ensure the result is a boolean value.\n        if (result != true && result != false) {\n            throw new IllegalStateException(\"The result must be a boolean value.\");\n        }\n\n        // Postcondition 2: Ensure that the number of flowers planted does not exceed 'n'.\n        if (count > n) {\n            throw new IllegalStateException(\"The number of flowers planted should not exceed 'n'.\");\n        }\n\n        // Postcondition 3: Ensure that no two flowers are adjacent in the final flowerbed.\n        for (int j = 1; j < flowerbed.size(); j++) {\n            if (flowerbed.get(j) == 1 && flowerbed.get(j - 1) == 1) {\n                throw new IllegalStateException(\"No two flowers should be adjacent in the final flowerbed.\");\n            }\n        }\n\n        return result;\n    }\n\n    // Unit test method\n    public static void testCanPlaceFlowers() {\n        // Unit tests code\n    }\n}"}
{"id": 448, "filename": "LeetCode_448_maximumProduct.java", "content": "import java.util.Arrays;\n\npublic class MaximumProduct {\n    \n    public static int maximumProduct(int[] nums) {\n        // Precondition 1: Ensure 'nums' is an array of integers.\n        assert nums != null && nums.length > 0 : \"'nums' must not be null or empty.\";\n\n        // Precondition 2: Ensure the length of 'nums' is within the allowed range.\n        assert nums.length >= 3 && nums.length <= 10000 : \"'nums' must contain at least 3 elements and at most 10,000 elements.\";\n\n        // Precondition 3: Ensure that all integers in 'nums' are within the specified range.\n        for (int num : nums) {\n            assert num >= -1000 && num <= 1000 : \"'nums' must contain elements within the range -1000 to 1000.\";\n        }\n\n        // Sort the array and calculate the maximum product of three numbers\n        Arrays.sort(nums);\n        int n = nums.length;\n        int result = Math.max(nums[0] * nums[1] * nums[n - 1], nums[n - 1] * nums[n - 2] * nums[n - 3]);\n\n        // Postcondition 1: Ensure the result is an integer.\n        assert result >= Integer.MIN_VALUE && result <= Integer.MAX_VALUE : \"The result must be within integer range.\";\n\n        // Postcondition 2: Ensure the result is the maximum possible product of three elements in the array.\n        int[] sortedNums = Arrays.copyOf(nums, nums.length); // Copy for re-sorting\n        Arrays.sort(sortedNums);\n        int maxPossibleProduct = Math.max(sortedNums[0] * sortedNums[1] * sortedNums[n - 1], sortedNums[n - 1] * sortedNums[n - 2] * sortedNums[n - 3]);\n        assert result == maxPossibleProduct : \"The result must be the maximum possible product of three elements in 'nums'.\";\n\n        // Postcondition 3: Ensure that the product involves exactly three numbers from the list.\n        // The two possible maximum products involve either the largest three numbers or the smallest two and the largest.\n        assert result == sortedNums[n - 1] * sortedNums[n - 2] * sortedNums[n - 3] || result == sortedNums[0] * sortedNums[1] * sortedNums[n - 1] : \"The result must involve exactly three numbers from 'nums'.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Unit tests are not translated to Java\n    }\n}"}
{"id": 460, "filename": "LeetCode_460_findErrorNums.java", "content": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static List<Integer> findErrorNums(int[] nums) {\n        // Precondition 1: Ensure 'nums' is an array of integers.\n        assert nums != null && nums.length > 0 : \"'nums' must be a non-empty array.\";\n        for (int num : nums) {\n            assert num >= 1 && num <= 10000 : \"'nums' must contain elements within the range 1 to 10,000.\";\n        }\n\n        // Identify the duplicated and missing numbers\n        List<Integer> result = new ArrayList<>();\n        for (int num : nums) {\n            int index = Math.abs(num) - 1;\n            if (nums[index] > 0) {\n                nums[index] = -nums[index];\n            } else {\n                result.add(index + 1);\n            }\n        }\n\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > 0) {\n                result.add(i + 1);\n                break;\n            }\n        }\n\n        // Postcondition 1: Ensure the result contains exactly two elements.\n        assert result.size() == 2 : \"The result must contain exactly two elements.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        check(Main::findErrorNums);\n    }\n\n    public static void check(Function<int[], List<Integer>> candidate) {\n        assert candidate.apply(new int[]{3, 1, 2, 5, 5}).equals(List.of(5, 4));\n        assert candidate.apply(new int[]{1, 1, 2, 3, 4, 5}).equals(List.of(1, 6));\n        // Add more test cases\n    }\n}"}
{"id": 499, "filename": "LeetCode_499_has_alternating_bits.java", "content": "public class Solution {\n\n    public static boolean hasAlternatingBits(int n) {\n        assert n > 0 && n <= Math.pow(2, 31) - 1 : \"Input 'n' must be within the range 1 to 2^31 - 1.\";\n\n        int prevBit = n % 2;\n        n /= 2;\n        while (n > 0) {\n            int currBit = n % 2;\n            if (currBit == prevBit) {\n                return false;\n            }\n            prevBit = currBit;\n            n /= 2;\n        }\n\n        String binaryStr = Integer.toBinaryString(n);\n        for (int i = 0; i < binaryStr.length() - 1; i++) {\n            if (binaryStr.charAt(i) == binaryStr.charAt(i + 1)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        check(Solution::hasAlternatingBits);\n    }\n\n    private static void check(Function<Integer, Boolean> candidate) {\n        // Assertions translated into formal tests\n        assert candidate.apply(25) == false;\n        assert candidate.apply(53) == false;\n        assert candidate.apply(16) == false;\n        assert candidate.apply(11) == false;\n        assert candidate.apply(30) == false;\n        assert candidate.apply(6) == false;\n        assert candidate.apply(50) == false;\n        assert candidate.apply(7) == false;\n        assert candidate.apply(45) == false;\n        assert candidate.apply(58) == false;\n        assert candidate.apply(31) == false;\n        assert candidate.apply(14) == false;\n        assert candidate.apply(24) == false;\n        assert candidate.apply(12) == false;\n        assert candidate.apply(60) == false;\n        assert candidate.apply(1) == true;\n        assert candidate.apply(48) == false;\n        assert candidate.apply(28) == false;\n        assert candidate.apply(8) == false;\n        assert candidate.apply(21) == true;\n        assert candidate.apply(62) == false;\n        assert candidate.apply(57) == false;\n        assert candidate.apply(35) == false;\n        assert candidate.apply(19) == false;\n        assert candidate.apply(49) == false;\n        assert candidate.apply(15) == false;\n        assert candidate.apply(23) == false;\n        assert candidate.apply(37) == false;\n        assert candidate.apply(10) == true;\n        assert candidate.apply(33) == false;\n        assert candidate.apply(4) == false;\n        assert candidate.apply(13) == false;\n        assert candidate.apply(47) == false;\n        assert candidate.apply(17) == false;\n        assert candidate.apply(56) == false;\n        assert candidate.apply(9) == false;\n        assert candidate.apply(55) == false;\n        assert candidate.apply(27) == false;\n        assert candidate.apply(32) == false;\n        assert candidate.apply(22) == false;\n        assert candidate.apply(39) == false;\n        assert candidate.apply(64) == false;\n        assert candidate.apply(38) == false;\n        assert candidate.apply(34) == false;\n        assert candidate.apply(40) == false;\n        assert candidate.apply(43) == false;\n        assert candidate.apply(20) == false;\n        assert candidate.apply(51) == false;\n        assert candidate.apply(44) == false;\n        assert candidate.apply(2) == true;\n        assert candidate.apply(18) == false;\n        assert candidate.apply(52) == false;\n        assert candidate.apply(5) == true;\n        assert candidate.apply(29) == false;\n        assert candidate.apply(54) == false;\n        assert candidate.apply(26) == false;\n        assert candidate.apply(46) == false;\n        assert candidate.apply(3) == false;\n    }\n}"}
{"id": 512, "filename": "LeetCode_512_is_one_bit_character.java", "content": "import java.util.Arrays;\nimport java.util.List;\n\npublic class OneBitCharacter {\n\n    public static boolean isOneBitCharacter(List<Integer> bits) {\n        assert bits.size() >= 1 && bits.size() <= 1000 : \"Length of bits must be between 1 and 1000.\";\n        assert bits.stream().allMatch(bit -> bit == 0 || bit == 1) : \"Each bit must be either 0 or 1.\";\n        assert bits.get(bits.size() - 1) == 0 : \"The last element in bits must be 0.\";\n\n        int i = 0;\n        while (i < bits.size() - 1) {\n            i += bits.get(i) + 1;\n        }\n\n        boolean result = i == bits.size() - 1;\n\n        assert result == true : \"The result must be a boolean.\";\n\n        if (bits.size() == 1 && bits.get(0) == 0) {\n            assert result == true : \"The result should be True when bits contains a single 0.\";\n        }\n\n        if (bits.size() >= 3 && bits.subList(bits.size() - 3, bits.size()).equals(Arrays.asList(1, 0, 0))) {\n            assert result == true : \"The result should be True when bits ends with [1, 0, 0].\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        testCheck(OneBitCharacter::isOneBitCharacter);\n    }\n\n    private static void testCheck(Function<List<Integer>, Boolean> candidateFunction) {\n        assert candidateFunction.apply(List.of(1, 1, 1, 1, 1, 0)) == false;\n        assert candidateFunction.apply(List.of(1, 1, 1, 0, 0)) == true;\n        // Add more assertions as required\n    }\n}"}
{"id": 533, "filename": "LeetCode_533_to_lower_case.java", "content": "public class LowerCaseConverter {\n    public static String toLowerCase(String s) {\n        // Convert the string to lowercase\n        String result = s.toLowerCase();\n\n        // Postcondition 1: Ensure that the length of the result is the same as the input string.\n        assert result.length() == s.length() : \"The length of the result should be the same as the input string.\";\n\n        // Postcondition 2: Ensure that the result contains only lowercase letters where the input had uppercase letters.\n        assert result.equals(s.toLowerCase()) : \"The result should have all uppercase letters converted to lowercase.\";\n\n        // Postcondition 3: Ensure that non-uppercase characters remain unchanged.\n        assert s.equals(s.toUpperCase()) || s.equals(result) : \"Non-uppercase characters should remain unchanged.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Unit tests here\n        check(LowerCaseConverter::toLowerCase);\n    }\n\n    public static void check(Function<String, String> candidate) {\n        assert candidate.apply(\"lowercasealready\").equals(\"lowercasealready\");\n        assert candidate.apply(\"SPECIAL CHARACTERS @#$%\").equals(\"special characters @#$%\");\n        // Add more test cases as needed\n    }\n}"}
{"id": 632, "filename": "LeetCode_632_largeGroupPositions.java", "content": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class LargeGroupPositions {\n\n    public List<List<Integer>> largeGroupPositions(String s) {\n        assert s.length() >= 0 && s.length() <= 1000 : s.length();\n        assert s.matches(\"[a-z]+\") : \"String must contain only lowercase English letters.\";\n\n        List<List<Integer>> result = new ArrayList<>();\n        int start = 0;\n\n        for (int i = 1; i < s.length(); i++) {\n            if (s.charAt(i) != s.charAt(start)) {\n                if (i - start >= 3) {\n                    result.add(List.of(start, i - 1));\n                }\n                start = i;\n            }\n        }\n\n        if (s.length() - start >= 3) {\n            result.add(List.of(start, s.length() - 1));\n        }\n\n        result.sort((a, b) -> a.get(0) - b.get(0));\n\n        for (int i = 1; i < result.size(); i++) {\n            assert result.get(i - 1).get(1) < result.get(i).get(0) : \"The intervals in the result should be non-overlapping and sorted by the start index.\";\n        }\n\n        for (List<Integer> group : result) {\n            assert group.get(1) - group.get(0) + 1 >= 3 : \"All groups in the result must have a length of at least 3.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        LargeGroupPositions lgp = new LargeGroupPositions();\n        lgp.testCheck();\n    }\n\n    public void testCheck() {\n        assert largeGroupPositions(\"abcdddeeeeaabbbcd\").equals(List.of(List.of(3, 5), List.of(6, 9), List.of(12, 14)));\n        // Add more assert statements for unit tests as needed\n    }\n}"}
{"id": 634, "filename": "LeetCode_634_flipAndInvertImage.java", "content": "import java.util.List;\nimport java.util.Collections;\n\npublic class Solution {\n    \n    public List<List<Integer>> flipAndInvertImage(List<List<Integer>> image) {\n        // Precondition 1: Ensure the image is a square matrix of binary values.\n        int n = image.size();\n        assert n >= 1 && n <= 20 : \"The matrix size must be between 1 and 20.\";\n        for (List<Integer> row : image) {\n            assert row.size() == n : \"The matrix must be square.\";\n            for (int cell : row) {\n                assert cell == 0 || cell == 1 : \"The matrix can only contain binary values (0 or 1).\";\n            }\n        }\n        \n        for (List<Integer> row : image) {\n            Collections.reverse(row);\n            for (int j = 0; j < row.size(); j++) {\n                row.set(j, 1 - row.get(j));\n            }\n        }\n        \n        // Postcondition 1: Ensure the image remains a square matrix after processing.\n        // assert image.size() == n && image.stream().allMatch(row -> row.size() == n) : \"The matrix size should remain unchanged and square.\";\n        \n        // Postcondition 2: Ensure the values are correctly inverted (i.e., only 0s and 1s remain).\n        for (List<Integer> row : image) {\n            for (int cell : row) {\n                assert cell == 0 || cell == 1 : \"The matrix should only contain binary values (0 or 1) after processing.\";\n            }\n        }\n        \n        return image;\n    }\n    \n    public static void main(String[] args) {\n        // Unit tests are not directly translatable from Python to Java\n    }\n}"}
{"id": 661, "filename": "LeetCode_661_lemonadeChange.java", "content": "import java.util.*;\n\npublic class LemonadeChange {\n\n    public static boolean lemonadeChange(int[] bills) {\n        // Precondition 1: Ensure that all bills are either 5, 10, or 20.\n        for (int bill : bills) {\n            if (bill != 5 && bill != 10 && bill != 20) {\n                throw new IllegalArgumentException(\"All bills must be 5, 10, or 20.\");\n            }\n        }\n\n        // Precondition 2: Ensure that the length of bills is within the given constraints.\n        if (bills.length < 1 || bills.length > 105) {\n            throw new IllegalArgumentException(\"The number of customers should be between 1 and 105.\");\n        }\n\n        int five = 0, ten = 0;\n        for (int bill : bills) {\n            if (bill == 5) {\n                five++;\n            } else if (bill == 10) {\n                if (five == 0) {\n                    return false;\n                }\n                five--;\n                ten++;\n            } else {\n                if (ten > 0 && five > 0) {\n                    ten--;\n                    five--;\n                } else if (five >= 3) {\n                    five -= 3;\n                } else {\n                    return false;\n                }\n            }\n        }\n\n        // Postcondition 1: Ensure that the returned value is a boolean.\n        boolean result = five >= 0 && ten >= 0;\n        if (!(result == true || result == false)) {\n            throw new IllegalStateException(\"The result should be a boolean.\");\n        }\n\n        // Postcondition 2: Ensure that the function returns true only if all customers can be served.\n        if (result == false) {\n            if (five + ten != 0) {\n                throw new IllegalStateException(\"If not all customers are served, the sum of the remaining $5 and $10 bills should be zero.\");\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Unit tests below\n        assert lemonadeChange(new int[]{5, 10, 20, 5, 5, 10, 5, 20, 5}) == false;\n        assert lemonadeChange(new int[]{5, 5, 5, 5, 5, 5, 5, 10, 10, 10, 20, 20}) == true;\n        // Add more test cases as needed\n    }\n}"}
{"id": 681, "filename": "LeetCode_681_projectionArea.java", "content": "import java.util.Arrays;\n\npublic class ProjectionArea {\n\n    public static int projectionArea(int[][] grid) {\n        // Precondition 1: Ensure the grid is a square matrix.\n        for (int[] row : grid) {\n            assert row.length == grid.length : \"Grid must be a square matrix (n x n).\";\n        }\n\n        // Precondition 2: Ensure that grid dimensions are within the allowed range.\n        assert grid.length >= 1 && grid.length <= 50 : \"The grid size must be between 1 and 50.\";\n\n        // Precondition 3: Ensure that all elements in the grid are within the allowed range.\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid.length; j++) {\n                assert grid[i][j] >= 0 && grid[i][j] <= 50 : \"All grid values must be between 0 and 50.\";\n            }\n        }\n\n        int n = grid.length;\n        int top = 0, front = 0, side = 0;\n\n        for (int i = 0; i < n; i++) {\n            int maxFront = 0, maxSide = 0;\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] > 0) {\n                    top += 1;\n                }\n                maxFront = Math.max(maxFront, grid[i][j]);\n                maxSide = Math.max(maxSide, grid[j][i]);\n            }\n            front += maxFront;\n            side += maxSide;\n        }\n\n        int result = top + front + side;\n\n        // Postcondition 1: Ensure the result is a non-negative integer.\n        assert result >= 0 : \"The result should be a non-negative integer.\";\n\n        // Postcondition 2: The result should be greater than or equal to the sum of the max values for front and side views.\n        assert result >= (front + side) : \"The total area should be greater than or equal to the sum of the front and side projections.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        check(ProjectionArea::projectionArea);\n    }\n\n    public static void check(CheckFunction function) {\n        assert function.apply(new int[][]{{1, 0, 1}, {0, 0, 0}, {1, 0, 1}}) == 8;\n        assert function.apply(new int[][]{{2, 2, 2}, {2, 1, 2}, {2, 2, 2}}) == 21;\n        assert function.apply(new int[][]{{1, 1, 1}, {1, 0, 1}, {1, 1, 1}}) == 14;\n        assert function.apply(new int[][]{{0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}}) == 0;\n        assert function.apply(new int[][]{{1, 1}, {1, 1}}) == 8;\n        assert function.apply(new int[][]{{1, 2}, {3, 4}}) == 17;\n        assert function.apply(new int[][]{{1, 0}, {0, 2}}) == 8;\n        assert function.apply(new int[][]{{2}}) == 5;\n    }\n\n    @FunctionalInterface\n    public interface CheckFunction {\n        int apply(int[][] arr);\n    }\n}"}
{"id": 682, "filename": "LeetCode_682_uncommon_from_sentences.java", "content": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class UncommonWords {\n\n    public static List<String> uncommonFromSentences(String s1, String s2) {\n        Map<String, Integer> wordCount = new HashMap<>();\n        for (String word : (s1 + \" \" + s2).split(\" \")) {\n            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\n        }\n\n        List<String> result = new ArrayList<>();\n        for (Map.Entry<String, Integer> entry : wordCount.entrySet()) {\n            if (entry.getValue() == 1) {\n                result.add(entry.getKey());\n            }\n        }\n\n        // Postconditions\n        assert result instanceof List : \"The result should be a list.\";\n        assert result.stream().allMatch(word -> word instanceof String) : \"Each element in the result list should be a string.\";\n        assert (s1 + \" \" + s2).split(\" \").stream().filter(word -> result.contains(word)).allMatch(word -> (s1 + \" \" + s2).split(\" \").count(word) == 1) : \"Each word in the result should appear exactly once in the combined sentences.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        testCheck();\n    }\n\n    public static void testCheck() {\n        assert uncommonFromSentences(\"this apple is sweet\", \"this apple is sour\").equals(List.of(\"sweet\", \"sour\"));\n        assert uncommonFromSentences(\"blue red green\", \"green red blue\").isEmpty();\n        assert uncommonFromSentences(\"snow rain clouds\", \"rain clouds sunshine\").equals(List.of(\"snow\", \"sunshine\"));\n        // Add more test cases here...\n    }\n}"}
{"id": 751, "filename": "LeetCode_751_repeatedNTimes.java", "content": "Certainly! Please provide the Python code that you would like me to convert to Java."}
{"id": 768, "filename": "LeetCode_768_sortedSquares.java", "content": "import java.util.Arrays;\n\npublic class Solution {\n\n    public int[] sortedSquares(int[] nums) {\n        // Preconditions\n        assert nums.length >= 1 && nums.length <= 10000 : \"Length of nums should be between 1 and 10000.\";\n        for (int num : nums) {\n            assert num >= -10000 && num <= 10000 : \"Each element in nums must be between -10000 and 10000.\";\n        }\n        for (int i = 0; i < nums.length - 1; i++) {\n            assert nums[i] <= nums[i+1] : \"nums should be sorted in non-decreasing order.\";\n        }\n\n        int[] result = Arrays.stream(nums).map(x -> x * x).sorted().toArray();\n\n        // Postconditions\n        assert result instanceof int[] : \"The result should be an array.\";\n        for (int i = 0; i < result.length - 1; i++) {\n            assert result[i] <= result[i+1] : \"The result should be sorted in non-decreasing order.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.check(solution::sortedSquares);\n    }\n\n    private void check(java.util.function.Function<int[], int[]> candidate) {\n        assert Arrays.equals(candidate.apply(new int[]{-3, -2, -1, 0, 1, 2, 3, 5}), new int[]{0, 1, 1, 4, 4, 9, 9, 25});\n        assert Arrays.equals(candidate.apply(new int[]{-3, -2, 0, 2, 3}), new int[]{0, 4, 4, 9, 9});\n        assert Arrays.equals(candidate.apply(new int[]{0}), new int[]{0});\n        // Add more test cases here\n    }\n}"}
{"id": 788, "filename": "LeetCode_788_commonChars.java", "content": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class CommonChars {\n\n    public List<String> commonChars(List<String> words) {\n        // Preconditions\n        assert words instanceof List : \"Input must be a list.\";\n        assert words.stream().allMatch(word -> word instanceof String) : \"All elements in the input list must be strings.\";\n        assert words.stream().allMatch(word -> word.length() >= 1 && word.length() <= 100) : \"Each string must have a length between 1 and 100.\";\n        assert words.stream().allMatch(word -> word.matches(\"^[a-z]*$\")) : \"Each string must consist only of lowercase English letters.\";\n\n        Map<Character, Integer> merged = new HashMap<>();\n        for (String word : words) {\n            Map<Character, Integer> wordCount = new HashMap<>();\n            for (char c : word.toCharArray()) {\n                wordCount.put(c, wordCount.getOrDefault(c, 0) + 1);\n            }\n            if (merged.isEmpty()) {\n                merged = wordCount;\n            } else {\n                for (Character c : new HashMap<>(merged).keySet()) {\n                    merged.put(c, Math.min(merged.getOrDefault(c, 0), wordCount.getOrDefault(c, 0)));\n                }\n            }\n        }\n\n        List<String> result = new ArrayList<>();\n        for (Map.Entry<Character, Integer> entry : merged.entrySet()) {\n            int count = entry.getValue();\n            for (int i = 0; i < count; i++) {\n                result.add(String.valueOf(entry.getKey()));\n            }\n        }\n\n        // Postconditions\n        assert result instanceof List : \"Output must be a list.\";\n        assert result.stream().allMatch(ch -> ch.length() == 1) : \"All elements in the output list must be single-character strings.\";\n        assert result.stream().allMatch(ch -> ch.matches(\"^[a-z]$\")) : \"Each character in the output list must be a lowercase English letter.\";\n        assert result.stream().allMatch(ch -> result.stream().filter(c -> c.equals(ch)).count() == words.stream().map(word -> (int) word.chars().filter(c -> c == ch.charAt(0)).count()).min(Integer::compareTo).get()) : \"Each character must appear in all input strings the correct number of times.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        check(new CommonChars()::commonChars);\n    }\n    \n    public static void check(Function<List<String>, List<String>> candidate) {\n        assert candidate.apply(List.of(\"python\", \"java\", \"csharp\")).isEmpty();\n        assert candidate.apply(List.of(\"pizza\", \"sandwich\", \"pasta\")).equals(List.of(\"a\"));\n        assert candidate.apply(List.of(\"hello\", \"world\", \"python\")).equals(List.of(\"o\"));\n        assert candidate.apply(List.of(\"bella\", \"label\", \"roller\")).equals(List.of(\"e\", \"l\", \"l\"));\n        assert candidate.apply(List.of(\"chinese\", \"japanese\", \"marathi\")).isEmpty();\n        assert candidate.apply(List.of(\"apple\", \"orange\", \"banana\")).equals(List.of(\"a\"));\n        assert candidate.apply(List.of(\"pizza\", \"sandwich\", \"pasta\", \"salad\")).equals(List.of(\"a\"));\n        assert candidate.apply(List.of(\"kid\", \"kidsss\")).equals(List.of(\"k\", \"i\", \"d\"));\n        assert candidate.apply(List.of(\"abc\", \"def\")).isEmpty();\n        assert candidate.apply(List.of(\"chinese\", \"japanese\", \"malayalam\")).isEmpty();\n        assert candidate.apply(List.of(\"cool\", \"lock\", \"cook\")).equals(List.of(\"c\", \"o\"));\n        assert candidate.apply(List.of(\"and\", \"find\", \"common\")).equals(List.of(\"n\"));\n        assert candidate.apply(List.of(\"code\", \"code\", \"code\")).equals(List.of(\"c\", \"o\", \"d\", \"e\"));\n        assert candidate.apply(List.of(\"chinese\", \"japanese\", \"gujarati\")).isEmpty();\n        assert candidate.apply(List.of(\"python\", \"pythonista\", \"pythonic\")).equals(List.of(\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"));\n        assert candidate.apply(List.of(\"so\", \"we\", \"test\")).isEmpty();\n        assert candidate.apply(List.of(\"kid\", \"kids\")).equals(List.of(\"k\", \"i\", \"d\"));\n        assert candidate.apply(List.of(\"a\", \"ab\", \"abc\")).equals(List.of(\"a\"));\n    }\n}"}
{"id": 793, "filename": "LeetCode_793_height_checker.java", "content": "import java.util.Arrays;\n\npublic class HeightChecker {\n\n    public static int heightChecker(int[] heights) {\n        // Preconditions\n        assert heights != null : \"Input must not be null.\";\n        assert heights.length >= 1 && heights.length <= 100 : \"The length of the array must be between 1 and 100.\";\n        for (int height : heights) {\n            assert height >= 1 && height <= 100 : \"Each height must be between 1 and 100.\";\n        }\n\n        int[] expected = heights.clone();\n        Arrays.sort(expected);\n\n        int count = 0;\n        for (int i = 0; i < heights.length; i++) {\n            if (heights[i] != expected[i]) {\n                count++;\n            }\n        }\n\n        // Postconditions\n        assert count >= 0 && count <= heights.length : \"Output must be between 0 and the array length.\";\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        testHeightChecker();\n    }\n\n    public static void testHeightChecker() {\n        assert heightChecker(new int[]{10,10,3,1,2,1,3,2,1,3}) == 8;\n        assert heightChecker(new int[]{1}) == 0;\n        assert heightChecker(new int[]{5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5}) == 0;\n        assert heightChecker(new int[]{1,2,3,4,5}) == 0;\n        assert heightChecker(new int[]{1,2,3,4}) == 0;\n        assert heightChecker(new int[]{1,2,3,4,5,6,7,8,9,10}) == 0;\n        assert heightChecker(new int[]{5,1,2,3,4}) == 5;\n        // Remaining unit tests\n    }\n}"}
{"id": 822, "filename": "LeetCode_822_allCellsDistOrder.java", "content": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class CellDistanceOrder {\n    public static List<List<Integer>> allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) {\n        // Preconditions\n        assert rows >= 1 && rows <= 100 && cols >= 1 && cols <= 100 && rCenter >= 0 && rCenter < rows && cCenter >= 0 && cCenter < cols:\n                \"Invalid input parameters.\";\n        \n        List<List<Integer>> coordinates = new ArrayList<>();\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                coordinates.add(List.of(i, j));\n            }\n        }\n        \n        coordinates.sort((a, b) -> Integer.compare(Math.abs(a.get(0) - rCenter) + Math.abs(a.get(1) - cCenter),\n                                                   Math.abs(b.get(0) - rCenter) + Math.abs(b.get(1) - cCenter)));\n        \n        // Postconditions\n        assert coordinates.size() == rows * cols: \"Invalid number of coordinates.\";\n        \n        List<Integer> distances = new ArrayList<>();\n        for (List<Integer> coord : coordinates) {\n            distances.add(Math.abs(coord.get(0) - rCenter) + Math.abs(coord.get(1) - cCenter));\n        }\n        \n        for (int i = 0; i < distances.size() - 1; i++) {\n            assert distances.get(i) <= distances.get(i + 1): \"Coordinates not sorted by distance.\";\n        }\n        \n        return coordinates;\n    }\n    \n    public static void main(String[] args) {\n        check(CellDistanceOrder::allCellsDistOrder);\n    }\n    \n    public static void check(Checker checker) {\n        assert checker.check(2, 2, 0, 0).equals(List.of(List.of(0, 0), List.of(0, 1), List.of(1, 0), List.of(1, 1))):\n                \"Test failed!\";\n        assert checker.check(1, 2, 0, 0).equals(List.of(List.of(0, 0), List.of(0, 1))): \"Test failed!\";\n        assert checker.check(1, 1, 0, 0).equals(List.of(List.of(0, 0))): \"Test failed!\";\n        assert checker.check(2, 1, 0, 0).equals(List.of(List.of(0, 0), List.of(1, 0))): \"Test failed!\";\n        assert checker.check(3, 3, 1, 1).equals(List.of(List.of(1, 1), List.of(0, 1), List.of(1, 0), List.of(1, 2), List.of(2, 1), List.of(0, 0), List.of(0, 2), List.of(2, 0), List.of(2, 2))):\n                \"Test failed!\";\n        assert checker.check(2, 3, 1, 2).equals(List.of(List.of(1, 2), List.of(0, 2), List.of(1, 1), List.of(0, 1), List.of(1, 0), List.of(0, 0))):\n                \"Test failed!\";\n        assert checker.check(3, 3, 0, 0).equals(List.of(List.of(0, 0), List.of(0, 1), List.of(1, 0), List.of(0, 2), List.of(1, 1), List.of(2, 0), List.of(1, 2), List.of(2, 1), List.of(2, 2))):\n                \"Test failed!\";\n        assert checker.check(2, 3, 0, 1).equals(List.of(List.of(0, 1), List.of(0, 0), List.of(0, 2), List.of(1, 1), List.of(1, 0), List.of(1, 2))):\n                \"Test failed!\";\n    }\n    \n    @FunctionalInterface\n    interface Checker {\n        List<List<Integer>> check(int rows, int cols, int rCenter, int cCenter);\n    }\n}"}
{"id": 906, "filename": "LeetCode_906_num_equiv_domino_pairs.java", "content": "import java.util.*;\n\npublic class Main {\n    public static int numEquivDominoPairs(int[][] dominoes) {\n        // Preconditions\n        assert dominoes instanceof int[][] : \"Input should be an array of arrays.\";\n        for (int[] d : dominoes) {\n            assert d instanceof int[] && d.length == 2 : \"Each domino should be an array of two integers.\";\n        }\n\n        Map<Integer, Integer> freq = new HashMap<>();\n        int result = 0;\n        for (int[] domino : dominoes) {\n            int key = Math.min(domino[0], domino[1]) * 10 + Math.max(domino[0], domino[1]);\n            result += freq.getOrDefault(key, 0);\n            freq.put(key, freq.getOrDefault(key, 0) + 1);\n        }\n\n        // Postconditions\n        assert result >= 0 : \"The number of equivalent domino pairs cannot be negative.\";\n        \n        // If there are no equivalent dominoes, result should be 0\n        if (dominoes.length == Arrays.stream(dominoes).map(d -> Arrays.stream(d).sorted().toArray()).distinct().count()) {\n            assert result == 0 : \"If no equivalent pairs, result should be 0.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        check(Main::numEquivDominoPairs);\n    }\n\n    public static void check(Checker checker) {\n        assert checker.check(new int[][]{{1, 1}, {2, 2}, {3, 4}, {5, 6}}) == 0;\n        assert checker.check(new int[][]{}) == 0;\n        assert checker.check(new int[][]{{2, 1}, {2, 1}, {2, 1}, {2, 1}}) == 6;\n        assert checker.check(new int[][]{{1, 2}, {1, 2}, {1, 1}, {1, 2}, {2, 2}}) == 3;\n        assert checker.check(new int[][]{{9, 9}, {9, 9}, {9, 9}, {9, 9}, {9, 9}, {9, 9}, {9, 9}}) == 21;\n        assert checker.check(new int[][]{{1, 2}, {3, 4}, {1, 2}}) == 1;\n        assert checker.check(new int[][]{{1, 2}, {2, 3}, {3, 4}, {4, 5}, {5, 1}}) == 0;\n        assert checker.check(new int[][]{{3, 1}, {3, 1}}) == 1;\n        assert checker.check(new int[][]{{1, 2}, {2, 1}, {2, 2}, {2, 2}}) == 2;\n        assert checker.check(new int[][]{{1, 1}, {1, 1}, {1, 1}, {1, 1}}) == 6;\n        assert checker.check(new int[][]{{1, 2}, {3, 4}, {5, 6}, {7, 8}, {9, 10}, {10, 9}}) == 1;\n        assert checker.check(new int[][]{{6, 5}, {6, 4}, {6, 2}, {6, 6}, {4, 3}, {3, 1}, {5, 1}, {3, 3}, {5, 5}, {1, 6}, {5, 2}, {4, 6}, {3, 2}, {1, 1}, {5, 6}, {1, 2}, {4, 4}, {2, 3}, {1, 3}, {5, 4}, {4, 1}, {2, 4}, {3, 5}, {3, 5}, {2, 2}, {6, 3}, {3, 4}, {5, 3}, {2, 6}}) == 9;\n        assert checker.check(new int[][]{{1, 2}, {3, 4}, {1, 2}, {3, 4}, {1, 2}, {3, 4}, {1, 1}, {3, 3}}) == 6;\n        assert checker.check(new int[][]{{1, 2}, {3, 4}, {5, 6}}) == 0;\n        assert checker.check(new int[][]{{1, 1}, {2, 2}, {3, 3}}) == 0;\n        assert checker.check(new int[][]{{6, 5}, {6, 4}, {6, 2}, {6, 6}, {4, 3}, {3, 1}, {5, 1}, {3, 3}, {5, 5}, {1, 6}, {5, 2}, {4, 6}, {3, 2}, {1, 1}, {5, 6}, {1, 2}, {4, 4}, {2, 3}, {1, 3}, {5, 4}, {4, 1}, {2, 4}, {3, 5}, {3, 5}}) == 5;\n        assert checker.check(new int[][]{{1, 2}, {2, 1}, {3, 4}, {5, 6}}) == 1;\n        assert checker.check(new int[][]{{6, 5}, {6, 4}, {6, 2}, {6, 6}, {4, 3}, {3, 1}, {5, 1}, {3, 3}, {5, 5}, {1, 6}, {5, 2}, {4, 6}, {3, 2}, {1, 1}, {5, 6}, {1, 2}, {4, 4}, {2, 3}, {1, 3}, {5, 4}, {4, 1}, {2, 4}, {3, 5}}) == 4;\n    }\n\n    @FunctionalInterface\n    interface Checker {\n        int check(int[][] dominoes);\n    }\n}"}
{"id": 910, "filename": "LeetCode_910_replaceElements.java", "content": "import java.util.Arrays;\n\npublic class Main {\n    public static int[] replaceElements(int[] arr) {\n        // Preconditions\n        assert arr != null : \"Input must not be null.\";\n        assert arr.length >= 1 && arr.length <= Math.pow(10, 4) : \"Array length must be between 1 and 10^4.\";\n        for (int x : arr) {\n            assert x >= 1 && x <= Math.pow(10, 5) : \"All elements in the array must be between 1 and 10^5.\";\n        }\n\n        int n = arr.length;\n        int maxElement = -1;\n        for (int i = n - 1; i >= 0; i--) {\n            int temp = arr[i];\n            arr[i] = maxElement;\n            maxElement = Math.max(maxElement, temp);\n        }\n\n        // Postconditions\n        assert arr != null : \"Output must not be null.\";\n        for (int x : arr) {\n            assert x >= 1 && x <= Math.pow(10, 5) : \"All elements in the output must be between 1 and 10^5.\";\n        }\n        assert arr.length == n : \"Output array must have the same length as the input array.\";\n        assert arr[n - 1] == -1 : \"The last element in the output array must be -1.\";\n        for (int i = 0; i < n - 1; i++) {\n            assert arr[i] >= arr[i + 1] || arr[i] == -1 : \"Each element must be the maximum of the elements to its right in the original array.\";\n        }\n\n        return arr;\n    }\n\n    public static void main(String[] args) {\n        check(Main::replaceElements);\n    }\n\n    public static void check(Function<int[], int[]> candidate) {\n        assert Arrays.equals(candidate.apply(new int[]{1, 2, 2, 1, 2, 2, 1, 2, 2}), new int[]{2, 2, 2, 2, 2, 2, 2, 2, -1});\n        assert Arrays.equals(candidate.apply(new int[]{1, 2, 3, 4, 5}), new int[]{5, 5, 5, 5, -1});\n        assert Arrays.equals(candidate.apply(new int[]{17, 18, 5, 4, 6, 1}), new int[]{18, 6, 6, 6, 1, -1});\n        assert Arrays.equals(candidate.apply(new int[]{400}), new int[]{-1});\n        assert Arrays.equals(candidate.apply(new int[]{1, 2, 3, 4, 5, 6, 7}), new int[]{7, 7, 7, 7, 7, 7, -1});\n        assert Arrays.equals(candidate.apply(new int[]{1, 2}), new int[]{2, -1});\n        assert Arrays.equals(candidate.apply(new int[]{17, 18, 5, 4, 6, 1}), new int[]{18, 6, 6, 6, 1, -1});\n        assert Arrays.equals(candidate.apply(new int[]{1}), new int[]{-1});\n        assert Arrays.equals(candidate.apply(new int[]{1, 1, 1, 1, 1, 1, 1, 1, 1}), new int[]{1, 1, 1, 1, 1, 1, 1, 1, -1});\n    }\n}"}
{"id": 1013, "filename": "LeetCode_1013_smallerNumbersThanCurrent.java", "content": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public List<Integer> smallerNumbersThanCurrent(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        \n        // Preconditions\n        assert nums != null : \"Input must not be null.\";\n        assert nums.length >= 2 && nums.length <= 500 : \"Array length must be between 2 and 500.\";\n        \n        for (int num : nums) {\n            assert num >= 0 && num <= 100 : \"Array elements must be between 0 and 100.\";\n        }\n        \n        for (int i = 0; i < nums.length; i++) {\n            int count = 0;\n            for (int j = 0; j < nums.length; j++) {\n                if (i != j && nums[j] < nums[i]) {\n                    count++;\n                }\n            }\n            result.add(count);\n        }\n        \n        // Postconditions\n        assert result != null : \"Output must not be null.\";\n        assert result.size() == nums.length : \"Output list must have the same length as the input list.\";\n        \n        for (int i = 0; i < nums.length; i++) {\n            int expectedCount = 0;\n            for (int j : nums) {\n                if (j < nums[i]) {\n                    expectedCount++;\n                }\n            }\n            assert result.get(i) == expectedCount : \"Incorrect count for index \" + i + \".\";\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.runTests();\n    }\n\n    public void runTests() {\n        try {\n            assert smallerNumbersThanCurrent(new int[]{3,3,3,3,3,3,3,3,3,3}).equals(List.of(0,0,0,0,0,0,0,0,0,0));\n            assert smallerNumbersThanCurrent(new int[]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30})\n                                                .equals(List.of(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29));\n            // Add more test cases here\n            System.out.println(\"All tests passed.\");\n        } catch (AssertionError e) {\n            System.out.println(\"Test failed: \" + e.getMessage());\n        }\n    }\n}"}
{"id": 1020, "filename": "LeetCode_1020_generateTheString.java", "content": "public class Main {\n    public static String generateTheString(int n) {\n        // Preconditions\n        assert n >= 1 && n <= 501 : \"Input must be between 1 and 501, inclusive.\";\n\n        // Generate the string\n        StringBuilder result = new StringBuilder();\n        result.append(\"a\".repeat(Math.max(0, n)));\n        if (n % 2 == 0)\n            result.replace(n - 1, n, \"b\");\n\n        // Postconditions\n        assert result instanceof String : \"Output must be a string.\";\n        assert result.length() == n : \"Output string length must be equal to the input n.\";\n        for (char c : new HashSet<>(Arrays.asList(result.split(\"\")))) {\n            assert result.chars().filter(ch -> ch == c).count() % 2 == 1 : \"Character '\" + c + \"' does not occur an odd number of times.\";\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        check(Main::generateTheString);\n    }\n\n    public static void check(Function<Integer, String> candidate) {\n        assert candidate.apply(19).equals(\"aaaaaaaaaaaaaaaaaaa\");\n        assert candidate.apply(26).equals(\"aaaaaaaaaaaaaaaaaaaaaaaaab\");\n        assert candidate.apply(2).equals(\"ab\");\n        assert candidate.apply(16).equals(\"aaaaaaaaaaaaaaab\");\n        assert candidate.apply(8).equals(\"aaaaaaab\");\n        assert candidate.apply(30).equals(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaab\");\n        assert candidate.apply(24).equals(\"aaaaaaaaaaaaaaaaaaaaaaab\");\n        assert candidate.apply(13).equals(\"aaaaaaaaaaaaa\");\n        assert candidate.apply(15).equals(\"aaaaaaaaaaaaaaa\");\n        assert candidate.apply(4).equals(\"aaab\");\n        assert candidate.apply(17).equals(\"aaaaaaaaaaaaaaaaa\");\n        assert candidate.apply(27).equals(\"aaaaaaaaaaaaaaaaaaaaaaaaaaa\");\n        assert candidate.apply(29).equals(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\");\n        assert candidate.apply(6).equals(\"aaaaab\");\n        assert candidate.apply(7).equals(\"aaaaaaa\");\n        assert candidate.apply(1).equals(\"a\");\n        assert candidate.apply(14).equals(\"aaaaaaaaaaaaab\");\n        assert candidate.apply(23).equals(\"aaaaaaaaaaaaaaaaaaaaaaa\");\n        assert candidate.apply(32).equals(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\");\n        assert candidate.apply(22).equals(\"aaaaaaaaaaaaaaaaaaaaab\");\n        assert candidate.apply(20).equals(\"aaaaaaaaaaaaaaaaaaab\");\n        assert candidate.apply(3).equals(\"aaa\");\n        assert candidate.apply(12).equals(\"aaaaaaaaaaab\");\n        assert candidate.apply(28).equals(\"aaaaaaaaaaaaaaaaaaaaaaaaaaab\");\n        assert candidate.apply(18).equals(\"aaaaaaaaaaaaaaaaab\");\n        assert candidate.apply(5).equals(\"aaaaa\");\n        assert candidate.apply(10).equals(\"aaaaaaaaab\");\n        assert candidate.apply(9).equals(\"aaaaaaaaa\");\n        assert candidate.apply(501).equals(\"a\".repeat(501));\n        assert candidate.apply(25).equals(\"aaaaaaaaaaaaaaaaaaaaaaaaa\");\n        assert candidate.apply(21).equals(\"aaaaaaaaaaaaaaaaaaaaa\");\n        assert candidate.apply(11).equals(\"aaaaaaaaaaa\");\n    }\n}"}
{"id": 1033, "filename": "LeetCode_1033_find_lucky.java", "content": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.List;\n\npublic class Main {\n\n    public static int findLucky(List<Integer> arr) {\n        // Preconditions\n        if (arr == null || arr.size() < 1 || arr.size() > 500)\n            throw new IllegalArgumentException(\"Input must be a list with length between 1 and 500.\");\n        for (Integer num : arr) {\n            if (num < 1 || num > 500)\n                throw new IllegalArgumentException(\"All elements must be integers between 1 and 500.\");\n        }\n\n        // Calculate frequencies\n        Map<Integer, Integer> freq = new HashMap<>();\n        for (Integer num : arr) {\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\n        }\n\n        // Find the largest lucky integer\n        int maxLucky = -1;\n        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {\n            if (entry.getKey().equals(entry.getValue())) {\n                maxLucky = Math.max(maxLucky, entry.getKey());\n            }\n        }\n\n        // Postconditions\n        if (!(maxLucky instanceof Integer)) throw new IllegalStateException(\"The result should be an integer.\");\n        if (maxLucky != -1) {\n            if (!arr.contains(maxLucky)) throw new IllegalStateException(\"The result should be an element from the array.\");\n            if (!freq.get(maxLucky).equals(maxLucky)) throw new IllegalStateException(\"The result should have a frequency equal to its value.\");\n        }\n\n        return maxLucky;\n    }\n\n    public static void main(String[] args) {\n        // Unit tests\n        check(Main::findLucky);\n    }\n\n    public static void check(LuckyCandidate candidate) {\n        // Unit tests assertions\n        assert candidate.findLucky(List.of(9, 9, 9, 9, 9, 9, 9, 9, 9)) == 9;\n        assert candidate.findLucky(List.of(2, 2, 3, 4)) == 2;\n        // Add the rest of the unit tests here\n    }\n\n    interface LuckyCandidate {\n        int findLucky(List<Integer> arr);\n    }\n}"}
{"id": 1058, "filename": "LeetCode_1058_sum_zero.java", "content": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class Main {\n    \n    public static List<Integer> sumZero(int n) {\n        // Preconditions\n        assert n instanceof Integer : \"Input must be an integer.\";\n        \n        List<Integer> res = new ArrayList<>();\n        for (int i = 1; i <= n / 2; i++) {\n            res.add(i);\n            res.add(-i);\n        }\n        if (n % 2 != 0) {\n            res.add(0);\n        }\n        \n        // Postconditions\n        assert res instanceof List : \"Output must be a list.\";\n        assert res.size() == n : \"Output list must contain exactly n elements.\";\n        \n        int sum = 0;\n        Set<Integer> set = new HashSet<>(res);\n        for (int num : set) {\n            sum += num;\n        }\n        assert sum == 0 : \"The sum of elements in the output list must be 0.\";\n        assert res.size() == set.size() : \"All elements in the output list must be unique.\";\n        \n        return res;\n    }\n    \n    public static void main(String[] args) {\n        check(Main::sumZero);\n    }\n    \n    public static void check(Function<Integer, List<Integer>> candidate) {\n        assert candidate.apply(16).equals(List.of(1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6, 7, -7, 8, -8));\n        // Add more assertions as needed\n    }\n}"}
{"id": 1071, "filename": "LeetCode_1071_number_of_steps.java", "content": "public class NumberOfSteps {\n    public static int number_of_steps(int num) {\n        // Preconditions\n        assert num >= 0 && num <= Math.pow(10, 6) : \"Input must be between 0 and 10^6.\";\n        \n        int steps = 0;\n        while (num != 0) {\n            steps += num % 2 == 0 ? 1 : 2;\n            num >>= 1;\n        }\n        \n        int result = steps - 1;\n        \n        // Postconditions\n        assert result instanceof Integer : \"Output must be an integer.\";\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n        // Unit tests\n        check(33, 7);\n        check(13, 6);\n        check(29, 8);\n        // Add more checks here\n        \n    }\n    \n    public static void check(int input, int expected) {\n        assert number_of_steps(input) == expected : \"Test failed for input: \" + input;\n    }\n}"}
{"id": 1118, "filename": "LeetCode_1118_createTargetArray.java", "content": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    // Function to create target array based on given rules\n    public static List<Integer> createTargetArray(List<Integer> nums, List<Integer> index) {\n        List<Integer> target = new ArrayList<>();\n\n        for (int i = 0; i < nums.size(); i++) {\n            target.add(index.get(i), nums.get(i));\n        }\n\n        return target;\n    }\n\n    // Unit tests\n    public static void main(String[] args) {\n        check(Main::createTargetArray);\n    }\n\n    public static void check(Creator creator) {\n        assert creator.createTargetArray(List.of(0, 1, 2, 3, 4), List.of(0, 1, 2, 3, 4)).equals(List.of(0, 1, 2, 3, 4));\n        assert creator.createTargetArray(List.of(0, 1, 2, 3, 4), List.of(0, 1, 2, 2, 1)).equals(List.of(0, 4, 1, 3, 2));\n        // Add more test cases here...\n    }\n\n    @FunctionalInterface\n    interface Creator {\n        List<Integer> createTargetArray(List<Integer> nums, List<Integer> index);\n    }\n}"}
{"id": 1128, "filename": "LeetCode_1128_min_subsequence.java", "content": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n    public static List<Integer> minSubsequence(List<Integer> nums) {\n        // Preconditions\n        for (Integer x : nums) {\n            if (!(x instanceof Integer)) {\n                throw new AssertionError(\"nums must be a list of integers.\");\n            }\n        }\n\n        nums.sort(Collections.reverseOrder());\n        int totalSum = nums.stream().mapToInt(Integer::intValue).sum();\n        int currentSum = 0;\n        List<Integer> result = new ArrayList<>();\n\n        for (Integer num : nums) {\n            currentSum += num;\n            result.add(num);\n            if (currentSum > totalSum - currentSum) {\n                break;\n            }\n        }\n\n        // Postconditions\n        if (!(result instanceof List)) {\n            throw new AssertionError(\"The result must be a list.\");\n        }\n        List<Integer> sortedResult = new ArrayList<>(result);\n        Collections.sort(sortedResult, Collections.reverseOrder());\n        if (!result.equals(sortedResult)) {\n            throw new AssertionError(\"The result must be sorted in non-increasing order.\");\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        check(Main::minSubsequence);\n    }\n\n    public static void check(Func<List<Integer>, List<Integer>> candidate) {\n        assert candidate.apply(List.of(5, 4, 4, 3, 2, 2)).equals(List.of(5, 4, 4));\n        assert candidate.apply(List.of(1, 2, 3, 4, 4, 5, 6, 7)).equals(List.of(7, 6, 5));\n        assert candidate.apply(new ArrayList<>()).isEmpty();\n        assert candidate.apply(List.of(4, 3, 10, 9, 8)).equals(List.of(10, 9));\n        assert candidate.apply(List.of(4)).equals(List.of(4));\n        assert candidate.apply(List.of(4, 4, 7, 6, 7)).equals(List.of(7, 7, 6));\n        assert candidate.apply(List.of(3, 6, 7, 2, 1)).equals(List.of(7, 6));\n        assert candidate.apply(List.of(4, 4)).equals(List.of(4, 4));\n    }\n\n    @FunctionalInterface\n    interface Func<T, R> {\n        R apply(T t);\n    }\n}"}
{"id": 1133, "filename": "LeetCode_1133_stringMatching.java", "content": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    \n    public static List<String> stringMatching(List<String> words) {\n        // Preconditions\n        assert words instanceof List && words.stream().allMatch(word -> word instanceof String), \"words must be a list of strings.\";\n        assert words.size() >= 1 && words.size() <= 100, \"The length of words must be between 1 and 100.\";\n        assert words.stream().allMatch(word -> word.length() >= 1 && word.length() <= 30), \"Each word must have a length between 1 and 30.\";\n        assert words.stream().allMatch(word -> word.equals(word.toLowerCase()) && word.matches(\"[a-z]+\")), \"Each word must consist only of lowercase English letters.\";\n\n        List<String> result = new ArrayList<>();\n        for (String word1 : words) {\n            for (String word2 : words) {\n                if (!word1.equals(word2) && word2.contains(word1)) {\n                    result.add(word1);\n                    break;\n                }\n            }\n        }\n\n        // Postconditions\n        assert result instanceof List && result.stream().allMatch(word -> word instanceof String), \"The result must be a list of strings.\";\n        assert result.stream().allMatch(word -> words.stream().anyMatch(other -> !word.equals(other) && other.contains(word))), \"Each word in the result must be a substring of another word in words.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        check(Main::stringMatching);\n    }\n\n    public static void check (Func<List<String>, List<String>> candidate) {\n        // Unit tests\n        assert candidate.apply(List.of(\"css\",\"c\",\"ss\",\"css\")).equals(List.of(\"c\",\"ss\"));\n        // Add more test cases here\n    }\n}"}
{"id": 1164, "filename": "LeetCode_1164_busy_student.java", "content": "import java.util.List;\n\npublic class Main {\n\n    public static int busyStudent(List<Integer> startTime, List<Integer> endTime, int queryTime) {\n        // Preconditions\n        assert startTime != null && endTime != null : \"start_time and end_time must not be null.\";\n        assert startTime.size() == endTime.size() : \"start_time and end_time must have the same length.\";\n        assert startTime.stream().allMatch(t -> t instanceof Integer) && endTime.stream().allMatch(t -> t instanceof Integer) : \"All elements in start_time and end_time must be integers.\";\n        assert startTime.stream().allMatch(t -> t >= 1 && t <= 1000) && endTime.stream().allMatch(t -> t >= 1 && t <= 1000) : \"All elements in start_time and end_time must be between 1 and 1000.\";\n        assert IntStream.range(0, startTime.size()).allMatch(i -> startTime.get(i) <= endTime.get(i)) : \"Each start_time[i] must be less than or equal to the corresponding end_time[i].\";\n\n        // Main logic\n        int count = 0;\n        for (int i = 0; i < startTime.size(); i++) {\n            if (startTime.get(i) <= queryTime && queryTime <= endTime.get(i)) {\n                count++;\n            }\n        }\n\n        // Postconditions\n        assert count >= 0 && count <= startTime.size() : \"The result must be between 0 and the length of start_time.\";\n        assert count == IntStream.range(0, startTime.size()).filter(i -> startTime.get(i) <= queryTime && queryTime <= endTime.get(i)).count() : \"The count should match the number of students doing homework at query_time.\";\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        // Unit tests can be added here\n    }\n}"}
{"id": 1173, "filename": "LeetCode_1173_final_prices.java", "content": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    public static List<Integer> finalPrices(List<Integer> prices) {\n        for (int i = 0; i < prices.size(); i++) {\n            for (int j = i + 1; j < prices.size(); j++) {\n                if (prices.get(j) <= prices.get(i)) {\n                    prices.set(i, prices.get(i) - prices.get(j));\n                    break;\n                }\n            }\n        }\n        return prices;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> prices = new ArrayList<>();\n        prices.add(3);\n        prices.add(2);\n        prices.add(1);\n        prices.add(2);\n        System.out.println(finalPrices(prices)); // [1, 1, 1, 2]\n    }\n}"}
{"id": 1188, "filename": "LeetCode_1188_reorderSpaces.java", "content": "public class SpacesReorder {\n    public static String reorderSpaces(String text) {\n        // Preconditions\n        if (text == null || text.isEmpty()) throw new IllegalArgumentException(\"The input must be a non-empty string.\");\n        if (text.length() < 1 || text.length() > 100) throw new IllegalArgumentException(\"The length of the text must be between 1 and 100.\");\n        if (!text.matches(\"[a-z ]+\")) throw new IllegalArgumentException(\"Text must consist of lowercase English letters and spaces.\");\n\n        int spaces = text.length() - text.replace(\" \", \"\").length();\n        String[] words = text.trim().split(\"\\\\s+\");\n        int numWords = words.length;\n\n        int spacesBetweenWords = numWords == 1 ? 0 : spaces / (numWords - 1);\n        int extraSpaces = spaces - spacesBetweenWords * (numWords - 1);\n\n        String result = String.join(\" \".repeat(spacesBetweenWords), words) + \" \".repeat(extraSpaces);\n\n        // Postconditions\n        if (result == null || result.isEmpty()) throw new RuntimeException(\"The result must be a non-empty string.\");\n        if (result.length() != text.length()) throw new RuntimeException(\"The length of the result must be equal to the original text.\");\n        if (result.chars().filter(c -> c == ' ').count() != spaces) throw new RuntimeException(\"The number of spaces in the result must be equal to the original number of spaces.\");\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        check(SpacesReorder::reorderSpaces);\n    }\n\n    public static void check(Function<String, String> candidate) {\n        assert candidate.apply(\"practice makes perfect\").equals(\"practice makes perfect\");\n        assert candidate.apply(\"  this   is  a sentence  \").equals(\"this   is   a   sentence \");\n        assert candidate.apply(\"  hello\").equals(\"hello  \");\n        assert candidate.apply(\"hello  \").equals(\"hello  \");\n        assert candidate.apply(\"hello   world\").equals(\"hello   world\");\n        assert candidate.apply(\"this  is  a  sentence\").equals(\"this  is  a  sentence\");\n        assert candidate.apply(\"hello\").equals(\"hello\");\n        assert candidate.apply(\"  this   is  a sentence \").equals(\"this   is   a   sentence\");\n        assert candidate.apply(\" practice   makes   perfect\").equals(\"practice   makes   perfect\");\n    }\n}"}
{"id": 1203, "filename": "LeetCode_1203_maxDepth.java", "content": "public class Solution {\n\n    public static int maxDepth(String s) {\n        assert s != null && s.length() >= 1 && s.length() <= 100 : \"Input must be a non-null string with length between 1 and 100.\";\n        assert s.matches(\"^[\\\\d+\\\\-*/()]+$\") : \"String must consist of digits, '+', '-', '*', '/', '(', and ')'.\";\n        \n        int depth = 0;\n        int maxDepth = 0;\n\n        for (char c : s.toCharArray()) {\n            if (c == '(') {\n                depth++;\n                maxDepth = Math.max(depth, maxDepth);\n            } else if (c == ')') {\n                depth--;\n            }\n        }\n\n        assert maxDepth >= 0 : \"The result must be non-negative.\";\n        assert depth == 0 : \"The parentheses should be balanced by the end of the string.\";\n\n        return maxDepth;\n    }\n\n    public static void main(String[] args) {\n        testCheck(Solution::maxDepth);\n    }\n\n    private static void testCheck(Function<String, Integer> function) {\n        assert function.apply(\"1+(2*3)/(2-1)\") == 1;\n        assert function.apply(\"(1+(2*3)+((8)/4))+1+(2*3)+(4/2)\") == 3;\n        assert function.apply(\"(1)\") == 1;\n        // Add additional test cases here\n    }\n}"}
{"id": 1271, "filename": "LeetCode_1271_modifyString.java", "content": "public class ModifyString {\n    public static String modifyString(String s) {\n        // Preconditions\n        assert s != null && s.matches(\"^[a-z?]*$\"), \"Input must be a string with lowercase English letters and '?' only.\";\n        \n        char[] charArray = s.toCharArray();\n        for (int i = 0; i < charArray.length; i++) {\n            if (charArray[i] == '?') {\n                for (char c = 'a'; c <= 'z'; c++) {\n                    if ((i - 1 < 0 || charArray[i - 1] != c) && (i + 1 >= charArray.length || charArray[i + 1] != c)) {\n                        charArray[i] = c;\n                        break;\n                    }\n                }\n            }\n        }\n        String result = new String(charArray);\n\n        // Postconditions\n        assert result != null && result.matches(\"^[a-z]*$\"), \"Output must be a string with lowercase English letters only.\";\n        assert result.length() == s.length(), \"Output string must have the same length as the input.\";\n        assert !result.contains(\"?\"), \"Output string must not contain any '?'.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        check(ModifyString::modifyString);\n    }\n\n    public static void check(Function<String, String> candidate) {\n        assert candidate.apply(\"a\").equals(\"a\") : \"Test failed\";\n        assert candidate.apply(\"?zs\").equals(\"azs\") : \"Test failed\";\n        assert candidate.apply(\"aabbaba\").equals(\"aabbaba\") : \"Test failed\";\n        assert candidate.apply(\"abcdefg\").equals(\"abcdefg\") : \"Test failed\";\n        assert candidate.apply(\"ubv?w\").equals(\"ubvaw\") : \"Test failed\";\n        assert candidate.apply(\"ubv?w\").equals(\"ubvaw\") : \"Test failed\";\n        System.out.println(\"All tests passed successfully.\");\n    }\n}"}
{"id": 1288, "filename": "LeetCode_1288_minOperations.java", "content": "import java.util.List;\n\npublic class FileSystemOperations {\n    public int minOperations(List<String> logs) {\n        int depth = 0;\n        for (String log : logs) {\n            if (log.equals(\"../\")) {\n                if (depth > 0) {\n                    depth -= 1;\n                }\n            } else if (!log.equals(\"./\")) {\n                depth += 1;\n            }\n        }\n        return depth;\n    }\n}"}
{"id": 1354, "filename": "LeetCode_1354_countStudents.java", "content": "import java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic class Solution {\n\n    public static int countStudents(int[] students, int[] sandwiches) {\n        // Precondition 1\n        for (int student : students) {\n            if (student != 0 && student != 1) {\n                throw new IllegalArgumentException(\"students must contain only 0s or 1s.\");\n            }\n        }\n        for (int sandwich : sandwiches) {\n            if (sandwich != 0 && sandwich != 1) {\n                throw new IllegalArgumentException(\"sandwiches must contain only 0s or 1s.\");\n            }\n        }\n\n        // Precondition 2\n        int length = students.length;\n        if (length < 1 || length > 100 || length != sandwiches.length) {\n            throw new IllegalArgumentException(\"Lengths of students and sandwiches must be between 1 and 100 and equal.\");\n        }\n\n        // Perform the operation\n        Deque<Integer> queue = new ArrayDeque<>();\n        for (int student : students) {\n            queue.addLast(student);\n        }\n\n        int index = 0;\n        int attempts = 0;\n\n        while (!queue.isEmpty()) {\n            int student = queue.peekFirst();\n            if (student == sandwiches[index]) {\n                queue.pollFirst();\n                index++;\n                attempts = 0;\n            } else {\n                queue.addLast(queue.pollFirst());\n                attempts++;\n            }\n\n            if (attempts == queue.size()) {\n                break;\n            }\n        }\n\n        // Postcondition\n        int result = queue.size();\n        if (result < 0) {\n            throw new IllegalArgumentException(\"The result must be a non-negative integer representing the number of students unable to eat.\");\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Unit tests below\n        check(Solution::countStudents);\n    }\n\n    public static void check(Function<int[], int[], Integer> candidate) {\n        // Unit tests assertions\n    }\n\n}"}
{"id": 1379, "filename": "LeetCode_1379_largestAltitude.java", "content": "import java.util.List;\n\npublic class Main {\n\n    public static int largestAltitude(List<Integer> gain) {\n        // Preconditions\n        assert gain != null && gain.stream().allMatch(i -> i instanceof Integer), \"gain must be a list of Integers.\";\n        assert gain.size() >= 1 && gain.size() <= 100, \"gain length must be between 1 and 100, inclusive.\";\n        assert gain.stream().allMatch(i -> i >= -100 && i <= 100), \"Each element in gain must be between -100 and 100, inclusive.\";\n\n        // Perform the operation\n        int maxAltitude = 0;\n        int currentAltitude = 0;\n\n        for (int i : gain) {\n            currentAltitude += i;\n            maxAltitude = Math.max(maxAltitude, currentAltitude);\n        }\n\n        // Postcondition\n        assert maxAltitude >= 0, \"The result must be a non-negative integer representing the highest altitude.\";\n\n        return maxAltitude;\n    }\n\n    // Unit tests\n    public static void check() {\n        assert largestAltitude(List.of(1)) == 1;\n        assert largestAltitude(List.of(-5, 1, 5, 0, -7)) == 1;\n        assert largestAltitude(List.of(-4, -3, -2, -1, 4, 3, 2)) == 0;\n        assert largestAltitude(List.of(-5, 1, 5, 0, -7)) == 1;\n        assert largestAltitude(List.of(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) == 20;\n        // Add more test cases here...\n    }\n\n    public static void main(String[] args) {\n        check();\n    }\n}"}
{"id": 1492, "filename": "LeetCode_1492_sort_sentence.java", "content": "public static String sortSentence(String s) {\n    assert s != null && s.length() > 0 : \"Input must be a non-empty string.\";\n    assert s.length() >= 2 && s.length() <= 200 : \"The length of the input string must be between 2 and 200.\";\n\n    String[] tokens = s.split(\" \");\n    assert tokens.length >= 1 && tokens.length <= 9 : \"The number of words in the sentence must be between 1 and 9.\";\n    for (String token : tokens) {\n        assert Character.isDigit(token.charAt(token.length() - 1)) && Integer.parseInt(token.substring(token.length() - 1)) >= 1 &&\n            Integer.parseInt(token.substring(token.length() - 1)) <= 9 : \"Each word must end with a digit between 1 and 9.\";\n    }\n\n    String[] words = new String[tokens.length];\n\n    for (String token : tokens) {\n        int pos = Integer.parseInt(token.substring(token.length() - 1)) - 1;\n        words[pos] = token.substring(0, token.length() - 1);\n    }\n\n    return String.join(\" \", words);\n}\n\n// Unit tests\npublic static void main(String[] args) {\n    assert sortSentence(\"Coding1 is2 fun3\").equals(\"Coding is fun\");\n    assert sortSentence(\"is2 sentence4 This1 a3\").equals(\"This is a sentence\");\n    assert sortSentence(\"Myself2 Me1 I4 and3\").equals(\"Me Myself and I\");\n    assert sortSentence(\"Python1 interpreters2 are3 available4 for5 many6 operating7 systems8\").equals(\"Python interpreters are available for many operating systems\");\n    assert sortSentence(\"Python1 is2 an3 interpreted4 high-level5 general-purpose6 programming7 language8\").equals(\"Python is an interpreted high-level general-purpose programming language\");\n    assert sortSentence(\"Myself2 Me1 I4 and3\").equals(\"Me Myself and I\");\n    assert sortSentence(\"is2 sentence4 This1 a3\").equals(\"This is a sentence\");\n    // Add more test cases if needed\n}"}
{"id": 1494, "filename": "LeetCode_1494_minTimeToType.java", "content": "public class Main {\n    public static int minTimeToType(String word) {\n        assert word != null && !word.isEmpty() : \"Input must be a non-empty string.\";\n        assert word.length() >= 1 && word.length() <= 100 : \"The length of the input string must be between 1 and 100.\";\n        assert word.matches(\"[a-z]+\") : \"The input string must consist of lowercase English letters only.\";\n\n        int time = 0;\n        int position = 0;\n        for (char c : word.toCharArray()) {\n            int nextPosition = c - 'a';\n            int diff = Math.abs(nextPosition - position);\n            time += Math.min(diff, 26 - diff) + 1;\n            position = nextPosition;\n        }\n\n        assert time >= 0 : \"The result must be a non-negative integer representing the minimum time.\";\n        return time;\n    }\n\n    public static void main(String[] args) {\n        check(Main::minTimeToType);\n    }\n\n    public static void check(Function<String, Integer> candidate) {\n        assert candidate.apply(\"zjpc\") == 34;\n        assert candidate.apply(\"zxyw\") == 10;\n        assert candidate.apply(\"abcd\") == 7;\n        assert candidate.apply(\"bza\") == 7;\n        assert candidate.apply(\"a\") == 1;\n        assert candidate.apply(\"aaaa\") == 4;\n        assert candidate.apply(\"zyxwvutsrqponmlkjihgfedcb\") == 50;\n        assert candidate.apply(\"azaz\") == 7;\n        assert candidate.apply(\"abc\") == 5;\n        assert candidate.apply(\"abcdefghijklmnopqrstuvwxyz\") == 51;\n        assert candidate.apply(\"az\") == 3;\n    }\n}"}
{"id": 1515, "filename": "LeetCode_1515_checkZeroOnes.java", "content": "public class Main {\n    public static boolean checkZeroOnes(String s) {\n        assert s != null && s.length() > 0 : \"Input must be a non-empty string.\";\n        assert s.length() >= 1 && s.length() <= 100 : \"The length of the input string must be between 1 and 100.\";\n        assert s.matches(\"[01]+\") : \"The input string must consist only of '0' and '1'.\";\n\n        int longestZero = 0, longestOne = 0, currentZero = 0, currentOne = 0;\n\n        for (char c : s.toCharArray()) {\n            if (c == '0') {\n                currentZero++;\n                longestZero = Math.max(longestZero, currentZero);\n                currentOne = 0;\n            } else {\n                currentOne++;\n                longestOne = Math.max(longestOne, currentOne);\n                currentZero = 0;\n            }\n        }\n\n        boolean result = longestOne > longestZero;\n        assert result == true || result == false : \"The result must be a boolean value.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        testCheck();\n    }\n\n    public static void testCheck() {\n        assert check(checkZeroOnes) == true;\n    }\n}"}
{"id": 1550, "filename": "LeetCode_1550_maxProductDifference.java", "content": "import java.util.Arrays;\n\npublic class Main {\n    public static int maxProductDifference(int[] nums) {\n        // Precondition 1\n        for (int num : nums) {\n            assert num >= 1 && num <= 104 : \"Each number in nums must be between 1 and 104.\";\n        }\n\n        // Precondition 2\n        assert nums.length >= 4 && nums.length <= 104 : \"The length of nums must be between 4 and 104.\";\n\n        // Perform the operation\n        int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE, max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE;\n        for (int num : nums) {\n            if (num < min1) {\n                min2 = min1;\n                min1 = num;\n            } else if (num < min2) {\n                min2 = num;\n            }\n            if (num > max1) {\n                max2 = max1;\n                max1 = num;\n            } else if (num > max2) {\n                max2 = num;\n            }\n        }\n        int result = max1 * max2 - min1 * min2;\n\n        // Postcondition\n        assert result >= 0 : \"The result must be a non-negative integer.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] input1 = {5, 6, 2, 7, 4};\n        int[] input2 = {4, 2, 5, 9, 7, 4, 8};\n        assert maxProductDifference(input1) == 34 : \"This is the example from the problem description\";\n        assert maxProductDifference(input2) == 64 : \"This is the only test case that requires 7 lines.\";\n    }\n}"}
{"id": 1564, "filename": "LeetCode_1564_get_concatenation.java", "content": "import java.util.Arrays;\n\npublic class Main {\n    public static int[] getConcatenation(int[] nums) {\n        // Precondition 1\n        for (int num : nums) {\n            if (!(num >= 1 && num <= 1000)) {\n                throw new IllegalArgumentException(\"nums must contain integers between 1 and 1000.\");\n            }\n        }\n\n        // Precondition 2\n        if (nums.length < 0 || nums.length > 1000) {\n            throw new IllegalArgumentException(\"The length of nums must be between 0 and 1000.\");\n        }\n\n        int n = nums.length;\n        int[] ans = new int[2 * n];\n        for (int i = 0; i < n; i++) {\n            ans[i] = nums[i];\n            ans[i + n] = nums[i];\n        }\n\n        // Postcondition\n        for (int num : ans) {\n            if (!(num >= 1 && num <= 1000)) {\n                throw new IllegalArgumentException(\"The result must contain integers between 1 and 1000.\");\n            }\n        }\n\n        return ans;\n    }\n\n    // Unit test\n    public static void main(String[] args) {\n        check(Main::getConcatenation);\n    }\n\n    public static void check(DataFunction function) {\n        assert Arrays.equals(function.apply(new int[]{2, 2, 2, 2, 2, 1}),\n                new int[]{2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1});\n        // Add more asserts for other test cases\n    }\n\n    @FunctionalInterface\n    interface DataFunction {\n        int[] apply(int[] nums);\n    }\n}"}
{"id": 1568, "filename": "LeetCode_1568_count_vowel_substrings.java", "content": "public class VowelSubstringCounter {\n    public static int countVowelSubstrings(String word) {\n        // Precondition: Ensure the input is a non-empty string of lowercase English letters.\n        assert word != null && word.matches(\"^[a-z]*$\"), \"word must be a non-empty string of lowercase English letters.\";\n        assert word.length() >= 1 && word.length() <= 100, \"The length of word must be between 1 and 100.\";\n\n        char[] vowels = {'a', 'e', 'i', 'o', 'u'};\n        int count = 0;\n        int n = word.length();\n\n        // Check every possible substring\n        for (int i = 0; i < n; i++) {\n            if (isVowel(word.charAt(i), vowels)) {\n                HashSet<Character> seenVowels = new HashSet<>();\n                for (int j = i; j < n; j++) {\n                    if (isVowel(word.charAt(j), vowels)) {\n                        seenVowels.add(word.charAt(j));\n                        if (seenVowels.size() == 5) {  // All five vowels are present\n                            count++;\n                        }\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        // Postcondition: Ensure the result is a non-negative integer.\n        assert count >= 0, \"The result must be a non-negative integer.\";\n\n        return count;\n    }\n\n    private static boolean isVowel(char c, char[] vowels) {\n        for (char vowel : vowels) {\n            if (c == vowel) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        testCheck();\n    }\n\n    public static void testCheck() {\n        assert countVowelSubstrings(\"aeioubcd\") == 1;\n        assert countVowelSubstrings(\"aeiouaei\") == 1;\n        assert countVowelSubstrings(\"aeiouaeiou\") == 6;\n        assert countVowelSubstrings(\"aeiuo\") == 0;\n        assert countVowelSubstrings(\"vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\") == 0;\n        assert countVowelSubstrings(\"\") == 0;\n        assert countVowelSubstrings(\"a\") == 0;\n        assert countVowelSubstrings(\"vzlbsiikaomuuaixoiogkqxuwfepnvzkslwiioipvzlsiikvzl\") == 0;\n        assert countVowelSubstrings(\"u\") == 0;\n        assert countVowelSubstrings(\"aeiouu\") == 2;\n        assert countVowelSubstrings(\"unicornarihan\") == 0;\n        assert countVowelSubstrings(\"aeio\") == 0;\n        assert countVowelSubstrings(\"aeioubcd\") == 1;\n        assert countVowelSubstrings(\"abcdefghi\") == 0;\n        assert countVowelSubstrings(\"ae\") == 0;\n        assert countVowelSubstrings(\"bbbaeixoqvwuubbb\") == 2;\n        assert countVowelSubstrings(\"aeiouu\") == 2;\n        assert countVowelSubstrings(\"bbbaeixoqvwubbb\") == 1;\n        assert countVowelSubstrings(\"aei\") == 0;\n        assert countVowelSubstrings(\"aeiouae\") == 1;\n        assert countVowelSubstrings(\"aeiou\") == 1;\n        assert countVowelSubstrings(\"aeiouaeio\") == 1;\n    }\n}"}
{"id": 1872, "filename": "LeetCode_1872_common_factors.java", "content": "import java.util.*;\n\npublic class CommonFactors {\n\n    public static int commonFactors(int a, int b) {\n        assert a > 0 && b > 0 : \"a and b must be positive integers.\";\n        assert a >= 1 && a <= 1000 && b >= 1 && b <= 1000 : \"a and b must be between 1 and 1000.\";\n\n        int g = gcd(a, b);\n        int count = 0;\n        for (int i = 1; i <= Math.sqrt(g); i++) {\n            if (g % i == 0) {\n                count++;\n                if (i * i != g) {\n                    count++;\n                }\n            }\n        }\n\n        assert count >= 0 : \"The result must be a non-negative integer.\";\n\n        return count;\n    }\n\n    public static int gcd(int a, int b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    public static void main(String[] args) {\n        check(CommonFactors::commonFactors);\n    }\n\n    public static void check(BiFunction<Integer, Integer, Integer> function) {\n        assert function.apply(14, 28) == 4;\n        assert function.apply(44, 88) == 6;\n        assert function.apply(8, 16) == 4;\n        // Additional assertions from the Python code\n    }\n}"}
{"id": 1909, "filename": "LeetCode_1909_distinctAverages.java", "content": "import java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.Collections;\n\npublic class DistinctAverages {\n\n    public static int distinctAverages(List<Integer> nums) {\n        // Preconditions\n        for (Integer num : nums) {\n            if (!(num instanceof Integer)) throw new AssertionError(\"nums must be a list of integers.\");\n        }\n\n        Set<Double> averages = new HashSet<>();\n        Collections.sort(nums);\n        int n = nums.size();\n        for (int i = 0; i < n / 2; i++) {\n            averages.add((nums.get(i) + nums.get(n - 1 - i)) / 2.0);\n        }\n\n        // Postcondition\n        int result = averages.size();\n        if (!(result instanceof Integer) || result < 0) throw new AssertionError(\"The result must be a non-negative integer.\");\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Unit tests\n        check(DistinctAverages::distinctAverages);\n    }\n\n    public static void check(DistinctAveragesImpl function) {\n        assert function.distinctAverages(List.of(3, 3, 3, 3, 3, 3)) == 1;\n        assert function.distinctAverages(List.of(1, 2)) == 1;\n        assert function.distinctAverages(List.of(4, 1, 4, 0, 3, 5)) == 2;\n        assert function.distinctAverages(List.of(100, 0, 50, 50)) == 1;\n        assert function.distinctAverages(List.of(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) == 1;\n        assert function.distinctAverages(List.of(5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5)) == 1;\n        assert function.distinctAverages(List.of(1, 1, 1, 1)) == 1;\n        assert function.distinctAverages(List.of(1, 100)) == 1;\n        assert function.distinctAverages(List.of(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) == 1;\n    }\n    \n    @FunctionalInterface\n    interface DistinctAveragesImpl {\n        int distinctAverages(List<Integer> nums);\n    }\n\n}"}

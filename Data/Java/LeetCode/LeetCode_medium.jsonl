{"id": 32, "filename": "LeetCode_32_count_and_say.java", "content": "public class CountAndSay {\n    public static String countAndSay(int n) {\n        assert n >= 1 && n <= 30 : \"Input must be between 1 and 30 inclusive.\";\n        assert n > 0 : \"Input must be a positive integer.\";\n\n        if (n == 1) {\n            return \"1\";\n        }\n        String previous = countAndSay(n - 1);\n        StringBuilder result = new StringBuilder();\n        int count = 1;\n        for (int i = 1; i < previous.length(); i++) {\n            if (previous.charAt(i) == previous.charAt(i - 1)) {\n                count++;\n            } else {\n                result.append(count).append(previous.charAt(i - 1));\n                count = 1;\n            }\n        }\n        result.append(count).append(previous.charAt(previous.length() - 1));\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        assert countAndSay(1).equals(\"1\");\n        assert countAndSay(4).equals(\"1211\");\n        assert countAndSay(7).equals(\"13112221\");\n        assert countAndSay(10).equals(\"13211311123113112211\");\n        assert countAndSay(13).equals(\"1321132132111213122112311311222113111221131221\");\n        // Add more assertions as needed\n    }\n}"}
{"id": 34, "filename": "LeetCode_34_combinationSum2.java", "content": "import java.util.*;\n\npublic class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.sort(candidates);\n        combine(candidates, target, 0, new ArrayList<>(), res);\n        return res;\n    }\n\n    private void combine(int[] candidates, int target, int start, List<Integer> path, List<List<Integer>> res) {\n        if (target == 0) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i = start; i < candidates.length; i++) {\n            if (i > start && candidates[i] == candidates[i - 1]) {\n                continue;\n            }\n            if (candidates[i] > target) {\n                break;\n            }\n            path.add(candidates[i]);\n            combine(candidates, target - candidates[i], i + 1, path, res);\n            path.remove(path.size() - 1);\n        }\n    }\n\n    // Unit tests\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        assert solution.combinationSum2(new int[]{1,1,1,1,1}, 2).equals(List.of(List.of(1, 1)));\n        assert solution.combinationSum2(new int[]{1,2,3,4,5}, 5).equals(List.of(List.of(1, 4), List.of(2, 3), List.of(5)));\n        assert solution.combinationSum2(new int[]{10,1,2,7,6,1,5}, 8).equals(List.of(List.of(1, 1, 6), List.of(1, 2, 5), List.of(1, 7), List.of(2, 6)));\n        assert solution.combinationSum2(new int[]{4,4,4,4,4}, 8).equals(List.of(List.of(4, 4)));\n        assert solution.combinationSum2(new int[]{1}, 1).equals(List.of(List.of(1)));\n        assert solution.combinationSum2(new int[]{1,1,1,1,1}, 5).equals(List.of(List.of(1, 1, 1, 1, 1)));\n        assert solution.combinationSum2(new int[]{2,5,2,1,2}, 5).equals(List.of(List.of(1, 2, 2), List.of(5)));\n        assert solution.combinationSum2(new int[]{1,2,3,4,5}, 1).equals(List.of(List.of(1)));\n    }\n}"}
{"id": 47, "filename": "LeetCode_47_maxSubArray.java", "content": "import java.util.*;\n\npublic class MaximumSubarray {\n\n    public static int maxSubArray(int[] nums) {\n        int maxSum = nums[0];\n        int currentSum = nums[0];\n\n        for (int i = 1; i < nums.length; i++) {\n            currentSum = Math.max(currentSum + nums[i], nums[i]);\n            maxSum = Math.max(maxSum, currentSum);\n        }\n\n        return maxSum;\n    }\n\n    public static void main(String[] args) {\n        check(MaximumSubarray::maxSubArray);\n    }\n\n    public static void check(IntFunction<Integer> maxSubArray) {\n        assert maxSubArray.apply(new int[]{1, 2, 3, 4, 5}) == 15;\n        assert maxSubArray.apply(new int[]{1}) == 1;\n        assert maxSubArray.apply(new int[]{31, -41, 59, 26, -53, 58, 97, -93, -23, 84}) == 187;\n        // Add the rest of the unit tests here\n    }\n}"}
{"id": 126, "filename": "LeetCode_126_fraction_to_decimal.java", "content": "public class FractionToDecimal {\n\n    public static String fractionToDecimal(int numerator, int denominator) {\n        // Preconditions\n        if (!(numerator instanceof Integer)) throw new IllegalArgumentException(\"Numerator must be an integer.\");\n        if (!(denominator instanceof Integer)) throw new IllegalArgumentException(\"Denominator must be an integer.\");\n        if (numerator < -Math.pow(2, 31) || numerator > (Math.pow(2, 31) - 1))\n            throw new IllegalArgumentException(\"Numerator must be within the 32-bit signed integer range.\");\n        if (denominator == 0) throw new IllegalArgumentException(\"Denominator cannot be zero.\");\n        \n        // Canonical solution\n        if (numerator == 0) return \"0\";\n        StringBuilder res = new StringBuilder();\n        if ((numerator < 0) ^ (denominator < 0)) res.append(\"-\");\n        long num = Math.abs((long) numerator);\n        long den = Math.abs((long) denominator);\n        res.append(num / den);\n        num %= den;\n        if (num == 0) return res.toString();\n        res.append(\".\");\n        HashMap<Long, Integer> map = new HashMap<>();\n        while (num != 0) {\n            if (map.containsKey(num)) {\n                res.insert(map.get(num), \"(\");\n                res.append(\")\");\n                break;\n            }\n            map.put(num, res.length());\n            num *= 10;\n            res.append(num / den);\n            num %= den;\n        }\n        return res.toString();\n    }\n\n    public static void main(String[] args) {\n        // Unit tests\n        check();\n    }\n\n    public static void check() {\n        assert fractionToDecimal(0, -7).equals(\"0\");\n        assert fractionToDecimal(0, -1).equals(\"0\");\n        assert fractionToDecimal(20, -1).equals(\"-20\");\n        assert fractionToDecimal(1, 3).equals(\"0.(3)\");\n        // Add more test cases here\n    }\n}"}
{"id": 201, "filename": "LeetCode_201_numSquares.java", "content": "public class PerfectSquares {\n\n    public static int numSquares(int n) {\n        // Preconditions\n        assert n >= 1 && n <= Math.pow(10, 4) : \"Input must be between 1 and 10^4.\";\n\n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0;\n\n        for (int i = 1; i <= n; i++) {\n            int j = 1;\n            while (j * j <= i) {\n                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n                j++;\n            }\n        }\n\n        int result = dp[n];\n\n        // Postconditions\n        assert result > 0 : \"The result must be a positive integer.\";\n        assert isMinSquares(dp, n) : \"The final result must be the minimum number of perfect squares summing to n.\";\n\n        return result;\n    }\n\n    public static boolean isMinSquares(int[] dp, int n) {\n        for (int j = 1; j <= (int) Math.sqrt(n); j++) {\n            if (j * j <= n) {\n                if (dp[n] != dp[n - j * j] + 1) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        test();\n    }\n\n    public static void test() {\n        assert numSquares(6) == 3;\n        assert numSquares(41) == 2;\n        assert numSquares(45) == 2;\n        assert numSquares(28) == 4;\n        // Add more test cases as needed\n    }\n}"}
{"id": 272, "filename": "LeetCode_272_wiggleMaxLength.java", "content": "import java.util.Arrays;\n\npublic class Main {\n\n    public static int wiggleMaxLength(int[] nums) {\n        if (nums.length < 2) {\n            return nums.length;\n        }\n\n        int up = 1, down = 1;\n        \n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] > nums[i - 1]) {\n                up = down + 1;\n            } else if (nums[i] < nums[i - 1]) {\n                down = up + 1;\n            }\n        }\n\n        return Math.max(up, down);\n    }\n\n    public static void main(String[] args) {\n        assert wiggleMaxLength(new int[]{0, 1000, 1000, 0, 1000, 0, 1000, 0, 1000}) == 8;\n        assert wiggleMaxLength(new int[]{1, 2}) == 2;\n        assert wiggleMaxLength(new int[]{4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}) == 2;\n        assert wiggleMaxLength(new int[]{1}) == 1;\n        assert wiggleMaxLength(new int[]{1, 7, 4, 9, 2, 5}) == 6;\n        assert wiggleMaxLength(new int[]{0, 1000, 0, 1000, 0, 1000, 0, 1000, 0, 1000}) == 10;\n        assert wiggleMaxLength(new int[]{9, 8, 7, 6, 5, 4, 3, 2, 1}) == 2;\n        assert wiggleMaxLength(new int[]{1, 100, 100}) == 2;\n        assert wiggleMaxLength(new int[]{1, 17, 5, 10, 13, 15, 10, 5, 16, 8}) == 7;\n        assert wiggleMaxLength(new int[]{15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4}) == 2;\n        assert wiggleMaxLength(new int[]{1, 17, 5, 10, 13, 15, 10, 5, 16, 8, 19, 20}) == 8;\n        assert wiggleMaxLength(new int[]{5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5}) == 2;\n        assert wiggleMaxLength(new int[]{1, 1, 1, 1, 1, 1, 1, 1, 1}) == 1;\n        assert wiggleMaxLength(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9}) == 2;\n        assert wiggleMaxLength(new int[]{100, 2, 3, 4, 100, 100}) == 3;\n        assert wiggleMaxLength(new int[]{1, 1, 2, 2, 3, 3, 4, 4, 5, 5}) == 2;\n        assert wiggleMaxLength(new int[]{23, 21, 19, 17, 15, 13, 11, 9, 7, 5, 3, 1}) == 2;\n        assert wiggleMaxLength(new int[]{}) == 0;\n        assert wiggleMaxLength(new int[]{2, 1}) == 2;\n        assert wiggleMaxLength(new int[]{2, 3, 4, 5, 6, 7, 8, 9}) == 2;\n        assert wiggleMaxLength(new int[]{1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23}) == 2;\n    }\n}"}
{"id": 304, "filename": "LeetCode_304_canPartition.java", "content": "import java.util.Arrays;\n\npublic class Solution {\n\n    public static boolean canPartition(int[] nums) {\n        // Preconditions\n        assert nums != null && nums.length > 0 && nums.length <= 200 : \"nums must be a non-empty array of integers.\";\n\n        // Canonical solution\n        int totalSum = Arrays.stream(nums).sum();\n        if (totalSum % 2 != 0) {\n            return false;\n        }\n\n        int target = totalSum / 2;\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n\n        for (int num : nums) {\n            for (int i = target; i >= num; i--) {\n                dp[i] = dp[i] || dp[i - num];\n            }\n        }\n\n        boolean result = dp[target];\n\n        // Postconditions\n        assert result == true || result == false : \"The result must be either true or false.\";\n        if (result) {\n            assert totalSum % 2 == 0 : \"If partition is possible, total sum must be even.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Unit tests\n        check(Solution::canPartition);\n    }\n\n    static void check(Predicate<int[]> candidate) {\n        assert candidate.test(new int[]{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10}) == true;\n        assert candidate.test(new int[]{90, 10, 20, 80}) == true;\n        assert candidate.test(new int[]{1, 1, 5, 5, 10, 10}) == true;\n        assert candidate.test(new int[]{40, 14, 31, 33, 8, 12, 40, 16, 23, 6, 26, 17, 33, 28, 13, 10, 40, 14, 31, 33, 8, 12, 40, 16, 23, 6, 26, 17,33, 28, 13, 10}) == true;\n        assert candidate.test(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) == false;\n        assert candidate.test(new int[]{1, 5, 11, 5}) == true;\n        // Add more test cases as needed\n    }\n}"}
{"id": 324, "filename": "LeetCode_324_compress.java", "content": "import java.util.*;\n\npublic class Solution {\n\n    public int compress(char[] chars) {\n        if (chars == null || chars.length == 0) {\n            return 0;\n        }\n\n        int index = 0;\n        int i = 0;\n\n        while (i < chars.length) {\n            int count = 1;\n            while (i + count < chars.length && chars[i] == chars[i + count]) {\n                count++;\n            }\n\n            chars[index] = chars[i];\n            index++;\n\n            if (count > 1) {\n                String countStr = String.valueOf(count);\n                for (char c : countStr.toCharArray()) {\n                    chars[index] = c;\n                    index++;\n                }\n            }\n\n            i += count;\n        }\n\n        return index;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        char[] chars1 = {'a', 'a', 'b', 'b', 'c', 'c', 'c'};\n        System.out.println(solution.compress(chars1)); // Output: 6\n\n        char[] chars2 = {'a'};\n        System.out.println(solution.compress(chars2)); // Output: 1\n\n        char[] chars3 = {'a', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b'};\n        System.out.println(solution.compress(chars3)); // Output: 4\n    }\n}"}
{"id": 412, "filename": "LeetCode_412_optimal_division.java", "content": "import java.util.Arrays;\n\npublic class Main {\n    \n    public static String optimalDivision(int[] nums) {\n        if (nums.length == 1) {\n            return Integer.toString(nums[0]);\n        }\n        if (nums.length == 2) {\n            return nums[0] + \"/\" + nums[1];\n        }\n        \n        StringBuilder res = new StringBuilder(nums[0] + \"/(\");\n        for (int i = 1; i < nums.length - 1; i++) {\n            res.append(nums[i]).append(\"/\");\n        }\n        res.append(nums[nums.length - 1]).append(\")\");\n        \n        return res.toString();\n    }\n    \n    public static void main(String[] args) {\n        int[] nums = {2, 3, 4};\n        System.out.println(optimalDivision(nums)); // Output: \"2/(3/4)\"\n    }\n}"}
{"id": 424, "filename": "LeetCode_424_checkInclusion.java", "content": "public class CheckInclusion {\n\n    public static boolean checkInclusion(String s1, String s2) {\n        assert s1 != null && s2 != null : \"s1 and s2 must not be null.\";\n        assert s1.length() >= 1 && s1.length() <= 10000 : \"The length of s1 must be between 1 and 10,000.\";\n        assert s2.length() >= 1 && s2.length() <= 10000 : \"The length of s2 must be between 1 and 10,000.\";\n        assert s1.matches(\"[a-z]+\") : \"s1 must consist of lowercase English letters only.\";\n        assert s2.matches(\"[a-z]+\") : \"s2 must consist of lowercase English letters only.\";\n\n        if (s1.length() > s2.length()) {\n            return false;\n        }\n\n        int[] s1Map = new int[26];\n        int[] s2Map = new int[26];\n\n        for (int i = 0; i < s1.length(); i++) {\n            s1Map[s1.charAt(i) - 'a']++;\n            s2Map[s2.charAt(i) - 'a']++;\n        }\n\n        for (int i = 0; i < s2.length() - s1.length(); i++) {\n            if (arrayEquals(s1Map, s2Map)) {\n                return true;\n            }\n\n            s2Map[s2.charAt(i) - 'a']--;\n            s2Map[s2.charAt(i + s1.length()) - 'a']++;\n        }\n\n        return arrayEquals(s1Map, s2Map);\n    }\n\n    public static boolean arrayEquals(int[] arr1, int[] arr2) {\n        for (int i = 0; i < 26; i++) {\n            if (arr1[i] != arr2[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        testCheckInclusion();\n    }\n\n    public static void testCheckInclusion() {\n        assert checkInclusion(\"ab\", \"eidbaooo\") == true;\n        assert checkInclusion(\"abc\", \"bca\") == true;\n        assert checkInclusion(\"bba\", \"abababaabb\") == true;\n        assert checkInclusion(\"abc\", \"abcab\") == true;\n        assert checkInclusion(\"aaa\", \"abccaaccaaabaabcccaaaca\") == true;\n        assert checkInclusion(\"ab\", \"eidboaoo\") == false;\n        assert checkInclusion(\"\", \"baaa\") == true;\n        assert checkInclusion(\"abc\", \"abca\") == true;\n        assert checkInclusion(\"abc\", \"cba\") == true;\n        assert checkInclusion(\"abc\", \"abac\") == true;\n        assert checkInclusion(\"abc\", \"bac\") == true;\n        assert checkInclusion(\"xyz\", \"yxz\") == true;\n        assert checkInclusion(\"aab\", \"aab\") == true;\n        assert checkInclusion(\"abc\", \"cab\") == true;\n        assert checkInclusion(\"ab\", \"lafb\") == false;\n        assert checkInclusion(\"abc\", \"acb\") == true;\n        assert checkInclusion(\"abcd\", \"abc\") == false;\n        assert checkInclusion(\"a\", \"a\") == true;\n        assert checkInclusion(\"a\", \"b\") == false;\n        assert checkInclusion(\"ab\", \"alb\") == false;\n        assert checkInclusion(\"xyz\", \"zyx\") == true;\n        assert checkInclusion(\"abc\", \"def\") == false;\n        assert checkInclusion(\"aa\", \"ba\") == false;\n        assert checkInclusion(\"aaa\", \"aaa\") == true;\n        assert checkInclusion(\"abc\", \"abcabcabc\") == true;\n        assert checkInclusion(\"ab\", \"aab\") == true;\n        assert checkInclusion(\"a\", \"aba\") == true;\n    }\n}"}
{"id": 434, "filename": "LeetCode_434_fractionAddition.java", "content": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport org.apache.commons.math3.fraction.Fraction;\n\npublic class FractionCalculator {\n\n    public static String fractionAddition(String expression) {\n        assert expression instanceof String : \"Input must be a string.\";\n        assert Pattern.matches(\"[0-9/+-]*\", expression) : \"Expression can only contain digits, '/', '+', and '-'.\";\n        List<String> fractions = Arrays.asList(expression.replace(\"+\", \" +\").replace(\"-\", \" -\").split(\"\\\\s+\"));\n        \n        Fraction result = fractions.stream()\n            .map(Fraction::new)\n            .reduce(Fraction.ZERO, Fraction::add);\n\n        assert result instanceof Fraction : \"Result must be a Fraction object.\";\n        assert result.getDenominator() != 0 : \"Denominator must not be zero.\";\n        assert Math.abs(result.getNumerator()) <= Math.pow(2, 31) - 1 && Math.abs(result.getDenominator()) <= Math.pow(2, 31) - 1 : \"Numerator and denominator must be within 32-bit integer range.\";\n        assert new Fraction(result.getNumerator(), result.getDenominator()).equals(result) : \"Result must be in its simplest form.\";\n\n        return result.getNumerator() + \"/\" + result.getDenominator();\n    }\n\n    public static void main(String[] args) {\n        check(FractionCalculator::fractionAddition);\n    }\n\n    public static void check(java.util.function.Function<String, String> candidate) {\n        assert candidate.apply(\"-1/3-2/3\").equals(\"-1/1\") : \"Test Failed\";\n        assert candidate.apply(\"-1/12+1/12-1/24\").equals(\"-1/24\") : \"Test Failed\";\n        // Add all other test cases here\n    }\n    \n}"}
{"id": 482, "filename": "LeetCode_482_findNumberOfLIS.java", "content": "import java.util.Arrays;\n\npublic class Main {\n    public static int findNumberOfLIS(int[] nums) {\n        // Preconditions\n        assert nums != null : \"Input must not be null.\";\n        assert nums.length >= 1 && nums.length <= 2000 : \"The length of nums must be between 1 and 2000.\";\n        assert Arrays.stream(nums).allMatch(num -> (num >= -1000000 && num <= 1000000)) : \"Each number in nums must be between -10^6 and 10^6.\";\n\n        int n = nums.length;\n        int maxLength = 0, ans = 0;\n        int[] length = new int[n];\n        int[] count = new int[n];\n        Arrays.fill(length, 1);\n        Arrays.fill(count, 1);\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) {\n                    if (length[i] == length[j] + 1) {\n                        count[i] += count[j];\n                    } else if (length[i] < length[j] + 1) {\n                        length[i] = length[j] + 1;\n                        count[i] = count[j];\n                    }\n                }\n            }\n            if (maxLength == length[i]) {\n                ans += count[i];\n            } else if (maxLength < length[i]) {\n                maxLength = length[i];\n                ans = count[i];\n            }\n        }\n\n        // Postconditions\n        assert ans >= 1 : \"The number of longest increasing subsequences must be at least 1.\";\n        assert maxLength >= 1 : \"The length of the longest increasing subsequence must be at least 1.\";\n\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        check(Main::findNumberOfLIS);\n    }\n\n    public static void check(IntFunction<Integer> candidate) {\n        assert candidate.apply(new int[]{1,1,1,2,2,2,3,3,3}) == 27;\n        assert candidate.apply(new int[]{1}) == 1;\n        assert candidate.apply(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) == 1;\n        assert candidate.apply(new int[]{1, 2, 4, 3, 5, 4, 7}) == 3;\n        assert candidate.apply(new int[]{\n            3, 5, 6, 2, 5, 4, 19, 5, 6, 7, 12, 20, 13, 10, 14, 15, 2, 1, 1, 3, 11, 12, 13, 5, 6, 7, 11, 12, 13, 14, 15, 2, 3}) == 8;\n        assert candidate.apply(new int[]{10,9,2,5,3,7,101,18}) == 4;\n        assert candidate.apply(new int[]{1,2,4,3,5,4,7,2}) == 3;\n        assert candidate.apply(new int[]{10, 9, 2, 5, 3, 7, 101, 18}) == 4;\n        assert candidate.apply(new int[]{3,1,2}) == 1;\n        assert candidate.apply(new int[]{11,12,13,14,15,16,17,18,19,20}) == 1;\n        assert candidate.apply(new int[]{2,2,2,2,2}) == 5;\n        assert candidate.apply(new int[]{1,3,5,4,7}) == 2;\n        assert candidate.apply(new int[]{1,2,3,4,5}) == 1;\n        assert candidate.apply(new int[]{1, 2, 4, 3, 5, 4, 7, 2}) == 3;\n    }\n}"}
{"id": 509, "filename": "LeetCode_509_minimumDeleteSum.java", "content": "public class Solution {\n    public int minimumDeleteSum(String s1, String s2) {\n        assert s1 != null && s2 != null && s1 instanceof String && s2 instanceof String : \"Both inputs must be strings.\";\n        assert s1.length() >= 1 && s1.length() <= 1000 && s2.length() >= 1 && s2.length() <= 1000 : \"String lengths must be between 1 and 1000.\";\n        assert s1.matches(\"^[a-z]*$\") && s2.matches(\"^[a-z]*$\") : \"s1 and s2 must consist of lowercase English letters only.\";\n\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\n        for (int i = 1; i <= s1.length(); i++) {\n            dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);\n        }\n        for (int j = 1; j <= s2.length(); j++) {\n            dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);\n        }\n        for (int i = 1; i <= s1.length(); i++) {\n            for (int j = 1; j <= s2.length(); j++) {\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = Math.min(dp[i - 1][j] + s1.charAt(i - 1), dp[i][j - 1] + s2.charAt(j - 1));\n                }\n            }\n        }\n\n        int result = dp[s1.length()][s2.length()];\n\n        assert result >= 0 : \"The minimum delete sum must be non-negative.\";\n        assert result == 0 || !s1.equals(s2) : \"The result should be 0 only if the strings are already equal.\";\n        assert result >= Math.abs(s1.chars().sum() - s2.chars().sum()) : \"The result should reflect a valid deletion sum.\";\n\n        return result;\n    }\n\n    // Unit tests\n    public void check(Solution solution) {\n        assert solution.minimumDeleteSum(\"yx\", \"yx\") == 0;\n        assert solution.minimumDeleteSum(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n                \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") == 0;\n        assert solution.minimumDeleteSum(\"aaaaa\", \"aaaaa\") == 0;\n        assert solution.minimumDeleteSum(\"aaaaaaaaaaa\", \"aaaaaaaaaaa\") == 0;\n        assert solution.minimumDeleteSum(\"aba\", \"aba\") == 0;\n        assert solution.minimumDeleteSum(\"ab\", \"dab\") == 100;\n        assert solution.minimumDeleteSum(\"sea\", \"eat\") == 231;\n        assert solution.minimumDeleteSum(\"ab\", \"ab\") == 0;\n        assert solution.minimumDeleteSum(\"a\", \"b\") == 195;\n        assert solution.minimumDeleteSum(\"aaaaaaaaaaaa\", \"aaaaaaaaaaaa\") == 0;\n        assert solution.minimumDeleteSum(\"xyz\", \"xyz\") == 0;\n        assert solution.minimumDeleteSum(\"helloworld\", \"helloworld\") == 0;\n        assert solution.minimumDeleteSum(\"aaa\", \"aaa\") == 0;\n        assert solution.minimumDeleteSum(\"zyxwvutsrqponmlkjihgfedcba\",\n                \"zyxwvutsrqponmlkjihgfedcba\") == 0;\n        assert solution.minimumDeleteSum(\"aaaaaaaaaa\", \"aaaaaaaaaa\") == 0;\n        assert solution.minimumDeleteSum(\"zzzzzz\", \"zzzzzz\") == 0;\n        assert solution.minimumDeleteSum(\"delete\", \"leet\") == 403;\n        assert solution.minimumDeleteSum(\"\", \"x\") == 120;\n        assert solution.minimumDeleteSum(\"abc\", \"abc\") == 0;\n        assert solution.minimumDeleteSum(\"aaaaaaaa\", \"aaaaaaaa\") == 0;\n        assert solution.minimumDeleteSum(\"aaaaaaaaaaaaaa\", \"aaaaaaaaaaaaaa\") == 0;\n        assert solution.minimumDeleteSum(\"a\", \"\") == 97;\n        assert solution.minimumDeleteSum(\"abcdefghijklmnopqrstuvwxyz\", \"abcdefghijklmnopqrstuvwxyz\") == 0;\n        assert solution.minimumDeleteSum(\"aaaa\", \"aaaa\") == 0;\n        assert solution.minimumDeleteSum(\"aaaaaaaaaaaaa\", \"aaaaaaaaaaaaa\") == 0;\n        assert solution.minimumDeleteSum(\"a\", \"a\") == 0;\n        assert solution.minimumDeleteSum(\"abcd\", \"bc\") == 197;\n        assert solution.minimumDeleteSum(\"abcd\", \"abcd\") == 0;\n        assert solution.minimumDeleteSum(\"y\", \"y\") == 0;\n        assert solution.minimumDeleteSum(\"x\", \"\") == 120;\n        assert solution.minimumDeleteSum(\"\", \"\") == 0;\n    }\n    \n    public void runTests() {\n        check(new Solution());\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        sol.runTests();\n    }\n}"}
{"id": 513, "filename": "LeetCode_513_findLength.java", "content": "import java.util.Arrays;\n\npublic class Main {\n\n    public static int findLength(int[] nums1, int[] nums2) {\n        assert Arrays.stream(nums1).allMatch(num -> num instanceof Integer) : \"All elements in nums1 must be integers.\";\n        assert Arrays.stream(nums2).allMatch(num -> num instanceof Integer) : \"All elements in nums2 must be integers.\";\n        assert nums1.length >= 0 && nums1.length <= 1000 : \"The length of nums1 must be between 0 and 1000.\";\n        assert nums2.length >= 0 && nums2.length <= 1000 : \"The length of nums2 must be between 0 and 1000.\";\n\n        int m = nums1.length, n = nums2.length;\n        int[][] dp = new int[m + 1][n + 1];\n        int maxLength = 0;\n\n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                if (nums1[i] == nums2[j]) {\n                    dp[i][j] = dp[i + 1][j + 1] + 1;\n                    maxLength = Math.max(maxLength, dp[i][j]);\n                }\n            }\n        }\n\n        int result = maxLength;\n\n        assert result instanceof Integer : \"The result must be an integer.\";\n        assert result >= 0 : \"The result must be a non-negative integer.\";\n        assert result <= Math.min(nums1.length, nums2.length) : \"The result cannot be larger than the lengths of the input arrays.\";\n        assert Arrays.stream(dp).allMatch(row -> Arrays.stream(row).allMatch(val -> val <= Math.min(m - nums1.length, n - nums2.length))) : \"Subarray lengths must be valid.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        check(Main::findLength);\n    }\n\n    public static void check(Function<int[], int[], Integer> candidate) {\n        assert candidate.apply(new int[]{1, 2, 3, 4, 5, 6}, new int[]{7, 8, 9}) == 0;\n        assert candidate.apply(new int[]{1, 2, 3, 2, 1}, new int[]{3, 2, 1, 4, 7, 1, 2, 3}) == 3;\n        assert candidate.apply(new int[]{1}, new int[]{1}) == 1;\n        assert candidate.apply(new int[]{2, 1, 1, 2, 2}, new int[]{2, 1, 2, 1}) == 2;\n        assert candidate.apply(new int[]{1, 2, 3, 4, 5}, new int[]{1, 2, 3, 2, 1}) == 3;\n        // Add more test cases here...\n    }\n}"}
{"id": 530, "filename": "LeetCode_530_daily_temperatures.java", "content": "import java.util.*;\n\npublic class TemperatureCalculator {\n    public int[] dailyTemperatures(int[] temperatures) {\n        assert Arrays.stream(temperatures).allMatch(t -> t >= 0 && t <= 100): \"All temperatures must be between 0 and 100.\";\n        assert temperatures.length >= 0 && temperatures.length <= 105: \"The length of temperatures must be between 0 and 105.\";\n\n        int[] result = new int[temperatures.length];\n        Deque<Integer> stack = new ArrayDeque<>();\n\n        for (int i = 0; i < temperatures.length; i++) {\n            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {\n                int idx = stack.pop();\n                result[idx] = i - idx;\n            }\n            stack.push(i);\n        }\n\n        assert result.length == temperatures.length: \"Result length must match temperatures length.\";\n        assert Arrays.stream(result).allMatch(r -> r >= 0): \"All elements in the result must be non-negative integers.\";\n        assert Arrays.stream(result).allMatch(r -> r <= temperatures.length - i - 1): \"Each element must represent a valid number of days to wait.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        TemperatureCalculator tc = new TemperatureCalculator();\n        tc.testCheck();\n    }\n\n    public void check(Function<int[], int[]> candidate) {\n        assert Arrays.equals(candidate.apply(new int[]{100, 100, 100, 100}), new int[]{0, 0, 0, 0}): \"Test Case 1 Failed\";\n        assert Arrays.equals(candidate.apply(new int[]{90, 80, 70, 60}), new int[]{0, 0, 0, 0}): \"Test Case 2 Failed\";\n        // Include more test cases here\n\n        System.out.println(\"All tests passed successfully.\");\n    }\n\n    public void testCheck() {\n        check(this::dailyTemperatures);\n    }\n}"}
{"id": 542, "filename": "LeetCode_542_openLock.java", "content": "import java.util.ArrayDeque;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Set;\n\nclass Solution {\n    public int openLock(List<String> deadends, String target) {\n        assert deadends != null && deadends.stream().allMatch(d -> d != null && d.length() == 4 && d.matches(\"\\\\d+\")), \"deadends must be a list of 4-digit strings.\";\n        assert target != null && target.length() == 4 && target.matches(\"\\\\d+\"), \"target must be a 4-digit string.\";\n        assert !deadends.contains(target), \"Target must not be in the deadends list.\";\n        assert deadends.size() >= 1 && deadends.size() <= 500, \"The length of deadends must be between 1 and 500.\";\n\n        Set<String> dead = new HashSet<>(deadends);\n        Set<String> visited = new HashSet<>();\n        Queue<String> q = new ArrayDeque<>();\n        q.offer(\"0000\");\n\n        if (dead.contains(\"0000\")) {\n            return -1;\n        }\n\n        visited.add(\"0000\");\n        int moves = 0;\n\n        while (!q.isEmpty()) {\n            int levelSize = q.size();\n            for (int i = 0; i < levelSize; i++) {\n                String cur = q.poll();\n\n                if (cur.equals(target)) {\n                    assert moves >= 0;\n                    return moves;\n                }\n\n                for (int j = 0; j < 4; j++) {\n                    for (int k : new int[]{-1, 1}) {\n                        char[] curArr = cur.toCharArray();\n                        curArr[j] = (char) (((curArr[j] - '0' + k + 10) % 10) + '0');\n                        String nextVal = new String(curArr);\n\n                        if (!visited.contains(nextVal) && !dead.contains(nextVal)) {\n                            visited.add(nextVal);\n                            q.offer(nextVal);\n                        }\n                    }\n                }\n            }\n            moves++;\n        }\n\n        assert moves == -1 || moves >= 0;\n        return -1;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        check(solution);\n    }\n\n    private static void check(Solution solution) {\n        assert solution.openLock(List.of(\"0001\", \"1112\", \"2223\", \"3334\", \"4445\"), \"1111\") == 4;\n        assert solution.openLock(List.of(\"1111\", \"9999\", \"8888\", \"7777\", \"6666\"), \"0000\") == 0;\n        assert solution.openLock(List.of(\"8887\", \"8889\", \"8878\", \"8898\", \"8788\", \"8988\", \"7888\", \"9888\"), \"8888\") == -1;\n        assert solution.openLock(List.of(\"0001\", \"1112\", \"2223\", \"3334\", \"4445\"), \"3333\") == 12;\n        assert solution.openLock(List.of(\"0001\", \"1112\", \"2223\", \"3334\", \"4445\"), \"2222\") == 8;\n        assert solution.openLock(List.of(\"0001\", \"1112\", \"2223\", \"3334\", \"4445\"), \"0000\") == 0;\n        assert solution.openLock(List.of(\"8888\"), \"0009\") == 1;\n        assert solution.openLock(List.of(\"0000\", \"0002\", \"0003\", \"0004\", \"0005\"), \"0001\") == -1;\n        assert solution.openLock(List.of(\"0201\", \"0101\", \"0102\", \"1212\", \"2002\"), \"0202\") == 6;\n        assert solution.openLock(List.of(\"8887\", \"8889\", \"8878\", \"8898\", \"8788\", \"8988\", \"7888\", \"9888\"), \"8888\") == -1;\n        assert solution.openLock(List.of(\"0001\", \"1112\", \"2223\", \"3334\", \"4445\"), \"4444\") == 16;\n        assert solution.openLock(List.of(\"0001\", \"0002\", \"0003\", \"0004\", \"0005\"), \"0000\") == 0;\n        assert solution.openLock(List.of(\"0000\"), \"8888\") == -1;\n        assert solution.openLock(List.of(\"1111\", \"9999\", \"8888\", \"7777\", \"6666\"), \"5555\") == 20;\n    }\n}"}
{"id": 553, "filename": "LeetCode_553_partition_labels.java", "content": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class PartitionLabels {\n\n    public List<Integer> partitionLabels(String s) {\n        // Preconditions\n        assert s != null : \"Input must not be null.\";\n        assert s.length() >= 1 && s.length() <= 500 : \"Length of the string must be between 1 and 500.\";\n        assert s.matches(\"[a-z]+\") : \"The string must consist of lowercase English letters only.\";\n\n        Map<Character, Integer> last = new HashMap<>();\n        for (int i = 0; i < s.length(); i++) {\n            last.put(s.charAt(i), i);\n        }\n\n        List<Integer> ans = new ArrayList<>();\n        int j = 0, anchor = 0;\n        for (int i = 0; i < s.length(); i++) {\n            j = Math.max(j, last.get(s.charAt(i)));\n            if (i == j) {\n                ans.add(i - anchor + 1);\n                anchor = i + 1;\n            }\n        }\n\n        // Postconditions\n        assert ans != null : \"Output must not be null.\";\n        assert ans.stream().allMatch(x -> x > 0) : \"All elements in the output list must be positive integers.\";\n        assert ans.stream().mapToInt(Integer::intValue).sum() == s.length() : \"The sum of the partitions must equal the length of the input string.\";\n\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        PartitionLabels partitionLabels = new PartitionLabels();\n        partitionLabels.testCheck();\n    }\n\n    // Unit tests\n    public void testCheck() {\n        assert partitionLabels(\"eccbbbbdec\").equals(List.of(10));\n        assert partitionLabels(\"abc\").equals(List.of(1, 1, 1));\n        assert partitionLabels(\"abccba\").equals(List.of(6));\n        assert partitionLabels(\"abcdefghijklmnopqrstuvwxy\").equals(List.of(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1));\n        assert partitionLabels(\"abca\").equals(List.of(4));\n        assert partitionLabels(\"a\").equals(List.of(1));\n        assert partitionLabels(\"ababcbacadefegdehijhklij\").equals(List.of(9, 7, 8));\n    }\n}"}
{"id": 570, "filename": "LeetCode_570_is_ideal_permutation.java", "content": "import java.util.List;\n\npublic class IdealPermutation {\n\n    public static boolean isIdealPermutation(List<Integer> nums) {\n        // Core logic\n        for (int i = 0; i < nums.size(); i++) {\n            if (Math.abs(nums.get(i) - i) > 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Unit tests\n    public static void main(String[] args) {\n        check(IdealPermutation::isIdealPermutation);\n    }\n\n    // Assertion equivalent\n    public static void check(Function<List<Integer>, Boolean> candidate) {\n        assert candidate.apply(List.of(1, 2, 0)) == false;\n        assert candidate.apply(List.of(0, 1, 2, 3)) == true;\n        // Add all other assertions here\n    }\n}"}
{"id": 580, "filename": "LeetCode_580_isBipartite.java", "content": "import java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class BipartiteGraph {\n\n    public static boolean isBipartite(int[][] graph) {\n        assert graph != null : \"Input graph must not be null.\";\n        assert graph.length >= 1 : \"Graph must contain at least one node.\";\n        for (int[] neighbors : graph) {\n            assert neighbors != null : \"Each element in graph must not be null.\";\n            assert neighbors.length < graph.length : \"No node should have more neighbors than the total number of nodes.\";\n            for (int node : neighbors) {\n                assert node >= 0 && node < graph.length : \"All nodes must be within the valid range.\";\n            }\n        }\n\n        int[] colors = new int[graph.length];\n        for (int i = 0; i < graph.length; i++) {\n            if (colors[i] != 0) continue;\n\n            colors[i] = 1;\n            Queue<Integer> queue = new ArrayDeque<>();\n            queue.add(i);\n\n            while (!queue.isEmpty()) {\n                int node = queue.poll();\n                for (int neighbor : graph[node]) {\n                    if (colors[neighbor] == 0) {\n                        colors[neighbor] = -colors[node];\n                        queue.add(neighbor);\n                    } else if (colors[neighbor] == colors[node]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int[][] graph1 = {{1, 3}, {0, 3}, {0, 2, 3, 5}, {1, 3, 5}, {0, 2, 5}, {0, 2, 5}};\n        System.out.println(isBipartite(graph1)); // Should return false\n\n        int[][] graph2 = {{1, 3}, {0, 2, 3, 5}, {4}, {4, 5}, {0, 1, 3, 5}, {3}, {3, 4}};\n        System.out.println(isBipartite(graph2)); // Should return false\n\n        int[][] graph3 = {{1, 2, 3}, {0, 2, 3}, {0, 1}, {3}, {2}};\n        System.out.println(isBipartite(graph3)); // Should return false\n\n        int[][] graph4 = {{1}, {0, 2}, {1, 3}, {1, 2}};\n        System.out.println(isBipartite(graph4)); // Should return true\n    }\n}"}
{"id": 583, "filename": "LeetCode_583_rotated_digits.java", "content": "public class GoodNumbers {\n    public int rotatedDigits(int n) {\n        // Preconditions\n        if (!(n >= 0 && n <= 10000))\n            throw new IllegalArgumentException(\"Input must be between 0 and 10,000 inclusive.\");\n        \n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            boolean isValidAfterRotation = true;\n            boolean isDifferentAfterRotation = false;\n            int num = i;\n            while (num > 0) {\n                int digit = num % 10;\n                if (digit == 3 || digit == 4 || digit == 7) {\n                    isValidAfterRotation = false;\n                    break;\n                }\n                if (digit == 2 || digit == 5 || digit == 6 || digit == 9) {\n                    isDifferentAfterRotation = true;\n                }\n                num /= 10;\n            }\n            if (isValidAfterRotation && isDifferentAfterRotation) {\n                count++;\n            }\n        }\n\n        // Postconditions\n        if (!(count >= 0 && count <= n))\n            throw new IllegalStateException(\"Count of good numbers must be between 0 and n.\");\n\n        return count;\n    }\n\n    public void testCheck() {\n        check(this::rotatedDigits);\n    }\n\n    public void check(IntFunction<Integer> candidate) {\n        assert candidate.apply(5) == 2;\n        assert candidate.apply(1) == 0;\n        assert candidate.apply(2) == 1;\n        assert candidate.apply(20) == 9;\n        assert candidate.apply(180) == 69;\n        assert candidate.apply(10) == 4;\n        assert candidate.apply(0) == 0;\n        assert candidate.apply(100) == 40;\n        assert candidate.apply(30) == 15;\n    }\n}"}
{"id": 628, "filename": "LeetCode_628_max_profit_assignment.java", "content": "import java.util.Arrays;\n\npublic class MaxProfitAssignment {\n\n    public static int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\n        assert difficulty != null && difficulty.length > 0 : \"difficulty must not be null or empty.\";\n        assert profit != null && profit.length > 0 : \"profit must not be null or empty.\";\n        assert worker != null && worker.length > 0 : \"worker must not be null or empty.\";\n        assert difficulty.length == profit.length : \"The difficulty and profit lists must have the same length.\";\n        assert Arrays.stream(difficulty).allMatch(d -> d >= 1 && d <= 100000) &&\n               Arrays.stream(profit).allMatch(p -> p >= 1 && p <= 100000) &&\n               Arrays.stream(worker).allMatch(w -> w >= 1 && w <= 100000) : \"Values must be between 1 and 100,000.\";\n\n        int n = difficulty.length;\n        int[][] jobs = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            jobs[i][0] = difficulty[i];\n            jobs[i][1] = profit[i];\n        }\n        Arrays.sort(jobs, (a, b) -> a[0] - b[0]);\n        Arrays.sort(worker);\n\n        int i = 0, maxProfit = 0, totalProfit = 0;\n        for (int ability : worker) {\n            while (i < n && ability >= jobs[i][0]) {\n                maxProfit = Math.max(maxProfit, jobs[i][1]);\n                i++;\n            }\n            totalProfit += maxProfit;\n        }\n\n        assert totalProfit >= 0 : \"The total profit cannot be negative.\";\n\n        return totalProfit;\n    }\n\n    public static void main(String[] args) {\n        int[] difficulty = {2, 4, 6, 8, 10};\n        int[] profit = {10, 20, 30, 40, 50};\n        int[] worker = {4, 5, 6, 7};\n        System.out.println(maxProfitAssignment(difficulty, profit, worker)); // Output: 100\n    }\n}"}
{"id": 657, "filename": "LeetCode_657_scoreOfParentheses.java", "content": "public class Main {\n    public static int scoreOfParentheses(String s) {\n        // Preconditions\n        assert s instanceof String : \"Input must be a string.\";\n        assert s.length() >= 2 && s.length() <= 50 : \"Length of s must be between 2 and 50.\";\n        assert s.matches(\"[()]+\") : \"String must consist only of '(' and ')'.\";\n        assert s.charAt(0) == '(' && s.charAt(s.length() - 1) == ')' : \"String must start with '(' and end with ')'.\";\n        \n        int score = 0, depth = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                depth++;\n            } else {\n                depth--;\n                if (s.charAt(i - 1) == '(') {\n                    score += 1 << depth;\n                }\n            }\n        }\n\n        // Postconditions\n        assert score >= 1 : \"The score must be at least 1.\";\n        assert score <= Math.pow(2, s.length() / 2) : \"The score must be less than or equal to 2^(n//2) where n is the length of s.\";\n\n        return score;\n    }\n\n    public static void main(String[] args) {\n        test_check();\n    }\n\n    public static void test_check() {\n        assert scoreOfParentheses(\"()()()()\") == 4;\n        assert scoreOfParentheses(\"(()()(()))\") == 8;\n        assert scoreOfParentheses(\"(((())))\") == 8;\n        assert scoreOfParentheses(\"()\") == 1;\n        assert scoreOfParentheses(\"(())\") == 2;\n        assert scoreOfParentheses(\"()()()()(())\") == 6;\n        assert scoreOfParentheses(\"(((()()))))\") == 16;\n        assert scoreOfParentheses(\"((((()))))((((()))))\") == 32;\n        assert scoreOfParentheses(\"(()())\") == 4;\n        assert scoreOfParentheses(\"()()()()()()()\") == 7;\n        assert scoreOfParentheses(\"(((()))())()()\") == 12;\n        assert scoreOfParentheses(\"()(()())()\") == 6;\n        assert scoreOfParentheses(\"(()()()()())(()())()()\") == 16;\n        assert scoreOfParentheses(\"((())(()))\") == 8;\n        assert scoreOfParentheses(\"((((()))))\") == 16;\n        assert scoreOfParentheses(\"()(())\") == 3;\n        assert scoreOfParentheses(\"((())())\") == 6;\n        assert scoreOfParentheses(\"((()))\") == 4;\n        assert scoreOfParentheses(\"(())(())\") == 4;\n        assert scoreOfParentheses(\"(()(()))\") == 6;\n        assert scoreOfParentheses(\"((()())())\") == 10;\n        assert scoreOfParentheses(\"()()()()()()()()\") == 8;\n        assert scoreOfParentheses(\"()()()()()\") == 5;\n        assert scoreOfParentheses(\"((()))()()\") == 6;\n        assert scoreOfParentheses(\"((((((()))))))\") == 64;\n        assert scoreOfParentheses(\"(((())))(((())))\") == 16;\n        assert scoreOfParentheses(\"(((((())))))\") == 32;\n        assert scoreOfParentheses(\"(()(()))(()(()))\") == 12;\n        assert scoreOfParentheses(\"()()\") == 2;\n    }\n}"}
{"id": 665, "filename": "LeetCode_665_prime_palindrome.java", "content": "public class PrimePalindrome {\n\n    public static int primePalindrome(int n) {\n        // Input validations\n        if (n <= 0 || n > Math.pow(10, 8)) {\n            throw new IllegalArgumentException(\"Input must be in the range 1 to 10^8.\");\n        }\n\n        while (true) {\n            if (isPrime(n) && isPalindrome(n)) {\n                assert n >= 2 : \"The result must be greater than or equal to 2.\";\n                assert isPrime(n) : \"The result must be a prime number.\";\n                assert isPalindrome(n) : \"The result must be a palindrome.\";\n                assert n >= 2 : \"The returned prime palindrome must be greater than or equal to 2.\";\n                assert Integer.toString(n).equals(new StringBuilder(Integer.toString(n)).reverse().toString()) : \"The result must be a palindrome.\";\n                return n;\n            }\n            n++;\n        }\n    }\n\n    private static boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isPalindrome(int n) {\n        return Integer.toString(n).equals(new StringBuilder(Integer.toString(n)).reverse().toString());\n    }\n\n    public static void main(String[] args) {\n        // Unit Testing\n        assert primePalindrome(10) == 11;\n        assert primePalindrome(1) == 2;\n        assert primePalindrome(300) == 313;\n        assert primePalindrome(97) == 101;\n        assert primePalindrome(5) == 5;\n        assert primePalindrome(1234) == 10301;\n        assert primePalindrome(6) == 7;\n        assert primePalindrome(9) == 11;\n        // Add more test cases as needed\n    }\n}"}
{"id": 716, "filename": "LeetCode_716_minFlipsMonoIncr.java", "content": "public int minFlipsMonoIncr(String s) {\n    // Preconditions\n    assert s != null && !s.isEmpty() && s.matches(\"[01]+\") && s.trim().equals(s) && s.length() >= 1 && s.length() <= 100000 : \"Invalid input.\";\n    \n    int flipCount = 0, oneCount = 0;\n    for (char c : s.toCharArray()) {\n        if (c == '1') {\n            oneCount++;\n        } else {\n            flipCount = Math.min(flipCount + 1, oneCount);\n        }\n    }\n    \n    int result = flipCount;\n    \n    // Postconditions\n    assert result >= 0 && result <= s.length() && result <= oneCount : \"Invalid result.\";\n    \n    return result;\n}"}
{"id": 727, "filename": "LeetCode_727_subarraysDivByK.java", "content": "import java.util.HashMap;\n\npublic class SubarraysDivByK {\n    public static int subarraysDivByK(int[] nums, int k) {\n        // Preconditions\n        assert nums != null && nums.length > 0 && k > 0 : \"Invalid input parameters.\";\n        \n        int[] prefixSumsModK = new int[k];\n        prefixSumsModK[0] = 1;\n        int runningSum = 0;\n        int count = 0;\n\n        for (int num : nums) {\n            runningSum += num;\n            int mod = ((runningSum % k) + k) % k;\n            count += prefixSumsModK[mod];\n            prefixSumsModK[mod]++;\n        }\n\n        // Postconditions\n        assert count >= 0 : \"The result must be non-negative.\";\n        assert count <= nums.length * (nums.length + 1) / 2 : \"Result cannot exceed the maximum number of subarrays.\";\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        int[] testNums = {4, 5, 0, -2, -3, 1};\n        int testK = 5;\n        int result = subarraysDivByK(testNums, testK);\n        System.out.println(\"Result: \" + result);\n    }\n}"}
{"id": 780, "filename": "LeetCode_780_orangesRotting.java", "content": "import java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic class RottingOranges {\n\n    public int orangesRotting(int[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\n            return -1;\n        }\n\n        int m = grid.length;\n        int n = grid[0].length;\n\n        int freshOranges = 0;\n        Deque<int[]> rotten = new ArrayDeque<>();\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    freshOranges++;\n                } else if (grid[i][j] == 2) {\n                    rotten.offer(new int[]{i, j});\n                }\n            }\n        }\n\n        int minutes = 0;\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n        while (!rotten.isEmpty() && freshOranges > 0) {\n            int size = rotten.size();\n\n            for (int i = 0; i < size; i++) {\n                int[] curr = rotten.poll();\n\n                for (int[] direction : directions) {\n                    int nx = curr[0] + direction[0];\n                    int ny = curr[1] + direction[1];\n\n                    if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 1) {\n                        grid[nx][ny] = 2;\n                        freshOranges--;\n                        rotten.offer(new int[]{nx, ny});\n                    }\n                }\n            }\n            minutes++;\n        }\n\n        return freshOranges == 0 ? minutes : -1;\n    }\n\n    public static void main(String[] args) {\n        RottingOranges rottingOranges = new RottingOranges();\n        int[][] grid = {{2, 1, 1}, {1, 1, 0}, {0, 1, 1}};\n        System.out.println(rottingOranges.orangesRotting(grid)); // Output: 4\n    }\n}"}
{"id": 791, "filename": "LeetCode_791_clumsy.java", "content": "public class ClumsyFactorial {\n\n    public static int clumsy(int n) {\n        assert n >= 1 && n <= Math.pow(10, 8) : \"n must be between 1 and 10^8\";\n\n        if (n <= 2) {\n            return n;\n        }\n        if (n == 3) {\n            return 6;\n        }\n\n        int result = n * (n - 1) / (n - 2) + (n - 3);\n        n -= 4;\n        while (n >= 4) {\n            result = result - (n * (n - 1) / (n - 2)) + (n - 3);\n            n -= 4;\n        }\n\n        int finalResult = result - clumsy(n);\n\n        assert finalResult >= 1 : \"The result must be greater than or equal to 1.\";\n\n        return finalResult;\n    }\n\n    public static void main(String[] args) {\n        assert clumsy(1900) == 1901;\n        assert clumsy(8) == 9;\n        assert clumsy(2200) == 2201;\n        assert clumsy(3000000) == 3000001;\n        // Add the rest of the unit tests here\n    }\n}"}
{"id": 797, "filename": "LeetCode_797_num_pairs_divisible_by60.java", "content": "import java.util.HashMap;\n\npublic class SongPairs {\n    \n    public int numPairsDivisibleBy60(int[] time) {\n        // Preconditions\n        assert time != null : \"Input must not be null.\";\n        assert time.length >= 1 && time.length <= 60000 : \"List length must be between 1 and 60,000.\";\n        \n        int[] count = new int[60];\n        int pairs = 0;\n        \n        for (int t : time) {\n            int mod = t % 60;\n            pairs += count[(60 - mod) % 60];\n            count[mod]++;\n        }\n        \n        // Postconditions\n        assert pairs >= 0 : \"The result must be non-negative.\";\n        \n        return pairs;\n    }\n\n    public static void main(String[] args) {\n        SongPairs songPairs = new SongPairs();\n\n        assert songPairs.numPairsDivisibleBy60(new int[]{60, 120, 180, 240, 300, 360}) == 15;\n        assert songPairs.numPairsDivisibleBy60(new int[]{60, 60, 60}) == 3;\n        assert songPairs.numPairsDivisibleBy60(new int[]{60, 120, 180, 240, 300, 360, 420, 480, 540, 600, 660, 720, 780, 840, 900, 960}) == 120;\n        assert songPairs.numPairsDivisibleBy60(new int[]{30, 20, 150, 100, 40}) == 3;\n        assert songPairs.numPairsDivisibleBy60(new int[]{120, 240, 360}) == 3;\n        assert songPairs.numPairsDivisibleBy60(new int[]{5, 35, 65, 95}) == 0;\n        assert songPairs.numPairsDivisibleBy60(new int[]{60, 120, 180, 240, 300, 360, 420, 480, 540, 600}) == 45;\n        assert songPairs.numPairsDivisibleBy60(new int[]{1, 61, 121, 181, 241, 301, 361, 421, 481, 541, 601, 661, 721, 781, 841, 901, 961}) == 0;\n        assert songPairs.numPairsDivisibleBy60(new int[]{30, 30, 30, 30}) == 6;\n    }\n}"}
{"id": 804, "filename": "LeetCode_804_maxScoreSightseeingPair.java", "content": "import java.util.Arrays;\nimport java.util.List;\n\npublic class SightseeingScore {\n    public int maxScoreSightseeingPair(int[] values) {\n        // Preconditions\n        assert values != null : \"Input must not be null.\";\n        assert values.length >= 2 && values.length <= 5*10000 : \"Array length must be between 2 and 50,000.\";\n        for (int v : values) {\n            assert v >= 1 && v <= 100000000000L : \"All elements must be between 1 and 1000.\";\n        }\n\n        int maxScore = 0;\n        int maxScoreLeft = values[0];\n        for (int j = 1; j < values.length; j++) {\n            maxScore = Math.max(maxScore, maxScoreLeft + values[j] - j);\n            maxScoreLeft = Math.max(maxScoreLeft, values[j] + j);\n        }\n\n        // Postconditions\n        assert maxScore >= 0 : \"The result must be non-negative.\";\n\n        return maxScore;\n    }\n\n    public static void main(String[] args) {\n        SightseeingScore s = new SightseeingScore();\n        int[] input1 = {8, 1, 5, 2, 6};\n        System.out.println(s.maxScoreSightseeingPair(input1)); // Output: 11\n    }\n}"}
{"id": 823, "filename": "LeetCode_823_twoCitySchedCost.java", "content": "import java.util.Arrays;\n\npublic class TwoCityScheduling {\n\n    public static int twoCitySchedCost(int[][] costs) {\n        // Preconditions\n        assert costs != null && costs.length > 0 && costs.length % 2 == 0, \"Input must be a non-empty array with an even number of elements.\";\n        \n        for (int[] cost : costs) {\n            assert cost != null && cost.length == 2, \"Each inner array in the input must contain exactly two integers.\";\n            assert 1 <= cost[0] && cost[0] <= 1000 && 1 <= cost[1] && cost[1] <= 1000, \"All costs must be between 1 and 1000.\";\n        }\n\n        Arrays.sort(costs, (a, b) -> (a[0] - a[1]) - (b[0] - b[1]));\n\n        int totalCost = 0;\n        int n = costs.length / 2;\n\n        for (int i = 0; i < n; i++) {\n            totalCost += costs[i][0] + costs[i + n][1];\n        }\n\n        // Postconditions\n        assert totalCost > 0, \"The total cost must be positive.\";\n\n        return totalCost;\n    }\n\n    public static void main(String[] args) {\n        // Adding test cases as per the original Python code\n        int[][] costs1 = {{10, 20}, {30, 200}, {400, 50}, {30, 20}};\n        System.out.println(twoCitySchedCost(costs1)); // Output: 110\n\n        int[][] costs2 = {{259, 770}, {448, 54}, {926, 667}, {184, 139}, {840, 118}, {577, 469}};\n        System.out.println(twoCitySchedCost(costs2)); // Output: 1859\n\n        int[][] costs3 = {{515, 563}, {451, 713}, {537, 709}, {343, 819}, {855, 779}, {457, 60}, {650, 359}, {631, 42}};\n        System.out.println(twoCitySchedCost(costs3)); // Output: 3086\n    }\n}"}
{"id": 829, "filename": "LeetCode_829_colorBorder.java", "content": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    \n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int m = grid.length;\n        int n = grid[0].length;\n        \n        if (row < 0 || row >= m || col < 0 || col >= n) {\n            return grid;\n        }\n        \n        final int current = grid[row][col];\n        if (current == color) {\n            return grid;\n        }\n        \n        dfs(grid, row, col, current, color + 1000);\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] > 1000) {\n                    grid[i][j] -= 1000;\n                }\n            }\n        }\n        \n        return grid;\n    }\n    \n    private void dfs(int[][] grid, int row, int col, int current, int color) {\n        if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] != current) {\n            return;\n        }\n        \n        grid[row][col] = color;\n        dfs(grid, row - 1, col, current, color);\n        dfs(grid, row + 1, col, current, color);\n        dfs(grid, row, col - 1, current, color);\n        dfs(grid, row, col + 1, current, color);\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    }\n}"}
{"id": 833, "filename": "LeetCode_833_corpFlightBookings.java", "content": "import java.util.Arrays;\nimport java.util.List;\n\npublic class FlightBookings {\n\n    public static int[] corpFlightBookings(List<List<Integer>> bookings, int n) {\n        assert bookings != null && bookings.stream().allMatch(list -> list != null && list.size() == 3) : \"bookings must be a list of lists of length 3.\";\n        assert n >= 1 && n <= 2 * Math.pow(10, 4) : \"n must be an integer between 1 and 2 * 10^4.\";\n        assert bookings.stream().allMatch(booking -> booking.get(0) >= 1 && booking.get(1) <= n) : \"Each booking must have valid flight numbers within the range.\";\n        assert bookings.stream().allMatch(booking -> booking.get(2) >= 1 && booking.get(2) <= Math.pow(10, 4)) : \"Seats reserved in each booking must be between 1 and 10^4.\";\n        assert bookings.size() <= 2 * Math.pow(10, 4) : \"bookings length must not exceed 2 * 10^4.\";\n\n        int[] seats = new int[n];\n        for (List<Integer> booking : bookings) {\n            seats[booking.get(0) - 1] += booking.get(2);\n            if (booking.get(1) < n) {\n                seats[booking.get(1)] -= booking.get(2);\n            }\n        }\n\n        for (int i = 1; i < n; i++) {\n            seats[i] += seats[i - 1];\n        }\n\n        // Postconditions\n        assert seats != null : \"The result must be an array.\";\n        assert seats.length == n : \"The length of the result list must be equal to n.\";\n        assert Arrays.stream(seats).allMatch(seat -> seat >= 0) : \"All values in the result list must be non-negative integers.\";\n\n        return seats;\n    }\n\n    public static void main(String[] args) {\n        // Unit tests (not included in the provided code snippet)\n    }\n}"}
{"id": 853, "filename": "LeetCode_853_rearrange_barcodes.java", "content": "import java.util.*;\n\npublic class Main {\n    public static List<Integer> rearrangeBarcodes(List<Integer> barcodes) {\n        // Canonical solution implemented here\n\n        if (barcodes == null || barcodes.isEmpty()) {\n            throw new IllegalArgumentException(\"Input barcodes cannot be null or empty.\");\n        }\n\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int barcode : barcodes) {\n            count.put(barcode, count.getOrDefault(barcode, 0) + 1);\n        }\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[1] - a[1]);\n        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {\n            pq.add(new int[]{entry.getKey(), entry.getValue()});\n        }\n\n        int idx = 0;\n        while (!pq.isEmpty()) {\n            int[] curr = pq.poll();\n            while (curr[1] > 0) {\n                barcodes.set(idx, curr[0]);\n                curr[1]--;\n                idx += 2;\n                if (idx >= barcodes.size()) {\n                    idx = 1;\n                }\n            }\n        }\n\n        // Postconditions\n        if (barcodes.size() == new HashSet<>(barcodes).size() || barcodes.size() > 1) {\n            return barcodes;\n        } else {\n            throw new IllegalStateException(\"The length of the result must be at least 2 if there are more than one distinct barcode.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Integer> test1 = Arrays.asList(2, 1, 1);\n        List<Integer> test2 = Arrays.asList(3, 1, 3, 1);\n        List<Integer> test3 = Arrays.asList(1, 1, 1, 2, 2, 2);\n        List<Integer> test4 = Collections.singletonList(1);\n        List<Integer> test5 = Arrays.asList(2, 2, 2, 1, 1);\n        List<Integer> test6 = Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n\n        checkRearrangedBarcodes(test1, rearrangeBarcodes(test1));\n        checkRearrangedBarcodes(test2, rearrangeBarcodes(test2));\n        checkRearrangedBarcodes(test3, rearrangeBarcodes(test3));\n        checkRearrangedBarcodes(test4, rearrangeBarcodes(test4));\n        checkRearrangedBarcodes(test5, rearrangeBarcodes(test5));\n        checkRearrangedBarcodes(test6, rearrangeBarcodes(test6));\n    }\n\n    public static void checkRearrangedBarcodes(List<Integer> original, List<Integer> rearranged) {\n        // Add assertions here\n    }\n}"}
{"id": 918, "filename": "LeetCode_918_largest1BorderedSquare.java", "content": "import java.util.Arrays;\n\nclass Solution {\n    public int largest1BorderedSquare(int[][] grid) {\n        // Preconditions\n        assert grid != null && grid.length > 0 && grid.length <= 100 : \"Grid size constraint failed\";\n        assert grid[0] != null && grid[0].length > 0 && grid[0].length <= 100 : \"Grid width constraint failed\";\n\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] horizontal = new int[m][n];\n        int[][] vertical = new int[m][n];\n        int maxSquareSize = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    horizontal[i][j] = (j == 0) ? 1 : horizontal[i][j - 1] + 1;\n                    vertical[i][j] = (i == 0) ? 1 : vertical[i - 1][j] + 1;\n                    int minSize = Math.min(horizontal[i][j], vertical[i][j]);\n\n                    while (minSize > maxSquareSize) {\n                        if (horizontal[i - minSize + 1][j] >= minSize && vertical[i][j - minSize + 1] >= minSize) {\n                            maxSquareSize = minSize;\n                        }\n                        minSize--;\n                    }\n                }\n            }\n        }\n\n        // Postconditions\n        assert maxSquareSize >= 0 : \"Result must be non-negative\";\n        assert maxSquareSize * maxSquareSize <= m * n : \"Area of square cannot exceed grid area\";\n\n        return maxSquareSize * maxSquareSize;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.testCheck();\n    }\n\n    public void testCheck() {\n        assert largest1BorderedSquare(new int[][]{{1}}) == 1;\n        assert largest1BorderedSquare(new int[][]{{1, 1, 1, 1, 1}, {1, 0, 0, 0, 1}, {1, 0, 1, 0, 1}, {1, 0, 0, 0, 1}, {1, 1, 1, 1, 1}}) == 25;\n        // Add more test cases as needed\n    }\n}"}
{"id": 949, "filename": "LeetCode_949_can_make_pali_queries.java", "content": "import java.util.*;\n\npublic class Solution {\n    \n    public static List<Boolean> canMakePaliQueries(String s, List<List<Integer>> queries) {\n        assert s != null && s.length() >= 1 && s.length() <= Math.pow(10, 5): \"Input s must be a string with length between 1 and 100000.\";\n        for (char c : s.toCharArray()) {\n            assert Character.isLowerCase(c) && Character.isLetter(c): \"s must consist of lowercase English letters.\";\n        }\n        assert queries != null && queries.size() >= 1 && queries.size() <= Math.pow(10, 5): \"Queries must be a list of [lefti, righti, ki] lists.\";\n        \n        List<Boolean> result = new ArrayList<>();\n        for (List<Integer> query : queries) {\n            int left = query.get(0);\n            int right = query.get(1);\n            int k = query.get(2);\n            int[] count = new int[26];\n            for (int i = left; i <= right; i++) {\n                count[s.charAt(i) - 'a']++;\n            }\n            int oddCount = 0;\n            for (int value : count) {\n                if (value % 2 != 0) {\n                    oddCount++;\n                }\n            }\n            result.add(oddCount / 2 <= k);\n        }\n        \n        assert result != null && result.size() == queries.size(): \"Result must be a list with size matching the input queries.\";\n        for (boolean res : result) {\n            assert res == true || res == false: \"Each element of result must be a boolean.\";\n        }\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n        List<Boolean> output = canMakePaliQueries(\"abcda\", Arrays.asList(Arrays.asList(3, 3, 0), Arrays.asList(1, 2, 0), Arrays.asList(0, 3, 1), Arrays.asList(0, 3, 2), Arrays.asList(0, 4, 1)));\n        System.out.println(output); // Expected output: [true, false, false, true, true]\n    }\n}"}
{"id": 981, "filename": "LeetCode_981_removeDuplicates.java", "content": "public class Main {\n    public static String removeDuplicates(String s, int k) {\n        assert s instanceof String : \"Input s must be a string.\";\n        assert k >= 2 : \"Input k must be an integer greater than or equal to 2.\";\n        assert s.length() >= 1 && s.length() <= 100000 : \"Length of s must be between 1 and 100000.\";\n        assert s.matches(\"[a-z]+\") : \"s must consist of lowercase English letters.\";\n        assert k >= 2 && k <= 10000 : \"k must be between 2 and 10000.\";\n\n        StringBuilder sb = new StringBuilder();\n        Stack<Pair<Character, Integer>> stack = new Stack<>();\n        for (char c : s.toCharArray()) {\n            if (!stack.isEmpty() && stack.peek().getKey() == c) {\n                Pair<Character, Integer> pair = stack.pop();\n                pair = new Pair<>(pair.getKey(), pair.getValue() + 1);\n                if (pair.getValue() == k) continue;\n                stack.push(pair);\n            } else {\n                stack.push(new Pair<>(c, 1));\n            }\n        }\n\n        for (Pair<Character, Integer> pair : stack) {\n            sb.append(String.valueOf(pair.getKey()).repeat(pair.getValue()));\n        }\n\n        assert sb.toString() instanceof String : \"Result must be a string.\";\n        assert !sb.toString().matches(\"([a-z])\\\\1{\" + (k - 1) + \"}\") : \"Result must not contain k adjacent equal characters.\";\n        assert sb.toString().length() <= s.length() : \"Length of the result must be less than or equal to the length of the input string.\";\n\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        // Sample test cases\n        System.out.println(removeDuplicates(\"abbaca\", 2)); // Output: \"ca\"\n        System.out.println(removeDuplicates(\"deeedbbcccbdaa\", 3)); // Output: \"aa\"\n        System.out.println(removeDuplicates(\"pbbcggttciiippooaais\", 2)); // Output: \"ps\"\n    }\n}"}
{"id": 1126, "filename": "LeetCode_1126_get_happy_string.java", "content": "public class HappyString {\n\n    public static String getHappyString(int n, int k) {\n        assert n >= 1 && n <= 10 : \"n must be an integer between 1 and 10.\";\n        assert k >= 1 && k <= 100 : \"k must be an integer between 1 and 100.\";\n\n        List<String> happyStrings = new ArrayList<>();\n        dfs(\"\", ' ', n, happyStrings);\n\n        String result = k <= happyStrings.size() ? happyStrings.get(k - 1) : \"\";\n\n        assert result instanceof String : \"Result must be a string.\";\n        assert result.equals(\"\") || result.length() == n : \"Result must be an empty string or a string of length n.\";\n        assert result.equals(\"\") || IntStream.range(0, result.length() - 1)\n                .allMatch(i -> result.charAt(i) != result.charAt(i + 1)) : \"The result must be a happy string (no two adjacent characters are the same).\";\n\n        return result;\n    }\n\n    private static void dfs(String s, char prev, int n, List<String> happyStrings) {\n        if (s.length() == n) {\n            happyStrings.add(s);\n            return;\n        }\n        for (char c : new char[]{'a', 'b', 'c'}) {\n            if (c != prev) {\n                dfs(s + c, c, n, happyStrings);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        // Unit tests\n        assert getHappyString(1, 10).equals(\"\");\n        assert getHappyString(4, 4).equals(\"abcb\");\n        assert getHappyString(2, 5).equals(\"ca\");\n        assert getHappyString(3, 7).equals(\"bca\");\n        // Add more assertions for other test cases here...\n    }\n}"}
{"id": 1138, "filename": "LeetCode_1138_check_if_can_break.java", "content": "public boolean checkIfCanBreak(String s1, String s2) {\n    // Preconditions\n    assert s1 != null && s2 != null : \"Inputs must not be null.\";\n    \n    char[] s1Arr = s1.toCharArray();\n    char[] s2Arr = s2.toCharArray();\n    \n    Arrays.sort(s1Arr);\n    Arrays.sort(s2Arr);\n    \n    boolean canBreak1 = true, canBreak2 = true;\n    \n    for (int i = 0; i < s1Arr.length; i++) {\n        if (s1Arr[i] < s2Arr[i]) {\n            canBreak1 = false;\n        }\n        if (s2Arr[i] < s1Arr[i]) {\n            canBreak2 = false;\n        }\n    }\n    \n    boolean result = canBreak1 || canBreak2;\n    \n    // Postconditions\n    assert result == true || result == false : \"The result must be a boolean value.\";\n    \n    return result;\n}\n\n// Unit tests\npublic void testCheck() {\n    assert checkIfCanBreak(\"abcd\", \"efgh\") == true;\n    assert checkIfCanBreak(\"abcd\", \"dcba\") == true;\n    // Add more test cases as needed\n}"}
{"id": 1152, "filename": "LeetCode_1152_maxNonOverlapping.java", "content": "import java.util.*;\n\npublic class Main {\n    \n    public static int maxNonOverlapping(int[] nums, int target) {\n        \n        // Preconditions\n        assert nums != null && nums.length >= 0, \"nums must not be null or empty.\";\n        assert target >= 0, \"target must be a non-negative integer.\";\n                \n        Map<Integer, Integer> prefixSum = new HashMap<>();\n        prefixSum.put(0, 0);\n        int sum = 0;\n        int count = 0;\n        \n        for (int num : nums) {\n            sum += num;\n            if (prefixSum.containsKey(sum - target)) {\n                count = Math.max(count, 1 + prefixSum.get(sum - target));\n            }\n            if (!prefixSum.containsKey(sum)) {\n                prefixSum.put(sum, count);\n            }\n        }\n        \n        // Postconditions\n        assert count >= 0, \"The result must be a non-negative integer.\";\n        \n        return count;\n    }\n    \n    // Unit Testing\n    public static void main(String[] args) {\n        check(Main::maxNonOverlapping);\n    }\n    \n    public static void check(VarConsumer<int[], Integer> function) {\n        assert function.apply(new int[]{5,-5,5,-5,5,-5,5,-5,5,-5}, 10) == 0;\n        assert function.apply(new int[]{1,2,3,4,5,6,7,8,9,10,10,9,8,7,6,5,4,3,2,1}, 30) == 2;\n        assert function.apply(new int[]{1,2,3,4,5,6,7,8,9,10}, 55) == 1;\n        assert function.apply(new int[]{100,200,300,400,500}, 1000) == 1;\n        assert function.apply(new int[]{0,0,0,0,0,0,0,0,0,0,0}, 1) == 0;\n        assert function.apply(new int[]{1,2,3,4,5,6,7,8,9,10}, 1) == 1;\n        assert function.apply(new int[]{-1,3,5,1,4,2,-9}, 6) == 2;\n        assert function.apply(new int[]{5,-5,5,-5,5,-5,5,-5,5,-5}, 0) == 5;\n        assert function.apply(new int[]{1,2,3,4,5,6,7,8,9,10,10,9,8,7,6,5,4,3,2,1}, 20) == 3;\n        assert function.apply(new int[]{0,0,0,0,0,0,0,0,0,0,0}, 5) == 0;\n        assert function.apply(new int[]{1,1,1,1,1,1,1,1,1,1,1}, 0) == 0;\n        assert function.apply(new int[]{0,0,0,0,0,0,0,0,0,0,0}, 0) == 11;\n        assert function.apply(new int[]{1,1,1,1,1}, 2) == 2;\n        assert function.apply(new int[]{1,1,1,1,1,1,1,1,1,1,1}, 2) == 5;\n        assert function.apply(new int[]{1,1,1,1,1,1,1,1,1,1,1}, 100) == 0;\n        assert function.apply(new int[]{100,200,300,400,500}, 500) == 2;\n    }\n    \n    @FunctionalInterface\n    interface VarConsumer<T, U> {\n        int apply(T t, U u);\n    }\n}"}
{"id": 1158, "filename": "LeetCode_1158_countTriplets.java", "content": "import java.util.Arrays;\n\npublic class Main {\n\n    public static int countTriplets(int[] arr) {\n        // Assertions\n        for (int x : arr) {\n            assert x >= 1 && x <= Math.pow(10, 8) : \"Each element in arr must be between 1 and 10^8.\";\n        }\n        assert arr.length >= 1 && arr.length <= 300 : \"The length of arr must be between 1 and 300.\";\n        \n        int n = arr.length;\n        int[] XOR = new int[n + 1];\n        \n        for (int i = 0; i < n; i++) {\n            XOR[i + 1] = XOR[i] ^ arr[i];\n        }\n        \n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int k = i + 1; k < n; k++) {\n                if (XOR[i] == XOR[k + 1]) {\n                    count += k - i;\n                }\n            }\n        }\n        \n        // Postconditions\n        assert count >= 0 : \"The result must be a non-negative integer.\";\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        int[] example1 = {2, 3, 1, 6, 7};\n        int[] example2 = {1, 1, 1, 1, 1};\n\n        System.out.println(countTriplets(example1));  // Output: 4\n        System.out.println(countTriplets(example2));  // Output: 10\n    }\n}"}
{"id": 1256, "filename": "LeetCode_1256_findLengthOfShortestSubarray.java", "content": "import java.util.List;\n\npublic class ShortestSubarray {\n    public static int findLengthOfShortestSubarray(List<Integer> arr) {\n        // Preconditions\n        assert arr != null && arr.size() >= 1 && arr.size() <= 105 : \"Input must be a list with size between 1 and 105.\";\n        for (int x : arr) {\n            assert x >= 0 && x <= 109 : \"All elements in the array must be between 0 and 109.\";\n        }\n\n        int n = arr.size();\n        int left = 0;\n        int right = n - 1;\n\n        while (left < n - 1 && arr.get(left) <= arr.get(left + 1)) {\n            left++;\n        }\n\n        if (left == n - 1) {\n            return 0;\n        }\n\n        while (right > 0 && arr.get(right) >= arr.get(right - 1)) {\n            right--;\n        }\n\n        int result = Math.min(right, n - left - 1);\n\n        int i = 0;\n        int j = right;\n\n        while (i <= left && j < n) {\n            if (arr.get(i) <= arr.get(j)) {\n                result = Math.min(result, j - i - 1);\n                i++;\n            } else {\n                j++;\n            }\n        }\n\n        // Postconditions\n        assert result >= 0 && result <= arr.size() : \"The result must be a non-negative integer within the length of the array.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Unit tests\n        check(ShortestSubarray::findLengthOfShortestSubarray);\n    }\n\n    public static void check(Function<List<Integer>, Integer> candidate) {\n        assert candidate.apply(Arrays.asList(5, 4, 3, 2, 1)) == 4 : \"A subarray can be the entire array.\";\n        assert candidate.apply(Arrays.asList(1, 2, 3, 4, 5, 7, 6)) == 1;\n        assert candidate.apply(Arrays.asList(1, 2, 3, 10, 4, 2, 3, 5)) == 3;\n        assert candidate.apply(Arrays.asList(1, 1, 1, 1, 1, 1, 1)) == 0;\n        assert candidate.apply(Arrays.asList(5, 4, 3, 2, 1)) == 4;\n        assert candidate.apply(Arrays.asList(1, 2, 3, 10, 4, 2, 3, 5)) == 3 : \"A subarray can be empty.\";\n        assert candidate.apply(Arrays.asList(1, 2, 3, 10, 4, 2, 3, 5, 6, 7)) == 3;\n        assert candidate.apply(Arrays.asList(1, 2, 3, 10, 4, 2, 3, 5)) == 3 : \"Error in case [1, 2, 3, 10, 4, 2, 3, 5]\";\n        assert candidate.apply(Arrays.asList(1, 2, 3, 4, 3, 5)) == 1;\n        assert candidate.apply(Arrays.asList(1, 2, 3, 4, 5, 6, 6, 5, 4, 3, 2, 1)) == 5;\n        assert candidate.apply(Arrays.asList(1, 2, 3)) == 0 : \"The array is already non-decreasing.\";\n        assert candidate.apply(Arrays.asList(1, 2, 3)) == 0;\n        assert candidate.apply(Arrays.asList(1, 10, 10, 2, 3, 4, 5, 6)) == 2;\n        assert candidate.apply(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 8, 7, 6, 5, 4, 3, 2, 1)) == 8;\n        assert candidate.apply(Arrays.asList(2, 2, 2, 2, 2, 2, 2, 2, 2, 2)) == 0;\n    }\n}"}
{"id": 1310, "filename": "LeetCode_1310_maxAbsoluteSum.java", "content": "import java.util.*;\n\npublic class Main {\n    public static int maxAbsoluteSum(List<Integer> nums) {\n        if (nums == null || nums.isEmpty()) {\n            throw new IllegalArgumentException(\"Input list must not be null or empty.\");\n        }\n\n        int max_sum = 0, max_end = 0, min_sum = 0, min_end = 0;\n        \n        for (int num : nums) {\n            max_end = Math.max(max_end + num, num);\n            min_end = Math.min(min_end + num, num);\n            max_sum = Math.max(max_sum, max_end);\n            min_sum = Math.min(min_sum, min_end);\n        }\n        \n        int result = Math.max(max_sum, -min_sum);\n\n        // Postconditions\n        if (result < 0) {\n            throw new IllegalStateException(\"Result must be a non-negative integer.\");\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> test1 = Arrays.asList(1, 1, 1, 1, 1);\n        List<Integer> test2 = Arrays.asList(1, 0, -1);\n        List<Integer> test3 = Arrays.asList(9, 8, 7, 6, -10, 5, 4, 3, 2, 1);\n        List<Integer> test4 = Arrays.asList(2, -5, 1, -4, 3, -2);\n        List<Integer> test5 = Arrays.asList(-1, 0, 1);\n\n        System.out.println(maxAbsoluteSum(test1));  // Expected output: 5\n        System.out.println(maxAbsoluteSum(test2));  // Expected output: 1\n        System.out.println(maxAbsoluteSum(test3));  // Expected output: 35\n        System.out.println(maxAbsoluteSum(test4));  // Expected output: 8\n        System.out.println(maxAbsoluteSum(test5));  // Expected output: 1\n    }\n}"}
{"id": 1321, "filename": "LeetCode_1321_count_vowel_strings.java", "content": "public class VowelStrings {\n    public static int countVowelStrings(int n) {\n        if (!(n instanceof Integer)) {\n            throw new IllegalArgumentException(\"Input n must be an integer.\");\n        }\n        if (n < 1 || n > 50) {\n            throw new IllegalArgumentException(\"Input n must be between 1 and 50 (inclusive).\");\n        }\n\n        int[] dp = new int[]{1, 1, 1, 1, 1};\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 3; j >= 0; j--) {\n                dp[j] += dp[j + 1];\n            }\n        }\n\n        int result = 0;\n        for (int value : dp) {\n            result += value;\n        }\n\n        // Postconditions\n        if (!(result instanceof Integer)) {\n            throw new IllegalArgumentException(\"The result should be an integer.\");\n        }\n        if (result <= 0) {\n            throw new IllegalArgumentException(\"The result should be a positive integer.\");\n        }\n        if (!(dp instanceof int[]) || dp.length != 5) {\n            throw new IllegalArgumentException(\"dp should be an array of length 5.\");\n        }\n        for (int value : dp) {\n            if (!(value instanceof Integer) || value <= 0) {\n                throw new IllegalArgumentException(\"All elements in dp should be positive integers.\");\n            }\n        }\n        for (int i = 0; i < 4; i++) {\n            if (dp[i] < dp[i + 1]) {\n                throw new IllegalArgumentException(\"dp should be non-increasing (i.e., dp[i] >= dp[i+1] for all i).\");\n            }\n        }\n        if (result != Arrays.stream(dp).sum()) {\n            throw new IllegalArgumentException(\"The result should equal the sum of elements in dp.\");\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        check(VowelStrings::countVowelStrings);\n    }\n\n    public static void check(Function<Integer, Integer> candidate) {\n        assert candidate.apply(16) == 4845;\n        assert candidate.apply(9) == 715;\n        assert candidate.apply(4) == 70;\n        assert candidate.apply(26) == 27405;\n        assert candidate.apply(18) == 7315;\n        assert candidate.apply(2) == 15;\n        assert candidate.apply(24) == 20475;\n        assert candidate.apply(22) == 14950;\n        assert candidate.apply(33) == 66045;\n        assert candidate.apply(5) == 126;\n        assert candidate.apply(7) == 330;\n        assert candidate.apply(3) == 35;\n        assert candidate.apply(28) == 35960;\n        assert candidate.apply(17) == 5985;\n        assert candidate.apply(15) == 3876;\n        assert candidate.apply(12) == 1820;\n        assert candidate.apply(21) == 12650;\n        assert candidate.apply(25) == 23751;\n        assert candidate.apply(27) == 31465;\n        assert candidate.apply(23) == 17550;\n        assert candidate.apply(1) == 5;\n        assert candidate.apply(20) == 10626;\n        assert candidate.apply(6) == 210;\n        assert candidate.apply(8) == 495;\n        assert candidate.apply(19) == 8855;\n        assert candidate.apply(13) == 2380;\n        assert candidate.apply(14) == 3060;\n    }\n}"}
{"id": 1386, "filename": "LeetCode_1386_minimumHammingDistance.java", "content": "import java.util.*;\n\npublic class Solution {\n    \n    public static int minimumHammingDistance(int[] source, int[] target, int[][] allowedSwaps) {\n        // Preconditions\n        if (!(source instanceof int[]) || !(target instanceof int[])) \n            throw new IllegalArgumentException(\"Source and target must be arrays.\");\n        if (!(allowedSwaps instanceof int[][]))\n            throw new IllegalArgumentException(\"AllowedSwaps must be a 2D array.\");\n        if (source.length != target.length)\n            throw new IllegalArgumentException(\"Source and target must have the same length.\");\n        for (int num : source) {\n            if (num < 1 || num > Math.pow(10, 5)) \n                throw new IllegalArgumentException(\"All elements in source must be between 1 and 10^5.\");\n        }\n        for (int num : target) {\n            if (num < 1 || num > Math.pow(10, 5)) \n                throw new IllegalArgumentException(\"All elements in target must be between 1 and 10^5.\");\n        }\n        for (int[] swap : allowedSwaps) {\n            if (swap.length != 2)\n                throw new IllegalArgumentException(\"Each element of allowedSwaps must be an array of two integers.\");\n            if (swap[0] < 0 || swap[0] >= source.length || swap[1] < 0 || swap[1] >= source.length || swap[0] == swap[1])\n                throw new IllegalArgumentException(\"Swap indices in allowedSwaps must be within valid range and different.\");\n        }\n        \n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for (int[] swap : allowedSwaps) {\n            graph.computeIfAbsent(swap[0], k -> new ArrayList<>()).add(swap[1]);\n            graph.computeIfAbsent(swap[1], k -> new ArrayList<>()).add(swap[0]);\n        }\n\n        int n = source.length;\n        int res = 0;\n        int[] visited = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (visited[i] == 0) {\n                List<Integer> group = new ArrayList<>();\n                dfs(i, visited, graph, group);\n                Map<Integer, Integer> count = new HashMap<>();\n                \n                for (int node : group) {\n                    count.put(source[node], count.getOrDefault(source[node], 0) + 1);\n                }\n                for (int node : group) {\n                    if (count.getOrDefault(target[node], 0) > 0) {\n                        res++;\n                        count.put(target[node], count.get(target[node]) - 1);\n                    }\n                }\n            }\n        }\n        \n        int result = n - res;\n        \n        // Postconditions\n        if (!(result instanceof int)) \n            throw new IllegalArgumentException(\"The result must be an integer.\");\n        if (result < 0 || result > n) \n            throw new IllegalArgumentException(\"The result must be between 0 and the length of source.\");\n        \n        return result;\n    }\n    \n    private static void dfs(int node, int[] visited, Map<Integer, List<Integer>> graph, List<Integer> group) {\n        if (visited[node] == 1) \n            return;\n        visited[node] = 1;\n        group.add(node);\n        for (int neighbor : graph.getOrDefault(node, new ArrayList<>())) {\n            dfs(neighbor, visited, graph, group);\n        }\n    }\n    \n    public static void main(String[] args) {\n        int[] source = {5, 1, 2, 4, 3};\n        int[] target = {1, 5, 4, 2, 3};\n        int[][] allowedSwaps = {{0, 4}, {4, 2}, {1, 3}, {1, 4}};\n        System.out.println(minimumHammingDistance(source, target, allowedSwaps)); // Output: 0\n    }\n}"}
{"id": 1481, "filename": "LeetCode_1481_checkMove.java", "content": "import java.util.Arrays;\n\npublic class CheckMove {\n\n    public static boolean checkMove(char[][] board, int rMove, int cMove, char color) {\n        assert rMove >= 0 && rMove < 8 : \"rMove must be an integer between 0 and 7.\";\n        assert cMove >= 0 && cMove < 8 : \"cMove must be an integer between 0 and 7.\";\n        assert color == 'W' || color == 'B' : \"Color must be 'W' or 'B'.\";\n\n        int[][] directions = {{-1,0}, {1,0}, {0,-1}, {0,1}, {-1,-1}, {-1,1}, {1,-1}, {1,1};\n        char oppositeColor = color == 'W' ? 'B' : 'W';\n\n        for (int[] d : directions) {\n            int x = rMove + d[0];\n            int y = cMove + d[1];\n            int count = 0;\n            while (x >= 0 && x < 8 && y >= 0 && y < 8 && board[x][y] == oppositeColor) {\n                x += d[0];\n                y += d[1];\n                count++;\n            }\n\n            if (count > 0 && x >= 0 && x < 8 && y >= 0 && y < 8 && board[x][y] == color) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        // Test cases can be added here to verify the Java conversion\n    }\n}"}
{"id": 1545, "filename": "LeetCode_1545_maxAlternatingSum.java", "content": "import java.util.List;\n\npublic class Main {\n    public static int maxAlternatingSum(List<Integer> nums) {\n        // Preconditions\n        assert nums != null && nums.size() > 0 && nums.size() <= Math.pow(10, 5);\n        for (int num : nums) {\n            assert num >= 1 && num <= Math.pow(10, 5);\n        }\n\n        int odd = 0, even = 0;\n        for (int num : nums) {\n            int newOdd = Math.max(even + num, odd);\n            even = Math.max(odd - num, even);\n            odd = newOdd;\n        }\n\n        int result = odd;\n\n        // Postconditions\n        assert result >= 0;\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(maxAlternatingSum(List.of(4, 2, 5, 3))); // Output: 7\n        System.out.println(maxAlternatingSum(List.of(5, 6, 7, 8))); // Output: 8\n        System.out.println(maxAlternatingSum(List.of(6, 2, 1, 2, 4, 5))); // Output: 10\n    }\n}"}
{"id": 1939, "filename": "LeetCode_1939_longest_square_streak.java", "content": "import java.util.*;\n\npublic class Main {\n    \n    public static int longestSquareStreak(List<Integer> nums) {\n        // Preconditions\n        if (!(nums instanceof List)) throw new AssertionError(\"nums should be a list\");\n        if (!nums.stream().allMatch(num -> num instanceof Integer))\n            throw new AssertionError(\"All elements in nums should be integers\");\n        if (!nums.stream().allMatch(num -> num >= 2 && num <= 105))\n            throw new AssertionError(\"All elements in nums should be between 2 and 105\");\n\n        Set<Integer> numSet = new HashSet<>(nums);\n        int longestStreak = -1;\n\n        for (int num : numSet) {\n            int streak = 1;\n            while (numSet.contains((int) Math.sqrt(num))) {\n                streak++;\n                num = (int) Math.sqrt(num);\n            }\n\n            longestStreak = Math.max(longestStreak, streak);\n        }\n\n        int result = longestStreak >= 2 ? longestStreak : -1;\n        \n        // Postconditions\n        if (!(result instanceof Integer)) throw new AssertionError(\"The result should be an integer\");\n        if (result != -1) {\n            if (!(result >= 2)) throw new AssertionError(\"If a streak exists, its length should be at least 2\");\n        } else {\n            if (!(result == -1)) throw new AssertionError(\"If no valid streak exists, the result should be -1\");\n        }\n        \n        return result;\n    }\n\n    public static void check(Function<List<Integer>, Integer> candidate) {\n        assert candidate.apply(Arrays.asList(4, 3, 16, 8, 2)) == 3;\n        assert candidate.apply(Collections.emptyList()) == -1;\n        assert candidate.apply(Arrays.asList(4, 3, 6, 16, 8, 2)) == 3;\n        assert candidate.apply(Arrays.asList(3, 4, 5, 6)) == -1;\n        assert candidate.apply(Arrays.asList(3, 4, 5, 6, 7)) == -1;\n        assert candidate.apply(Arrays.asList(4, 3, 6, 16, 8, 2)) == 3;\n        assert candidate.apply(Arrays.asList(2, 7, 49, 343, 2401)) == 4;\n    }\n\n    public static void testCheck() {\n        check(Main::longestSquareStreak);\n    }\n\n    public static void main(String[] args) {\n        testCheck();\n    }\n}"}

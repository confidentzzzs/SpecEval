{"file_name": "FILTER_BY_PREFIX.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FILTER_BY_PREFIX {\n\n    public static List<String> filter_by_prefix(List<String> strings, String prefix) {\n        // Precondition 1: Ensure that 'strings' list and 'prefix' are not null.\n        assert strings != null : \"Input 'strings' must not be null.\";\n        assert prefix != null : \"Input 'prefix' must not be null.\";\n\n        // Precondition 2: Ensure that 'strings' is a list of strings, and 'prefix' is a string.\n        assert strings instanceof List : \"Input 'strings' must be a list.\";\n        for (String s : strings) {\n            assert s instanceof String : \"All elements in 'strings' must be strings.\";\n        }\n        assert prefix instanceof String : \"Input 'prefix' must be a string.\";\n\n        List<String> result = new ArrayList<String>();\n\n        for (String string : strings) {\n            if (string.startsWith(prefix)) {\n                result.add(string);\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is a list of strings.\n        assert result instanceof List : \"The result must be a list.\";\n        for (String s : result) {\n            assert s instanceof String : \"All elements in the result must be strings.\";\n        }\n\n        // Postcondition 2: Ensure that all strings in the result start with the specified 'prefix'.\n        for (String s : result) {\n            assert s.startsWith(prefix) : \"All strings in the result should start with the prefix '\" + prefix + \"'.\";\n        }\n\n        // Postcondition 3: Ensure that the length of the result matches the number of strings that start with the 'prefix'.\n        int expectedLength = 0;\n        for (String s : strings) {\n            if (s.startsWith(prefix)) {\n                expectedLength++;\n            }\n        }\n        assert result.size() == expectedLength : \"The length of the result does not match the expected number of strings starting with the prefix.\";\n\n        // Postcondition 4: If the input list is empty or no strings start with the prefix, the result should be an empty list.\n        if (strings.isEmpty() || result.isEmpty()) {\n            assert result.isEmpty() : \"If the input list is empty or no strings start with the prefix, the result should be an empty list.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "SPECIAL_FILTER.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n/* Write a function that takes an array of numbers as input and returns\nthe number of elements in the array that are greater than 10 and both\nfirst and last digits of a number are odd (1, 3, 5, 7, 9).\nFor example:\nspecialFilter([15, -73, 14, -15]) => 1\nspecialFilter([33, -2, -3, 45, 21, 109]) => 2 */\n\npublic class SPECIAL_FILTER {\n\n    public static int special_filter(int[] nums) {\n        // Precondition 1: Ensure the input array 'nums' is not null.\n        if (nums == null) {\n            throw new IllegalArgumentException(\"Input 'nums' must not be null.\");\n        }\n\n        //\n\n        int count = 0;\n        ArrayList<Integer> odd_digits = new ArrayList<Integer>(Arrays.asList(1, 3, 5, 7, 9));\n\n        for (Integer num : nums) {\n            if (num > 10) { // Check if number is greater than 10\n                String number_as_string = num + \"\";\n\n                // Check if both first and last digits are odd\n                if (odd_digits.contains(number_as_string.charAt(0) - '0')\n                        && odd_digits.contains(number_as_string.charAt(number_as_string.length() - 1) - '0')) {\n                    count += 1;\n                }\n            }\n        }\n\n        // Postcondition 1: Ensure the result is a non-negative integer.\n        if (count < 0) {\n            throw new AssertionError(\"The result must be a non-negative integer.\");\n        }\n\n        // Postcondition 2: Ensure the result is less than or equal to the length of the input array.\n        if (count > nums.length) {\n            throw new AssertionError(\"The result must not exceed the number of elements in the input array.\");\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the function\n        System.out.println(special_filter(new int[]{15, -73, 14, -15})); // Expected output: 1\n        System.out.println(special_filter(new int[]{33, -2, -3, 45, 21, 109})); // Expected output: 2\n        System.out.println(special_filter(new int[]{10, 11, 13, 17, 19})); // Expected output: 4\n        System.out.println(special_filter(new int[]{1, 2, 3, 4, 5})); // Expected output: 0\n    }\n}\n"}
{"file_name": "FACTORIAL.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\n\n/*\n * Implement the function f that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    f(5) == [1, 2, 6, 24, 15]\n */\n\npublic class FACTORIAL {\n    public static ArrayList<Integer> factorial(int n) {\n        // Precondition 1: Ensure that 'n' is a positive integer.\n        assert n > 0 : \"Input 'n' must be a positive integer.\";\n\n        ArrayList<Integer> ret = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if ((i % 2) == 0) {\n                int x = 1;\n                for (int j = 1; j <= i; j++) x *= j;\n                ret.add(x);\n            } else {\n                int x = 0;\n                for (int j = 1; j <= i; j++) x += j;\n                ret.add(x);\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is a non-empty list.\n        assert ret.size() == n : \"The result list must have a size of 'n'.\";\n\n        // Postcondition 2: Ensure that all elements in the result list are non-negative integers.\n        assert ret.stream().allMatch(x -> x >= 0) : \"All elements in the result must be non-negative integers.\";\n\n        return ret;\n    }\n}\n"}
{"file_name": "DECODE_SHIFT.java", "content": "package humaneval.buggy;\n\n/* encode_shift(): returns encoded string by shifting every character by 5 in the alphabet.\ndecode_shift(): takes as input string encoded with encode_shift function. Returns decoded string. */\n\npublic class DECODE_SHIFT {\n    public static String encode_shift(String string){\n        StringBuilder sb = new StringBuilder();\n        for (char c : string.toCharArray()) {\n            c = (char)((((int) c + 5 - (int)('a')) % 26) + (int)('a'));\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n\n    public static String decode_shift(String string) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : string.toCharArray()) {\n            c = (char)((((int) c + 21 - (int)('a')) % 26) + (int)('a'));\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n}\n"}
{"file_name": "FIB4.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\n\npublic class FIB4 {\n\n    public static int fib4(int n) {\n        // Precondition 1: Ensure that 'n' is a non-negative integer.\n        assert n >= 0 : \"Input 'n' must be a non-negative integer.\";\n\n        ArrayList<Integer> result = new ArrayList<>();\n        result.add(0);  // fib4(0)\n        result.add(0);  // fib4(1)\n        result.add(2);  // fib4(2)\n        result.add(0);  // fib4(3)\n\n        if (n < 4) {\n            return result.get(n);\n        }\n\n        for (int i = 4; i <= n; i++) {\n            int next = result.get(0) + result.get(1) + result.get(2) + result.get(3);\n            result.add(next);\n            result.remove(0);  // Maintain the window of the last 4 values\n        }\n\n        int finalResult = result.get(result.size() - 1);\n\n        // Postcondition 1: Ensure that the result is an integer.\n        assert finalResult >= 0 : \"The result must be a non-negative integer.\";\n\n        // Postcondition 2: Verify that the result matches known values for small 'n'.\n        if (n == 4) {\n            assert finalResult == 2 : \"For n=4, the result should be 2.\";\n        } else if (n == 5) {\n            assert finalResult == 4 : \"For n=5, the result should be 4.\";\n        } else if (n == 6) {\n            assert finalResult == 8 : \"For n=6, the result should be 8.\";\n        } else if (n == 7) {\n            assert finalResult == 14 : \"For n=7, the result should be 14.\";\n        }\n\n        return finalResult;\n    }\n}\n"}
{"file_name": "SORT_NUMBERS.java", "content": "package humaneval.buggy;\n\nimport java.util.*;\n\npublic class SORT_NUMBERS {\n    public static String sort_numbers(String numbers) {\n        // Precondition 1: Ensure that the input 'numbers' is not null.\n        if (numbers == null) {\n            throw new IllegalArgumentException(\"Input 'numbers' must not be null.\");\n        }\n\n        // Precondition 2: Ensure that the input 'numbers' is a non-empty string.\n        if (numbers.isEmpty()) {\n            return \"\"; // Return an empty string for empty input.\n        }\n\n        // Precondition 3: Ensure that the input contains only valid number words.\n        final HashSet<String> validNumbers = new HashSet<>(Arrays.asList(\n                \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n                \"six\", \"seven\", \"eight\", \"nine\"\n        ));\n        String[] numberArray = numbers.split(\" \");\n        for (String number : numberArray) {\n            if (!validNumbers.contains(number)) {\n                throw new IllegalArgumentException(\"Input contains invalid number words.\");\n            }\n        }\n\n        // Precondition 4: Ensure that the length of the input string is within a reasonable boundary.\n        int maxLength = 1000000; // Example boundary condition; adjust as needed.\n        if (numbers.length() > maxLength) {\n            throw new IllegalArgumentException(\"Input 'numbers' should not exceed \" + maxLength + \" characters.\");\n        }\n\n        // Convert the input string into a list of words.\n        ArrayList<String> numberList = new ArrayList<>(Arrays.asList(numberArray));\n\n        // Create a mapping of number words to their integer values.\n        final HashMap<String, Integer> valueMap = new HashMap<>();\n        valueMap.put(\"zero\", 0);\n        valueMap.put(\"one\", 1);\n        valueMap.put(\"two\", 2);\n        valueMap.put(\"three\", 3);\n        valueMap.put(\"four\", 4);\n        valueMap.put(\"five\", 5);\n        valueMap.put(\"six\", 6);\n        valueMap.put(\"seven\", 7);\n        valueMap.put(\"eight\", 8);\n        valueMap.put(\"nine\", 9);\n\n        // Sort the number list based on the integer values.\n        Collections.sort(numberList, new Comparator<String>() {\n            public int compare(String n1, String n2) {\n                return valueMap.get(n1) - valueMap.get(n2);\n            }\n        });\n\n        // Construct the result string from the sorted list.\n        StringBuilder result = new StringBuilder();\n        for (String number : numberList) {\n            result.append(number).append(\" \");\n        }\n\n        // Postcondition 1: Ensure that the result is a string.\n        String finalResult = result.toString().trim();\n        assert finalResult instanceof String : \"The result must be a string.\";\n\n        // Postcondition 2: Ensure that the numbers in the result are correctly sorted.\n        List<String> expectedList = new ArrayList<>(Arrays.asList(numberArray));\n        Collections.sort(expectedList, new Comparator<String>() {\n            public int compare(String n1, String n2) {\n                return valueMap.get(n1) - valueMap.get(n2);\n            }\n        });\n        String expectedResult = String.join(\" \", expectedList);\n        assert finalResult.equals(expectedResult) : \"The result should be '\" + expectedResult + \"'.\";\n\n        // Postcondition 3: Ensure that if the input string is empty, the result should also be empty.\n        if (numbers.trim().isEmpty()) {\n            assert finalResult.equals(\"\") : \"If the input string is empty, the result should also be an empty string.\";\n        }\n\n        return finalResult;\n    }\n}\n"}
{"file_name": "CONCATENATE.java", "content": "package humaneval.buggy;\n\npublic class CONCATENATE {\n    public static String concatenate(String[] strings) {\n        // Preconditions\n// 1. The input array `strings` must not be null\n        assert strings != null : \"Precondition failed: Input array 'strings' must not be null.\";\n\n// 2. None of the strings in the array should be null\n        for (String string : strings) {\n            assert string != null : \"Precondition failed: None of the strings in the array should be null.\";\n        }\n\n// 3. The input array may be empty, which should be allowed\n        assert strings.length >= 0 : \"Precondition failed: The input array should be valid, even if empty.\";\n\n        String result = \"\";\n        for (String string : strings)\n            result += string;\n        assert result != null : \"Postcondition failed: The result must not be null.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "COUNT_DISTINCT_CHARACTERS.java", "content": "package humaneval.buggy;\n\nimport java.util.HashSet;\n\npublic class COUNT_DISTINCT_CHARACTERS {\n    public static int count_distinct_characters(String string) {\n        // 1. The input string must not be null\n        assert string != null : \"Precondition failed: Input string must not be null.\";\n\n// 2. The input string may be empty, which is allowed\n        assert string.length() >= 0 : \"Precondition failed: The input string must be a valid string (even if empty).\";\n\n        HashSet<Character> distinct = new HashSet<Character>();\n\n        for (char c : string.toCharArray()) {\n            if (! distinct.contains(Character.toLowerCase(c)))\n                distinct.add(Character.toLowerCase(c));\n        }\n        // Postconditions\n// 1. The result must be a non-negative integer (count of distinct characters)\n        assert distinct.size() >= 0 : \"Postcondition failed: Result must be a non-negative integer.\";\n\n// 2. If the input string is empty, the result must be 0\n        if (string.isEmpty()) {\n            assert distinct.size() == 0 : \"Postcondition failed: Result must be 0 for an empty string.\";\n        }\n\n// 3. The result must be equal to the number of unique case-insensitive characters in the string\n        HashSet<Character> uniqueChars = new HashSet<>();\n        for (char c : string.toCharArray()) {\n            uniqueChars.add(Character.toLowerCase(c));\n        }\n        assert distinct.size() == uniqueChars.size() : \"Postcondition failed: The result does not match the expected number of distinct characters.\";\n\n// 4. The result must remain consistent (use the size of the `distinct` set)\n        int expectedSize = distinct.size();\n        assert distinct.size() == expectedSize : \"Postcondition failed: The result is inconsistent across evaluations.\";\n\n        return distinct.size();\n    }\n}\n"}
{"file_name": "COMPARE.java", "content": "package humaneval.buggy;\n\n/* I think we all remember that feeling when the result of some long-awaited\nevent is finally known. The feelings and thoughts you have at that moment are\ndefinitely worth noting down and comparing.\nYour task is to determine if a person correctly guessed the results of a number of matches.\nYou are given two arrays of scores and guesses of equal length, where each index shows a match.\nReturn an array of the same length denoting how far off each guess was. If they have guessed correctly,\nthe value is 0, and if not, the value is the absolute difference between the guess and the score. */\n\npublic class COMPARE {\n    public static int[] compare(int[] game, int[] guess) {\n        assert game != null && guess != null : \"Precondition failed: game and guess arrays must not be null.\";\n        assert game.length > 0 : \"Precondition failed: Arrays must have at least one element.\";\n\n        int[] result = new int[game.length];\n\n        for (int i = 0; i < game.length; i += 1) {\n            result[i] = Math.abs(game[i] - guess[i]);\n        }\n        assert result.length == game.length : \"Postcondition failed: The result array length does not match the input arrays' length.\";\n        for (int i = 0; i < result.length; i++) {\n            assert result[i] >= 0 : \"Postcondition failed: The result contains negative values.\";\n        }\n        for (int i = 0; i < game.length; i++) {\n            if (game[i] != guess[i]) {\n                assert result[i] == Math.abs(game[i] - guess[i]) : \"Postcondition failed: The result does not reflect the correct difference.\";\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "CYCPATTERN_CHECK.java", "content": "package humaneval.buggy;\n\n// You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n// cycpattern_check(\"abcd\",\"abd\") => False\n// cycpattern_check(\"hello\",\"ell\") => True\n// cycpattern_check(\"whassup\",\"psus\") => False\n// cycpattern_check(\"abab\",\"baa\") => True\n// cycpattern_check(\"efef\",\"eeff\") => False\n// cycpattern_check(\"himenss\",\"simen\") => True\n\npublic class CYCPATTERN_CHECK {\n    public static boolean cycpattern_check(String a, String b) {\n        // Preconditions\n// 1. The input strings `a` and `b` must not be null\n        assert a != null && b != null : \"Precondition failed: Input strings 'a' and 'b' must not be null.\";\n\n// 2. The input strings `a` and `b` may be empty, which is allowed\n        assert a.length() >= 0 && b.length() >= 0 : \"Precondition failed: Input strings must be valid (even if empty).\";\n\n// 3. Ensure that the length of `b` is less than or equal to `a`\n        assert b.length() <= a.length() : \"Precondition failed: The length of 'b' must not exceed the length of 'a'.\";\n\n        int l = b.length();\n        String pat = b + b;\n        for (int i = 0; i < a.length() - l + 1; i += 1) {\n            for (int j = 0; j < l + 1; j += 1) {\n                if (a.substring(i, i + l).equals(pat.substring(j, j + l))) return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"file_name": "TRIPLES_SUM_TO_ZERO.java", "content": "package humaneval.buggy;\n\n/*\n * triples_sum_to_zero takes a list of integers as an input.\n * It returns True if there are three distinct elements in the list that\n * sum to zero, and False otherwise.\n *\n * >>> triples_sum_to_zero([1, 3, 5, 0]) => False\n * >>> triples_sum_to_zero([1, 3, -2, 1]) => True\n * >>> triples_sum_to_zero([1, 2, 3, 7]) => False\n * >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7]) => True\n * >>> triples_sum_to_zero([1]) => False\n */\n\npublic class TRIPLES_SUM_TO_ZERO {\n    public static boolean triples_sum_to_zero(int[] numbers) {\n        // Precondition 1: The input 'numbers' should not be null.\n        assert numbers != null : \"Precondition failed: Input 'numbers' must not be null.\";\n\n\n        for (int i = 0; i < numbers.length; i += 1) {\n            for (int j = i + 1; j < numbers.length; j += 1) {\n                for (int k = j + 1; k < numbers.length; k += 1) {\n                    if (numbers[i] + numbers[j] + numbers[k] == 0) {\n                        // Postcondition 1: If there is a triplet that sums to zero, the result should be true.\n                        assert numbers[i] + numbers[j] + numbers[k] == 0 :\n                                \"Postcondition failed: Found a triplet that sums to zero but returning false.\";\n                        return true;\n                    }\n                }\n            }\n        }\n\n        // Postcondition 2: If no such triplet exists, the result should be false.\n        assert true : \"Postcondition failed: No triplet found that sums to zero.\";\n        return false;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the function\n        assert !triples_sum_to_zero(new int[]{1, 3, 5, 0}) : \"Test case 1 failed\";\n        assert triples_sum_to_zero(new int[]{1, 3, -2, 1}) : \"Test case 2 failed\";\n        assert !triples_sum_to_zero(new int[]{1, 2, 3, 7}) : \"Test case 3 failed\";\n        assert triples_sum_to_zero(new int[]{2, 4, -5, 3, 9, 7}) : \"Test case 4 failed\";\n        assert !triples_sum_to_zero(new int[]{1}) : \"Test case 5 failed\";\n    }\n}\n"}
{"file_name": "EVEN_ODD_COUNT.java", "content": "package humaneval.buggy;\n\npublic class EVEN_ODD_COUNT {\n\n    public static int[] even_odd_count(int num) {\n        // Precondition 1: Ensure that 'num' is an integer.\n        // In Java, this is redundant because the method signature already enforces the input type to be int.\n\n        int even_count = 0;\n        int odd_count = 0;\n\n        for (char c : (Math.abs(num) + \"\").toCharArray()) {\n            int n = c - '0';\n            if (n % 2 == 0) even_count += 1;\n            if (n % 2 == 1) odd_count += 1;\n        }\n\n        // Postcondition 1: Ensure that the result is an array (since Java uses arrays instead of tuples).\n        assert (new int[] {even_count, odd_count}) instanceof int[] : \"The result must be an array.\";\n\n        // Postcondition 2: Ensure that the array contains two non-negative integers.\n        assert even_count >= 0 : \"The number of even digits must be a non-negative integer.\";\n        assert odd_count >= 0 : \"The number of odd digits must be a non-negative integer.\";\n\n        return new int[] {even_count, odd_count};\n    }\n}\n"}
{"file_name": "SOLUTION.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\n\npublic class SOLUTION {\n    public static int solution(ArrayList<Integer> lst) {\n        // Preconditions:\n\n        // Precondition 1: Ensure that 'lst' is not null.\n        assert lst != null : \"Input 'lst' must not be null.\";\n\n        // Precondition 2: Ensure that 'lst' is a non-empty list.\n        assert lst.size() > 0 : \"Input 'lst' must be a non-empty list.\";\n\n        // Precondition 3: Ensure that all elements in 'lst' are integers.\n        for (Integer num : lst) {\n            assert num != null : \"All elements in 'lst' must be integers.\";\n        }\n\n        int result = 0;\n\n        // Calculate the sum of all odd elements in even positions\n        for (int i = 0; i < lst.size(); i++) {\n            if ((i % 2) == 0 && (lst.get(i) % 2) == 1) {\n                result += lst.get(i);\n            }\n        }\n\n        // Postconditions:\n\n        // Postcondition 1: Ensure that the result is an integer.\n        assert Integer.class.isInstance(result) : \"The result must be an integer.\";\n\n        // Postcondition 2: Ensure that the result is non-negative.\n        assert result >= 0 : \"The result must be a non-negative integer.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the implementation\n        ArrayList<Integer> list1 = new ArrayList<>();\n        list1.add(5);\n        list1.add(8);\n        list1.add(7);\n        list1.add(1);\n        System.out.println(solution(list1)); // Output: 12\n\n        ArrayList<Integer> list2 = new ArrayList<>();\n        list2.add(3);\n        list2.add(3);\n        list2.add(3);\n        list2.add(3);\n        list2.add(3);\n        System.out.println(solution(list2)); // Output: 9\n\n        ArrayList<Integer> list3 = new ArrayList<>();\n        list3.add(30);\n        list3.add(13);\n        list3.add(24);\n        list3.add(321);\n        System.out.println(solution(list3)); // Output: 0\n    }\n}\n"}
{"file_name": "SORT_ARRAY_BINARY.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\n/*\n * In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n */\n\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\n/*\n * In this Kata, you have to sort an array of non-negative integers according to\n * number of ones in their binary representation in ascending order.\n * For similar number of ones, sort based on decimal value.\n *\n * It must be implemented like this:\n * >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n * >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n * >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n */\n\npublic class SORT_ARRAY_BINARY {\n\n   // Helper function to count the number of 1s in the binary representation of a number.\n   public static int number_ones(int n) {\n      if (n < 0) n *= -1; // Consider absolute value for negative numbers\n      int count = 0;\n      while (n > 0) {\n         count += n & 1; // Check the least significant bit\n         n >>= 1; // Shift right to check the next bit\n      }\n      return count;\n   }\n\n   // Function to sort the array based on the number of 1s in binary representation.\n   public static ArrayList<Integer> sort_array_binary(ArrayList<Integer> arr) {\n      // Precondition 1: Ensure that the input 'arr' is not null.\n      assert arr != null : \"Input 'arr' must not be null.\";\n\n      // Precondition 2: Ensure that all elements in the list are integers.\n      for (Integer num : arr) {\n         assert num != null : \"All elements in 'arr' must be integers.\";\n      }\n\n      // Sorting the array based on the number of 1s in binary representation.\n      Collections.sort(arr, new Comparator<Integer>() {\n         @Override\n         public int compare(Integer o1, Integer o2) {\n            int num_ones_o1 = number_ones(o1);\n            int num_ones_o2 = number_ones(o2);\n            if (num_ones_o1 == num_ones_o2) {\n               // If the number of 1s is the same, compare by value.\n               return Integer.compare(o1, o2);\n            }\n            return Integer.compare(num_ones_o1, num_ones_o2);\n         }\n      });\n\n      // Postcondition 1: Ensure that the result is a list of integers.\n      assert arr instanceof ArrayList : \"The result must be an ArrayList.\";\n      for (Integer num : arr) {\n         assert num instanceof Integer : \"All elements in the result must be integers.\";\n      }\n\n      // Postcondition 2: Ensure that the result is sorted based on the number of 1s in binary representation.\n      for (int i = 1; i < arr.size(); i++) {\n         assert number_ones(arr.get(i - 1)) <= number_ones(arr.get(i)) :\n                 \"The array is not correctly sorted based on the number of 1s in binary representation.\";\n      }\n\n      // Postcondition 3: Ensure that numbers with the same number of 1s are sorted in ascending order.\n      for (int i = 1; i < arr.size(); i++) {\n         if (number_ones(arr.get(i - 1)) == number_ones(arr.get(i))) {\n            assert arr.get(i - 1) <= arr.get(i) :\n                    \"Numbers with the same number of 1s are not in ascending order.\";\n         }\n      }\n\n      return arr;\n   }\n}\n"}
{"file_name": "SORTED_LIST_SUM.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/* Write a function that accepts a list of strings as a parameter,\ndeletes the strings that have odd lengths from it,\nand returns the resulted list with a sorted order,\nThe list is always a list of strings and never an array of numbers,\nand it may contain duplicates.\nThe order of the list should be ascending by length of each word, and you\nshould return the list sorted by that rule.\nIf two words have the same length, sort the list alphabetically.\nThe function should return a list of strings in sorted order.\nYou may assume that all words will have the same length.\nFor example:\nassert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\nassert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"] */\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class SORTED_LIST_SUM {\n\n    public static ArrayList<String> sorted_list_sum(ArrayList<String> lst) {\n        // Precondition 1: Ensure the input list 'lst' is not null.\n        if (lst == null) {\n            throw new IllegalArgumentException(\"Input 'lst' must not be null.\");\n        }\n\n        // Precondition 2: Ensure that all elements in 'lst' are strings.\n        for (Object obj : lst) {\n            if (!(obj instanceof String)) {\n                throw new IllegalArgumentException(\"All elements in 'lst' must be strings.\");\n            }\n        }\n\n        // Create a result list to store the filtered and sorted strings.\n        ArrayList<String> result = new ArrayList<>();\n\n        // Filter out strings with odd lengths.\n        for (String str : lst) {\n            if (str.length() % 2 == 0) {\n                result.add(str);\n            }\n        }\n\n        // Sort the result list by length and then alphabetically.\n        Collections.sort(\n                result,\n                (s1, s2) -> {\n                    if (s1.length() == s2.length()) {\n                        return s1.compareTo(s2);\n                    }\n                    return s1.length() - s2.length();\n                }\n        );\n\n        // Postcondition 1: Ensure the result is not null.\n        if (result == null) {\n            throw new AssertionError(\"The result must not be null.\");\n        }\n\n        // Postcondition 2: Ensure the result is a list of strings.\n        for (Object obj : result) {\n            if (!(obj instanceof String)) {\n                throw new AssertionError(\"All elements in the result must be strings.\");\n            }\n        }\n\n        // Postcondition 3: Ensure all elements in the result list have even lengths.\n        for (String str : result) {\n            if (str.length() % 2 != 0) {\n                throw new AssertionError(\"All elements in the result must have even lengths.\");\n            }\n        }\n\n        // Postcondition 4: Ensure the list is sorted by length and then alphabetically.\n        for (int i = 1; i < result.size(); i++) {\n            String prev = result.get(i - 1);\n            String curr = result.get(i);\n            if (prev.length() > curr.length() || (prev.length() == curr.length() && prev.compareTo(curr) > 0)) {\n                throw new AssertionError(\"The result list must be sorted by length and alphabetically for same length.\");\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "FIND_CLOSEST_ELEMENTS.java", "content": "package humaneval.buggy;\n\nimport java.util.Arrays;\n\npublic class FIND_CLOSEST_ELEMENTS {\n\n    public static double[] find_closest_elements(double[] numbers) {\n        // Precondition 1: Ensure that 'numbers' is not null.\n        assert numbers != null : \"Input 'numbers' must not be null.\";\n\n        // Precondition 2: Ensure that 'numbers' is a list of floats/doubles.\n        assert numbers instanceof double[] : \"Input 'numbers' must be an array of doubles.\";\n\n        // Precondition 3: Ensure that the input array 'numbers' has at least two elements.\n        assert numbers.length >= 2 : \"Input array 'numbers' must have at least two elements.\";\n\n        // Precondition 4: Ensure that the length of 'numbers' does not exceed a reasonable boundary.\n        int max_length = 1000000;  // Example boundary condition.\n        assert numbers.length <= max_length : \"Input array 'numbers' should not exceed \" + max_length + \" elements.\";\n\n        // Sort the array to find the closest elements efficiently.\n        Arrays.sort(numbers);\n\n        double[] result = new double[2];\n        double min_diff = Double.MAX_VALUE;\n\n        for (int i = 0; i < numbers.length - 1; i++) {\n            double diff = numbers[i + 1] - numbers[i];\n            if (diff < min_diff) {\n                min_diff = diff;\n                result[0] = numbers[i];\n                result[1] = numbers[i + 1];\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is an array of two doubles.\n        assert result.length == 2 : \"The result must be an array of two elements.\";\n\n        // Postcondition 2: Ensure that the first element in the result is less than or equal to the second element.\n        assert result[0] <= result[1] : \"The first element in the result should be less than or equal to the second element.\";\n\n        // Postcondition 3: Ensure that the result is the closest pair of numbers in the input list.\n        double closest_diff = Double.MAX_VALUE;\n        for (int i = 0; i < numbers.length - 1; i++) {\n            closest_diff = Math.min(closest_diff, numbers[i + 1] - numbers[i]);\n        }\n        assert result[1] - result[0] == closest_diff : \"The result should have the smallest difference between any two elements in the list.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "PARSE_MUSIC.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\n/*\n * Input to this function is a string representing musical notes in a special ASCII format.\n * Your task is to parse this string and return list of integers corresponding to how many beats does each\n * note last.\n *\n * Here is a legend:\n * 'o'  - whole note, lasts four beats\n * 'o|' - half note, lasts two beats\n * '.|' - quarter note, lasts one beat\n *\n * Examples:\n * >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n * [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n */\n\npublic class PARSE_MUSIC {\n    public static List<Integer> parse_music(String music_string) {\n        // Precondition 1: The input 'music_string' should not be null.\n        assert music_string != null : \"Input 'music_string' must not be null.\";\n\n        HashMap<String, Integer> note_map = new HashMap<String, Integer>();\n        note_map.put(\"o\", 4);\n        note_map.put(\"o|\", 2);\n        note_map.put(\".|\", 1);\n\n        List<Integer> result = new ArrayList<Integer>();\n\n        // Precondition 2: If 'music_string' is empty, return an empty list.\n        if (music_string.trim().equals(\"\")) {\n            assert result.isEmpty() : \"If input is empty, result should be an empty list.\";\n            return result;\n        }\n\n        // Split the music string by spaces and process each note.\n        for (String note : music_string.split(\" \")) {\n            // Precondition 3: Each note in the input should be a valid note defined in the legend.\n            assert note_map.containsKey(note) : \"Invalid note found in 'music_string'.\";\n            result.add(note_map.get(note));\n        }\n\n        // Postcondition 1: The result should be a list.\n        assert result instanceof List : \"The result must be a list.\";\n\n        // Postcondition 2: Each element in the result list should be an integer.\n        for (Integer beat : result) {\n            assert beat instanceof Integer : \"Each element in the result list must be an integer.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "MONOTONIC.java", "content": "package humaneval.buggy;\n\nimport java.util.Arrays;\n\npublic class MONOTONIC {\n\n    public static boolean monotonic(int[] l) {\n        // Precondition 1: The input array 'l' should not be null.\n        assert l != null : \"Input array 'l' must not be null.\";\n\n        // Precondition 2: All elements in the array 'l' should be integers.\n        // (This is inherently checked by Java's type system as 'l' is an int array).\n\n        // Precondition 3: The input list 'l' can be empty or have any length.\n\n        // Check if the list is monotonically increasing or decreasing\n        int[] sorted = Arrays.copyOf(l, l.length);\n        int[] reverse_sorted = Arrays.copyOf(l, l.length);\n\n        // Sorting arrays for comparison\n        Arrays.sort(sorted);\n        for (int i = 0; i < l.length; i += 1) {\n            reverse_sorted[i] = sorted[l.length - i - 1];\n        }\n\n        // Check for monotonicity\n        boolean result = Arrays.equals(l, sorted) || Arrays.equals(l, reverse_sorted);\n\n        // Postcondition 1: The result should be a boolean value.\n        assert result == true || result == false : \"The result must be a boolean value.\";\n\n        // Postcondition 2: The result should correctly reflect the monotonicity of the list.\n        boolean inc = true, dec = true;\n        for (int i = 0; i < l.length - 1; i++) {\n            if (l[i] > l[i + 1]) inc = false;\n            if (l[i] < l[i + 1]) dec = false;\n        }\n        if (result) {\n            assert inc || dec : \"The list must be either monotonically increasing or decreasing.\";\n        } else {\n            assert !(inc || dec) : \"The list must not be monotonically increasing or decreasing.\";\n        }\n\n        // Postcondition 3: The result should be true for an empty list (trivially monotonic).\n        if (l.length == 0) {\n            assert result == true : \"The result must be true for an empty list.\";\n        }\n\n        // Postcondition 4: The result should be true for a single-element list (trivially monotonic).\n        if (l.length == 1) {\n            assert result == true : \"The result must be true for a single-element list.\";\n        }\n\n        // Postcondition 5: If the list is strictly increasing, the result must be true.\n        boolean strictlyInc = true;\n        for (int i = 0; i < l.length - 1; i++) {\n            if (l[i] >= l[i + 1]) strictlyInc = false;\n        }\n        if (strictlyInc) {\n            assert result == true : \"The result must be true for a strictly increasing list.\";\n        }\n\n        // Postcondition 6: If the list is strictly decreasing, the result must be true.\n        boolean strictlyDec = true;\n        for (int i = 0; i < l.length - 1; i++) {\n            if (l[i] <= l[i + 1]) strictlyDec = false;\n        }\n        if (strictlyDec) {\n            assert result == true : \"The result must be true for a strictly decreasing list.\";\n        }\n\n        // Postcondition 7: If the list is not monotonic, the result must be false.\n        boolean notMonotonic = false;\n        for (int i = 0; i < l.length - 1; i++) {\n            if ((l[i] < l[i + 1] && !strictlyInc) || (l[i] > l[i + 1] && !strictlyDec)) {\n                notMonotonic = true;\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "ANTI_SHUFFLE.java", "content": "package humaneval.buggy;\n\nimport java.util.Arrays;\n\npublic class ANTI_SHUFFLE {\n\n    public static String anti_shuffle(String s) {\n        // Preconditions\n        assert s != null : \"Input string should not be null\";  // Precondition 1\n        assert s.length() >= 0 : \"Input string length should be non-negative\";  // Precondition 2\n        assert s.chars().allMatch(ch -> ch >= 0 && ch <= 127) : \"Input string should only contain ASCII characters\";  // Precondition 3\n        assert s.matches(\"[\\\\x20-\\\\x7E]*\") : \"Input string should only contain printable ASCII characters\";  // Precondition 4\n        assert !s.contains(\"\\t\") && !s.contains(\"\\n\") && !s.contains(\"\\r\") : \"Input string should not contain tab or newline characters\";  // Precondition 5\n\n        String result = \"\";\n        for (String str : s.split(\" \")) {\n            char[] chars = str.toCharArray();\n            Arrays.sort(chars);\n            result += new String(chars) + \" \";\n        }\n        result = result.substring(0, result.length() - 1);\n\n        // Postconditions\n        assert result != null : \"Result string should not be null\";  // Postcondition 1\n        assert result.length() == s.length() : \"Result string should have the same length as input string\";  // Postcondition 2\n        assert result.equals(s) || !result.equals(s) : \"Result string should differ from input if input is shuffled\";  // Postcondition 3\n        assert result.chars().allMatch(ch -> ch >= 0 && ch <= 127) : \"Result string should only contain ASCII characters\";  // Postcondition 4\n        assert result.matches(\"[\\\\x20-\\\\x7E]*\") : \"Result string should only contain printable ASCII characters\";  // Postcondition 5\n        assert s.split(\" \").length == result.split(\" \").length : \"Result string should have the same number of words as input string\";  // Postcondition 6\n        assert Arrays.equals(\n                s.replaceAll(\"[^ ]\", \"\").toCharArray(),\n                result.replaceAll(\"[^ ]\", \"\").toCharArray()\n        ) : \"Result string should maintain the same spaces as input string\";  // Postcondition 7\n\n        return result;\n    }\n}\n"}
{"file_name": "IS_PRIME.java", "content": "package humaneval.buggy;\n\npublic class IS_PRIME {\n\n    public static boolean is_prime(int n) {\n        // Precondition 1: The input 'n' should not be negative.\n        assert n >= 0 : \"Input 'n' must be a non-negative integer.\";\n\n        // Precondition 2: The input 'n' should be an integer.\n        // This precondition is inherently true in Java since 'n' is of type int.\n\n        if (n < 2) {\n            return false;\n        }\n\n        for (int k = 2; k <= Math.sqrt(n); k += 1) {\n            if (n % k == 0) {\n                return false;\n            }\n        }\n\n        boolean result = true;\n\n        // Postcondition 1: The result should be a boolean value.\n        assert result == true || result == false : \"The result must be a boolean value.\";\n\n        // Postcondition 2: If the result is true, 'n' should have no divisors other than 1 and 'n'.\n        if (result) {\n            for (int i = 2; i < n; i++) {\n                assert n % i != 0 : \"If the result is true, 'n' must have no divisors other than 1 and itself.\";\n            }\n        }\n\n        // Postcondition 3: If the result is false, 'n' should have at least one divisor other than 1 and 'n'.\n        if (!result) {\n            boolean hasDivisor = false;\n            for (int i = 2; i < n; i++) {\n                if (n % i == 0) {\n                    hasDivisor = true;\n                    break;\n                }\n            }\n            assert hasDivisor : \"If the result is false, 'n' must have at least one divisor other than 1 and itself.\";\n        }\n\n        // Postcondition 4: The result should be false for 'n' = 0 or 'n' = 1.\n        if (n == 0 || n == 1) {\n            assert result == false : \"The result must be false for 'n' = 0 or 'n' = 1.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "DERIVATIVE.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/* xs represent coefficients of a polynomial.\nxs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return derivative of this polynomial in the same form.\n>>> derivative([3, 1, 2, 4, 5])\n[1, 4, 12, 20]\n>>> derivative([1, 2, 3])\n[2, 6] */\n\npublic class DERIVATIVE {\n    public static List<Integer> derivative(List<Integer> xs) {\n        // Preconditions\n// 1. The input list `xs` must not be null\n        assert xs != null : \"Precondition failed: Input list 'xs' must not be null.\";\n\n// 3. All elements in `xs` must be integers\n        for (Integer coefficient : xs) {\n            assert coefficient != null : \"Precondition failed: All elements in the list must be integers.\";\n        }\n\n\n        List<Integer> result = new ArrayList<Integer>();\n        \n        for (int i = 1; i < xs.size(); i += 1)\n            result.add(i * xs.get(i));\n\n        // Postconditions\n// 1. The result must not be null\n        assert result != null : \"Postcondition failed: The result must not be null.\";\n\n// 2. The result must have one fewer element than the input list\n        assert result.size() == xs.size() - 1 : \"Postcondition failed: The result must have one fewer element than the input list.\";\n\n// 3. Each element of the result must be the correct derivative of the corresponding term\n        for (int i = 1; i < xs.size(); i++) {\n            assert result.get(i - 1) == i * xs.get(i) : \"Postcondition failed: The result is incorrect for the term at index \" + i;\n        }\n\n//// 4. The result must remain consistent across repeated evaluations\n//        List<Integer> repeatedResult = derivative(xs);\n//        assert result.equals(repeatedResult) : \"Postcondition failed: The result is inconsistent across repeated evaluations.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "CAN_ARRANGE.java", "content": "package humaneval.buggy;\n\n/*\n * Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists, return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n */\n\npublic class CAN_ARRANGE {\n    public static int can_arrange(int[] arr) {\n        // Precondition 1: The array should not be null\n        assert arr != null : \"Precondition failed: Input array must not be null.\";\n\n        // Precondition 3: The array should not contain duplicate elements (as per problem statement)\n        for (int i = 0; i < arr.length - 1; i++) {\n            assert arr[i] != arr[i + 1] : \"Precondition failed: Array contains duplicate elements.\";\n        }\n\n        // Precondition 4: The array should be an integer array\n        for (int num : arr) {\n            assert num == (int) num : \"Precondition failed: Array contains non-integer values.\";\n        }\n\n        // Precondition 5: The array size should not exceed 1000 (arbitrary upper limit for performance)\n        assert arr.length <= 1000 : \"Precondition failed: Array length exceeds 1000 elements.\";\n\n        int ind = -1;\n\n        // Traverse the array to find the largest index where arr[i] < arr[i - 1]\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] < arr[i - 1]) {\n                ind = i;\n            }\n        }\n\n        // Postcondition 1: The result should be -1 if the array is already sorted in ascending order\n        boolean isSorted = true;\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] < arr[i - 1]) {\n                isSorted = false;\n                break;\n            }\n        }\n        assert !isSorted || ind == -1 : \"Postcondition failed: Array is sorted but result is not -1.\";\n\n        // Postcondition 2: If the result is not -1, the element at that index should be less than the previous element\n        if (ind != -1) {\n            assert arr[ind] < arr[ind - 1] : \"Postcondition failed: The element at index \" + ind + \" is not less than the previous element.\";\n        }\n\n        // Postcondition 3: The index returned should be the largest such index where arr[i] < arr[i - 1]\n        if (ind != -1) {\n            for (int i = ind + 1; i < arr.length; i++) {\n                assert arr[i] >= arr[i - 1] : \"Postcondition failed: There is a larger index where arr[i] < arr[i - 1].\";\n            }\n        }\n\n        // Postcondition 4: If the array contains only two elements, ind should be 1 or -1\n        if (arr.length == 2) {\n            assert ind == 1 || ind == -1 : \"Postcondition failed: For a two-element array, the index should be 1 or -1.\";\n        }\n\n        // Postcondition 5: The result must be between -1 and arr.length - 1\n        assert ind >= -1 && ind < arr.length : \"Postcondition failed: Result index is out of valid bounds.\";\n\n        return ind;\n    }\n}\n"}
{"file_name": "VOWELS_COUNT.java", "content": "package humaneval.buggy;\n\n/* Write a function vowels_count which takes a string representing\na word as input and returns the number of vowels in the string.\nVowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\nvowel, but only when it is at the end of the given word.\n\nExample:\n>>> vowels_count(\"abcde\")\n2\n>>> vowels_count(\"ACEDY\")\n3\n*/\n\npublic class VOWELS_COUNT {\n\n    public static int vowels_count(String str) {\n        // Precondition 1: Ensure that the input 'str' is not null.\n        assert str != null : \"Precondition failed: Input 'str' must not be null.\";\n\n        // Precondition 2: Ensure that the input 'str' is not empty.\n        assert !str.isEmpty() : \"Precondition failed: Input 'str' must not be empty.\";\n\n        int result = 0;\n        char[] str_chars = str.toCharArray();\n\n        for (char c : str_chars) {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n                    c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                result += 1;\n            }\n        }\n\n        // Check if the last character is 'y' or 'Y' and if so, add to the count.\n        if (str_chars.length > 0 && (str_chars[str_chars.length - 1] == 'y' ||\n                str_chars[str_chars.length - 1] == 'Y')) {\n            result += 1;\n        }\n\n        // Postcondition 1: Ensure that the result is a non-negative integer.\n        assert result >= 0 : \"Postcondition failed: The result must be a non-negative integer.\";\n\n        // Postcondition 2: Ensure that the number of vowels counted is less than or equal to the length of the input string.\n        assert result <= str.length() : \"Postcondition failed: The number of vowels cannot exceed the length of the input string.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        assert vowels_count(\"abcde\") == 2 : \"Test case 1 failed\";\n        assert vowels_count(\"ACEDY\") == 3 : \"Test case 2 failed\";\n        assert vowels_count(\"y\") == 1 : \"Test case 3 failed\";\n        assert vowels_count(\"yyy\") == 1 : \"Test case 4 failed\";\n        assert vowels_count(\"bcdf\") == 0 : \"Test case 5 failed\";\n        assert vowels_count(\"aeiou\") == 5 : \"Test case 6 failed\";\n        assert vowels_count(\"AEIOU\") == 5 : \"Test case 7 failed\";\n    }\n}\n"}
{"file_name": "FIND_ZERO.java", "content": "package humaneval.buggy;\n\nimport java.util.List;\n\npublic class FIND_ZERO {\n\n    // Evaluate the polynomial with coefficients 'xs' at point 'x'.\n    public static double poly(List<Double> xs, double x) {\n        // Precondition 1: Ensure that 'xs' is not null.\n        assert xs != null : \"Input 'xs' must not be null.\";\n\n        // Precondition 2: Ensure that 'xs' is a list of numbers.\n        assert xs instanceof List : \"Input 'xs' must be a list of doubles.\";\n        for (Object coeff : xs) {\n            assert coeff instanceof Double : \"All elements in 'xs' must be doubles.\";\n        }\n\n        double sum = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            sum += xs.get(i) * Math.pow(x, i);\n        }\n\n        // Postcondition 1: Ensure that the result is a number.\n        assert sum == sum : \"The result must be a number.\";\n\n        return sum;\n    }\n\n    public static double find_zero(List<Double> xs) {\n        // Precondition 1: Ensure that 'xs' is not null.\n        assert xs != null : \"Input 'xs' must not be null.\";\n\n        // Precondition 2: Ensure that 'xs' is a list of doubles.\n        assert xs instanceof List : \"Input 'xs' must be a list of doubles.\";\n        for (Object coeff : xs) {\n            assert coeff instanceof Double : \"All elements in 'xs' must be doubles.\";\n        }\n\n        // Precondition 3: Ensure that the length of 'xs' is even.\n        assert xs.size() % 2 == 0 : \"The length of 'xs' must be even.\";\n\n        // Precondition 4: Ensure that the highest degree coefficient is non-zero.\n        assert xs.get(xs.size() - 1) != 0 : \"The highest degree coefficient must be non-zero.\";\n\n        double begin = -1.;\n        double end = 1.;\n\n        // Expand the interval to ensure a sign change between begin and end\n        while (poly(xs, begin) * poly(xs, end) > 0) {\n            begin *= 2.;\n            end *= 2.;\n        }\n\n        // Use binary search to find the zero of the polynomial\n        while (end - begin > 1e-10) {\n            double center = (begin + end) / 2.;\n\n            if (poly(xs, center) * poly(xs, begin) > 0) {\n                begin = center;\n            } else {\n                end = center;\n            }\n        }\n\n        double result = begin;\n\n        // Postcondition 1: Ensure that the result is a number.\n        assert result == result : \"The result must be a number.\";\n\n        // Postcondition 2: Ensure that the result satisfies poly(xs, result) = 0 within a specified tolerance.\n        double tol = 1e-5;\n        assert Math.abs(poly(xs, result)) < tol : \"The result does not satisfy poly(xs, result) = 0 within the specified tolerance.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "COUNT_UP_TO.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n// Implement a function that takes an non-negative integer and returns an array of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0) => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n// count_up_to(18) => [2,3,5,7,11,13,17]\n\npublic class COUNT_UP_TO {\n    public static List<Integer> count_up_to(int n) {\n        // Preconditions\n// 1. The input `n` must be a non-negative integer\n        assert n >= 0 : \"Precondition failed: Input 'n' must be a non-negative integer.\";\n\n        List<Integer> primes = new ArrayList<Integer>();\n\n        for (int i = 2; i < n; i += 1){\n            boolean is_prime = true;\n            for (int j = 2; j < i; j += 1){\n                if (i % j == 0) {\n                    is_prime = false;\n                    break;\n                }\n            }\n            if (is_prime) primes.add(i);\n        }\n        if (n < 2) {\n            assert primes.isEmpty() : \"Postcondition failed: The result must be an empty list if 'n' is less than 2.\";\n        }\n\n// 4. The result must be sorted in ascending order\n        for (int i = 1; i < primes.size(); i++) {\n            assert primes.get(i) > primes.get(i - 1) : \"Postcondition failed: The result list is not sorted in ascending order.\";\n        }\n        return primes;\n    }\n}\n"}
{"file_name": "SPECIAL_FACTORIAL.java", "content": "package humaneval.buggy;\n\npublic class SPECIAL_FACTORIAL {\n    public static long special_factorial(long n) {\n        // Precondition 1: Ensure that 'n' is a positive integer.\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input 'n' must be a positive integer.\");\n        }\n\n        // Initialize variables for factorial calculation and special factorial result.\n        long fact_i = 1;\n        long special_fact = 1;\n\n        // Calculate the special factorial using the defined formula.\n        for (int i = 1; i <= n; i++) {\n            fact_i *= i;\n            special_fact *= fact_i;\n        }\n\n        // Postcondition 1: Ensure that the result is a non-negative integer.\n        if (special_fact < 0) {\n            throw new AssertionError(\"The result must be a non-negative integer.\");\n        }\n\n        return special_fact;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the function\n        System.out.println(special_factorial(4));  // Expected output: 288\n        System.out.println(special_factorial(1));  // Expected output: 1\n        System.out.println(special_factorial(5));  // Expected output: 34560\n    }\n}\n"}
{"file_name": "ENCODE.java", "content": "package humaneval.buggy;\n\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n\n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n// 'tHKS KS C MGSSCGG'\n\npublic class ENCODE {\n    public static String encode(String message) {\n        // Preconditions\n// 1. The input string `message` must not be null\n        assert message != null : \"Precondition failed: Input string 'message' must not be null.\";\n\n// 2. The input string `message` must not be empty (although empty input may be allowed, validate this depending on requirements)\n        assert message.length() >= 0 : \"Precondition failed: Input string must be valid (even if empty).\";\n\n\n\n        StringBuilder sb = new StringBuilder();\n        for (char c : message.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                c = Character.toLowerCase(c);\n            } \n            else if (Character.isLowerCase(c)) {\n                c = Character.toUpperCase(c);\n            }\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O'\n                    || c == 'U') {\n                c = (char) ((int) c + 2);\n            }\n            sb.append(c);\n        }\n\n        return sb.toString();\n    }\n}\n"}
{"file_name": "ADD_ELEMENTS.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\n\n/*\n * Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n    Assume that the negative sign counts as a digit, e.g. -5 has two digits\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n */\n\npublic class ADD_ELEMENTS {\n\n    public static int add_elements(ArrayList<Integer> arr, int k) {\n        // Precondition 1: The array should not be empty\n        assert arr != null && !arr.isEmpty() : \"Precondition failed: The array must not be null or empty.\";\n\n        // Precondition 2: The array size should be between 1 and 100\n        assert arr.size() >= 1 && arr.size() <= 100 : \"Precondition failed: The array size must be between 1 and 100.\";\n\n        // Precondition 3: k must be within valid bounds (1 <= k <= arr.size())\n        assert k >= 1 && k <= arr.size() : \"Precondition failed: k must be between 1 and the size of the array.\";\n\n        // Precondition 4: Elements of the array must be integers\n        for (Integer element : arr) {\n            assert element != null : \"Precondition failed: Array contains null values.\";\n        }\n\n        // Precondition 5: The array should not contain elements with more than 10 digits\n        for (Integer element : arr) {\n            assert Integer.toString(element).length() <= 10 : \"Precondition failed: Elements in the array must have at most 10 digits.\";\n        }\n\n        int result = 0;\n\n        for (int i = 0; i < k; i++) {\n            // Check if the element has at most two digits\n            if (Integer.toString(Math.abs(arr.get(i))).length() <= 2) {\n                result += arr.get(i);\n            }\n        }\n\n        assert result == (int) result : \"Postcondition failed: Result is not an integer.\";\n\n\n        assert result <= arr.subList(0, k).stream().mapToInt(Integer::intValue).sum() : \"Postcondition failed: Result exceeds the sum of the first k elements.\";\n\n        if (arr.stream().allMatch(n -> n >= 0)) {\n            assert result >= 0 : \"Postcondition failed: Result should not be negative when all elements are positive.\";\n        }\n\n        long expectedSum = arr.subList(0, k).stream().filter(n -> Integer.toString(Math.abs(n)).length() <= 2).mapToInt(Integer::intValue).sum();\n        assert result == expectedSum : \"Postcondition failed: The result is not accurate for the selected elements.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "STRING_SEQUENCE.java", "content": "package humaneval.buggy;\n\npublic class STRING_SEQUENCE {\n\n    public static String string_sequence(int n) {\n        // Precondition 1: Ensure that 'n' is a non-negative integer.\n        if (n < 0) {\n            throw new IllegalArgumentException(\"Input 'n' must be a non-negative integer.\");\n        }\n\n        // Generate the sequence of numbers as a string\n        String result = \"\";\n        for (int i = 0; i <= n; i += 1) {\n            result += i + \" \";\n        }\n\n        result = result.trim();\n\n        // Postcondition 1: Ensure that the result is not null.\n        if (result == null) {\n            throw new AssertionError(\"The result must not be null.\");\n        }\n\n        // Postcondition 2: Ensure that the result is a single string of space-separated integers from 0 to n.\n        String[] parts = result.split(\" \");\n        for (int i = 0; i <= n; i++) {\n            if (!parts[i].equals(Integer.toString(i))) {\n                throw new AssertionError(\"The result must contain integers from 0 to n, separated by a single space.\");\n            }\n        }\n\n        // Postcondition 3: Ensure that the number of elements in the result matches n + 1.\n        if (parts.length != n + 1) {\n            throw new AssertionError(\"The number of elements in the result must be equal to n + 1.\");\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the function\n        System.out.println(string_sequence(5));  // Expected: \"0 1 2 3 4 5\"\n        System.out.println(string_sequence(0));  // Expected: \"0\"\n        System.out.println(string_sequence(10)); // Expected: \"0 1 2 3 4 5 6 7 8 9 10\"\n    }\n}\n"}
{"file_name": "MIN_SUBARRAY_SUM.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\n\npublic class MIN_SUBARRAY_SUM {\n\n    public static long min_subarray_sum(ArrayList<Long> nums) {\n        // Precondition 1: Ensure that the input list 'nums' is not null.\n        assert nums != null : \"Input 'nums' must not be null.\";\n\n        // Precondition 2: Ensure that the input list 'nums' is not empty.\n        assert nums.size() > 0 : \"Input 'nums' must be a non-empty list.\";\n\n        // Precondition 3: Ensure that all elements in the list 'nums' are integers (longs in this case).\n        assert nums.stream().allMatch(num -> num instanceof Long) : \"All elements in 'nums' must be of type Long.\";\n\n        long minSum = Long.MAX_VALUE; // The minimum subarray sum.\n        long currentSum = 0;          // The current sum of the subarray.\n\n        for (long num : nums) {\n            currentSum += num;\n            if (currentSum < minSum) {\n                minSum = currentSum;\n            }\n            if (currentSum > 0) {\n                currentSum = 0;\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is an integer (long in this case).\n        assert minSum == (long) minSum : \"The result must be a long integer.\";\n\n        // Postcondition 2: Ensure that the result is less than or equal to the sum of all elements in 'nums'.\n        long totalSum = nums.stream().mapToLong(Long::longValue).sum();\n        assert minSum <= totalSum : \"The result must be less than or equal to the sum of the entire array.\";\n\n        return minSum;\n    }\n}\n"}
{"file_name": "EXCHANGE.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\n\n/*\n * In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n */\n\npublic class EXCHANGE {\n\n    public static String exchange(ArrayList<Integer> lst1, ArrayList<Integer> lst2) {\n        // Precondition 1: Ensure that 'lst1' and 'lst2' are not null.\n        assert lst1 != null && lst2 != null : \"Input lists 'lst1' and 'lst2' must not be null.\";\n\n        // Precondition 2: Ensure that 'lst1' and 'lst2' are instances of ArrayList.\n        assert lst1 instanceof ArrayList && lst2 instanceof ArrayList : \"Inputs 'lst1' and 'lst2' must be instances of ArrayList.\";\n\n        // Precondition 3: Ensure that 'lst1' and 'lst2' are non-empty lists.\n        assert lst1.size() > 0 && lst2.size() > 0 : \"Input lists 'lst1' and 'lst2' must be non-empty.\";\n\n        // Precondition 4: Ensure that all elements in 'lst1' and 'lst2' are integers.\n        assert lst1.stream().allMatch(x -> x instanceof Integer) : \"All elements in 'lst1' must be integers.\";\n        assert lst2.stream().allMatch(x -> x instanceof Integer) : \"All elements in 'lst2' must be integers.\";\n\n        int odd = 0, even = 0;\n        for(int i : lst1) {\n            if((i % 2) == 1) odd++;\n        }\n        for(int i : lst2) {\n            if((i % 2) == 0) even++;\n        }\n\n        String result = (even >= odd) ? \"YES\" : \"NO\";\n\n        // Postcondition 1: Ensure that the result is a string.\n        assert result instanceof String : \"The result must be a string.\";\n\n        // Postcondition 2: Ensure that the result is either 'YES' or 'NO'.\n        assert result.equals(\"YES\") || result.equals(\"NO\") : \"The result must be either 'YES' or 'NO'.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "FIZZ_BUZZ.java", "content": "package humaneval.buggy;\n\npublic class FIZZ_BUZZ {\n    public static int fizz_buzz(int n) {\n        // Precondition 1: Ensure that 'n' is a positive integer greater than 0.\n        assert n > 0 : \"Input 'n' must be a positive integer greater than 0.\";\n\n        int result = 0;\n\n        // Loop through all integers less than n\n        for (int i = 0; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                // Convert the number to a string and count occurrences of '7'\n                String numberStr = Integer.toString(i);\n                for (int j = 0; j < numberStr.length(); j++) {\n                    if (numberStr.charAt(j) == '7') {\n                        result += 1;\n                    }\n                }\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is an integer.\n        assert result >= 0 : \"The result must be a non-negative integer.\";\n\n        // Postcondition 2: Ensure the result correctly counts the occurrences of '7'.\n        int expected_count = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                expected_count += (int) Integer.toString(i).chars().filter(c -> c == '7').count();\n            }\n        }\n        assert result == expected_count : \"The result should correctly count the occurrences of '7'.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "EAT.java", "content": "package humaneval.buggy;\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return an array of [ total number of eaten carrots after your meals,\n//                                 the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n\n// Example:\n// * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n\n// Variables:\n// @number : integer\n//     the number of carrots that you have eaten.\n// @need : integer\n//     the number of carrots that you need to eat.\n// @remaining : integer\n//     the number of remaining carrots thet exist in stock\n\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\n// Have fun :)\n\npublic class EAT {\n    public static int[] eat(int number, int need, int remaining) {\n        // Preconditions\n// 1. The number of eaten carrots `number` must be a non-negative integer within the range [0, 1000]\n        assert number >= 0 && number <= 1000 : \"Precondition failed: 'number' must be between 0 and 1000.\";\n\n// 2. The number of carrots needed `need` must be a non-negative integer within the range [0, 1000]\n        assert need >= 0 && need <= 1000 : \"Precondition failed: 'need' must be between 0 and 1000.\";\n\n// 3. The number of remaining carrots `remaining` must be a non-negative integer within the range [0, 1000]\n        assert remaining >= 0 && remaining <= 1000 : \"Precondition failed: 'remaining' must be between 0 and 1000.\";\n\n        if (need <= remaining) {\n            return new int[] {number + need,  remaining - need};\n        }\n        else {\n            return new int[] {number + remaining , 0};\n        }\n    }\n}\n"}
{"file_name": "X_OR_Y.java", "content": "package humaneval.buggy;\n\n/* A simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\n\nExamples:\nfor x_or_y(7, 34, 12) == 34\nfor x_or_y(15, 8, 5) == 5 */\n\npublic class X_OR_Y {\n    public static int x_or_y(int n, int x, int y) {\n\n        // Precondition 2: Ensure that 'n' is not zero because 0 is not a valid prime number.\n        assert n != 0 : \"Precondition failed: 'n' must not be zero.\";\n\n        // Prime number check\n        if (n == 1) {\n            // Postcondition 1: If 'n' is 1, it should return 'y' because 1 is not a prime number.\n            assert y == y : \"Postcondition failed: Should return 'y' because 1 is not a prime number.\";\n            return y;\n        }\n\n        for (int i = 2; i < n; i += 1) {\n            if (n % i == 0) {\n                // Postcondition 2: If 'n' is divisible by any 'i', it is not prime and should return 'y'.\n                assert y == y : \"Postcondition failed: Should return 'y' because 'n' is not a prime number.\";\n                return y;\n            }\n        }\n\n        // Postcondition 3: If 'n' is a prime number, it should return 'x'.\n        assert x == x : \"Postcondition failed: Should return 'x' because 'n' is a prime number.\";\n        return x;\n    }\n}\n"}
{"file_name": "PROD_SIGNS.java", "content": "package humaneval.buggy;\n\npublic class PROD_SIGNS {\n    public static int prod_signs(int[] arr) {\n        // Precondition 1: Ensure that the input array 'arr' is not null.\n        assert arr != null : \"Input 'arr' must not be null.\";\n\n        // Precondition 2: Ensure that the array 'arr' is not empty.\n        if (arr.length == 0) return -10;\n\n        // Initialize the product of signs and the sum of magnitudes\n        int prod = 1;\n        int sum = 0;\n\n        // Calculate the product of signs and sum of magnitudes\n        for (int num : arr) {\n            // If there's a zero in the array, the product will be zero\n            if (num == 0) {\n                prod = 0;\n            } else if (num < 0) {\n                prod *= -1; // Multiply by -1 for each negative number\n            }\n            sum += Math.abs(num); // Sum of magnitudes\n        }\n\n        // Calculate the final result\n        int result = prod * sum;\n\n        // Postcondition 1: Ensure that the result is an integer.\n        assert result == (prod * sum) : \"The result must be the product of sign and sum of magnitudes.\";\n\n        // Postcondition 2: If the input array contains a zero, the result should be zero.\n        if (prod == 0) {\n            assert result == 0 : \"If the input array contains a zero, the result must be zero.\";\n        }\n\n        // Postcondition 3: If the array is empty, the result should be -10.\n        assert !(arr.length == 0) : \"If the input array is empty, the result must be -10.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "REMOVE_DUPLICATES.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class REMOVE_DUPLICATES {\n\n    public static List<Integer> remove_duplicates(List<Integer> numbers) {\n        // Precondition 1: The input 'numbers' should not be null.\n        assert numbers != null : \"Input 'numbers' must not be null.\";\n\n        // Precondition 2: The input 'numbers' should be a list of integers.\n        for (Object num : numbers) {\n            assert num instanceof Integer : \"All elements in 'numbers' must be integers.\";\n        }\n\n        // Using a HashMap to count occurrences of each number\n        HashMap<Integer, Integer> count = new HashMap<Integer, Integer>();\n        for (Integer n : numbers) {\n            count.put(n, count.getOrDefault(n, 0) + 1);\n        }\n\n        // Creating the result list with elements that appear exactly once\n        List<Integer> result = new ArrayList<Integer>();\n        for (Integer n : numbers) {\n            if (count.get(n) == 1) {\n                result.add(n);\n            }\n        }\n\n        // Postcondition 1: The result should be a list of integers.\n        assert result instanceof List : \"The result must be a list.\";\n        for (Object num : result) {\n            assert num instanceof Integer : \"All elements in the result must be integers.\";\n        }\n\n        // Postcondition 2: The result should contain only elements that appear exactly once in the input list.\n        for (Integer num : result) {\n            assert count.get(num) == 1 : \"All elements in the result should appear exactly once in the input list.\";\n        }\n\n\n\n        // Postcondition 4: If all elements in the input list occur more than once, the result should be an empty list.\n        boolean allDuplicates = true;\n        for (Integer n : numbers) {\n            if (count.get(n) == 1) {\n                allDuplicates = false;\n                break;\n            }\n        }\n        if (allDuplicates) {\n            assert result.isEmpty() : \"If all elements in the input list occur more than once, the result should be an empty list.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "ANY_INT.java", "content": "package humaneval.buggy;\n\npublic class ANY_INT {\n    public static boolean any_int(double x, double y, double z) {\n        // Preconditions\n        // Precondition 1: Ensure that all three numbers are double values.\n        assert x == (double) x : \"Precondition failed: 'x' must be a double.\";\n        assert y == (double) y : \"Precondition failed: 'y' must be a double.\";\n        assert z == (double) z : \"Precondition failed: 'z' must be a double.\";\n\n        // Check if all numbers can be converted to integers without losing precision\n        boolean areIntegers = ((int) x == x) && ((int) y == y) && ((int) z == z);\n\n        // Postcondition 1: All inputs should be representable as integers for the result to be true.\n        assert !areIntegers || ((int) x == x && (int) y == y && (int) z == z) : \"Postcondition failed: All inputs must be representable as integers.\";\n\n        // Check if one number equals the sum of the other two\n        boolean result = (x + y == z) || (x + z == y) || (y + z == x);\n\n        // Postcondition 2: If any number equals the sum of the other two, the result must be true.\n        if (areIntegers && result) {\n            assert (x + y == z || x + z == y || y + z == x) : \"Postcondition failed: One number must equal the sum of the other two.\";\n        }\n\n\n\n        return areIntegers && result;\n    }\n\n}\n"}
{"file_name": "FIBFIB.java", "content": "package humaneval.buggy;\n\npublic class FIBFIB {\n\n    public static int fibfib(int n) {\n        // Precondition 1: Ensure that 'n' is a non-negative integer.\n        assert n >= 0 : \"Input 'n' must be a non-negative integer.\";\n\n        // Base cases\n        if (n == 0) return 0;\n        if (n == 1) return 0;\n        if (n == 2) return 1;\n\n        // Efficient calculation using iteration instead of recursion\n        int a = 0, b = 0, c = 1;\n        for (int i = 3; i <= n; i++) {\n            int next = a + b + c;\n            a = b;\n            b = c;\n            c = next;\n        }\n\n        int result = c;\n\n        // Postcondition 1: Ensure that the result is an integer.\n        assert result >= 0 : \"The result must be a non-negative integer.\";\n\n        // Postcondition 2: Check base cases.\n        if (n == 0 || n == 1) {\n            assert result == 0 : \"For n=\" + n + \", the result should be 0.\";\n        } else if (n == 2) {\n            assert result == 1 : \"For n=2, the result should be 1.\";\n        }\n\n        // Postcondition 3: Correctness check for larger n.\n        // Ensure result satisfies the recurrence relation fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n        if (n > 2) {\n            int checkResult = fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n            assert result == checkResult : \"The result must satisfy the fibfib recurrence relation for n=\" + n + \".\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "MEDIAN.java", "content": "package humaneval.buggy;\n\nimport java.util.Arrays;\n\npublic class MEDIAN {\n\n    public static double median(int[] list) {\n        // Precondition 1: Ensure that the input list is not null.\n        assert list != null : \"Input list must not be null.\";\n\n        // Precondition 2: Ensure that the input list is not empty.\n        assert list.length > 0 : \"Input list must not be empty.\";\n\n        // Precondition 3: Ensure that all elements in the list are integers (as it's a list of int).\n        // This precondition is implicit due to the type of the array being int[].\n\n        // Sorting the list to find the median\n        Arrays.sort(list);\n\n        // Calculating the median\n        double result;\n        if (list.length % 2 == 1) {\n            // If the length of the list is odd, return the middle element\n            result = list[list.length / 2];\n        } else {\n            // If the length of the list is even, return the average of the two middle elements\n            result = (list[list.length / 2] + list[list.length / 2 - 1]) / 2.0;\n        }\n\n        // Postcondition 1: Ensure that the result is either an integer or a float.\n        // This is implied by the return type of the function, which is double.\n        assert result == (int) result || result == (double) result : \"The result must be an integer or a float.\";\n\n        // Postcondition 2: Ensure that the result is the correct median value.\n        double expectedMedian;\n        if (list.length % 2 == 1) {\n            // For odd-length list, the median is the middle element.\n            expectedMedian = list[list.length / 2];\n            assert result == expectedMedian : \"The result must be the correct median for an odd-length list.\";\n        } else {\n            // For even-length list, the median is the average of the two middle elements.\n            expectedMedian = (list[list.length / 2] + list[list.length / 2 - 1]) / 2.0;\n            assert result == expectedMedian : \"The result must be the correct median for an even-length list.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "IS_NESTED.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/*\n * Create a function that takes a string as input which contains only square brackets.\n * The function should return true if and only if there is a valid subsequence of brackets\n * where at least one bracket in the subsequence is nested.\n *\n * is_nested('[[]]') ➞ true\n * is_nested('[]]]]]]][[[[[]') ➞ false\n * is_nested('[][]') ➞ false\n * is_nested('[]') ➞ false\n * is_nested('[[][]]') ➞ true\n * is_nested('[[]][[') ➞ true\n */\n\npublic class IS_NESTED {\n\n    public static boolean is_nested(String brackets) {\n        // Precondition 1: Ensure that 'brackets' is not null\n        assert brackets != null : \"Input 'brackets' must not be null.\";\n\n        // Precondition 2: Ensure that 'brackets' is a string\n        assert brackets instanceof String : \"Input 'brackets' must be a string.\";\n\n        // Precondition 3: Ensure that 'brackets' contains only square brackets\n        for (char ch : brackets.toCharArray()) {\n            assert ch == '[' || ch == ']' : \"Input 'brackets' must contain only square brackets.\";\n        }\n\n        ArrayList<Integer> opening_brackets = new ArrayList<>();\n        ArrayList<Integer> closing_brackets = new ArrayList<>();\n\n        // Collect positions of opening and closing brackets\n        for (int i = 0; i < brackets.length(); i++) {\n            if (brackets.charAt(i) == '[')\n                opening_brackets.add(i);\n            else\n                closing_brackets.add(i);\n        }\n\n        Collections.reverse(closing_brackets);\n        int cnt = 0, i = 0, l = closing_brackets.size();\n\n        for (int idx : opening_brackets) {\n            if (i < l && idx < closing_brackets.get(i)) {\n                i++;\n                cnt++;\n            }\n        }\n\n        boolean result = cnt >= 2;\n\n        // Postcondition 1: Ensure that the result is a boolean\n        assert result == true || result == false : \"The result must be a boolean.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "INT_TO_MINI_ROMAN.java", "content": "package humaneval.buggy;\n\npublic class INT_TO_MINI_ROMAN {\n\n    public static String int_to_mini_roman(int number) {\n        // Precondition 1: Ensure that 'number' is an integer.\n        assert number == (int) number : \"Input 'number' must be an integer.\";\n\n        // Precondition 2: Ensure that 'number' is within the valid range (1 <= number <= 1000).\n        assert 1 <= number && number <= 1000 : \"Input 'number' must be between 1 and 1000, inclusive.\";\n\n        int[] num = new int[]{1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\n        String[] sym = new String[]{\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"};\n\n        int i = 12;\n        StringBuilder result = new StringBuilder();\n        while (number > 0) {\n            int div = number / num[i];\n            while (div > 0) {\n                result.append(sym[i]);\n                div--;\n            }\n            number %= num[i];\n            i--;\n        }\n\n        String finalResult = result.toString().toLowerCase();\n\n        // Postcondition 1: Ensure that the result is a string.\n        assert finalResult instanceof String : \"The result must be a string.\";\n\n        // Postcondition 2: Ensure that the result is in lowercase.\n        assert finalResult.equals(finalResult.toLowerCase()) : \"The result must be in lowercase.\";\n\n        return finalResult;\n    }\n}\n"}
{"file_name": "REMOVE_VOWELS.java", "content": "package humaneval.buggy;\n\npublic class REMOVE_VOWELS {\n\n    public static String remove_vowels(String string) {\n        // Precondition 1: The input string 'string' should not be null.\n        assert string != null : \"Input 'string' must not be null.\";\n\n        // Precondition 2: The input 'string' should be of type String.\n        assert string instanceof String : \"Input 'string' must be a string.\";\n\n        StringBuilder sb = new StringBuilder();\n        for (char c : string.toCharArray()) {\n            char c_lower = Character.toLowerCase(c);\n            if (c_lower == 'a' || c_lower == 'e' || c_lower == 'i' || c_lower == 'o' || c_lower == 'u') {\n                continue;\n            }\n            sb.append(c);\n        }\n\n        String result = sb.toString();\n\n        // Postcondition 1: The result should be a string.\n        assert result instanceof String : \"The result must be a string.\";\n\n        // Postcondition 2: The result should not contain any vowels.\n        String vowels = \"aeiouAEIOU\";\n        for (char ch : result.toCharArray()) {\n            assert vowels.indexOf(ch) == -1 : \"The result should not contain any vowels.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "GET_MAX_TRIPLES.java", "content": "package humaneval.buggy;\n\npublic class GET_MAX_TRIPLES {\n\n    public static int get_max_triples(int n) {\n        // Precondition 1: Ensure that 'n' is a positive integer.\n        assert n > 0 : \"Input 'n' must be a positive integer.\";\n\n        // Handle cases where n is too small to form any triples\n        if (n <= 2) {\n            return 0;\n        }\n\n        // Create the array A where A[i] = i * i - i + 1\n        int[] A = new int[n];\n        for (int i = 1; i <= n; i++) {\n            A[i - 1] = i * i - i + 1;\n        }\n\n        int result = 0;\n\n        // Find triples (A[i], A[j], A[k]) where i < j < k and (A[i] + A[j] + A[k]) % 3 == 0\n        for (int i = 0; i < n - 2; i++) {\n            for (int j = i + 1; j < n - 1; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    if ((A[i] + A[j] + A[k]) % 3 == 0) {\n                        result += 1;\n                    }\n                }\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is a non-negative integer.\n        assert result >= 0 : \"The result must be a non-negative integer.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "ISCUBE.java", "content": "package humaneval.buggy;\n\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\n\n// Write a function that takes an integer a and returns true\n// if this integer is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// iscube(1) ==> true\n// iscube(2) ==> false\n// iscube(-1) ==> true\n// iscube(64) ==> true\n// iscube(0) ==> true\n// iscube(180) ==> false\n\npublic class ISCUBE {\n    public static boolean iscude(int a) {\n        // Precondition 1: The input 'a' should be an integer.\n        assert a == (int) a : \"Input 'a' must be an integer.\";\n\n        // Compute the absolute value of 'a'.\n        int a_abs = Math.abs(a);\n\n        // Calculate the cube root of the absolute value of 'a'.\n        double root = Math.pow(a_abs, 1.0 / 3.0);\n\n        // Round the cube root to the nearest integer.\n        BigDecimal bd = BigDecimal.valueOf(root);\n        int round_root = (int) bd.setScale(0, RoundingMode.HALF_UP).doubleValue();\n\n        // Check if the rounded cube root, when cubed, equals the absolute value of 'a'.\n        boolean result = ((int) Math.pow(round_root, 3)) == a_abs;\n\n        // Postcondition 1: The result should be a boolean value.\n        assert (result == true || result == false) : \"The result must be a boolean value.\";\n\n        // Postcondition 2: If the result is true, 'a' should be a perfect cube.\n        if (result) {\n            assert (int) Math.pow(round_root, 3) == a_abs : \"'a' should be a perfect cube if the result is true.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "SOLVE_STRING.java", "content": "package humaneval.buggy;\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\npublic class SOLVE_STRING {\n    public static String solve_string(String s) {\n        // Preconditions\n        // Precondition 1: Ensure that the input 's' is not null.\n        assert s != null : \"Input string 's' must not be null.\";\n\n        // Precondition 2: Ensure that the input 's' is a valid string (not empty).\n        assert !s.isEmpty() : \"Input string 's' must not be empty.\";\n\n        // Initialize a flag to check if the string contains any alphabetic characters\n        int flg = 0;\n\n        // StringBuilder to build the result string\n        StringBuilder sb = new StringBuilder();\n\n        // Iterate through each character in the input string\n        for (char c : s.toCharArray()) {\n            if (Character.isAlphabetic(c)) {\n                // If the character is alphabetic, swap its case\n                if (Character.isLowerCase(c)) {\n                    sb.append(Character.toUpperCase(c));\n                } else {\n                    sb.append(Character.toLowerCase(c));\n                }\n                flg = 1; // Set flag to indicate the presence of alphabetic characters\n            } else {\n                // If the character is not alphabetic, append it as is\n                sb.append(c);\n            }\n        }\n\n        // If no alphabetic characters were found, reverse the input string\n        if (flg == 0) {\n            sb = new StringBuilder();\n            for (int i = s.length() - 1; i >= 0; i -= 1) {\n                sb.append(s.charAt(i));\n            }\n        }\n\n        // Convert StringBuilder to string for result\n        String result = sb.toString();\n\n        // Postconditions\n        // Postcondition 1: Ensure that the result is a string.\n        assert result instanceof String : \"The result must be a string.\";\n\n        // Postcondition 2: If the original string 's' contains alphabetic characters,\n        // ensure that all alphabetic characters have their case swapped in the result.\n        if (s.chars().anyMatch(Character::isAlphabetic)) {\n            for (int i = 0; i < s.length(); i++) {\n                char originalChar = s.charAt(i);\n                char resultChar = result.charAt(i);\n\n            }\n        }\n\n        // Postcondition 3: If the original string 's' contains no alphabetic characters,\n        // ensure that the result is the reversed string.\n        if (s.chars().noneMatch(Character::isAlphabetic)) {\n            assert result.equals(new StringBuilder(s).reverse().toString()) :\n                    \"If the input string contains no alphabetic characters, it should be reversed in the result.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the implementation\n        System.out.println(solve_string(\"1234\"));    // Output: \"4321\"\n        System.out.println(solve_string(\"ab\"));      // Output: \"AB\"\n        System.out.println(solve_string(\"#a@C\"));    // Output: \"#A@c\"\n    }\n}\n"}
{"file_name": "SUM_SQUARED_NUMS.java", "content": "package humaneval.buggy;\n\n/*\n * You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output should be 29\n    For lst = [-2.4,1,1] the output should be 6\n */\n\npublic class SUM_SQUARED_NUMS {\n    public static long sum_squared_nums(double[] lst) {\n        // Precondition 1: Ensure that the input 'lst' is not null.\n        assert lst != null : \"Precondition failed: Input 'lst' must not be null.\";\n\n        // Precondition 2: Ensure that the input 'lst' is not empty.\n        assert lst.length > 0 : \"Precondition failed: Input 'lst' must not be empty.\";\n\n        // Precondition 3: Ensure that all elements in 'lst' are finite numbers (not NaN or Infinity).\n        for (double num : lst) {\n            assert !Double.isNaN(num) && !Double.isInfinite(num) : \"Precondition failed: All elements in 'lst' must be finite numbers.\";\n        }\n\n        int result = 0;\n\n        for (int i = 0; i < lst.length; i++) {\n            // Postcondition 1: Ensure that the ceiling value is greater than or equal to the original value.\n            assert Math.ceil(lst[i]) >= lst[i] : \"Postcondition failed: Ceil value should be greater than or equal to the original value.\";\n\n            double ceilValue = Math.ceil(lst[i]);\n\n            // Postcondition 2: Ensure that the ceiling value is an integer.\n            assert ceilValue == (int) ceilValue : \"Postcondition failed: Ceil value must be an integer.\";\n\n            result += ceilValue * ceilValue;\n        }\n\n        // Postcondition 3: Ensure that the result is a non-negative integer.\n        assert result >= 0 : \"Postcondition failed: The result must be a non-negative integer.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the function\n        System.out.println(sum_squared_nums(new double[]{1, 2, 3})); // Expected output: 14\n        System.out.println(sum_squared_nums(new double[]{1, 4, 9})); // Expected output: 98\n        System.out.println(sum_squared_nums(new double[]{1, 3, 5, 7})); // Expected output: 84\n        System.out.println(sum_squared_nums(new double[]{1.4, 4.2, 0})); // Expected output: 29\n        System.out.println(sum_squared_nums(new double[]{-2.4, 1, 1})); // Expected output: 6\n    }\n}\n"}
{"file_name": "DECIMAL_TO_BINARY.java", "content": "package humaneval.buggy;\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\n\npublic class DECIMAL_TO_BINARY {\n    public static String decimal_to_binary(int decimal) {\n        // Preconditions\n// 1. The input `decimal` must be a non-negative integer\n        assert decimal >= 0 : \"Precondition failed: Input 'decimal' must be a non-negative integer.\";\n\n        String result = Integer.toBinaryString(decimal);\n\n        assert result != null : \"Postcondition failed: The result must not be null.\";\n\n\n        return \"db\" + result + \"db\";\n    }\n}\n"}
{"file_name": "UNIQUE.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class UNIQUE {\n\n    public static List<Integer> unique(List<Integer> l) {\n        // Precondition 1: Ensure the input list 'l' is not null.\n        assert l != null : \"Precondition failed: Input list 'l' must not be null.\";\n\n        // Precondition 2: Ensure all elements in the list 'l' are not null.\n        assert !l.contains(null) : \"Precondition failed: Input list 'l' must not contain null elements.\";\n\n        List<Integer> result = new ArrayList<>();\n\n        // Adding unique elements to the result list\n        for (Integer n : l) {\n            if (result.contains(n)) {\n                continue;\n            }\n            result.add(n);\n        }\n\n        // Sorting the result list\n        Collections.sort(result);\n\n        // Postcondition 1: Ensure the result is not null.\n        assert result != null : \"Postcondition failed: Result list must not be null.\";\n\n        // Postcondition 2: Ensure the result list has no duplicates.\n        for (int i = 1; i < result.size(); i++) {\n            assert !result.get(i).equals(result.get(i - 1)) : \"Postcondition failed: Result list must not contain duplicates.\";\n        }\n\n        // Postcondition 3: Ensure the result list is sorted.\n        for (int i = 1; i < result.size(); i++) {\n            assert result.get(i) >= result.get(i - 1) : \"Postcondition failed: Result list must be sorted in ascending order.\";\n        }\n\n        // Postcondition 4: Ensure all elements in the result list are in the input list.\n        for (Integer n : result) {\n            assert l.contains(n) : \"Postcondition failed: All elements in the result list must be present in the input list.\";\n        }\n\n        return result;\n    }\n\n}\n"}
{"file_name": "NUMERICAL_LETTER_GRADE.java", "content": "package humaneval.buggy;\n\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a list of GPAs for some students and you have to write \n// a function that can output a list of letter grades using the following table:\n//             GPA       |    Letter grade\n//             4.0                A+\n//           > 3.7                A \n//           > 3.3                A- \n//           > 3.0                B+\n//           > 2.7                B \n//           > 2.3                B-\n//           > 2.0                C+\n//           > 1.7                C\n//           > 1.3                C-\n//           > 1.0                D+ \n//           > 0.7                D \n//           > 0.0                D-\n//             0.0                E\n// Example:\n// grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n\npublic class NUMERICAL_LETTER_GRADE {\n    public static String[] numerical_letter_grade(double[] grades) {\n        String[] letter_grade = new String[grades.length];\n\n        for (int i = 0; i < grades.length; i += 1) {\n            double gpa = grades[i];\n            if (gpa == 4.0)\n                letter_grade[i] = \"A+\";\n            else if (gpa > 3.7)\n                letter_grade[i] = \"A\";\n            else if (gpa > 3.3)\n                letter_grade[i] = \"A-\";\n            else if (gpa > 3.0)\n                letter_grade[i] = \"B+\";\n            else if (gpa > 2.7)\n                letter_grade[i] = \"B\";\n            else if (gpa > 2.3)\n                letter_grade[i] = \"B-\";\n            else if (gpa > 2.0)\n                letter_grade[i] = \"C+\";\n            else if (gpa > 1.7)\n                letter_grade[i] = \"C\";\n            else if (gpa > 1.3)\n                letter_grade[i] = \"C-\";\n            else if (gpa > 1.0)\n                letter_grade[i] = \"D+\";\n            else if (gpa > 0.7)\n                letter_grade[i] = \"D\";\n            else if (gpa > 0.0)\n                letter_grade[i] = \"D-\";\n            else\n                letter_grade[i] = \"E\";\n        }\n        return letter_grade;\n    }\n}\n"}
{"file_name": "COUNT_UPPER.java", "content": "package humaneval.buggy;\n\n// Given a string s, count the number of uppercase vowels in even indices.\n\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\n\npublic class COUNT_UPPER {\n    public static int count_upper(String s) {\n        // Preconditions\n// 1. The input string `s` must not be null\n        assert s != null : \"Precondition failed: Input string 's' must not be null.\";\n\n// 2. The input string `s` may be empty, which is allowed\n        assert s.length() >= 0 : \"Precondition failed: Input string must be a valid string (even if empty).\";\n\n        int count = 0;\n        for (int i = 0; i < s.length(); i += 2) {\n            char c = s.charAt(i);\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\n                count += 1;\n        }\n        return count;\n    }\n}\n"}
{"file_name": "COMPARE_ONE.java", "content": "package humaneval.buggy;\n\n/*\n * Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_one(1, 2.5) ➞ 2.5\n    compare_one(1, \"2,3\") ➞ \"2,3\"\n    compare_one(\"5,1\", \"6\") ➞ \"6\"\n    compare_one(\"1\", 1) ➞ None\n\n */\n\npublic class COMPARE_ONE {\n    public static Object compare_one(Object a, Object b) {\n        // Preconditions\n// 1. a and b must be either integers, doubles, or strings representing real numbers\n        assert (a instanceof String || a instanceof Integer || a instanceof Double)\n                : \"Precondition failed: 'a' must be an integer, double, or string representing a real number.\";\n        assert (b instanceof String || b instanceof Integer || b instanceof Double)\n                : \"Precondition failed: 'b' must be an integer, double, or string representing a real number.\";\n\n// 2. If a or b are strings, they must represent valid real numbers\n        try {\n            if (a instanceof String) {\n                String temp_a_string = a.toString().replace(',', '.');\n                Double.parseDouble(temp_a_string);\n            }\n            if (b instanceof String) {\n                String temp_b_string = b.toString().replace(',', '.');\n                Double.parseDouble(temp_b_string);\n            }\n        } catch (NumberFormatException e) {\n            assert false : \"Precondition failed: Strings must represent valid real numbers.\";\n        }\n\n        double temp_a = 0, temp_b = 0;\n        if(a instanceof String) {\n            String temp_a_string = a.toString();\n            temp_a_string = temp_a_string.replace(',', '.');\n            temp_a = Double.parseDouble(temp_a_string);\n        }\n        if(b instanceof String) {\n            String temp_b_string = b.toString();\n            temp_b_string = temp_b_string.replace(',', '.');\n            temp_b = Double.parseDouble(temp_b_string);\n        }\n        if(a instanceof Double) temp_a = (Double) a;\n        if(b instanceof Double) temp_b = (Double) b;\n        if(a instanceof Integer) temp_a = ((Integer) a).doubleValue();\n        if(b instanceof Integer) temp_b = ((Integer) b).doubleValue();\n        if(temp_a == temp_b) return null;\n        if(temp_a > temp_b) return a;\n\n\n        else return b;\n    }\n}\n"}
{"file_name": "SORT_EVEN.java", "content": "package humaneval.buggy;\n\nimport java.util.Arrays;\n\npublic class SORT_EVEN {\n\n    public static int[] sort_even(int[] l) {\n        // Precondition 1: Ensure that the input 'l' is not null.\n        if (l == null) {\n            throw new IllegalArgumentException(\"Input array 'l' must not be null.\");\n        }\n\n        // Precondition 2: Ensure that the input 'l' is a non-empty array.\n        if (l.length == 0) {\n            return new int[]{}; // Return an empty array for empty input.\n        }\n\n        // Precondition 3: Ensure that all elements in the list 'l' are integers.\n\n\n        // Create a new array for the result to maintain original order for odd indices.\n        int[] result = new int[l.length];\n\n        // Extract even index elements from 'l' into a separate array.\n        int[] evens = new int[(int) Math.ceil(l.length / 2.0)];\n        for (int i = 0; i < l.length; i += 2) {\n            evens[i / 2] = l[i];\n        }\n\n        // Sort the even index elements.\n        Arrays.sort(evens);\n\n        // Rebuild the result array using sorted evens at even indices and original values at odd indices.\n        for (int i = 0; i < l.length; i += 1) {\n            if (i % 2 == 0) {\n                result[i] = evens[i / 2];\n            } else {\n                result[i] = l[i];\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is not null.\n        assert result != null : \"The result array must not be null.\";\n\n        // Postcondition 2: Ensure that the result array has the same length as the input array.\n        assert result.length == l.length : \"The result array must have the same length as the input array.\";\n\n        // Postcondition 3: Ensure that elements at even indices in the result array are sorted.\n        for (int i = 0; i < evens.length - 1; i++) {\n            assert evens[i] <= evens[i + 1] : \"Elements at even indices should be sorted in the result array.\";\n        }\n\n        // Postcondition 4: Ensure that elements at odd indices in the result array match the original array.\n        for (int i = 1; i < l.length; i += 2) {\n            assert result[i] == l[i] : \"Elements at odd indices should remain unchanged.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "INCR_LIST.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class INCR_LIST {\n\n    public static List<Integer> incr_list(List<Integer> l) {\n        // Precondition 1: Ensure that the input list 'l' is not null.\n        assert l != null : \"Input list 'l' must not be null.\";\n\n        // Precondition 2: Ensure that the input 'l' is a list.\n        assert l instanceof List : \"Input 'l' must be a list.\";\n\n        // Precondition 3: Ensure that all elements in the list 'l' are integers.\n        for (Object item : l) {\n            assert item instanceof Integer : \"All elements in 'l' must be integers.\";\n        }\n\n        List<Integer> result = new ArrayList<Integer>();\n\n        // Increment each element by 1\n        for (Integer n : l) {\n            result.add(n + 1);\n        }\n\n        // Postcondition 1: Ensure that the result is a list.\n        assert result instanceof List : \"The result must be a list.\";\n\n        // Postcondition 2: Ensure that each element in the result is 1 greater than the corresponding element in the input list.\n        for (int i = 0; i < l.size(); i++) {\n            assert result.get(i) == l.get(i) + 1 : \"Each element in the result must be 1 greater than in the input list.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "GENERATE_INTEGERS.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\n\npublic class GENERATE_INTEGERS {\n\n    public static ArrayList<Integer> generate_integers(int a, int b) {\n        // Precondition 1: Ensure that 'a' and 'b' are positive integers.\n        assert a > 0 : \"Input 'a' must be a positive integer.\";\n        assert b > 0 : \"Input 'b' must be a positive integer.\";\n\n        int lower = Math.max(2, Math.min(a, b));  // The lower bound should be at least 2.\n        int upper = Math.min(8, Math.max(a, b));  // The upper bound should be at most 8.\n\n        ArrayList<Integer> result = new ArrayList<Integer>();\n        for (int i = lower; i <= upper; i++) {\n            if (i % 2 == 0) {\n                result.add(i);\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is an ArrayList.\n        assert result instanceof ArrayList : \"The result must be an ArrayList.\";\n\n        // Postcondition 2: Ensure that the result contains only even digits.\n        for (int num : result) {\n            assert num % 2 == 0 : \"All elements in the result must be even digits.\";\n        }\n\n        // Postcondition 3: Ensure that the result contains only digits between 2 and 8 (inclusive).\n        for (int num : result) {\n            assert num >= 2 && num <= 8 : \"All elements in the result must be between 2 and 8.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "ALL_PREFIXES.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ALL_PREFIXES {\n    public static List<String> all_prefixes(String string) {\n        // Precondition 1: The string should not be null\n        assert string != null : \"Precondition failed: Input string must not be null.\";\n\n\n        // Precondition 3: The string should only contain valid characters (e.g., not null characters or invalid Unicode)\n        assert string.chars().allMatch(c -> c > 0) : \"Precondition failed: String contains invalid characters.\";\n\n\n\n        // Precondition 5: The string should not contain more than 10,000 characters (additional safeguard if limits change)\n        assert string.length() <= 10000 : \"Precondition failed: String length exceeds 10,000 characters.\";\n\n        List<String> result = new ArrayList<String>();\n\n        for (int i = 0; i < string.length(); i += 1) {\n            result.add(string.substring(0, i + 1));\n        }\n\n        // Postcondition 1: The result should not be null\n        assert result != null : \"Postcondition failed: The result must not be null.\";\n\n        // Postcondition 2: The number of prefixes should equal the length of the input string\n        assert result.size() == string.length() : \"Postcondition failed: The number of prefixes must equal the length of the input string.\";\n\n\n\n\n        return result;\n    }\n}\n"}
{"file_name": "CHOOSE_NUM.java", "content": "package humaneval.buggy;\n\n/*\n    This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n*/\n\npublic class CHOOSE_NUM {\n    public static int choose_num(int x, int y) {\n        // Precondition 1: x and y must be positive integers\n        assert x > 0 && y > 0 : \"Precondition failed: x and y must be positive integers.\";\n\n\n\n        // Precondition 3: x and y must be integers (already guaranteed by Java's type system)\n\n        // Precondition 4: Ensure that the input values aren't too large (arbitrary upper bound)\n        assert x <= 1000000 && y <= 1000000 : \"Precondition failed: Input values are too large.\";\n\n        // Original logic\n        int result;\n        if (x > y) return -1;\n        if ((y % 2) == 0) result = y;\n        else if (x == y) return -1;\n        else result = y - 1;\n\n        // Postcondition 1: If x > y, the result must be -1\n        if (x > y) {\n            assert result == -1 : \"Postcondition failed: If x > y, the result must be -1.\";\n        }\n\n        // Postcondition 2: The result must be an even number if not -1\n        if (result != -1) {\n            assert result % 2 == 0 : \"Postcondition failed: The result is not an even number.\";\n        }\n\n        // Postcondition 3: The result must be within the range [x, y]\n        if (result != -1) {\n            assert result >= x && result <= y : \"Postcondition failed: The result is not within the range [x, y].\";\n        }\n\n        // Postcondition 4: If no even number exists in the range, the result must be -1\n        boolean evenExistsInRange = false;\n        for (int i = y; i >= x; i--) {\n            if (i % 2 == 0) {\n                evenExistsInRange = true;\n                break;\n            }\n        }\n        if (!evenExistsInRange) {\n            assert result == -1 : \"Postcondition failed: There is no even number in the range, but result is not -1.\";\n        }\n\n        // Postcondition 5: The result must remain consistent on repeated evaluations\n        int repeatedResult = result;\n        assert result == repeatedResult : \"Postcondition failed: The result is inconsistent on repeated evaluations.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "BELOW_THRESHOLD.java", "content": "package humaneval.buggy;\n\n/* Return True if all numbers in the list l are below threshold t.\n>>> below_threshold([1, 2, 4, 10], 100) ➞ True\n>>> below_threshold([1, 20, 4, 10], 5) ➞ False */\n\npublic class BELOW_THRESHOLD {\n    public static boolean below_threshold(int[] l, int t) {\n        assert l != null : \"Precondition failed: The input list must not be null.\";\n\n        // Precondition 2: The list should not be empty\n        assert l.length > 0 : \"Precondition failed: The input list must not be empty.\";\n\n        // Precondition 3: The threshold t should be a valid integer\n        assert t == (int) t : \"Precondition failed: The threshold must be a valid integer.\";\n\n        // Precondition 4: All elements in the list should be valid integers\n        for (int i = 0; i < l.length; i++) {\n            assert l[i] == (int) l[i] : \"Precondition failed: All elements in the list must be integers.\";\n        }\n\n        for (int i = 0; i < l.length; i += 1) {\n            if (l[i] >= t)\n                return false;\n        }\n\n        return true;\n    }\n}"}
{"file_name": "CHANGE_BASE.java", "content": "package humaneval.buggy;\n\n/*\n * Change the numerical base of the input number x to the specified base.\n * Return string representation after the conversion.\n * Base must be less than 10.\n *\n * Examples:\n * >>> change_base(8, 3)\n * '22'\n * >>> change_base(8, 2)\n * '1000'\n * >>> change_base(7, 2)\n * '111'\n */\n\npublic class CHANGE_BASE {\n    public static String change_base(int x, int base) {\n        // Precondition 1: x should be a non-negative integer\n        assert x >= 0 : \"Precondition failed: Input number x must be non-negative.\";\n\n        // Precondition 2: base should be greater than or equal to 2 (minimum valid base is binary)\n        assert base >= 2 : \"Precondition failed: Base must be greater than or equal to 2.\";\n\n        // Precondition 3: base should be less than or equal to 9 (as per problem constraint)\n        assert base <= 9 : \"Precondition failed: Base must be less than or equal to 9.\";\n\n        // Precondition 4: x and base must both be integers (handled by Java type system)\n        // No assertion needed here.\n\n        // Precondition 5: For the number x = 0, the result must be \"0\"\n        if (x == 0) {\n            return \"0\";\n        }\n\n        String result = \"\";\n\n        // Perform base conversion\n        while (x > 0) {\n            result = (x % base) + result;\n            x = x / base;\n        }\n\n        // Postcondition 1: The result must not be an empty string (since we return \"0\" for x == 0)\n        assert !result.isEmpty() : \"Postcondition failed: Result string is empty.\";\n\n        // Postcondition 2: The result should only contain valid digits for the given base\n        for (char c : result.toCharArray()) {\n            assert Character.isDigit(c) && Character.getNumericValue(c) < base\n                    : \"Postcondition failed: Result contains digits outside the valid range for the given base.\";\n        }\n\n\n        // Postcondition 4: The first digit of the result must be non-zero (except for the case x == 0)\n        assert result.charAt(0) != '0' : \"Postcondition failed: Leading digit is zero, which is incorrect.\";\n\n        // Postcondition 5: The result must represent the correct value when converted back to base 10\n        int convertedBack = Integer.parseInt(result, base);\n        assert convertedBack == Integer.parseInt(result, base)\n                : \"Postcondition failed: Result does not correctly represent the original number in base \" + base + \".\";\n\n        return result;\n    }\n}\n"}
{"file_name": "SUM_SQUARES.java", "content": "package humaneval.buggy;\n\n/* This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \nmultiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \nchange the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n\nExamples:\nFor lst = [1,2,3] the output should be 6\nFor lst = []  the output should be 0\nFor lst = [-1,-5,2,-1,-5]  the output should be -126 */\n\npublic class SUM_SQUARES {\n    public static int sum_squares(int[] lst) {\n        // Precondition 1: Ensure that the input 'lst' is not null.\n        assert lst != null : \"Precondition failed: Input 'lst' must not be null.\";\n\n        // Precondition 2: Ensure that the input 'lst' is a valid array (not null or containing invalid elements).\n        assert lst.length >= 0 : \"Precondition failed: Input 'lst' must be a valid array.\";\n\n        int result = 0;\n\n        for (int i = 0; i < lst.length; i += 1) {\n            // Postcondition 1: Ensure that index 'i' and corresponding value in 'lst' are correctly accessed.\n            assert i < lst.length : \"Postcondition failed: Index 'i' must be within the bounds of the array.\";\n\n            if (i % 3 == 0) {\n                // For indices that are multiples of 3, square the value\n                result += lst[i] * lst[i];\n\n                // Postcondition 2: Ensure that squaring is done correctly.\n                assert result >= Integer.MIN_VALUE && result <= Integer.MAX_VALUE :\n                        \"Postcondition failed: Result should be within integer limits after squaring.\";\n            }\n            else if (i % 4 == 0) {\n                // For indices that are multiples of 4 and not multiples of 3, cube the value\n                result += lst[i] * lst[i] * lst[i];\n\n                // Postcondition 3: Ensure that cubing is done correctly.\n                assert result >= Integer.MIN_VALUE && result <= Integer.MAX_VALUE :\n                        \"Postcondition failed: Result should be within integer limits after cubing.\";\n            }\n            else {\n                // For other indices, add the value as it is\n                result += lst[i];\n            }\n\n            // Postcondition 4: Ensure that the result remains a valid integer after each operation.\n            assert result >= Integer.MIN_VALUE && result <= Integer.MAX_VALUE :\n                    \"Postcondition failed: Result should be within integer limits after adding.\";\n        }\n\n        // Postcondition 5: Ensure that the result is correctly calculated as an integer.\n        assert result >= Integer.MIN_VALUE && result <= Integer.MAX_VALUE :\n                \"Postcondition failed: The final result must be a valid integer.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the function\n        assert sum_squares(new int[]{1, 2, 3}) == 6 : \"Test case 1 failed\";\n        assert sum_squares(new int[]{}) == 0 : \"Test case 2 failed\";\n        assert sum_squares(new int[]{-1, -5, 2, -1, -5}) == -126 : \"Test case 3 failed\";\n    }\n}\n"}
{"file_name": "PRIME_LENGTH.java", "content": "package humaneval.buggy;\n\npublic class PRIME_LENGTH {\n\n    public static boolean prime_length(String string) {\n        // Precondition 1: The input 'string' should not be null.\n        assert string != null : \"Input 'string' must not be null.\";\n\n        // Precondition 2: The input 'string' should be a string.\n        assert string instanceof String : \"Input 'string' must be a string.\";\n\n        int l = string.length();\n\n        // If the length is less than or equal to 1, it's not prime.\n        if (l <= 1) {\n            return false;\n        }\n\n        // Check if the length is a prime number.\n        for (int i = 2; i <= Math.sqrt(l); i++) {\n            if (l % i == 0) {\n                return false;\n            }\n        }\n\n        // The length is prime.\n        boolean result = true;\n\n        // Postcondition 1: The result should be a boolean value.\n        assert result == true || result == false : \"The result must be a boolean value.\";\n\n        // Postcondition 2: If the result is true, the length of the string should be a prime number.\n        if (result) {\n            assert l > 1 && isPrime(l) : \"If the result is true, the length of the string should be a prime number.\";\n        }\n\n        return result;\n    }\n\n    // Helper function to check if a number is prime.\n    private static boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"file_name": "CIRCULAR_SHIFT.java", "content": "package humaneval.buggy;\n\n/*\nCircular shift the digits of the integer x, shift the digits right by shift\nand return the result as a string.\nIf shift > number of digits, return digits reversed.\n\n>>> circular_shift(12, 1)  -> \"21\"\n>>> circular_shift(12, 2)  -> \"12\"\n*/\n\npublic class CIRCULAR_SHIFT {\n    public static String circular_shift(int x, int shift) {\n        // Precondition 1: x should be non-negative\n        assert x >= 0 : \"Precondition failed: x must be a non-negative integer.\";\n\n        // Precondition 2: shift should be non-negative\n        assert shift >= 0 : \"Precondition failed: shift must be a non-negative integer.\";\n\n        // Precondition 3: x should have at least one digit\n        assert String.valueOf(x).length() > 0 : \"Precondition failed: x must have at least one digit.\";\n\n        // Convert the integer to a string to work with its digits\n        String s = Integer.toString(x);\n\n        String result;\n\n        // If shift is greater than the number of digits, reverse the digits\n        if (shift > s.length()) {\n            StringBuilder sb = new StringBuilder();\n            for (int i = s.length() - 1; i >= 0; i--) {\n                sb.append(s.charAt(i));\n            }\n            result = sb.toString();\n        } else {\n            // Perform circular shift\n            result = s.substring(s.length() - shift) + s.substring(0, s.length() - shift);\n        }\n\n        // Postcondition 1: The result must have the same number of digits as the original number\n        assert result.length() == s.length() : \"Postcondition failed: The result must have the same number of digits as x.\";\n\n\n        return result;\n    }\n}\n"}
{"file_name": "FIB.java", "content": "package humaneval.buggy;\n\npublic class FIB {\n\n    public static int fib(int n) {\n        // Precondition 1: Ensure that 'n' is a non-negative integer.\n        assert n >= 0 : \"Input 'n' must be a non-negative integer.\";\n\n        // Base cases\n        if (n == 0) return 0;\n        if (n == 1 || n == 2) return 1;\n\n        // Iteratively calculate Fibonacci numbers to avoid recursion overhead\n        int a = 1, b = 1;\n        for (int i = 3; i <= n; i++) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n\n        int result = b;\n\n        // Postcondition 1: Ensure that the result is an integer.\n        assert result >= 0 : \"The result must be a non-negative integer.\";\n\n        // Postcondition 2: Verify the result against known Fibonacci numbers for small n.\n        int[] knownFibs = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55};\n        if (n < knownFibs.length) {\n            assert result == knownFibs[n] : \"The result must be \" + knownFibs[n] + \" for n=\" + n;\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "MAX_ELEMENT.java", "content": "package humaneval.buggy;\n\nimport java.util.List;\n\npublic class MAX_ELEMENT {\n\n    public static int max_element(List<Integer> l) {\n        // Precondition 1: The input list 'l' should not be null.\n        assert l != null : \"Input list 'l' must not be null.\";\n\n        // Precondition 2: The input 'l' should be a list.\n        assert l instanceof List : \"Input 'l' must be a list.\";\n\n        // Precondition 3: The input list 'l' should not be empty.\n        assert !l.isEmpty() : \"Input list 'l' must not be empty.\";\n\n        // Precondition 4: All elements in the list 'l' should be integers.\n        for (Object x : l) {\n            assert x instanceof Integer : \"All elements in 'l' must be integers.\";\n        }\n\n        // Calculating the maximum element in the list\n        int m = l.get(0);\n        for (Integer e : l) {\n            if (e > m) {\n                m = e;\n            }\n        }\n\n\n        // Postcondition 2: The result should be the maximum value in the list.\n        for (Integer e : l) {\n            assert m >= e : \"The result must be the maximum value in the list.\";\n        }\n\n        return m;\n    }\n}\n"}
{"file_name": "TRUNCATE_NUMBER.java", "content": "package humaneval.buggy;\n\npublic class TRUNCATE_NUMBER {\n\n    public static double truncate_number(double number) {\n        // Precondition 1: Ensure that 'number' is a finite value.\n        assert Double.isFinite(number) : \"Precondition failed: Input 'number' must be a finite value.\";\n\n        // Truncate the fractional part of the number\n        double result = number % 1.0;\n\n        // Postcondition 1: The result should be between 0 (inclusive) and 1 (exclusive) if the input is positive.\n        // If the input is negative, the result should be between 0 (exclusive) and -1 (inclusive).\n        if (number >= 0) {\n            assert result >= 0 && result < 1 : \"Postcondition failed: Result should be between 0 (inclusive) and 1 (exclusive) for positive numbers.\";\n        } else {\n            assert result > -1 && result <= 0 : \"Postcondition failed: Result should be between -1 (inclusive) and 0 (exclusive) for negative numbers.\";\n        }\n\n        // Postcondition 2: The result should have the same sign as the input number.\n        assert Math.signum(result) == Math.signum(number) : \"Postcondition failed: Result should have the same sign as the input number.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the function\n        assert truncate_number(5.8) == 0.8 : \"Test case 1 failed\";\n        assert truncate_number(-3.4) == -0.4 : \"Test case 2 failed\";\n        assert truncate_number(0.999) == 0.999 : \"Test case 3 failed\";\n        assert truncate_number(0.0) == 0.0 : \"Test case 4 failed\";\n        assert truncate_number(-0.75) == -0.75 : \"Test case 5 failed\";\n    }\n}\n"}
{"file_name": "FILTER_BY_SUBSTRING.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FILTER_BY_SUBSTRING {\n\n    public static List<String> filter_by_substring(List<String> strings, String substring) {\n        // Precondition 1: Ensure that 'strings' list and 'substring' are not null.\n        assert strings != null : \"Input list 'strings' must not be null.\";\n        assert substring != null : \"Input 'substring' must not be null.\";\n\n        // Precondition 2: Ensure that 'strings' is a list and 'substring' is a string.\n        assert strings instanceof List : \"Input 'strings' must be a list.\";\n        assert substring instanceof String : \"Input 'substring' must be a string.\";\n\n        // Precondition 3: Ensure that all elements in 'strings' are strings.\n        for (String s : strings) {\n            assert s instanceof String : \"All elements in 'strings' must be strings.\";\n        }\n\n        // Precondition 4: Ensure that the length of the 'strings' list is within a reasonable boundary.\n        int max_length = 1000000;  // Example boundary condition; adjust as needed.\n        assert strings.size() <= max_length : \"Input list 'strings' should not exceed \" + max_length + \" elements.\";\n\n        // Make a copy of the original list to check if the input remains unchanged.\n        List<String> originalStrings = new ArrayList<>(strings);\n\n        List<String> result = new ArrayList<String>();\n        for (String string : strings) {\n            if (string.contains(substring)) {\n                result.add(string);\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is a list of strings.\n        assert result instanceof List : \"The result must be a list.\";\n        for (String s : result) {\n            assert s instanceof String : \"All elements in the result must be strings.\";\n        }\n\n        // Postcondition 2: Ensure that each string in the result contains the 'substring'.\n        for (String s : result) {\n            assert s.contains(substring) : \"Each string in the result should contain the 'substring'.\";\n        }\n\n        // Postcondition 3: Ensure that the input list 'strings' remains unchanged.\n        assert strings.equals(originalStrings) : \"The input list 'strings' should remain unchanged.\";\n\n        // Postcondition 4: If 'substring' is an empty string, the result should be the same as the input 'strings'.\n        if (substring.equals(\"\")) {\n            assert result.equals(strings) : \"If 'substring' is empty, the result should be the same as the input 'strings'.\";\n        }\n\n        // Postcondition 5: If the input list 'strings' is empty, the result should also be an empty list.\n        if (strings.isEmpty()) {\n            assert result.isEmpty() : \"If the input list 'strings' is empty, the result should also be an empty list.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "TRI.java", "content": "package humaneval.buggy;\n\n/*\n * Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to return a list of the\n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    tri(3) = [1, 3, 2, 8]\n */\n\npublic class TRI {\n    public static int[] tri(int n) {\n        // Precondition 1: Ensure that 'n' is a non-negative integer.\n        assert n >= 0 : \"Precondition failed: 'n' must be a non-negative integer.\";\n\n        // Initializing the sequence array with n + 1 elements.\n        int[] sequence = new int[n + 1];\n\n        // Handling the special case when n is 0.\n        if (n == 0) {\n            sequence[0] = 1;\n            // Postcondition 1: Ensure that the length of the sequence is 1 when n is 0.\n            assert sequence.length == 1 : \"Postcondition failed: The sequence length must be 1 when n is 0.\";\n            // Postcondition 2: Ensure that the first element is 1 when n is 0.\n            assert sequence[0] == 1 : \"Postcondition failed: The first element must be 1 when n is 0.\";\n            return sequence;\n        }\n\n        // Setting up the first two elements of the sequence.\n        sequence[0] = 1;\n        sequence[1] = 3;\n\n        // Calculating the rest of the sequence based on the given recurrence relations.\n        for (int i = 2; i <= n; i++) {\n            if (i % 2 == 0) {\n                sequence[i] = 1 + i / 2;\n            } else {\n                sequence[i] = sequence[i - 1] + sequence[i - 2] + (i + 3) / 2;\n            }\n        }\n\n        // Postcondition 3: Ensure that the sequence array has the correct length of n + 1.\n        assert sequence.length == n + 1 : \"Postcondition failed: The sequence length must be n + 1.\";\n\n        // Postcondition 4: Ensure that all elements of the sequence are greater than 0.\n        for (int value : sequence) {\n            assert value > 0 : \"Postcondition failed: All elements in the sequence must be greater than 0.\";\n        }\n\n        // Postcondition 5: Ensure that the second element is 3 if n >= 1.\n        if (n >= 1) {\n            assert sequence[1] == 3 : \"Postcondition failed: The second element must be 3 when n >= 1.\";\n        }\n\n        return sequence;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the function\n        assert java.util.Arrays.equals(tri(3), new int[]{1, 3, 2, 8}) : \"Test case 1 failed\";\n        assert java.util.Arrays.equals(tri(0), new int[]{1}) : \"Test case 2 failed\";\n        assert java.util.Arrays.equals(tri(2), new int[]{1, 3, 2}) : \"Test case 3 failed\";\n        assert java.util.Arrays.equals(tri(4), new int[]{1, 3, 2, 11, 3}) : \"Test case 4 failed\";\n    }\n}\n"}
{"file_name": "IS_BORED.java", "content": "package humaneval.buggy;\n\n/* You'll be given a string of words, and your task is to count the number\nof boredoms. A boredom is a sentence that starts with the word \"I\".\nSentences are delimited by '.', '?' or '!'.\n\nFor example:\n>>> is_bored(\"Hello world\")\n0\n>>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n1 */\n\npublic class IS_BORED {\n\n    public static int is_bored(String S) {\n        // Precondition 1: The input string 'S' should not be null.\n        assert S != null : \"Input string 'S' must not be null.\";\n\n        // Precondition 2: The input 'S' should be a string.\n        assert S instanceof String : \"Input 'S' must be a string.\";\n\n        // Normalize sentence delimiters and split into sentences.\n        String[] sentences = S.split(\"[.!?]\");\n\n        int result = 0;\n        for (String sentence : sentences) {\n            sentence = sentence.trim();\n            // Check if the sentence starts with \"I \"\n            if (sentence.startsWith(\"I \")) {\n                result += 1;\n            }\n        }\n\n        // Postcondition 1: The result should be an integer.\n        assert result >= 0 : \"The result must be a non-negative integer.\";\n\n        // Postcondition 2: The result should be non-negative.\n        assert result >= 0 : \"The result must be non-negative.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "GREATEST_COMMON_DIVISOR.java", "content": "package humaneval.buggy;\n\npublic class GREATEST_COMMON_DIVISOR {\n\n    public static int greatest_common_divisor(int a, int b) {\n        // Precondition 1: Ensure that 'a' and 'b' are non-negative integers.\n        assert a >= 0 : \"Input 'a' must be a non-negative integer.\";\n        assert b >= 0 : \"Input 'b' must be a non-negative integer.\";\n\n        // Implementing the GCD algorithm (Euclidean algorithm)\n        while (b > 0) {\n            int tmp = a;\n            a = b;\n            b = tmp % b;\n        }\n\n        int result = a;\n\n        // Postcondition 1: Ensure that the result is an integer.\n        assert result >= 0 : \"The result must be a non-negative integer.\";\n\n        // Postcondition 2: Ensure that the result divides both 'a' and 'b' without a remainder.\n        assert (a % result == 0) && (b % result == 0) : \"The result must divide both 'a' and 'b' without a remainder.\";\n\n        // Postcondition 3: Ensure that the result is the greatest common divisor.\n        for (int i = 1; i <= Math.min(a, b); i++) {\n            if (a % i == 0 && b % i == 0) {\n                assert i <= result : \"The result must be the greatest common divisor.\";\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "IS_HAPPY.java", "content": "package humaneval.buggy;\n\n// You are given a string s.\n// Your task is to check if the string is happy or not.\n// A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// is_happy(a) => False\n// is_happy(aa) => False\n// is_happy(abcd) => True\n// is_happy(aabb) => False\n// is_happy(adb) => True\n// is_happy(xyy) => False\n\npublic class IS_HAPPY {\n    public static boolean is_happy(String s) {\n        // Precondition 1: The input string 's' should not be null.\n        assert s != null : \"Input string 's' must not be null.\";\n\n        // Precondition 2: The input 's' should be a string (implicitly checked since 's' is a String parameter).\n\n        // Postcondition 2: The function should return false if the length of 's' is less than 3.\n        if (s.length() < 3) {\n            return false;\n        }\n\n        // Check if every 3 consecutive letters are distinct\n        for (int i = 0; i < s.length() - 2; i += 1) {\n            if (s.charAt(i) == s.charAt(i + 1) || s.charAt(i + 1) == s.charAt(i + 2) || s.charAt(i + 2) == s.charAt(i)) {\n                return false;\n            }\n        }\n        boolean result = true;\n\n        // Postcondition 1: The result should be a boolean value.\n        assert result == true || result == false : \"The result must be a boolean value.\";\n\n        // Postcondition 3: Ensure that every three consecutive characters in the string are distinct.\n        for (int i = 0; i < s.length() - 2; i += 1) {\n            assert s.charAt(i) != s.charAt(i + 1) && s.charAt(i) != s.charAt(i + 2) && s.charAt(i + 1) != s.charAt(i + 2) :\n                    \"Every three consecutive characters in the string must be distinct.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "WORDS_STRINGS.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\n\n/*\n * You will be given a string of words separated by commas or spaces. Your task is\n * to split the string into words and return an array of the words.\n *\n * For example:\n * words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n * words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n */\n\npublic class WORDS_STRINGS {\n\tpublic static ArrayList<String> words_strings(String s) {\n\t\t// Precondition 1: The input string should not be null.\n\t\tassert s != null : \"Precondition failed: The input string must not be null.\";\n\n\t\t// Precondition 2: The input string should not contain any non-printable characters.\n\t\tassert s.matches(\"[\\\\p{Print}]*\") : \"Precondition failed: The input string must not contain non-printable characters.\";\n\n\t\tArrayList<String> result = new ArrayList<String>();\n\n\t\t// Precondition 3: If the input string is empty, the result should be an empty list.\n\t\tif (s.isEmpty()) {\n\t\t\tassert result.isEmpty() : \"Postcondition failed: If the input string is empty, the result must be an empty list.\";\n\t\t\treturn result;\n\t\t}\n\n\t\tString s_list = \"\";\n\t\tfor (char c : s.toCharArray()) {\n\t\t\tif (c == ',') {\n\t\t\t\ts_list += ' ';\n\t\t\t} else {\n\t\t\t\ts_list += c;\n\t\t\t}\n\t\t}\n\n\t\tString[] result_array = s_list.trim().split(\"\\\\s+\");\n\t\tfor (String r : result_array) {\n\t\t\tresult.add(r);\n\t\t}\n\n\t\t// Postcondition 1: The result should not be null.\n\t\tassert result != null : \"Postcondition failed: The result must not be null.\";\n\n\t\t// Postcondition 2: The result list should contain only non-empty strings.\n\t\tassert result.stream().allMatch(str -> str != null && !str.isEmpty()) : \"Postcondition failed: The result list must contain only non-empty strings.\";\n\n\t\t// Postcondition 3: The number of words in the result should be equal to the number of words in the input string (words are separated by commas or spaces).\n\t\tassert result.size() == s_list.trim().split(\"\\\\s+\").length :\n\t\t\t\t\"Postcondition failed: The number of words in the result should match the number of words in the input string.\";\n\n\t\treturn result;\n\t}\n\n\n}\n"}
{"file_name": "INTERSPERSE.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class INTERSPERSE {\n\n    public static List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        // Precondition 1: The input list 'numbers' should not be null.\n        assert numbers != null : \"Input list 'numbers' must not be null.\";\n\n        // Precondition 2: The input 'numbers' should be a list and 'delimiter' should be an integer.\n        assert numbers instanceof List : \"Input 'numbers' must be a list.\";\n\n        // Precondition 3: All elements in the list should be integers.\n        for (Object num : numbers) {\n            assert num instanceof Integer : \"All elements in 'numbers' must be integers.\";\n        }\n\n        // Precondition 4: The length of the 'numbers' list should be within a reasonable boundary.\n        int max_length = (int) Math.pow(10, 6);\n        assert numbers.size() <= max_length : \"Input list 'numbers' should not exceed \" + max_length + \" elements.\";\n\n        // Copy of the original list for postcondition check\n        List<Integer> original_numbers = new ArrayList<>(numbers);\n\n        List<Integer> result = new ArrayList<>();\n\n        if (numbers.size() == 0)\n            return result;\n\n        for (int i = 0; i < numbers.size() - 1; i += 1) {\n            result.add(numbers.get(i));\n            result.add(delimiter);\n        }\n        result.add(numbers.get(numbers.size() - 1));\n\n        // Postcondition 1: The result should be a list.\n        assert result instanceof List : \"The result must be a list.\";\n\n        // Postcondition 2: The length of the result should be 2 * len(numbers) - 1 if numbers is not empty.\n        int expected_length = 2 * numbers.size() - 1;\n        assert result.size() == expected_length : \"The length of the result is incorrect.\";\n\n        // Postcondition 3: The delimiter should be placed correctly between every two consecutive elements.\n        for (int i = 1; i < result.size() - 1; i += 2) {\n            assert result.get(i) == delimiter : \"The delimiter is not correctly placed between elements.\";\n        }\n\n        // Postcondition 4: The input list 'numbers' should remain unchanged.\n        assert numbers.equals(original_numbers) : \"The input list 'numbers' should remain unchanged.\";\n\n        // Postcondition 5: If the input list is empty, the result should also be an empty list.\n        if (numbers.size() == 0) {\n            assert result.isEmpty() : \"If the input list is empty, the result should also be an empty list.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "MOVE_ONE_BALL.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class MOVE_ONE_BALL {\n\n    public static boolean move_one_ball(ArrayList<Integer> arr) {\n        // Precondition 1: The input list 'arr' should not be null.\n        assert arr != null : \"Input 'arr' must not be null.\";\n\n        // Precondition 2: Ensure that 'arr' is a list of integers.\n        // This is inherently checked by Java's type system as 'arr' is an ArrayList of Integers.\n\n        // Precondition 3: Ensure that all elements in 'arr' are integers.\n        // This is inherently checked by Java's type system as 'arr' is an ArrayList of Integers.\n\n        // Precondition 4: Ensure that all elements in 'arr' are unique.\n        assert arr.size() == arr.stream().distinct().count() : \"All elements in 'arr' must be unique.\";\n\n        // Postcondition 1: If the array is empty, return true.\n        if (arr.size() == 0) {\n            assert true : \"The result must be true if the input array is empty.\";\n            return true;\n        }\n\n        ArrayList<Integer> sorted_arr = new ArrayList<>(arr);\n        Collections.sort(sorted_arr);\n\n        // Postcondition 2: Ensure that the array is not already sorted.\n        if (arr.equals(sorted_arr)) {\n            assert arr.equals(sorted_arr) : \"If the array is already sorted, the result must be true.\";\n            return true;\n        }\n\n        // Check if the array can be sorted by any number of right shifts\n        for (int i = 1; i < arr.size(); i++) {\n            ArrayList<Integer> shifted = new ArrayList<>(arr.subList(i, arr.size()));\n            shifted.addAll(arr.subList(0, i));\n            if (shifted.equals(sorted_arr)) {\n                // Postcondition 3: Ensure that a valid right shift results in a sorted array.\n                assert shifted.equals(sorted_arr) : \"A valid right shift should result in a sorted array.\";\n                return true;\n            }\n        }\n\n        // Postcondition 4: Ensure that no possible right shift results in a sorted array.\n        assert arr.size() > 1 || !arr.equals(sorted_arr) : \"No possible right shift should result in a sorted array if the result is false.\";\n        return false;\n    }\n}\n"}
{"file_name": "DO_ALGEBRA.java", "content": "package humaneval.buggy;\n\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptException;\n\n// Given two lists operator, and operand. The first list has basic algebra operations, and\n// the second list is a list of integers. Use the two given lists to build the algebric\n// expression and return the evaluation of this expression.\n\n// The basic algebra operations:\n// Addition ( + )\n// Subtraction ( - )\n// Multiplication ( * )\n// Floor division ( / )\n// Exponentiation ( ** ), deprecated in Java\n\n// Example:\n// operator['+', '*', '-']\n// array = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n\n// Note:\n//     The length of operator list is equal to the length of operand list minus one.\n//     Operand is a list of of non-negative integers.\n//     Operator list has at least one operator, and operand list has at least two operands.\n\npublic class DO_ALGEBRA {\n    public static double do_algebra(String[] operator, int[] operand) throws NumberFormatException, ScriptException {\n        ScriptEngineManager mgr = new ScriptEngineManager();\n        ScriptEngine engine = mgr.getEngineByName(\"JavaScript\");\n        String expression = operand[0] + \"\";\n        for (int i = 0; i < operator.length; i += 1) {\n            expression += operator[i] + operand[i + 1];\n        }\n        return Double.parseDouble(engine.eval(expression).toString());\n    }\n}"}
{"file_name": "RESCALE_TO_UNIT.java", "content": "package humaneval.buggy;\n\npublic class RESCALE_TO_UNIT {\n\n    public static double[] rescale_to_unit(double[] numbers) {\n        // Precondition 1: The input array 'numbers' should not be null.\n        assert numbers != null : \"Input 'numbers' must not be null.\";\n\n        // Precondition 2: The input 'numbers' should have at least two elements.\n        assert numbers.length >= 2 : \"Input array 'numbers' must have at least two elements.\";\n\n        // Precondition 3: The array should contain at least two distinct values.\n        double min = Double.MAX_VALUE;\n        double max = Double.MIN_VALUE;\n        for (double num : numbers) {\n            if (num > max) {\n                max = num;\n            }\n            if (num < min) {\n                min = num;\n            }\n        }\n        assert max != min : \"The array must contain at least two distinct values.\";\n\n        double[] result = new double[numbers.length];\n        for (int i = 0; i < numbers.length; i++) {\n            result[i] = (numbers[i] - min) / (max - min);\n        }\n\n        // Postcondition 1: The result should be an array of doubles.\n        assert result instanceof double[] : \"The result must be an array of doubles.\";\n\n        // Postcondition 2: The length of the result array should match the length of the input array.\n        assert result.length == numbers.length : \"The length of the result array must match the length of the input array.\";\n\n        // Postcondition 3: The smallest value in the result array should be 0.0, and the largest value should be 1.0.\n        double resultMin = Double.MAX_VALUE;\n        double resultMax = Double.MIN_VALUE;\n        for (double val : result) {\n            if (val > resultMax) {\n                resultMax = val;\n            }\n            if (val < resultMin) {\n                resultMin = val;\n            }\n        }\n        assert resultMin == 0.0 && resultMax == 1.0 : \"The result should have a minimum value of 0.0 and a maximum value of 1.0.\";\n\n\n\n        return result;\n    }\n}\n"}
{"file_name": "RIGHT_ANGLE_TRIANGLE.java", "content": "package humaneval.buggy;\n\n// Given the lengths of the three sides of a triangle. Return True if the three\n// sides form a right-angled triangle, False otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or\n// 90 degree.\n// Example:\n// right_angle_triangle(3, 4, 5) == True\n// right_angle_triangle(1, 2, 3) == False\n\npublic class RIGHT_ANGLE_TRIANGLE {\n    public static boolean right_angle_triangle(int a, int b, int c) {\n        assert a > 0 : \"'a' must be a positive number.\";\n        assert b > 0 : \"'b' must be a positive number.\";\n        assert c > 0 : \"'c' must be a positive number.\";\n\n        return a*a + b*b == c*c || b*b + c*c == a*a || c*c + a*a == b*b;\n    }\n}\n"}
{"file_name": "BELOW_ZERO.java", "content": "package humaneval.buggy;\n\nimport java.util.List;\n\npublic class BELOW_ZERO {\n    public static boolean below_zero(List<Integer> operations) {\n        assert operations != null : \"Precondition failed: The operations list must not be null.\";\n\n\n\n        // Precondition 4: The number of operations should not exceed 10,000 (arbitrary upper constraint)\n        assert operations.size() <= 10000 : \"Precondition failed: The operations list size exceeds the limit of 10,000.\";\n\n        // Precondition 5: The initial balance should be non-negative\n        int balance = 0;\n        assert balance >= 0 : \"Precondition failed: Initial balance must be non-negative.\";\n\n        for (Integer op : operations){\n            balance += op;\n            if (balance < 0){\n                return true;\n            }\n        }\n        assert balance >= 0 : \"Postcondition failed: Function returned false, but balance went below zero.\";\n\n        // Postcondition 3: The final balance should reflect the sum of all operations\n        int sumOfOperations = 0;\n        for (int op : operations) {\n            sumOfOperations += op;\n        }\n        assert balance == sumOfOperations : \"Postcondition failed: Final balance does not match the sum of operations.\";\n\n        // Postcondition 4: If all operations are positive, the result should be false\n        boolean allPositive = true;\n        for (int op : operations) {\n            if (op < 0) {\n                allPositive = false;\n                break;\n            }\n        }\n        assert !allPositive || balance >= 0 : \"Postcondition failed: All operations were positive, but the balance went below zero.\";\n\n        // Postcondition 5: If the result is false, the balance should not have gone negative during any step\n        assert balance >= 0 : \"Postcondition failed: Returning false but balance went negative during operations.\";\n\n        return false;\n    }\n}"}
{"file_name": "SUM_TO_N.java", "content": "package humaneval.buggy;\n\n/*\n * sum_to_n is a function that sums numbers from 1 to n.\n *\n * >>> sum_to_n(30)\n * 465\n * >>> sum_to_n(100)\n * 5050\n * >>> sum_to_n(5)\n * 15\n * >>> sum_to_n(10)\n * 55\n * >>> sum_to_n(1)\n * 1\n */\n\npublic class SUM_TO_N {\n    public static int sum_to_n(int n) {\n        // Precondition 1: Ensure that 'n' is a positive integer.\n        assert n > 0 : \"Precondition failed: 'n' must be a positive integer.\";\n\n        // Calculate the sum from 1 to n using the formula (n * (n + 1)) / 2.\n        int result = (n + 1) * n / 2;\n\n        // Postcondition 1: Ensure that the result is a non-negative integer.\n        assert result >= 0 : \"Postcondition failed: The result must be a non-negative integer.\";\n\n        // Postcondition 2: Ensure that the result is the correct sum from 1 to n.\n        // The sum of the first n natural numbers is given by n * (n + 1) / 2\n        int expectedSum = n * (n + 1) / 2;\n        assert result == expectedSum : \"Postcondition failed: The result must be the correct sum from 1 to n.\";\n\n        // Postcondition 3: Ensure that if n = 1, the result should be 1.\n        if (n == 1) {\n            assert result == 1 : \"Postcondition failed: For n = 1, the result should be 1.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the function\n        assert sum_to_n(30) == 465 : \"Test case 1 failed\";\n        assert sum_to_n(100) == 5050 : \"Test case 2 failed\";\n        assert sum_to_n(5) == 15 : \"Test case 3 failed\";\n        assert sum_to_n(10) == 55 : \"Test case 4 failed\";\n        assert sum_to_n(1) == 1 : \"Test case 5 failed\";\n    }\n}\n"}
{"file_name": "STRLEN.java", "content": "package humaneval.buggy;\n\npublic class STRLEN {\n    public static int strlen(String string) {\n        // Precondition 1: Ensure that the input 'string' is not null.\n        assert string != null : \"Precondition failed: Input 'string' must not be null.\";\n\n        // Calculate the length of the string.\n        int length = string.length();\n\n        // Postcondition 1: Ensure that the result is a non-negative integer.\n        assert length >= 0 : \"Postcondition failed: The length of the string must be a non-negative integer.\";\n\n        // Postcondition 2: Ensure that the result matches the number of characters in the input string.\n        assert string.chars().count() == length : \"Postcondition failed: The result must match the number of characters in the input string.\";\n\n        // Postcondition 3: Ensure that for an empty string, the result is zero.\n        if (string.isEmpty()) {\n            assert length == 0 : \"Postcondition failed: The length of an empty string must be 0.\";\n        }\n\n        // Postcondition 4: Ensure that the length does not change after rechecking.\n        int recheckedLength = string.length();\n        assert recheckedLength == length : \"Postcondition failed: The length should be consistent when rechecked.\";\n\n        return length;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the function\n        System.out.println(strlen(\"Hello\")); // Expected: 5\n        System.out.println(strlen(\"\"));      // Expected: 0\n        System.out.println(strlen(\" \"));     // Expected: 1\n        System.out.println(strlen(\"Hello, World!\")); // Expected: 13\n    }\n}\n"}
{"file_name": "DIGITS.java", "content": "package humaneval.buggy;\n\n/*\n * Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n */\n\npublic class DIGITS {\n    public static int digits(int n) {\n        // Preconditions\n        // Precondition 1: Ensure that 'n' is a positive integer.\n        assert n > 0 : \"Precondition failed: 'n' must be a positive integer.\";\n\n        int product = 1;\n        int odd_count = 0;\n\n        while (n > 0) {\n            int digit = n % 10;\n            if (digit % 2 == 1) { // Check if the digit is odd\n                product *= digit;\n                odd_count++;\n            }\n            n /= 10;\n        }\n\n        // Postconditions\n        // Postcondition 1: If there were no odd digits, the result must be 0.\n        if (odd_count == 0) {\n            assert product == 1 : \"Postcondition failed: There are no odd digits, so the product should be 1.\";\n            return 0;\n        }\n\n        // Postcondition 2: If there are odd digits, the product must be greater than 1.\n        assert odd_count > 0 && product > 0 : \"Postcondition failed: The product should be greater than 0 if there are odd digits.\";\n\n\n        return product;\n    }\n\n    // Helper method to calculate the expected product for postcondition check.\n    private static int calculateExpectedProduct(int originalN) {\n        int expectedProduct = 1;\n        int tempN = originalN;\n\n        while (tempN > 0) {\n            int digit = tempN % 10;\n            if (digit % 2 == 1) { // Check if the digit is odd\n                expectedProduct *= digit;\n            }\n            tempN /= 10;\n        }\n        return expectedProduct == 1 ? 0 : expectedProduct; // If no odd digits, return 0 as expected\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the function\n        assert digits(1) == 1 : \"Test case 1 failed.\";\n        assert digits(4) == 0 : \"Test case 2 failed.\";\n        assert digits(235) == 15 : \"Test case 3 failed.\";\n        assert digits(246) == 0 : \"Test case 4 failed.\";\n        assert digits(123456789) == 945 : \"Test case 5 failed.\";\n    }\n}\n"}
{"file_name": "CLOSEST_INTEGER.java", "content": "package humaneval.buggy;\n\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n\n// Examples\n// >>> closest_integer(\"10\") ➞ 10\n// >>> closest_integer(\"15.3\") ➞ 15\n// >>> closest_integer(\"14.5\") ➞ 15\n// >>> closest_integer(\"-14.5\") ➞ -15\n\npublic class CLOSEST_INTEGER {\n    public static int closest_integer(String value) {\n        // Precondition 1: The input string should not be null\n        assert value != null : \"Precondition failed: Input value must not be null.\";\n\n        // Precondition 2: The input string should not be empty\n        assert !value.isEmpty() : \"Precondition failed: Input value must not be an empty string.\";\n\n        // Precondition 3: The input string should represent a valid number\n        try {\n            Double.parseDouble(value);\n        } catch (NumberFormatException e) {\n            assert false : \"Precondition failed: Input value is not a valid number.\";\n        }\n\n        // Remove trailing zeros after decimal point, if present\n        if (value.indexOf('.') >= 0) {\n            while (value.charAt(value.length() - 1) == '0')\n                value = value.substring(0, value.length() - 1);\n        }\n\n        // Parse the string into a number\n        double num = Double.parseDouble(value);\n        int result = 0;\n\n        // Handle cases where the number ends in \".5\" and should be rounded away from zero\n        if (value.length() >= 2 && value.substring(value.length() - 2).equals(\".5\")) {\n            result = num > 0 ? (int)Math.ceil(num) : (int)Math.floor(num);\n        } else if (value.length() > 0) {\n            result = (int)Math.round(num);\n        }\n\n        // Postcondition 1: The result should be an integer\n        assert result == (int)result : \"Postcondition failed: The result is not an integer.\";\n\n        // Postcondition 2: If the number is equidistant from two integers (.5), it should be rounded away from zero\n        if (value.endsWith(\".5\")) {\n            if (num > 0) {\n                assert result == (int) Math.ceil(num) : \"Postcondition failed: The number should round away from zero.\";\n            } else {\n                assert result == (int) Math.floor(num) : \"Postcondition failed: The number should round away from zero.\";\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "NEXT_SMALLEST.java", "content": "package humaneval.buggy;\n\nimport java.util.*;\n\n/* You are given a list of integers.\nWrite a function next_smallest() that returns the 2nd smallest element of the list.\nReturn None if there is no such element.\n\nnext_smallest([1, 2, 3, 4, 5]) == 2\nnext_smallest([5, 1, 4, 3, 2]) == 2\nnext_smallest([]) == None\nnext_smallest([1, 1]) == None */\n\npublic class NEXT_SMALLEST {\n    public static Integer next_smallest(int[] lst) {\n        // Precondition 1: The input list should not be null.\n        assert lst != null : \"Input list 'lst' must not be null.\";\n\n        // Precondition 2: The input list should contain at least two elements.\n        if (lst.length <= 1) {\n            return null;\n        }\n\n        // Use a set to remove duplicates and find the second smallest element.\n        HashSet<Integer> numbers = new HashSet<>();\n        for (int n : lst) {\n            numbers.add(n);\n        }\n\n        // Convert the set to a list and sort it.\n        ArrayList<Integer> noDuplicate = new ArrayList<>(numbers);\n        Collections.sort(noDuplicate);\n\n        // If there are less than 2 distinct elements, return null.\n        if (noDuplicate.size() < 2) {\n            return null;\n        }\n\n        Integer result = noDuplicate.get(1);\n\n        // Postcondition 1: The result should be an integer or null.\n        assert result == null || result instanceof Integer : \"The result must be an integer or null.\";\n\n        // Postcondition 2: The result should be the second smallest distinct element.\n        if (result != null) {\n            assert result > noDuplicate.get(0) : \"The result should be the second smallest element.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "PAIRS_SUM_TO_ZERO.java", "content": "package humaneval.buggy;\n\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/* pairs_sum_to_zero takes a list of integers as an input.\nit returns True if there are two distinct elements in the list that\nsum to zero, and False otherwise. */\n\npublic class PAIRS_SUM_TO_ZERO {\n    public static boolean pairs_sum_to_zero(List<Integer> l) {\n        // Precondition 1: The input list 'l' should not be null.\n        assert l != null : \"Input list 'l' must not be null.\";\n\n        // Precondition 2: Ensure that all elements in 'l' are not null.\n        for (Integer num : l) {\n            assert num != null : \"Elements of 'l' must not be null.\";\n        }\n\n        // Precondition 3: All elements in the list 'l' should be integers (already enforced by the List<Integer> type).\n\n        Set<Integer> seen = new HashSet<>();\n        for (Integer num : l) {\n            if (seen.contains(-num)) {\n                // Postcondition 1: The result should be a boolean value.\n                boolean result = true;\n                assert result == true : \"The result must be a boolean value.\";\n                return result;\n            }\n            seen.add(num);\n        }\n\n        // Postcondition 1: The result should be a boolean value.\n        boolean result = false;\n        assert result == false : \"The result must be a boolean value.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "LONGEST.java", "content": "package humaneval.buggy;\n\nimport java.util.List;\n\npublic class LONGEST {\n    public static String longest(List<String> strings) {\n        // Precondition 1: Ensure that 'strings' is not null.\n        assert strings != null : \"Input list 'strings' must not be null.\";\n\n        // Precondition 2: Ensure that 'strings' is a list.\n        assert strings instanceof List<?> : \"Input 'strings' must be a list.\";\n\n        // Precondition 3: Ensure that all elements in the list 'strings' are strings.\n        assert strings.stream().allMatch(s -> s instanceof String) : \"All elements in 'strings' must be strings.\";\n\n        // Precondition 4: Ensure that the length of the 'strings' list is within a reasonable boundary.\n        int max_length = 1000000; // Example boundary condition; adjust as needed.\n        assert strings.size() <= max_length : \"Input list 'strings' should not exceed \" + max_length + \" elements.\";\n\n        if (strings.isEmpty()) {\n            return null;\n        }\n\n        int maxlen = 0;\n        String result = null;\n\n        // Find the maximum length of strings in the list\n        for (String string : strings) {\n            if (string.length() > maxlen) {\n                maxlen = string.length();\n                result = string; // Keep track of the first string with the maximum length\n            }\n        }\n\n        // Postcondition 1: The result should be either a string or null.\n        assert result == null || result instanceof String : \"The result must be either a string or null.\";\n\n        // Postcondition 2: The result should be the longest string from the input list, if not null.\n        if (result != null) {\n            int finalMaxLen = maxlen;\n            assert strings.stream().anyMatch(s -> s.length() == finalMaxLen) : \"The result must be the longest string from the input list.\";\n        }\n\n        // Postcondition 3: If there are multiple strings of the same maximum length, the result should be the first one.\n        if (result != null) {\n            int finalMaxLen = maxlen;\n            assert strings.stream().filter(s -> s.length() == finalMaxLen).findFirst().orElse(null).equals(result) : \"The result must be the first string with the maximum length.\";\n        }\n\n        // Postcondition 4: If the input list is empty, the result should be null.\n        if (strings.isEmpty()) {\n            assert result == null : \"If the input list is empty, the result should be null.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "PLUCK.java", "content": "package humaneval.buggy;\n\npublic class PLUCK {\n\n    public static int[] pluck(int[] arr) {\n        // Precondition: Check that the input 'arr' is not null and contains non-negative integers.\n        assert arr != null : \"Input array 'arr' must not be null.\";\n        for (int value : arr) {\n            assert value >= 0 : \"All elements in the array must be non-negative integers.\";\n        }\n\n        if (arr.length == 0) {\n            // If the array is empty, return an empty array.\n            return new int[]{};\n        }\n\n        int min_even = Integer.MAX_VALUE;\n        int index = -1;\n\n        // Iterate through the array to find the smallest even value and its index.\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] % 2 == 0 && arr[i] < min_even) {\n                min_even = arr[i];\n                index = i;\n            }\n        }\n\n        // Postcondition: Check if an even number was found, otherwise return an empty array.\n        if (index == -1) {\n            assert index == -1 : \"There should be no even values in the array if index is -1.\";\n            return new int[]{};\n        } else {\n            assert index >= 0 : \"The index must be valid.\";\n            assert min_even % 2 == 0 : \"The minimum value must be even.\";\n            assert min_even == arr[index] : \"The returned value and index must correspond.\";\n            return new int[]{min_even, index};\n        }\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the solution\n        assert java.util.Arrays.equals(pluck(new int[]{4, 2, 3}), new int[]{2, 1}) : \"Test Case 1 Failed\";\n        assert java.util.Arrays.equals(pluck(new int[]{1, 2, 3}), new int[]{2, 1}) : \"Test Case 2 Failed\";\n        assert java.util.Arrays.equals(pluck(new int[]{}), new int[]{}) : \"Test Case 3 Failed\";\n        assert java.util.Arrays.equals(pluck(new int[]{5, 0, 3, 0, 4, 2}), new int[]{0, 1}) : \"Test Case 4 Failed\";\n        assert java.util.Arrays.equals(pluck(new int[]{5, 7, 3}), new int[]{}) : \"Test Case 5 Failed\"; // No even numbers\n\n        System.out.println(\"All test cases passed!\");\n    }\n}\n"}
{"file_name": "ODD_COUNT.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\n\npublic class ODD_COUNT {\n    public static ArrayList<String> odd_count(ArrayList<String> lst) {\n        // Precondition 1: Ensure that 'lst' is not null.\n        assert lst != null : \"Input 'lst' must not be null.\";\n\n        // Precondition 2: Ensure that 'lst' is not empty.\n        assert lst.size() > 0 : \"Input 'lst' must not be empty.\";\n\n        // Precondition 3: Ensure that all elements in 'lst' are strings containing only digits.\n        for (String s : lst) {\n            assert s != null : \"All elements in 'lst' must not be null.\";\n            assert s.matches(\"\\\\d+\") : \"All elements in 'lst' must contain only digits.\";\n        }\n\n        ArrayList<String> result = new ArrayList<>();\n        for (String s : lst) {\n            int n = 0;\n            for (int i = 0; i < s.length(); i++) {\n                int digit = s.charAt(i) - '0';\n                if (digit % 2 == 1) {\n                    n++;\n                }\n            }\n            result.add(\"the number of odd elements \" + n + \"n the str\" + n + \"ng \" + n + \" of the \" + n + \"nput.\");\n        }\n\n        // Postcondition 1: Ensure that the result is not null.\n        assert result != null : \"The result must not be null.\";\n\n        // Postcondition 2: Ensure that the result list has the same length as the input list.\n        assert result.size() == lst.size() : \"The result list must have the same length as the input list.\";\n\n        // Postcondition 3: Ensure that each output string correctly replaces 'i' with the odd count.\n        for (int i = 0; i < lst.size(); i++) {\n            String s = lst.get(i);\n            int n = 0;\n            for (int j = 0; j < s.length(); j++) {\n                int digit = s.charAt(j) - '0';\n                if (digit % 2 == 1) {\n                    n++;\n                }\n            }\n            String expectedOutput = \"the number of odd elements \" + n + \"n the str\" + n + \"ng \" + n + \" of the \" + n + \"nput.\";\n            assert result.get(i).equals(expectedOutput) : \"The output string for input '\" + s + \"' does not match the expected format.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "MAXIMUM_K.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class MAXIMUM_K {\n    public static ArrayList<Integer> maximum_k(ArrayList<Integer> arr, int k) {\n        // Precondition 1: Ensure that 'arr' is not null.\n        assert arr != null : \"Input 'arr' must not be null.\";\n\n        // Precondition 2: Ensure that 'arr' is a list.\n        assert arr instanceof ArrayList<?> : \"Input 'arr' must be a list.\";\n\n        // Precondition 3: Ensure that all elements in 'arr' are integers.\n        for (Object element : arr) {\n            assert element instanceof Integer : \"All elements in 'arr' must be integers.\";\n        }\n\n        // Precondition 4: Ensure that 'k' is a non-negative integer within the valid range.\n        assert k >= 0 && k <= arr.size() : \"Input 'k' must be a non-negative integer within the valid range.\";\n\n        // Sort the array in descending order and pick the first 'k' elements.\n        Collections.sort(arr, Collections.reverseOrder());\n        ArrayList<Integer> result = new ArrayList<>(arr.subList(0, k));\n\n        // Sort the result in ascending order.\n        Collections.sort(result);\n\n        // Postcondition 1: Ensure that the result is a list.\n        assert result instanceof ArrayList<?> : \"The result must be a list.\";\n\n        // Postcondition 2: Ensure that the length of the result list is equal to 'k'.\n        assert result.size() == k : \"The result list must have a length equal to 'k'.\";\n\n        // Postcondition 3: Ensure that the result list is sorted in ascending order.\n        for (int i = 0; i < result.size() - 1; i++) {\n            assert result.get(i) <= result.get(i + 1) : \"The result list must be sorted in ascending order.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "CAR_RACE_COLLISION.java", "content": "package humaneval.buggy;\n\n/*\nImagine a road that's a perfectly straight, infinitely long line.\nn cars are driving left to right; simultaneously, a different set of n cars\nare driving right to left. The two sets of cars start out being very far from\neach other. All cars move at the same speed. Two cars are said to collide\nwhen a car moving left to right hits a car moving right to left.\nHowever, the cars are infinitely sturdy and strong; as a result, they continue moving\nin their trajectory as if they did not collide.\n\nThis function outputs the number of such collisions.\n*/\n\npublic class CAR_RACE_COLLISION {\n    public static int car_race_collision(int n) {\n        // Precondition 1: n should be a non-negative integer\n        assert n >= 0 : \"Precondition failed: Number of cars must be a non-negative integer.\";\n\n        // Precondition 2: n should not be excessively large (arbitrary upper limit)\n        assert n <= 1000000 : \"Precondition failed: Number of cars exceeds maximum allowed limit (1,000,000).\";\n\n        // Precondition 3: The result of n * n should not overflow the integer range\n        assert n <= Math.sqrt(Integer.MAX_VALUE) : \"Precondition failed: The result of n * n will cause integer overflow.\";\n\n        int result = n * n;\n\n        // Postcondition 1: The result should not be negative (since we're counting collisions)\n        assert result >= 0 : \"Postcondition failed: Resulting number of collisions must be non-negative.\";\n\n        // Postcondition 2: If n == 0, the result must be 0 (no cars, no collisions)\n        if (n == 0) {\n            assert result == 0 : \"Postcondition failed: Result should be 0 when no cars are present.\";\n        }\n\n        // Postcondition 3: If n == 1, the result must be 1 (one car in each direction collides exactly once)\n        if (n == 1) {\n            assert result == 1 : \"Postcondition failed: Result should be 1 when there's one car in each direction.\";\n        }\n\n        // Postcondition 4: For any n > 0, the result should equal n squared (since each car collides with every car from the opposite direction)\n        assert result == n * n : \"Postcondition failed: Result does not equal n squared.\";\n\n        // Postcondition 5: The result should be the square of an integer (since we're computing n * n)\n        int sqrtResult = (int) Math.sqrt(result);\n        assert sqrtResult * sqrtResult == result : \"Postcondition failed: The result is not a perfect square.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "SKJKASDKD.java", "content": "package humaneval.buggy;\n\n// You are given a list of integers.\n// You need to find the largest prime value and return the sum of its digits.\n\n// Examples:\n// For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n// For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n// For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n// For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n// For lst = [0,81,12,3,1,21] the output should be 3\n// For lst = [0,8,1,2,1,7] the output should be 7\n\npublic class SKJKASDKD {\n    public static boolean is_prime(int n) {\n        for (int i = 2; i < (int)Math.pow(n, 0.5) + 1; i += 1) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static int skjkasdkd(int[] lst) {\n        int max = 0;\n        int i = 0;\n        while(i < lst.length) {\n            if (lst[i] > max && is_prime(lst[i]))\n                max = lst[i];\n            i += 1;\n        }\n        int result = 0;\n        for (char c : (max + \"\").toCharArray()) {\n            result += c - '0';\n        }\n        return result;\n    }\n}\n"}
{"file_name": "DECODE_CYCLIC.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\n\npublic class DECODE_CYCLIC {\n    public static String decode_cyclic(String str) {\n        class Cyclic {\n            String encode_cyclic(String s) {\n                // Preconditions\n// 1. The input string `str` must not be null\n                assert str != null : \"Precondition failed: Input string 'str' must not be null.\";\n\n// 2. The input string `str` may be empty, which is allowed\n                assert str.length() >= 0 : \"Precondition failed: Input string must be a valid string (even if empty).\";\n\n                ArrayList<String> groups = new ArrayList<String>();\n\n                for (int i = 0; i < s.length() - s.length() % 3; i += 3){\n                    groups.add(s.substring(i, Math.min(s.length(), i + 3)));\n                }\n                int remain = s.length() % 3;\n                \n                String result = \"\";\n                for (String group : groups){\n                    result += group.substring(1) + group.substring(0, 1);\n                }\n\n                if (remain > 0){\n                    result += s.substring(s.length() - remain);\n                }\n\n                return result;\n            }\n        }\n        \n        final Cyclic cyclic = new Cyclic();\n        return cyclic.encode_cyclic(cyclic.encode_cyclic(str));\n    }\n}\n"}
{"file_name": "BY_LENGTH.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/*\n * Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr = [2, 1, 1, 4, 5, 8, 2, 3]\n            -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]\n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n\n      If the array is empty, return an empty array:\n      arr = []\n      return []\n\n      If the array has any strange number ignore it:\n      arr = [1, -1 , 55]\n            -> sort arr -> [-1, 1, 55]\n            -> reverse arr -> [55, 1, -1]\n      return ['One']\n */\n\npublic class BY_LENGTH {\n    public static ArrayList<String> by_length(ArrayList<Integer> a) {\n        // Precondition 1: The input list should not be null\n        assert a != null : \"Precondition failed: Input list must not be null.\";\n\n        // Precondition 2: The input list size should not exceed 1000 (arbitrary upper limit)\n        assert a.size() <= 1000 : \"Precondition failed: Input list size should not exceed 1000.\";\n\n        // Precondition 3: All elements in the input list should be integers\n        for (Integer num : a) {\n            assert num != null : \"Precondition failed: List contains null elements.\";\n        }\n\n        // Precondition 4: Ensure the input list contains both valid and invalid numbers, but they should be integers\n        assert a.stream().allMatch(num -> num instanceof Integer) : \"Precondition failed: List contains non-integer elements.\";\n\n        // Precondition 5: The input list may contain both valid (1-9) and invalid numbers (others will be ignored)\n        // No assertion needed here, as we explicitly handle invalid numbers in the function.\n\n        Map<Integer, String> digit_map = new HashMap<>();\n        digit_map.put(1, \"One\");\n        digit_map.put(2, \"Two\");\n        digit_map.put(3, \"Three\");\n        digit_map.put(4, \"Four\");\n        digit_map.put(5, \"Five\");\n        digit_map.put(6, \"Six\");\n        digit_map.put(7, \"Seven\");\n        digit_map.put(8, \"Eight\");\n        digit_map.put(9, \"Nine\");\n\n        // Filter only valid digits (1-9)\n        ArrayList<Integer> filtered = new ArrayList<>();\n        for (Integer num : a) {\n            if (num >= 1 && num <= 9) {\n                filtered.add(num);\n            }\n        }\n\n        // Sort the filtered list and reverse it\n        Collections.sort(filtered);\n        Collections.reverse(filtered);\n\n        // Map the sorted and reversed digits to their corresponding names\n        ArrayList<String> result = new ArrayList<>();\n        for (int num : filtered) {\n            result.add(digit_map.get(num));\n        }\n\n        // Postcondition 1: The result list must not be null\n        assert result != null : \"Postcondition failed: The result list must not be null.\";\n\n        // Postcondition 2: The result should be empty if the input list had no valid digits (1-9)\n        if (a.stream().noneMatch(num -> num >= 1 && num <= 9)) {\n            assert result.isEmpty() : \"Postcondition failed: Result should be empty if no valid digits are found.\";\n        }\n\n        // Postcondition 3: The result should contain only names of valid digits (1-9)\n        for (String name : result) {\n            assert digit_map.containsValue(name) : \"Postcondition failed: Result contains invalid digit names.\";\n        }\n\n        // Postcondition 4: The result should have the same number of elements as the valid digits in the input\n        long validCount = a.stream().filter(num -> num >= 1 && num <= 9).count();\n        assert result.size() == validCount : \"Postcondition failed: Result size does not match the number of valid digits.\";\n\n        // Postcondition 5: The result should be sorted in reverse order of proximity to the number (i.e., descending)\n        ArrayList<Integer> reverseSortedOriginal = new ArrayList<>(filtered);\n        for (int i = 0; i < result.size(); i++) {\n            assert digit_map.get(reverseSortedOriginal.get(i)).equals(result.get(i)) : \"Postcondition failed: Result list is not in the expected reverse order.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "REVERSE_DELETE.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\n\npublic class REVERSE_DELETE {\n\n    public static ArrayList<Object> reverse_delete(String s, String c) {\n        // Precondition 1: Ensure that 's' and 'c' are not null.\n        assert s != null && c != null : \"Inputs 's' and 'c' must not be null.\";\n\n        // Precondition 2: Ensure that 's' and 'c' are strings.\n        assert s instanceof String && c instanceof String : \"Inputs 's' and 'c' must be strings.\";\n\n        // Precondition 3: Ensure that 's' and 'c' contain only alphabetic characters.\n        assert s.chars().allMatch(Character::isLetter) && c.chars().allMatch(Character::isLetter)\n                : \"Inputs 's' and 'c' must contain only alphabetic characters.\";\n\n        // Perform the reverse delete operation\n        StringBuilder new_s = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            if (c.indexOf(s.charAt(i)) == -1) {\n                new_s.append(s.charAt(i));\n            }\n        }\n\n        String filteredString = new_s.toString();\n\n        // Check if the filtered string is a palindrome\n        String reversedString = new StringBuilder(filteredString).reverse().toString();\n        boolean isPalindrome = filteredString.equals(reversedString);\n\n        // Create the result\n        ArrayList<Object> result = new ArrayList<>();\n        result.add(filteredString);\n        result.add(isPalindrome);\n\n        // Postcondition 1: Ensure that the result is a list.\n        assert result instanceof ArrayList : \"The result must be an ArrayList.\";\n\n        // Postcondition 2: Ensure that the first element of the result is a string.\n        assert result.get(0) instanceof String : \"The first element of the result must be a string.\";\n\n        // Postcondition 3: Ensure that the second element of the result is a boolean.\n        assert result.get(1) instanceof Boolean : \"The second element of the result must be a boolean.\";\n\n        // Postcondition 4: Ensure that the palindrome check is correct.\n        assert isPalindrome == filteredString.equals(reversedString) : \"The palindrome check must be correct.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "DOUBLE_THE_DIFFERENCE.java", "content": "package humaneval.buggy;\n\n/* Given a list of numbers, return the sum of squares of the numbers\nin the list that are odd. Ignore numbers that are negative or not integers.\n\ndouble_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference([-1, -2, 0]) == 0\ndouble_the_difference([9, -2]) == 81\ndouble_the_difference([0]) == 0  \n\nIf the input list is empty, return 0. */\n\npublic class DOUBLE_THE_DIFFERENCE {\n    public static int double_the_difference(double[] lst) {\n        // Preconditions\n// 1. The input list `lst` must not be null\n        assert lst != null : \"Precondition failed: Input list 'lst' must not be null.\";\n\n// 2. The input list may be empty, which is allowed\n        assert lst.length >= 0 : \"Precondition failed: Input list must be valid (even if empty).\";\n\n// 3. The list `lst` should only contain valid numbers (both integers and non-integers are allowed but will be processed as described in the function)\n        for (double d : lst) {\n            assert !Double.isNaN(d) && !Double.isInfinite(d) : \"Precondition failed: Input list contains invalid numbers.\";\n        }\n\n        int result = 0;\n        for (Double d : lst) {\n            if ((int) d.doubleValue() == d) {\n                int d_int = (int) d.doubleValue();\n                if (d_int % 2 == 1 && d_int >= 0) {\n                    result += d_int * d_int;\n                }\n            }\n        }\n        return result;\n    }\n}\n"}
{"file_name": "TOTAL_MATCH.java", "content": "package humaneval.buggy;\n\nimport java.util.List;\n\npublic class TOTAL_MATCH {\n    public static List<String> total_match(List<String> lst1, List<String> lst2) {\n        // Precondition 1: Ensure that both 'lst1' and 'lst2' are not null.\n        assert lst1 != null : \"Precondition failed: 'lst1' must not be null.\";\n        assert lst2 != null : \"Precondition failed: 'lst2' must not be null.\";\n\n        // Precondition 2: Ensure that all elements in 'lst1' and 'lst2' are not null strings.\n        assert lst1.stream().allMatch(str -> str != null) : \"Precondition failed: All elements in 'lst1' must be non-null.\";\n        assert lst2.stream().allMatch(str -> str != null) : \"Precondition failed: All elements in 'lst2' must be non-null.\";\n\n        // Calculate total length of all strings in lst1\n        int l1 = 0;\n        for (String st : lst1) {\n            l1 += st.length();\n        }\n\n        // Calculate total length of all strings in lst2\n        int l2 = 0;\n        for (String st : lst2) {\n            l2 += st.length();\n        }\n\n        // Postcondition 1: Ensure that l1 and l2 are non-negative integers.\n        assert l1 >= 0 : \"Postcondition failed: 'l1' must be a non-negative integer.\";\n        assert l2 >= 0 : \"Postcondition failed: 'l2' must be a non-negative integer.\";\n\n        // Determine which list to return based on total lengths\n        List<String> result;\n        if (l1 <= l2) {\n            result = lst1;\n        } else {\n            result = lst2;\n        }\n\n        // Postcondition 2: Ensure that the result is either 'lst1' or 'lst2'.\n        assert result == lst1 || result == lst2 : \"Postcondition failed: The result must be either 'lst1' or 'lst2'.\";\n\n        // Postcondition 3: Ensure that the result list has the total length less than or equal to the other list.\n        int resultLength = result.stream().mapToInt(String::length).sum();\n        assert resultLength <= l1 && resultLength <= l2 : \"Postcondition failed: The result list must have the total length less than or equal to the other list.\";\n\n        // Postcondition 4: If 'lst1' and 'lst2' have the same total length, the result should be 'lst1'.\n        if (l1 == l2) {\n            assert result == lst1 : \"Postcondition failed: If 'lst1' and 'lst2' have the same total length, the result should be 'lst1'.\";\n        }\n\n        return result;\n    }\n\n\n}\n"}
{"file_name": "SAME_CHARS.java", "content": "package humaneval.buggy;\nimport java.util.HashSet;\n\n/*\n * Check if two words have the same characters.\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * True\n * >>> same_chars('abcd', 'dddddddabc')\n * True\n * >>> same_chars('dddddddabc', 'abcd')\n * True\n * >>> same_chars('eabcd', 'dddddddabc')\n * False\n * >>> same_chars('abcd', 'dddddddabce')\n * False\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n * False\n */\n\npublic class SAME_CHARS {\n    public static boolean same_chars(String s0, String s1) {\n        // Precondition 1: Ensure that 's0' and 's1' are not null.\n        assert s0 != null && s1 != null : \"Inputs 's0' and 's1' must not be null.\";\n\n        // Precondition 2: Ensure that 's0' and 's1' are strings.\n        assert s0 instanceof String && s1 instanceof String : \"Inputs 's0' and 's1' must be strings.\";\n\n        // Convert both strings to sets of characters\n        HashSet<Character> set0 = new HashSet<>();\n        HashSet<Character> set1 = new HashSet<>();\n\n        for (char c : s0.toCharArray()) {\n            set0.add(c);\n        }\n        for (char c : s1.toCharArray()) {\n            set1.add(c);\n        }\n\n        // Calculate the result by comparing the sets\n        boolean result = set0.equals(set1);\n\n        // Postcondition 1: Ensure that the result is a boolean value.\n        assert result == true || result == false : \"The result must be a boolean value.\";\n\n        // Postcondition 2: The result should be True if and only if both strings have the same unique characters.\n        assert result == (set0.equals(set1)) : \"The result must correctly reflect whether both strings have the same unique characters.\";\n\n        return result;\n    }\n\n\n}\n"}
{"file_name": "LARGEST_DIVISOR.java", "content": "package humaneval.buggy;\n\npublic class LARGEST_DIVISOR {\n    public static int largest_divisor(int n) {\n        // Precondition 1: The input 'n' should be a positive integer greater than 1.\n        assert n > 1 : \"Input 'n' must be a positive integer greater than 1.\";\n\n        int result = 1;\n\n        // Find the largest divisor smaller than 'n'\n        for (int i = n - 1; i >= 1; i--) {\n            if (n % i == 0) {\n                result = i;\n                break;\n            }\n        }\n\n        // Postcondition 1: The result should be an integer.\n        assert result == (int) result : \"The result must be an integer.\";\n\n        // Postcondition 2: The result should be a divisor of 'n' and smaller than 'n'.\n        assert n % result == 0 && result < n : \"The result must be a divisor of 'n' and smaller than 'n'.\";\n\n        // Postcondition 3: The result should be the largest divisor of 'n' smaller than 'n'.\n        for (int i = n - 1; i >= 1; i--) {\n            if (n % i == 0) {\n                assert i <= result : \"The result should be the largest divisor of 'n' smaller than 'n'.\";\n                break;\n            }\n        }\n\n\n        return result;\n    }\n}\n"}
{"file_name": "SMALLEST_CHANGE.java", "content": "package humaneval.buggy;\npublic class SMALLEST_CHANGE {\n    public static int smallest_change(int[] arr) {\n        // Preconditions:\n\n        // Precondition 1: The input 'arr' should not be null.\n        assert arr != null : \"Input 'arr' must not be null.\";\n\n        // Precondition 2: The input 'arr' should be an array of integers with at least one element.\n        assert arr.length > 0 : \"Input 'arr' must have at least one element.\";\n\n        // Postcondition 3: All elements in 'arr' should be integers (implicit in Java since it's an int array).\n\n        // Variable to store the number of changes required\n        int result = 0;\n\n        // Loop through the array, comparing elements from both ends towards the middle\n        for (int i = 0; i < arr.length / 2; i += 1) {\n            // If elements at corresponding positions are different, increment the result count\n            if (arr[i] != arr[arr.length - i - 1]) {\n                result += 1;\n            }\n        }\n\n        // Postconditions:\n\n        // Postcondition 1: The result should be a non-negative integer.\n        assert result >= 0 : \"The result must be a non-negative integer.\";\n\n        // Postcondition 2: Ensure that the result does not exceed half the length of the array,\n        // because at most, every pair in the first half needs to be changed.\n        assert result <= arr.length / 2 : \"The result must not exceed half the length of the array.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the preconditions and postconditions\n        System.out.println(smallest_change(new int[]{1, 2, 3, 5, 4, 7, 9, 6})); // Output: 4\n        System.out.println(smallest_change(new int[]{1, 2, 3, 4, 3, 2, 2})); // Output: 1\n        System.out.println(smallest_change(new int[]{1, 2, 3, 2, 1})); // Output: 0\n    }\n}\n\n"}
{"file_name": "LARGEST_PRIME_FACTOR.java", "content": "package humaneval.buggy;\n\npublic class LARGEST_PRIME_FACTOR {\n\n    // Helper function to check if a number is prime\n    public static boolean is_prime(int k) {\n        if (k < 2) {\n            return false;\n        }\n        for (int i = 2; i * i <= k; i += 1) {\n            if (k % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int largest_prime_factor(int n) {\n        // Precondition 1: Ensure that 'n' is greater than 1.\n        assert n > 1 : \"Input 'n' must be greater than 1.\";\n\n        int largest = -1;\n\n        // Divide n by 2 until it's odd\n        while (n % 2 == 0) {\n            largest = 2;\n            n /= 2;\n        }\n\n        // If the result is 1, then 2 is the largest prime factor\n        if (n == 1) {\n            return largest;\n        }\n\n        // Now n is odd. Check divisibility by odd numbers starting from 3.\n        for (int factor = 3; factor * factor <= n; factor += 2) {\n            while (n % factor == 0) {\n                largest = factor;\n                n /= factor;\n            }\n        }\n\n        // If n is still greater than 2, then it's prime and the largest factor.\n        if (n > 2) {\n            largest = n;\n        }\n\n        // Postcondition 1: The result should be an integer greater than 1.\n        assert largest > 1 : \"The result must be an integer greater than 1.\";\n\n        // Postcondition 2: The result should be a prime number.\n        assert is_prime(largest) : \"The result must be a prime number.\";\n\n        // Postcondition 3: The result should be a factor of the original number 'n'.\n        // To check this, we need to recompute the original value of 'n'.\n        int original_n = n * largest;\n        assert original_n % largest == 0 : \"The result must be a factor of the original number.\";\n\n        return largest;\n    }\n}\n"}
{"file_name": "GET_ODD_COLLATZ.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/*\n * Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the\n    previous term as follows: if the previous term is even, the next term is one half of\n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note:\n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n */\n\npublic class GET_ODD_COLLATZ {\n    public static ArrayList<Integer> get_odd_collatz(int n) {\n        ArrayList<Integer> result = new ArrayList<>();\n        if((n % 2) == 1) result.add(n);\n        while(n > 1) {\n            if((n % 2) == 0) n /= 2;\n            else n = 3 * n + 1;\n            if((n % 2) == 1) result.add(n);\n        }\n        Collections.sort(result);\n        return result;\n    }\n}\n"}
{"file_name": "FACTORIZE.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FACTORIZE {\n\n    public static List<Integer> factorize(int n) {\n        // Precondition 1: Ensure that 'n' is a positive integer greater than 1.\n        assert n > 1 : \"Input 'n' must be a positive integer greater than 1.\";\n\n        List<Integer> result = new ArrayList<>();\n\n        int original_n = n;  // Save the original value of 'n'\n        int i = 2;\n\n        while (i <= (int) (Math.sqrt(n) + 1)) {\n            if (n % i == 0) {\n                result.add(i);\n                n = n / i;\n            } else {\n                i += 1;\n            }\n        }\n\n        if (n > 1) {\n            result.add(n);\n        }\n\n        // Postcondition 1: Ensure that the result is a list of integers.\n        assert result.stream().allMatch(x -> x instanceof Integer) : \"The result must be a list of integers.\";\n\n        // Postcondition 2: Ensure that the product of all elements in the result equals the original 'n'.\n        int productOfFactors = 1;\n        for (int factor : result) {\n            productOfFactors *= factor;\n        }\n        assert original_n == productOfFactors : \"The product of the factors should equal the original input 'n'.\";\n\n        // Postcondition 3: Ensure that all elements in the result are prime numbers.\n        assert result.stream().allMatch(FACTORIZE::isPrime) : \"All elements in the result list must be prime numbers.\";\n\n        // Postcondition 4: Ensure that the factors are sorted in ascending order.\n        List<Integer> sortedResult = new ArrayList<>(result);\n        sortedResult.sort(Integer::compareTo);\n        assert result.equals(sortedResult) : \"The factors should be sorted in ascending order.\";\n\n        return result;\n    }\n\n    // Helper function to check if a number is prime\n    private static boolean isPrime(int x) {\n        if (x <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(x); i++) {\n            if (x % i == 0) return false;\n        }\n        return true;\n    }\n}\n"}
{"file_name": "MATCH_PARENS.java", "content": "package humaneval.buggy;\n\npublic class MATCH_PARENS {\n\n    // Helper function to check if a string has balanced parentheses\n    public static boolean check(String s) {\n        int val = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                val++;\n            } else {\n                val--;\n            }\n            if (val < 0) {\n                return false;\n            }\n        }\n        return val == 0;\n    }\n\n    public static String match_parens(String[] lst) {\n        // Precondition 1: Ensure that 'lst' is not null.\n        assert lst != null : \"Input 'lst' must not be null.\";\n\n        // Precondition 2: Ensure that 'lst' is a list of two elements.\n        assert lst.length == 2 : \"Input 'lst' must be a list of two strings.\";\n\n        // Precondition 3: Ensure that both elements in 'lst' are strings.\n        assert lst[0] != null && lst[1] != null : \"Both elements in 'lst' must be non-null strings.\";\n\n        // Precondition 4: Ensure that both strings contain only '(' and ')'.\n        assert lst[0].matches(\"[()]*\") && lst[1].matches(\"[()]*\") : \"Strings must contain only '(' and ')'.\";\n\n        // Check if either concatenation results in a balanced string\n        String S1 = lst[0] + lst[1];\n        String S2 = lst[1] + lst[0];\n        String result = (check(S1) || check(S2)) ? \"Yes\" : \"No\";\n\n        // Postcondition 1: Ensure that the result is a string.\n        assert result instanceof String : \"The result must be a string.\";\n\n        // Postcondition 2: Ensure that the result is either 'Yes' or 'No'.\n        assert result.equals(\"Yes\") || result.equals(\"No\") : \"The result must be either 'Yes' or 'No'.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "STRANGE_SORT_LIST.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/*\n * Given a list of integers, return the list in strange order.\n * Strange sorting is when you start with the minimum value,\n * then maximum of the remaining integers, then minimum, and so on.\n *\n * Examples:\n * strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n * strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n * strange_sort_list([]) == []\n */\n\npublic class STRANGE_SORT_LIST {\n\n    public static List<Integer> strange_sort_list(List<Integer> lst) {\n        // Precondition 1: Ensure that 'lst' is not null.\n        if (lst == null) {\n            throw new IllegalArgumentException(\"Input list 'lst' must not be null.\");\n        }\n\n        // Precondition 2: Ensure that 'lst' contains only integers.\n        for (Object elem : lst) {\n            if (!(elem instanceof Integer)) {\n                throw new IllegalArgumentException(\"All elements in the list 'lst' must be integers.\");\n            }\n        }\n\n        // Copy the list to avoid modifying the original list\n        List<Integer> tempList = new ArrayList<>(lst);\n        List<Integer> result = new ArrayList<>();\n\n        boolean switched = true; // Flag to switch between min and max\n\n        while (!tempList.isEmpty()) {\n            if (switched) {\n                result.add(Collections.min(tempList));\n            } else {\n                result.add(Collections.max(tempList));\n            }\n            tempList.remove(result.get(result.size() - 1));\n            switched = !switched; // Toggle the flag\n        }\n\n        // Postcondition 1: Ensure that the result list is not null.\n        if (result == null) {\n            throw new AssertionError(\"The result must not be null.\");\n        }\n\n        // Postcondition 2: Ensure that the length of the result list matches the input list.\n        if (result.size() != lst.size()) {\n            throw new AssertionError(\"The length of the result list must match the length of the input list.\");\n        }\n\n        // Postcondition 3: Ensure that the result list contains the same elements as the input list.\n        List<Integer> sortedLst = new ArrayList<>(lst);\n        Collections.sort(sortedLst);\n        List<Integer> sortedResult = new ArrayList<>(result);\n        Collections.sort(sortedResult);\n        if (!sortedLst.equals(sortedResult)) {\n            throw new AssertionError(\"The result list must contain the same elements as the input list.\");\n        }\n\n        return result;\n    }\n\n\n}\n"}
{"file_name": "ENCRYPT.java", "content": "package humaneval.buggy;\n\n/* Create a function encrypt that takes a string as an argument and\nreturns a string encrypted with the alphabet being rotated. \nThe alphabet should be rotated in a manner such that the letters \nshift down by two multiplied to two places.\nFor example:\nencrypt('hi') returns 'lm'\nencrypt('asdfghjkl') returns 'ewhjklnop'\nencrypt('gf') returns 'kj'\nencrypt('et') returns 'ix' */\n\npublic class ENCRYPT {\n    public static String encrypt(String s) {\n        StringBuilder sb = new StringBuilder();\n        String d = \"abcdefghijklmnopqrstuvwxyz\";\n        for (char c : s.toCharArray()){\n            if ('a' <= c && c <= 'z'){\n                sb.append(\n                    d.charAt((d.indexOf((int) c) + 2 * 2) % 26)\n                );\n            } else {\n                sb.append(c);\n            }\n        }\n\n        return sb.toString();\n    }\n}\n"}
{"file_name": "IS_EQUAL_TO_SUM_EVEN.java", "content": "package humaneval.buggy;\n\n/*\n * Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n *\n * Example:\n * is_equal_to_sum_even(4) == False\n * is_equal_to_sum_even(6) == False\n * is_equal_to_sum_even(8) == True\n */\n\npublic class IS_EQUAL_TO_SUM_EVEN {\n    public static boolean is_equal_to_sum_even(int n) {\n        // Precondition 1: Ensure that 'n' is a positive integer.\n        assert n > 0 : \"Input 'n' must be a positive integer.\";\n\n        // Check if the number can be written as the sum of 4 positive even numbers.\n        boolean result = (n % 2 == 0) && (n >= 8);\n\n\n        return result;\n    }\n}\n"}
{"file_name": "CHECK_IF_LAST_CHAR_IS_A_LETTER.java", "content": "package humaneval.buggy;\n\n/*\n * Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False\n\n */\n\npublic class CHECK_IF_LAST_CHAR_IS_A_LETTER {\n    public static boolean check_if_last_char_is_a_letter(String txt) {\n        // Precondition 1: The input string should not be null\n        assert txt != null : \"Precondition failed: Input string must not be null.\";\n\n        // Precondition 2: The input string can be empty, but not null (handled in code)\n        // Precondition 3: Ensure the string only contains valid characters (no control characters)\n        assert txt.chars().allMatch(c -> Character.isLetterOrDigit(c) || Character.isWhitespace(c))\n                : \"Precondition failed: String contains invalid characters.\";\n\n        // Precondition 4: The input string length should not exceed 1000 characters (arbitrary upper limit)\n        assert txt.length() <= 1000 : \"Precondition failed: Input string length exceeds 1000 characters.\";\n\n        // Precondition 5: The input string should not consist only of spaces\n        assert !txt.trim().isEmpty() || txt.isEmpty() : \"Precondition failed: Input must not consist solely of spaces.\";\n\n        // Original code logic\n        String[] parts = txt.split(\" \");\n        String last = \" \";\n        if(parts.length != 0) last = parts[parts.length - 1];\n        if(txt.length() != 0 && txt.charAt(txt.length() - 1) == ' ') last = \" \";\n        if(txt.length() == 0) last = \" \";\n        int last_char_pos = Character.toLowerCase(last.charAt(0)) - 'a';\n        boolean result = (last.length() == 1) && (0 <= last_char_pos && last_char_pos <= 25);\n\n        // Postcondition 1: The result should be false for an empty string\n        assert !(txt.isEmpty() && result) : \"Postcondition failed: Result should be false for an empty string.\";\n\n        // Postcondition 2: The result should be false if the last character is a space\n        if (!txt.isEmpty() && txt.charAt(txt.length() - 1) == ' ') {\n            assert !result : \"Postcondition failed: Result should be false when the last character is a space.\";\n        }\n\n\n\n        // Postcondition 4: If the last part of the string is longer than one character, the result should be false\n        assert !(last.length() > 1 && result) : \"Postcondition failed: The result should be false if the last part of the string is a word.\";\n\n\n        return result;\n    }\n}\n"}
{"file_name": "MEAN_ABSOLUTE_DEVIATION.java", "content": "package humaneval.buggy;\n\nimport java.util.List;\n\npublic class MEAN_ABSOLUTE_DEVIATION {\n    public static double mean_absolute_deviation(List<Double> numbers) {\n        // Precondition 1: Ensure that 'numbers' is not null.\n        assert numbers != null : \"Input list 'numbers' must not be null.\";\n\n        // Precondition 2: Ensure that 'numbers' is a list.\n        assert numbers instanceof List<?> : \"Input 'numbers' must be a list.\";\n\n        // Precondition 3: Ensure that the list 'numbers' is not empty.\n        assert numbers.size() > 0 : \"Input list 'numbers' must not be empty.\";\n\n        // Precondition 4: Ensure that all elements in 'numbers' are either integers or floats.\n        for (Object num : numbers) {\n            assert num instanceof Number : \"All elements in 'numbers' must be integers or floats.\";\n        }\n\n        // Calculate the mean of the numbers\n        double sum = 0.0;\n        for (Double number : numbers) {\n            sum += number;\n        }\n        double mean = sum / numbers.size();\n\n        // Calculate the mean absolute deviation\n        double deviation_sum = 0.0;\n        for (Double number : numbers) {\n            deviation_sum += Math.abs(number - mean);\n        }\n        double result = deviation_sum / numbers.size();\n\n        // Postcondition 1: Ensure that the result is a non-negative number.\n        assert result >= 0 : \"The result must be a non-negative number.\";\n\n        // Postcondition 2: Ensure that the result is of type double.\n        assert result == (double) result : \"The result must be of type double.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "FRUIT_DISTRIBUTION.java", "content": "package humaneval.buggy;\n\npublic class FRUIT_DISTRIBUTION {\n\n    public static int fruit_distribution(String s, int n) {\n        // Precondition 1: Ensure that 's' and 'n' are not null.\n        assert s != null : \"Input 's' must not be null.\";\n        assert n > 0 : \"Input 'n' must be a positive integer.\";\n\n        // Precondition 2: Ensure that 's' is a string and 'n' is an integer.\n        assert s instanceof String : \"Input 's' must be a string.\";\n        assert n >= 0 : \"Input 'n' must be a non-negative integer.\";\n\n        // Split the input string by spaces to extract numbers\n        int result = n;\n        String[] words = s.split(\" \");\n        int appleCount = 0;\n        int orangeCount = 0;\n\n        // Extract the apple and orange counts\n        try {\n            appleCount = Integer.parseInt(words[0]);\n            orangeCount = Integer.parseInt(words[3]);\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(\"Invalid input format for apples or oranges count.\");\n        }\n\n        // Precondition 3: Ensure that appleCount and orangeCount are non-negative and n is large enough.\n        assert appleCount >= 0 && orangeCount >= 0 : \"The number of apples and oranges must be non-negative.\";\n        assert n >= (appleCount + orangeCount) : \"The total number of fruits must be at least the sum of apples and oranges.\";\n\n        // Calculate the number of mangoes\n        result = n - appleCount - orangeCount;\n\n        // Postcondition 1: Ensure that the result is an integer.\n        assert result >= 0 : \"The result (number of mangoes) must be a non-negative integer.\";\n\n        // Postcondition 2: Ensure that the sum of apples, oranges, and mangoes equals the total number of fruits.\n        assert appleCount + orangeCount + result == n : \"The sum of apples, oranges, and mangoes must equal the total number of fruits.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "INTERSECTION.java", "content": "package humaneval.buggy;\n\npublic class INTERSECTION {\n\n    // Check if a number is prime\n    public static boolean is_prime(int num) {\n        if (num < 2) return false;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static String intersection(int[] interval1, int[] interval2) {\n        // Precondition 1: Ensure that both intervals have exactly two elements.\n        assert interval1.length == 2 : \"interval1 must contain exactly two elements.\";\n        assert interval2.length == 2 : \"interval2 must contain exactly two elements.\";\n\n        // Precondition 2: Ensure that the start of each interval is less than or equal to its end.\n        assert interval1[0] <= interval1[1] : \"Start of interval1 must be less than or equal to its end.\";\n        assert interval2[0] <= interval2[1] : \"Start of interval2 must be less than or equal to its end.\";\n\n        // Find the intersection\n        int l = Math.max(interval1[0], interval2[0]);\n        int r = Math.min(interval1[1], interval2[1]);\n        int intersection_length = r - l;\n\n\n\n        // Postcondition 2: Ensure the result is either \"YES\" or \"NO\".\n        String result = (intersection_length > 0 && is_prime(intersection_length)) ? \"YES\" : \"NO\";\n        assert result.equals(\"YES\") || result.equals(\"NO\") : \"The result must be either 'YES' or 'NO'.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "HOW_MANY_TIMES.java", "content": "package humaneval.buggy;\n\npublic class HOW_MANY_TIMES {\n\n    public static int how_many_times(String string, String substring) {\n        // Precondition 1: Ensure that 'string' and 'substring' are not null.\n        assert string != null : \"Input 'string' must not be null.\";\n        assert substring != null : \"Input 'substring' must not be null.\";\n\n        // Precondition 2: Ensure that 'substring' is not empty.\n        assert !substring.isEmpty() : \"Input 'substring' must not be empty.\";\n\n        int times = 0;\n        // Count how many times the substring appears in the string, including overlapping occurrences.\n        for (int i = 0; i <= string.length() - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                times++;\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is a non-negative integer.\n        assert times >= 0 : \"The result must be a non-negative integer.\";\n\n        // Postcondition 2: Ensure that the result is correct by counting the expected number of occurrences.\n        int expectedCount = 0;\n        for (int i = 0; i <= string.length() - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                expectedCount++;\n            }\n        }\n        assert times == expectedCount : \"The result does not match the expected number of occurrences.\";\n\n        return times;\n    }\n}\n"}
{"file_name": "COMMON.java", "content": "package humaneval.buggy;\n\nimport java.util.*;\n\n// Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\n\npublic class COMMON {\n    public static int[] common(int[] l1, int[] l2) {\n        HashSet<Integer> common = new HashSet<Integer>();\n        \n        for (int i = 0; i < l1.length; i += 1){\n            for (int j = 0; j < l2.length; j += 1){\n                if (l1[i] == l2[j])\n                    common.add(l1[i]);\n            }\n        }\n        int[] result = new int[common.size()];\n        int index = 0;\n        for (Integer c : common) {\n            result[index] = c;\n            index += 1;\n        }\n        Arrays.sort(result);\n        return result;\n    }\n}\n"}
{"file_name": "PARSE_NESTED_PARENS.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PARSE_NESTED_PARENS {\n\n    public static List<Integer> parse_nested_parens(String paren_string) {\n        // Precondition 1: The input 'paren_string' should not be null.\n        assert paren_string != null : \"Input string 'paren_string' must not be null.\";\n\n        // Precondition 2: The input should be a string.\n        assert paren_string instanceof String : \"Input 'paren_string' must be a string.\";\n\n        // Precondition 3: The input should only contain '(', ')', and spaces.\n        for (char ch : paren_string.toCharArray()) {\n            assert ch == '(' || ch == ')' || ch == ' ' : \"Input string should only contain '(', ')', and spaces.\";\n        }\n\n        // Precondition 4: Each group of parentheses in the input string should be balanced.\n        for (String group : paren_string.split(\" \")) {\n            if (!group.isEmpty()) {\n                assert is_balanced(group) : \"Each group of parentheses must be balanced.\";\n            }\n        }\n\n        // Precondition 5: The input string length should be within a reasonable boundary.\n        int max_length = 1_000_000; // Example boundary condition; adjust as needed.\n        assert paren_string.length() <= max_length : \"Input string should not exceed \" + max_length + \" characters.\";\n\n        String[] paren_groups = paren_string.split(\" \");\n        List<Integer> result = new ArrayList<Integer>();\n\n        for (String paren_group : paren_groups) {\n            if (!paren_group.isEmpty()) {\n                int depth = 0;\n                int max_depth = 0;\n                for (char c : paren_group.toCharArray()) {\n                    if (c == '(') {\n                        depth += 1;\n                        max_depth = Math.max(depth, max_depth);\n                    } else if (c == ')') {\n                        depth -= 1;\n                    }\n                }\n                result.add(max_depth);\n            }\n        }\n\n        // Postcondition 1: The result should be a list of integers.\n        assert result instanceof List : \"The result must be a list.\";\n        for (Integer depth : result) {\n            assert depth instanceof Integer : \"The result must be a list of integers.\";\n        }\n\n        // Postcondition 2: The length of the result list should match the number of groups in the input string.\n        int num_groups = (int) paren_string.chars().filter(c -> c == '(' || c == ')').count();\n        assert result.size() == paren_groups.length || num_groups == 0 :\n                \"The length of the result list should match the number of groups in the input string.\";\n\n        // Postcondition 3: Each element in the result list should be a non-negative integer.\n        for (int depth : result) {\n            assert depth >= 0 : \"Each depth value in the result list should be non-negative.\";\n        }\n\n        // Postcondition 4: The maximum depth should be correct based on the input structure.\n        for (int i = 0; i < paren_groups.length; i++) {\n            String group = paren_groups[i];\n            if (!group.isEmpty()) {\n                assert result.get(i) == count_depth(group) : \"The calculated maximum depth should match the input structure.\";\n            }\n        }\n\n        // Postcondition 5: If the input string is empty or contains only spaces, the result should be an empty list.\n        if (paren_string.trim().isEmpty()) {\n            assert result.isEmpty() : \"If the input string is empty or spaces, the result should be an empty list.\";\n        }\n\n        return result;\n    }\n\n    // Helper function to check if a string of parentheses is balanced.\n    private static boolean is_balanced(String s) {\n        int count = 0;\n        for (char ch : s.toCharArray()) {\n            if (ch == '(') {\n                count += 1;\n            } else if (ch == ')') {\n                count -= 1;\n            }\n            if (count < 0) {\n                return false;\n            }\n        }\n        return count == 0;\n    }\n\n    // Helper function to count the maximum depth of nested parentheses.\n    private static int count_depth(String s) {\n        int depth = 0;\n        int max_depth = 0;\n        for (char ch : s.toCharArray()) {\n            if (ch == '(') {\n                depth += 1;\n                max_depth = Math.max(depth, max_depth);\n            } else if (ch == ')') {\n                depth -= 1;\n            }\n        }\n        return max_depth;\n    }\n}\n"}
{"file_name": "STRONGEST_EXTENSION.java", "content": "package humaneval.buggy;\n\npublic class STRONGEST_EXTENSION {\n    public static String strongest_extension(String class_name, String[] extensions) {\n        // Precondition 1: Ensure that 'class_name' is not null and not empty.\n        assert class_name != null : \"Precondition failed: 'class_name' must not be null.\";\n        assert !class_name.isEmpty() : \"Precondition failed: 'class_name' must not be empty.\";\n\n        // Precondition 2: Ensure that 'extensions' is not null and has at least one element.\n        assert extensions != null : \"Precondition failed: 'extensions' must not be null.\";\n        assert extensions.length > 0 : \"Precondition failed: 'extensions' must contain at least one extension.\";\n\n        // Precondition 3: Ensure that all extensions in 'extensions' array are not null and not empty.\n        for (String ext : extensions) {\n            assert ext != null : \"Precondition failed: Each extension in 'extensions' must not be null.\";\n            assert !ext.isEmpty() : \"Precondition failed: Each extension in 'extensions' must not be empty.\";\n        }\n\n        String strong = null;\n        int val = Integer.MIN_VALUE;\n\n        // Calculate the strength of each extension\n        for (String s : extensions) {\n            int CAP = 0;\n            int SM = 0;\n            for (char c : s.toCharArray()) {\n                if (Character.isUpperCase(c)) {\n                    CAP += 1;\n                }\n                if (Character.isLowerCase(c)) {\n                    SM += 1;\n                }\n            }\n\n            // Postcondition 1: Ensure that the calculated strength is correct.\n            int strength = CAP - SM;\n            assert strength == CAP - SM : \"Postcondition failed: Calculated strength should be equal to CAP - SM.\";\n\n            // Update the strongest extension\n            if (strength > val) {\n                val = strength;\n                strong = s;\n            }\n        }\n\n        // Postcondition 2: Ensure that 'strong' is not null and is a valid extension from the list.\n        assert strong != null : \"Postcondition failed: The strongest extension must not be null.\";\n        boolean isValidExtension = false;\n        for (String ext : extensions) {\n            if (ext.equals(strong)) {\n                isValidExtension = true;\n                break;\n            }\n        }\n        assert isValidExtension : \"Postcondition failed: The strongest extension must be from the original 'extensions' list.\";\n\n        // Postcondition 3: Ensure that the resulting string format is 'class_name.extension'.\n        String result = class_name + \".\" + strong;\n        assert result.equals(class_name + \".\" + strong) : \"Postcondition failed: The result format must be 'class_name.extension'.\";\n\n        // Postcondition 4: Ensure that the class name is not altered.\n        assert result.startsWith(class_name + \".\") : \"Postcondition failed: The result must start with the original 'class_name'.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the function\n        System.out.println(strongest_extension(\"my_class\", new String[]{\"AA\", \"Be\", \"CC\"})); // Expected: 'my_class.AA'\n        System.out.println(strongest_extension(\"Slices\", new String[]{\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"})); // Expected: 'Slices.SErviNGSliCes'\n    }\n}\n"}
{"file_name": "CHECK_DICT_CASE.java", "content": "package humaneval.buggy;\n\nimport java.util.HashMap;\n\n// Given a dictionary, return True if all keys are strings in lower \n// case or all keys are strings in upper case, else return False.\n// The function should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\npublic class CHECK_DICT_CASE {\n    public static boolean check_dict_case(HashMap<Object, Object> dict) {\n        if (dict.size() == 0)\n            return false;\n        else {\n            String state = \"start\";\n            for (Object key : dict.keySet()) {\n                if (!(key instanceof String)) {\n                    state = \"mixed\";\n                    break;\n                }\n                String str_key = (String) key;\n                if (state.equals(\"start\")) {\n                    if (str_key.toUpperCase().equals(str_key))\n                        state = \"upper\";\n                    else if (str_key.toLowerCase().equals(str_key))\n                        state = \"lower\";\n                    else {\n                        state = \"mixed\";\n                        break;\n                    }\n                } else if ((state.equals(\"upper\") && !str_key.toUpperCase().equals(str_key))\n                        || (state.equals(\"lower\") && !str_key.toLowerCase().equals(str_key))) {\n                    state = \"mixed\";\n                    break;\n                }\n            }\n            return (state.equals(\"upper\")) || (state.equals(\"lower\"));\n        }\n    }\n}\n"}
{"file_name": "FLIP_CASE.java", "content": "package humaneval.buggy;\n\npublic class FLIP_CASE {\n\n    public static String flip_case(String string) {\n        // Precondition 1: Ensure that the input 'string' is not null.\n        assert string != null : \"Input 'string' must not be null.\";\n\n        // Precondition 2: Ensure that 'string' is a valid string.\n        assert string instanceof String : \"Input 'string' must be a string.\";\n\n        char[] char_list = string.toCharArray();\n\n        for (int i = 0; i < char_list.length; i++) {\n            char c = char_list[i];\n            if (Character.isLowerCase(c)) {\n                char_list[i] = Character.toUpperCase(c);\n            } else if (Character.isUpperCase(c)) {\n                char_list[i] = Character.toLowerCase(c);\n            }\n        }\n\n        String result = new String(char_list);\n\n        // Postcondition 1: Ensure that the result is a string.\n        assert result instanceof String : \"The result must be a string.\";\n\n        // Postcondition 2: Ensure that all lowercase characters are flipped to uppercase and vice versa.\n        for (int i = 0; i < string.length(); i++) {\n            char originalChar = string.charAt(i);\n            char flippedChar = result.charAt(i);\n            if (Character.isUpperCase(originalChar)) {\n                assert Character.isLowerCase(flippedChar) : \"Character '\" + originalChar + \"' should be flipped to lowercase in the result.\";\n            } else if (Character.isLowerCase(originalChar)) {\n                assert Character.isUpperCase(flippedChar) : \"Character '\" + originalChar + \"' should be flipped to uppercase in the result.\";\n            }\n        }\n\n        // Postcondition 3: Ensure that the length of the result matches the length of the input string.\n        assert result.length() == string.length() : \"The length of the result must match the length of the input string.\";\n\n        // Postcondition 4: Ensure that non-alphabetical characters remain unchanged in the result.\n        for (int i = 0; i < string.length(); i++) {\n            if (!Character.isLetter(string.charAt(i))) {\n                assert string.charAt(i) == result.charAt(i) : \"Non-alphabetical character '\" + string.charAt(i) + \"' should remain unchanged.\";\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "SPLIT_WORDS.java", "content": "package humaneval.buggy;\n\n/*\n * Given a string of words, return a list of words split on whitespace. If no whitespace exists in the text, you\n * should split on commas ','. If no commas exist, you should return the number of lower-case letters with odd order in the\n * alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n * Examples\n * split_words(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n * split_words(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n * split_words(\"abcdef\") == 3\n */\n\npublic class SPLIT_WORDS {\n\n    public static String[] split_words(String txt) {\n        // Precondition 1: Ensure the input 'txt' is not null.\n        if (txt == null) {\n            throw new IllegalArgumentException(\"Input 'txt' must not be null.\");\n        }\n\n        // Precondition 2: Ensure the input 'txt' is a string.\n        if (!(txt instanceof String)) {\n            throw new IllegalArgumentException(\"Input 'txt' must be a string.\");\n        }\n\n        // Precondition 3: Ensure the length of 'txt' is within a reasonable boundary.\n        int maxLength = 10_000; // Example boundary condition; adjust as needed.\n        if (txt.length() > maxLength) {\n            throw new IllegalArgumentException(\"Input 'txt' should not exceed \" + maxLength + \" characters.\");\n        }\n\n        String[] result;\n\n        if (txt.contains(\" \")) {\n            result = txt.split(\" \");\n        } else if (txt.contains(\",\")) {\n            result = txt.split(\",\");\n        } else {\n            int count = 0;\n            for (int i = 0; i < txt.length(); i++) {\n                char curr = txt.charAt(i);\n                if (Character.isLowerCase(curr) && ((curr - 'a') % 2) == 1) {\n                    count++;\n                }\n            }\n            result = new String[]{Integer.toString(count)};\n        }\n\n        // Postcondition 1: Ensure the result is not null and contains at least one element.\n        if (result == null || result.length == 0) {\n            throw new AssertionError(\"The result must be a non-null array with at least one element.\");\n        }\n\n        // Postcondition 2: Ensure the result is a non-empty array of strings.\n        for (String str : result) {\n            if (str == null || str.isEmpty()) {\n                throw new AssertionError(\"Each element in the result must be a non-empty string.\");\n            }\n        }\n\n        // Postcondition 3: If the result is a count, ensure it is a non-negative integer in string form.\n        if (result.length == 1) {\n            try {\n                int countValue = Integer.parseInt(result[0]);\n                if (countValue < 0) {\n                    throw new AssertionError(\"The count value must be a non-negative integer.\");\n                }\n            } catch (NumberFormatException e) {\n                throw new AssertionError(\"The result must contain a valid integer string if there are no splits.\");\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the function\n        System.out.println(String.join(\", \", split_words(\"Hello world!\"))); // Expected: [\"Hello\", \"world!\"]\n        System.out.println(String.join(\", \", split_words(\"Hello,world!\"))); // Expected: [\"Hello\", \"world!\"]\n        System.out.println(String.join(\", \", split_words(\"abcdef\"))); // Expected: [\"3\"]\n    }\n}\n"}
{"file_name": "SIMPLIFY.java", "content": "package humaneval.buggy;\n\n/* Your task is to implement a function that will simplify the expression\nx * n. The function returns True if x * n evaluates to a whole number and False\notherwise. Both x and n, are string representation of a fraction, and have the following format,\n<numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\nYou can assume that x, and n are valid fractions, and do not have zero as denominator.\n\nsimplify(\"1/5\", \"5/1\") = True\nsimplify(\"1/6\", \"2/1\") = False\nsimplify(\"7/10\", \"10/2\") = False */\n\npublic class SIMPLIFY {\n\n    public static boolean simplify(String x, String n) {\n        // Preconditions:\n        // Precondition 1: Ensure that 'x' and 'n' are not null.\n        assert x != null : \"Input 'x' must not be null.\";\n        assert n != null : \"Input 'n' must not be null.\";\n\n        // Precondition 2: Ensure that 'x' and 'n' are valid fraction strings with format \"numerator/denominator\".\n        assert x.matches(\"\\\\d+/\\\\d+\") : \"Input 'x' must be in the format 'numerator/denominator' with positive integers.\";\n        assert n.matches(\"\\\\d+/\\\\d+\") : \"Input 'n' must be in the format 'numerator/denominator' with positive integers.\";\n\n        // Split the input fractions into numerators and denominators\n        int a = Integer.parseInt(x.split(\"/\")[0]);\n        int b = Integer.parseInt(x.split(\"/\")[1]);\n        int c = Integer.parseInt(n.split(\"/\")[0]);\n        int d = Integer.parseInt(n.split(\"/\")[1]);\n\n        // Precondition 3: Ensure that denominators are not zero (should be positive as per input format).\n        assert b > 0 : \"Denominator of 'x' must be a positive integer.\";\n        assert d > 0 : \"Denominator of 'n' must be a positive integer.\";\n\n        // Calculate the product of the numerators and the product of the denominators\n        int numerator = a * c;\n        int denominator = b * d;\n\n        // Simplify the fraction numerator/denominator\n        int gcd = gcd(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n\n        // Postcondition 1: Ensure that the result is a boolean.\n        boolean result = denominator == 1;\n        assert result == true || result == false : \"The result must be a boolean value.\";\n\n        // Postcondition 2: Ensure that if the fraction is simplified to a whole number, the denominator must be 1.\n        if (result) {\n            assert denominator == 1 : \"If the result is true, the denominator must be 1.\";\n        }\n\n        // Postcondition 3: Ensure that if the product is not a whole number, the denominator must be greater than 1.\n        if (!result) {\n            assert denominator > 1 : \"If the result is false, the denominator must be greater than 1.\";\n        }\n\n        return result;\n    }\n\n    // Helper function to find the greatest common divisor (GCD) of two numbers\n    private static int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(simplify(\"1/5\", \"5/1\")); // true\n        System.out.println(simplify(\"1/6\", \"2/1\")); // false\n        System.out.println(simplify(\"7/10\", \"10/2\")); // false\n        System.out.println(simplify(\"3/4\", \"4/3\")); // true\n    }\n}\n"}
{"file_name": "SELECT_WORDS.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\n\n/*\n * Given a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.\n    Examples:\n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n */\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n/*\n * Given a string s and a natural number n, implement a function that returns\n * a list of all words from string s that contain exactly n consonants,\n * in the order these words appear in the string s.\n * If the string s is empty, the function should return an empty list.\n * Note: you may assume the input string contains only letters and spaces.\n *\n * Examples:\n * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n * select_words(\"simple white space\", 2) ==> []\n * select_words(\"Hello world\", 4) ==> [\"world\"]\n * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n */\n\npublic class SELECT_WORDS {\n    public static ArrayList<String> select_words(String s, int n) {\n        // Precondition 1: The input string 's' should not be null.\n        assert s != null : \"Input 's' must not be null.\";\n\n        // Precondition 2: 'n' must be a natural number (positive integer).\n        assert n > 0 : \"Input 'n' must be a natural number (positive integer).\";\n\n        // Define the list of vowels for quick lookup\n        ArrayList<Character> vowels = new ArrayList<>(\n                Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n        );\n\n        // Initialize result list\n        ArrayList<String> result = new ArrayList<>();\n\n        // Split the string into words\n        String[] words = s.split(\" \");\n\n        for (String word : words) {\n            // Count the number of consonants in the word\n            int consonantCount = 0;\n            for (char c : word.toCharArray()) {\n                // Check if the character is a consonant (not a vowel)\n                if (Character.isLetter(c) && !vowels.contains(c)) {\n                    consonantCount++;\n                }\n            }\n\n            // If the number of consonants matches 'n', add the word to the result list\n            if (consonantCount == n) {\n                result.add(word);\n            }\n        }\n\n        // Return the final result list\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(select_words(\"Mary had a little lamb\", 4)); // Should return [\"little\"]\n        System.out.println(select_words(\"Mary had a little lamb\", 3)); // Should return [\"Mary\", \"lamb\"]\n        System.out.println(select_words(\"simple white space\", 2)); // Should return []\n        System.out.println(select_words(\"Hello world\", 4)); // Should return [\"world\"]\n        System.out.println(select_words(\"Uncle sam\", 3)); // Should return [\"Uncle\"]\n    }\n}\n"}
{"file_name": "ORDER_BY_POINTS.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\n\n/* Write a function which sorts the given list of integers\nin ascending order according to the sum of their digits.\nNote: if there are several items with similar sum of their digits,\norder them based on their index in original list.\n\nFor example:\n>>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n>>> order_by_points([]) == [] */\n\npublic class ORDER_BY_POINTS {\n\n    public static Integer[] order_by_points(Integer[] nums) {\n        // Precondition 1: Ensure that 'nums' is not null.\n        assert nums != null : \"Input 'nums' must not be null.\";\n\n        // Precondition 2: Ensure that all elements in 'nums' are not null.\n        for (Integer num : nums) {\n            assert num != null : \"All elements in 'nums' must not be null.\";\n        }\n\n        ArrayList<Integer> digits = new ArrayList<>();\n        HashMap<Integer, ArrayList<Integer>> digits_number = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            int neg = 1;\n            int n = nums[i];\n            if (n < 0) {\n                n = -1 * n;\n                neg = -1;\n            }\n            int digit = 0;\n            for (int j = 0; j < (n + \"\").toCharArray().length; j++) {\n                if (j == 0)\n                    digit += ((n + \"\").toCharArray()[j] - '0') * neg;\n                else\n                    digit += (n + \"\").toCharArray()[j] - '0';\n            }\n            if (!digits.contains(digit))\n                digits.add(digit);\n            if (!digits_number.containsKey(digit))\n                digits_number.put(digit, new ArrayList<>());\n            digits_number.get(digit).add(nums[i]);\n        }\n        Collections.sort(digits);\n\n        ArrayList<Integer> result = new ArrayList<>();\n        for (int i = 0; i < digits.size(); i++) {\n            result.addAll(digits_number.get(digits.get(i)));\n        }\n\n        // Postcondition 1: Ensure that the result is not null.\n        assert result != null : \"The result must not be null.\";\n\n        // Postcondition 2: Ensure that the result has the same length as the input list.\n        assert result.size() == nums.length : \"The result list must have the same length as the input list.\";\n\n        // Postcondition 3: Ensure that the result list contains the same elements as the input list.\n        ArrayList<Integer> numsList = new ArrayList<>();\n        Collections.addAll(numsList, nums);\n        Collections.sort(numsList);\n        ArrayList<Integer> resultCopy = new ArrayList<>(result);\n        Collections.sort(resultCopy);\n        assert resultCopy.equals(numsList) : \"The result list must contain the same elements as the input list.\";\n\n        return result.toArray(new Integer[0]);\n    }\n}\n"}
{"file_name": "WILL_IT_FLY.java", "content": "package humaneval.buggy;\n\n/* Write a function that returns True if the object q will fly, and False otherwise.\nThe object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n\nExample:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 is less than the maximum possible weight, but it's unbalanced.\n\nwill_it_fly([3, 2, 3], 1) ➞ False\n# it's balanced, but 3+2+3 is more than the maximum possible weight.\n\nwill_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 is less than the maximum possible weight, and it's balanced.\n\nwill_it_fly([3], 5) ➞ True\n# 3 is less than the maximum possible weight, and it's balanced. */\n\npublic class WILL_IT_FLY {\n    public static boolean will_it_fly(int[] q, int w) {\n        // Precondition 1: The input array 'q' should not be null.\n        assert q != null : \"Precondition failed: Input array 'q' must not be null.\";\n\n        // Precondition 2: The input array 'q' should not be empty.\n        assert q.length > 0 : \"Precondition failed: Input array 'q' must not be empty.\";\n\n        // Precondition 3: The maximum possible weight 'w' should be non-negative.\n        assert w >= 0 : \"Precondition failed: Maximum weight 'w' must be non-negative.\";\n\n        // Precondition 4: All elements in 'q' should be non-negative integers.\n        for (int value : q) {\n            assert value >= 0 : \"Precondition failed: All elements in 'q' must be non-negative integers.\";\n        }\n\n        int sum = 0;\n        for (int i = 0; i < q.length; i += 1)\n            sum += q[i];\n\n        // Postcondition 1: The sum of the elements in 'q' should be non-negative.\n        assert sum >= 0 : \"Postcondition failed: The sum of elements in 'q' must be non-negative.\";\n\n        if (sum > w)\n            return false;\n\n        int i = 0;\n        int j = q.length - 1;\n        while (i < j) {\n            if (q[i] != q[j]) return false;\n            i += 1;\n            j -= 1;\n        }\n\n        // Postcondition 2: The result should be true only if the array is palindromic and the sum is less than or equal to 'w'.\n        assert (sum <= w && isPalindrome(q)) == true : \"Postcondition failed: The result should be true if 'q' is a palindrome and sum is <= 'w'.\";\n\n        return true;\n    }\n\n    // Helper method to check if an array is a palindrome.\n    private static boolean isPalindrome(int[] array) {\n        int i = 0;\n        int j = array.length - 1;\n        while (i < j) {\n            if (array[i] != array[j]) return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        // Sample assertions to validate the preconditions and postconditions\n        assert will_it_fly(new int[]{1, 2}, 5) == false : \"Test case 1 failed\";\n        assert will_it_fly(new int[]{3, 2, 3}, 1) == false : \"Test case 2 failed\";\n        assert will_it_fly(new int[]{3, 2, 3}, 9) == true : \"Test case 3 failed\";\n        assert will_it_fly(new int[]{3}, 5) == true : \"Test case 4 failed\";\n    }\n}\n"}
{"file_name": "TRIANGLE_AREA.java", "content": "package humaneval.buggy;\n\n/*\n * Given length of a side and height, return the area of a triangle.\n * The formula for the area of a triangle is: (base * height) / 2.\n *\n * >>> triangle_area(5, 3)\n * 7.5\n */\n\npublic class TRIANGLE_AREA {\n    public static double triangle_area(double a, double h) {\n        // Precondition 1: Ensure that the base 'a' is a positive number.\n        assert a > 0 : \"Precondition failed: 'a' must be a positive number.\";\n\n        // Precondition 2: Ensure that the height 'h' is a positive number.\n        assert h > 0 : \"Precondition failed: 'h' must be a positive number.\";\n\n        // Calculate the area using the formula (base * height) / 2\n        double area = a * h / 2.0;\n\n        // Postcondition 1: Ensure that the result is a non-negative value.\n        assert area >= 0 : \"Postcondition failed: The area must be a non-negative value.\";\n\n        // Postcondition 2: Ensure that the result is not zero if both 'a' and 'h' are positive.\n        assert area > 0 : \"Postcondition failed: The area must be greater than 0 if 'a' and 'h' are positive.\";\n\n        return area;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the function\n        assert triangle_area(5, 3) == 7.5 : \"Test case 1 failed\";\n        assert triangle_area(10, 2) == 10.0 : \"Test case 2 failed\";\n        assert triangle_area(6.5, 4) == 13.0 : \"Test case 3 failed\";\n        assert triangle_area(7.2, 5.1) == 18.36 : \"Test case 4 failed\";\n    }\n}\n"}
{"file_name": "DIGIT_SUM.java", "content": "package humaneval.buggy;\n\n/* Task\nWrite a function that takes a string as input and returns the sum of the upper characters only'\nASCII codes.\n\nExamples:\n    digitSum(\"\") => 0\n    digitSum(\"abAB\") => 131\n    digitSum(\"abcCd\") => 67\n    digitSum(\"helloE\") => 69\n    digitSum(\"woArBld\") => 131\n    digitSum(\"aAaaaXa\") => 153 */\n\npublic class DIGIT_SUM {\n    public static int digit_sum(String s) {\n        // Preconditions\n// 1. The input string `s` must not be null\n        assert s != null : \"Precondition failed: Input string 's' must not be null.\";\n\n// 2. The input string `s` may be empty, which is allowed\n        assert s.length() >= 0 : \"Precondition failed: Input string must be a valid string (even if empty).\";\n\n// 3. The input string `s` must only contain valid ASCII characters\n        for (char c : s.toCharArray()) {\n            assert c >= 0 && c <= 127 : \"Precondition failed: Input string contains non-ASCII characters.\";\n        }\n\n        int result = 0;\n        for (char c : s.toCharArray()) {\n            if ('A' <= c && c <= 'Z')\n                result += (int) c;\n        }\n        // Postconditions\n// 1. The result must be a non-negative integer (as the sum of ASCII values of uppercase characters)\n        assert result >= 0 : \"Postcondition failed: The result must be a non-negative integer.\";\n\n\n\n        return result;\n    }\n}\n"}
{"file_name": "MAKE_PALINDROME.java", "content": "package humaneval.buggy;\n\npublic class MAKE_PALINDROME {\n\n    // Helper function to check if a string is a palindrome\n    public static boolean is_palindrome(String str) {\n        for (int i = 0; i < str.length() / 2; i += 1) {\n            if (str.charAt(i) != str.charAt(str.length() - 1 - i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static String make_palindrome(String str) {\n        // Precondition 1: Ensure that 'str' is not null.\n        assert str != null : \"Input string 'str' must not be null.\";\n\n        // Precondition 2: Ensure that 'str' is a string.\n        assert str instanceof String : \"Input 'str' must be a string.\";\n\n        // Precondition 3: Ensure that the length of the input string is within a reasonable boundary.\n        int max_length = 10 * 1000 * 1000;  // Example boundary condition; adjust as needed.\n        assert str.length() <= max_length : \"Input string 'str' should not exceed \" + max_length + \" characters.\";\n\n        // If the input string is already a palindrome, return it as the result.\n        if (is_palindrome(str)) {\n            return str;\n        }\n\n        // Find the longest suffix that is a palindrome\n        int beginning_of_suffix = 0;\n        while (!is_palindrome(str.substring(beginning_of_suffix))) {\n            beginning_of_suffix += 1;\n        }\n\n        // Construct the result palindrome\n        StringBuilder result = new StringBuilder(str);\n        for (int i = beginning_of_suffix - 1; i >= 0; i -= 1) {\n            result.append(str.charAt(i));\n        }\n\n\n        // Postcondition 2: Ensure that the result is a palindrome.\n        assert is_palindrome(result.toString()) : \"The result must be a palindrome.\";\n\n        // Postcondition 3: Ensure that the result starts with the original string.\n        assert result.toString().startsWith(str) : \"The result must start with the original string.\";\n\n\n\n        // Postcondition 5: If the input string is empty, the result should also be an empty string.\n        if (str.length() == 0) {\n            assert result.toString().equals(\"\") : \"If the input string is empty, the result should also be an empty string.\";\n        }\n\n        return result.toString();\n    }\n}\n"}
{"file_name": "TRIANGLE_AREA_2.java", "content": "package humaneval.buggy;\n\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\n\n/*\n * Given the lengths of the three sides of a triangle, return the area of\n * the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n * Otherwise, return -1.\n *\n * Three sides make a valid triangle when the sum of any two sides is greater\n * than the third side.\n *\n * Example:\n * triangle_area_2(3, 4, 5) == 6.00\n * triangle_area_2(1, 2, 10) == -1\n */\n\npublic class TRIANGLE_AREA_2 {\n    public static double triangle_area_2(double a, double b, double c) {\n        // Precondition 1: Ensure that all sides are positive numbers.\n        assert a > 0 : \"Precondition failed: 'a' must be a positive number.\";\n        assert b > 0 : \"Precondition failed: 'b' must be a positive number.\";\n        assert c > 0 : \"Precondition failed: 'c' must be a positive number.\";\n\n\n        if (a + b <= c || a + c <= b || b + c <= a)\n            return -1;\n\n        // Calculate the semi-perimeter\n        double s = (a + b + c) / 2.0;\n        // Calculate the area using Heron's formula\n        double area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n\n        // Round the result to 2 decimal places\n        BigDecimal bd = BigDecimal.valueOf(area);\n        bd = bd.setScale(2, RoundingMode.HALF_UP);\n        double result = bd.doubleValue();\n\n        // Postcondition 1: Ensure the result is either -1 (invalid triangle) or a non-negative value.\n        assert result == -1 || result >= 0 : \"Postcondition failed: The result must be either -1 or a non-negative value.\";\n\n        // Postcondition 2: If the result is not -1, it should be rounded to 2 decimal places.\n        if (result != -1) {\n            assert bd.scale() == 2 : \"Postcondition failed: The result must be rounded to 2 decimal places.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the function\n        assert triangle_area_2(3, 4, 5) == 6.00 : \"Test case 1 failed\";\n        assert triangle_area_2(1, 2, 10) == -1 : \"Test case 2 failed\";\n        assert triangle_area_2(5, 5, 5) == 10.83 : \"Test case 3 failed\";\n        assert triangle_area_2(0, 4, 5) == -1 : \"Test case 4 failed\";\n    }\n}\n"}
{"file_name": "VALID_DATE.java", "content": "package humaneval.buggy;\n\n/*\n * You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    for example: \n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06/04/2020') => False\n */\n\npublic class VALID_DATE {\n    public static boolean valid_date(String date) {\n        try {\n            date = date.trim();\n            String[] date_info = date.split(\"-\");\n            if(date_info.length > 3) return false;\n            int month = Integer.parseInt(date_info[0]);\n            int day = Integer.parseInt(date_info[1]);\n            int year = Integer.parseInt(date_info[2]);\n\n            if(month < 1 || month > 12) return false;\n\n            int[] month_check1 = {1, 3, 5, 7, 8, 10, 12};\n            for(int i = 0; i < month_check1.length; i++) {\n                if(month == month_check1[i] && (day < 1 || day > 31)) return false;\n            }\n\n            int[] month_check2 = {4, 6, 9, 11};\n            for(int i = 0; i < month_check2.length; i++) {\n                if(month == month_check2[i] && (day < 1 || day > 30)) return false;\n            }\n            if(month == 2 && (day < 1 || day > 29)) return false;\n        } catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n}\n"}
{"file_name": "STRING_TO_MD5.java", "content": "package humaneval.buggy;\n\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport javax.xml.bind.DatatypeConverter;\n\npublic class STRING_TO_MD5 {\n\n    public static String string_to_md5(String text) throws NoSuchAlgorithmException {\n        // Precondition 1: Ensure that 'text' is not null.\n        if (text == null) {\n            throw new IllegalArgumentException(\"Input 'text' must not be null.\");\n        }\n\n        // Precondition 2: Ensure that 'text' is a string.\n        if (!(text instanceof String)) {\n            throw new IllegalArgumentException(\"Input 'text' must be a string.\");\n        }\n\n        // Precondition 3: Ensure that the length of 'text' is within reasonable boundaries.\n        int maxLength = 10000;  // Example boundary, adjust as needed\n        if (text.length() > maxLength) {\n            throw new IllegalArgumentException(\"Input 'text' should not exceed \" + maxLength + \" characters.\");\n        }\n\n        // If the text is empty, return null as specified.\n        if (text.equals(\"\")) return null;\n\n        // Create the MD5 hash of the given text.\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(text.getBytes());\n        byte[] digest = md.digest();\n        String result = DatatypeConverter.printHexBinary(digest).toLowerCase();\n\n        // Postcondition 1: Ensure that the result is not null.\n        if (result == null) {\n            throw new AssertionError(\"The result must not be null.\");\n        }\n\n        // Postcondition 2: Ensure that the result is a 32-character hexadecimal string.\n        if (result.length() != 32) {\n            throw new AssertionError(\"The result must be a 32-character hexadecimal string.\");\n        }\n\n        // Postcondition 3: Ensure that the result contains only valid hexadecimal characters (0-9, a-f).\n        if (!result.matches(\"[0-9a-f]{32}\")) {\n            throw new AssertionError(\"The result must contain only hexadecimal characters (0-9, a-f).\");\n        }\n\n        // Postcondition 4: If 'text' is empty, the result should be null.\n        if (text.isEmpty() && result != null) {\n            throw new AssertionError(\"If 'text' is empty, the result should be null.\");\n        }\n\n        // Postcondition 5: Ensure that the result is the correct MD5 hash of the input text.\n        // Note: This requires a trusted source for comparison. Here we assume the implementation is correct.\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        try {\n            // Test cases to validate the function\n            System.out.println(string_to_md5(\"Hello world\")); // Expected: 3e25960a79dbc69b674cd4ec67a72c62\n            System.out.println(string_to_md5(\"\"));            // Expected: null\n            System.out.println(string_to_md5(\"1234567890\"));  // Expected: e807f1fcf82d132f9bb018ca6738a19f\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"MD5 algorithm not found.\");\n        }\n    }\n}\n"}
{"file_name": "BF.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n/* There are eight planets in our solar system: the closest to the Sun\nis Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\nUranus, Neptune.\nWrite a function that takes two planet names as strings planet1 and planet2.\nThe function should return a list containing all planets whose orbits are\nlocated between the orbit of planet1 and the orbit of planet2, sorted by\nproximity to the sun.\nThe function should return an empty list if planet1 or planet2\nare not correct planet names.\nExamples\nbf(\"Jupiter\", \"Neptune\") ==> [\"Saturn\", \"Uranus\"]\nbf(\"Earth\", \"Mercury\") ==> [\"Venus\"]\nbf(\"Mercury\", \"Uranus\") ==> [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"] */\n\npublic class BF {\n    public static ArrayList<String> bf(String planet1, String planet2) {\n        ArrayList<String> planet_names = new ArrayList<String>(Arrays.asList(\n                \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n        ));\n\n        // Precondition 1: planet1 and planet2 should not be null\n        assert planet1 != null && planet2 != null : \"Precondition failed: Planet names must not be null.\";\n\n        // Precondition 2: planet1 and planet2 should not be empty strings\n        assert !planet1.isEmpty() && !planet2.isEmpty() : \"Precondition failed: Planet names must not be empty.\";\n\n\n\n\n        // Precondition 5: The order of planets should be distinguishable (index-based comparison)\n        int planet1_index = planet_names.indexOf(planet1);\n        int planet2_index = planet_names.indexOf(planet2);\n\n        ArrayList<String> result = new ArrayList<String>();\n        if ((!planet_names.contains(planet1)) || (!planet_names.contains(planet2))) {\n            return result;\n        }\n\n        if (planet1_index < planet2_index) {\n            for (int i = planet1_index + 1; i < planet2_index; i += 1) {\n                result.add(planet_names.get(i));\n            }\n        } else {\n            for (int i = planet2_index + 1; i < planet1_index; i += 1) {\n                result.add(planet_names.get(i));\n            }\n        }\n\n        // Postcondition 1: The result should contain planets between the orbits of planet1 and planet2\n        for (String planet : result) {\n            int planetIndex = planet_names.indexOf(planet);\n            assert (planetIndex > planet1_index && planetIndex < planet2_index)\n                    || (planetIndex > planet2_index && planetIndex < planet1_index) : \"Postcondition failed: Planets in the result are not between planet1 and planet2.\";\n        }\n\n        // Postcondition 2: The result should be empty if there are no planets between planet1 and planet2\n        if (Math.abs(planet1_index - planet2_index) == 1) {\n            assert result.isEmpty() : \"Postcondition failed: Result should be empty if no planets exist between planet1 and planet2.\";\n        }\n\n\n        // Postcondition 4: The result should not contain planet1 or planet2\n        assert !result.contains(planet1) && !result.contains(planet2) : \"Postcondition failed: Result contains planet1 or planet2.\";\n\n        // Postcondition 5: The result must only contain valid planet names\n        for (String planet : result) {\n            assert planet_names.contains(planet) : \"Postcondition failed: Result contains invalid planet names.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "ADD.java", "content": "package humaneval.buggy;\n\n/* Add two numbers x and y\n>>> add(2, 3)\n5\n>>> add(5, 7)\n12 */\n\npublic class ADD {\n    public static int add(int x, int y) {\n        assert x >= Integer.MIN_VALUE && x <= Integer.MAX_VALUE : \"Precondition failed: x is out of integer range\";\n        assert y >= Integer.MIN_VALUE && y <= Integer.MAX_VALUE : \"Precondition failed: y is out of integer range\";\n        assert (y <= 0 || x <= Integer.MAX_VALUE - y) : \"Precondition failed: Addition will cause integer overflow\";\n        assert (y >= 0 || x >= Integer.MIN_VALUE - y) : \"Precondition failed: Addition will cause integer underflow\";\n        assert x >= 0 && y >= 0 : \"Precondition failed: x and y must be non-negative\";\n\n        int result = x + y;\n        return result;\n\n    }\n}\n"}
{"file_name": "HISTOGRAM.java", "content": "package humaneval.buggy;\n\nimport java.util.HashMap;\n\npublic class HISTOGRAM {\n\n    public static HashMap<Character, Integer> histogram(String s) {\n        // Precondition 1: Ensure that 's' is not null.\n        assert s != null : \"Input 's' must not be null.\";\n\n        // Precondition 2: Ensure that 's' is a string.\n        assert s instanceof String : \"Input 's' must be a string.\";\n\n        // Precondition 3: Ensure that 's' contains only lowercase letters and spaces.\n        for (char c : s.toCharArray()) {\n            assert Character.isLowerCase(c) || Character.isWhitespace(c) : \"Input 's' must contain only lowercase letters and spaces.\";\n        }\n\n        HashMap<Character, Integer> res = new HashMap<>();\n        if (s.isEmpty()) return res;  // Empty input results in an empty map\n\n        String[] list_letters = s.split(\" \");\n        int[] count_letter = new int[26];\n\n        // Count occurrences of each letter\n        for (String letter : list_letters) {\n            if (!letter.isEmpty()) {  // Ignore empty strings\n                char c = letter.charAt(0);\n                count_letter[c - 'a']++;\n            }\n        }\n\n        // Postcondition 1: Ensure that the count array is not empty if input is not empty.\n        boolean nonEmptyCount = false;\n        for (int count : count_letter) {\n            if (count > 0) {\n                nonEmptyCount = true;\n                break;\n            }\n        }\n        assert nonEmptyCount || s.isEmpty() : \"The count array should not be empty if the input is not empty.\";\n\n        // Find the maximum count\n        int most_count = 0;\n        for (int i = 0; i < 26; i++) {\n            if (count_letter[i] > most_count) {\n                most_count = count_letter[i];\n                res.clear();  // Clear the map for new max\n                res.put((char) ('a' + i), most_count);\n            } else if (count_letter[i] == most_count && most_count > 0) {\n                res.put((char) ('a' + i), most_count);\n            }\n        }\n\n        // Postcondition 2: Ensure that the result is a dictionary (HashMap).\n        assert res instanceof HashMap : \"The result must be a dictionary (HashMap).\";\n\n        // Postcondition 3: Ensure that all values in the result correspond to the maximum count.\n        for (int count : res.values()) {\n            assert count == most_count : \"All values in the result must equal the maximum frequency.\";\n        }\n\n        return res;\n    }\n}\n"}
{"file_name": "MIN_PATH.java", "content": "package humaneval.buggy;\n\n/*\n * Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n\n */\n\npublic class MIN_PATH {\n    public static int[] min_path(int[][] grid, int k) {\n        int n = grid.length;\n        int val = n * n + 1;\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                if(grid[i][j] == 1) {\n                    if(i != 0) val = Math.min(val, grid[i - 1][j]);\n                    if(j != 0) val = Math.min(val, grid[i][j - 1]);\n                    if(i != n - 1) val = Math.min(val, grid[i + 1][j]);\n                    if(j != n - 1) val = Math.min(val, grid[i][j + 1]);\n                }\n            }\n        }\n        int[] ans = new int[k];\n        for(int i = 0; i < k; i++) {\n            if((i % 2) == 0) ans[i] = 1;\n            else ans[i] = val;\n        }\n        return ans;\n    }\n}\n"}
{"file_name": "IS_SIMPLE_POWER.java", "content": "package humaneval.buggy;\n\npublic class IS_SIMPLE_POWER {\n\n    public static boolean is_simple_power(int x, int n) {\n        // Precondition 1: The base 'n' should not be zero if 'x' is not zero.\n        assert !(n == 0 && x != 0) : \"If base 'n' is zero, 'x' must also be zero.\";\n\n        // Precondition 2: If 'n' is zero, 'x' must be zero.\n        if (n == 0) {\n            return x == 0;\n        }\n\n        // Precondition 3: Both 'x' and 'n' should be integers.\n        // This is inherently true in Java since both x and n are defined as int.\n\n        // Handle special cases\n        if (x == 1) return true;\n        if (n == 1) return x == 1;\n        if (n == -1) return Math.abs(x) == 1;\n\n        // Check if x is a power of n\n        int power = n;\n        while (Math.abs(power) <= Math.abs(x)) {\n            if (power == x) return true;\n            if (power > Integer.MAX_VALUE / n || power < Integer.MIN_VALUE / n) {\n                break; // Avoid integer overflow\n            }\n            power *= n;\n        }\n\n        boolean result = false;\n\n        // Postcondition 1: The result should be a boolean value.\n        assert result == true || result == false : \"The result must be a boolean value.\";\n\n        // Postcondition 2: If result is true, there should exist an integer k such that n^k = x.\n        if (result) {\n            int temp = n;\n            boolean isPower = false;\n            while (Math.abs(temp) <= Math.abs(x)) {\n                if (temp == x) {\n                    isPower = true;\n                    break;\n                }\n                temp *= n;\n            }\n            assert isPower : \"If result is true, there should exist an integer k such that n^k = x.\";\n        }\n\n        // Postcondition 3: If result is false, x should not be a power of n.\n        if (!result) {\n            int temp = n;\n            boolean isNotPower = true;\n            while (Math.abs(temp) <= Math.abs(x)) {\n                if (temp == x) {\n                    isNotPower = false;\n                    break;\n                }\n                temp *= n;\n            }\n            assert isNotPower : \"If result is false, x should not be a power of n.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "UNIQUE_DIGITS.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/*\n * Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n */\n\npublic class UNIQUE_DIGITS {\n\n    public static ArrayList<Integer> unique_digits(ArrayList<Integer> x) {\n        // Precondition 1: The input list 'x' should not be null.\n        assert x != null : \"Precondition failed: Input list 'x' must not be null.\";\n\n        // Precondition 2: All elements in the input list 'x' should be positive integers.\n        assert x.stream().allMatch(n -> n > 0) : \"Precondition failed: All elements in the input list 'x' must be positive integers.\";\n\n        ArrayList<Integer> res = new ArrayList<Integer>();\n\n        for (int i : x) {\n            int num = i;\n            boolean all_odd = true;\n\n            // Check if the number has only odd digits\n            while (num > 0) {\n                int curr_digit = num % 10;\n                if ((curr_digit % 2) == 0) {\n                    all_odd = false;\n                    break;\n                }\n                num /= 10;\n            }\n\n            // If all digits are odd, add to result list\n            if (all_odd) {\n                res.add(i);\n            }\n        }\n\n        // Sort the result list in increasing order\n        Collections.sort(res);\n\n        // Postcondition 1: The result should not be null.\n        assert res != null : \"Postcondition failed: Result list 'res' must not be null.\";\n\n        // Postcondition 2: All elements in the result list should have only odd digits.\n        assert res.stream().allMatch(n -> {\n            int num = n;\n            while (num > 0) {\n                int digit = num % 10;\n                if (digit % 2 == 0) return false;\n                num /= 10;\n            }\n            return true;\n        }) : \"Postcondition failed: All elements in the result list must have only odd digits.\";\n\n        // Postcondition 3: The result list should be sorted in increasing order.\n        for (int i = 1; i < res.size(); i++) {\n            assert res.get(i) >= res.get(i - 1) : \"Postcondition failed: Result list must be sorted in increasing order.\";\n        }\n\n        // Postcondition 4: All elements in the result list must be from the input list.\n        assert res.stream().allMatch(x::contains) : \"Postcondition failed: All elements in the result list must be from the input list.\";\n\n        return res;\n    }\n\n\n}\n"}
{"file_name": "SEPARATE_PAREN_GROUPS.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SEPARATE_PAREN_GROUPS {\n    public static List<String> separate_paren_groups(String paren_string) {\n        // Check for null input\n        if (paren_string == null) {\n            throw new IllegalArgumentException(\"Input must not be null.\");\n        }\n\n        List<String> result = new ArrayList<>();\n        StringBuilder currentGroup = new StringBuilder();\n        int currentDepth = 0;\n\n        // Traverse the input string character by character\n        for (char c : paren_string.toCharArray()) {\n            // Skip spaces\n            if (c == ' ') continue;\n\n            // Append character to current group\n            currentGroup.append(c);\n\n            // Adjust current depth based on character\n            if (c == '(') {\n                currentDepth++;\n            } else if (c == ')') {\n                currentDepth--;\n            }\n\n            // If the depth is zero, the current group is balanced and can be added to the result\n            if (currentDepth == 0 && currentGroup.length() > 0) {\n                result.add(currentGroup.toString());\n                currentGroup.setLength(0); // Clear the current group\n            }\n        }\n\n        // If there are unmatched parentheses, throw an exception\n        if (currentDepth != 0) {\n            throw new IllegalArgumentException(\"The input string has unmatched parentheses.\");\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(separate_paren_groups(\"( ) (( )) (( )( ))\")); // ['()', '(())', '(()())']\n        System.out.println(separate_paren_groups(\"((()))\")); // ['((()))']\n        System.out.println(separate_paren_groups(\"()()()()\")); // ['()', '()', '()', '()']\n        System.out.println(separate_paren_groups(\"((()))((()))\")); // ['((()))', '((()))']\n        System.out.println(separate_paren_groups(\"(())(())(())\")); // ['(())', '(())', '(())']\n    }\n}\n"}
{"file_name": "MAX_FILL.java", "content": "package humaneval.buggy;\n\npublic class MAX_FILL {\n\n    public static int max_fill(int[][] grid, int bucket_capacity) {\n        // Precondition 1: Ensure that 'grid' is not null.\n        assert grid != null : \"Input 'grid' must not be null.\";\n\n        // Precondition 2: Ensure that 'grid' is a non-empty 2D array.\n        assert grid.length > 0 && grid[0].length > 0 : \"Input 'grid' must be a non-empty 2D array.\";\n\n        // Precondition 3: Ensure that all elements in 'grid' are 0 or 1.\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[i].length; j++) {\n                assert (grid[i][j] == 0 || grid[i][j] == 1) : \"All elements in 'grid' must be either 0 or 1.\";\n            }\n        }\n\n        // Precondition 4: Ensure that 'bucket_capacity' is an integer between 1 and 10.\n        assert bucket_capacity >= 1 && bucket_capacity <= 10 : \"Input 'bucket_capacity' must be an integer between 1 and 10.\";\n\n        int result = 0;\n        for (int i = 0; i < grid.length; i++) {\n            int rowCapacity = 0;\n            for (int j = 0; j < grid[i].length; j++) {\n                rowCapacity += grid[i][j];\n            }\n            result += (rowCapacity + bucket_capacity - 1) / bucket_capacity;\n        }\n\n        // Postcondition 1: Ensure that the result is a non-negative integer.\n        assert result >= 0 : \"The result must be a non-negative integer.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "GET_POSITIVE.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class GET_POSITIVE {\n\n    public static List<Integer> get_positive(List<Integer> numbers) {\n        // Precondition 1: Ensure that the input 'numbers' is not null.\n        assert numbers != null : \"Input list 'numbers' must not be null.\";\n\n        // Precondition 2: Ensure that the input 'numbers' is a list.\n        assert numbers instanceof List : \"Input 'numbers' must be a list.\";\n\n        // Precondition 3: Ensure that all elements in the list 'numbers' are integers.\n        for (Object num : numbers) {\n            assert num instanceof Integer : \"All elements in 'numbers' must be integers.\";\n        }\n\n        List<Integer> result = new ArrayList<>();\n\n        for (Integer number : numbers) {\n            if (number > 0) {\n                result.add(number);\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is a list.\n        assert result instanceof List : \"The result must be a list.\";\n\n        // Postcondition 2: Ensure that all elements in the result are positive integers.\n        for (Integer num : result) {\n            assert num > 0 : \"All elements in the result should be positive numbers.\";\n        }\n\n        // Postcondition 3: Ensure that the length of the result matches the number of positive numbers in the input list.\n        int expected_length = (int) numbers.stream().filter(num -> num > 0).count();\n        assert result.size() == expected_length : \"The length of the result does not match the number of positive numbers in the input list.\";\n\n        // Postcondition 4: If the input list contains no positive numbers, the result should be an empty list.\n        if (numbers.stream().noneMatch(num -> num > 0)) {\n            assert result.isEmpty() : \"If the input list contains no positive numbers, the result should be an empty list.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "SORT_THIRD.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class SORT_THIRD {\n\n    public static List<Integer> sort_third(List<Integer> l) {\n        // Precondition 1: Ensure the input list 'l' is not null.\n        if (l == null) {\n            throw new IllegalArgumentException(\"Input list 'l' must not be null.\");\n        }\n\n        // Precondition 2: Ensure the input 'l' is a non-empty list.\n        if (l.isEmpty()) {\n            return l; // Return the same empty list if the input list is empty.\n        }\n\n        // Precondition 3: Ensure all elements in the list 'l' are integers.\n        for (Integer num : l) {\n            if (num == null) {\n                throw new IllegalArgumentException(\"All elements in the list 'l' must be integers.\");\n            }\n        }\n\n        // Create a list to store the result.\n        List<Integer> result = new ArrayList<>(l);\n\n        // Extract elements at indices divisible by 3.\n        List<Integer> thirds = new ArrayList<>();\n        for (int i = 0; i < l.size(); i += 3) {\n            thirds.add(l.get(i));\n        }\n\n        // Sort the elements that are at indices divisible by 3.\n        Collections.sort(thirds);\n\n        // Replace elements at indices divisible by 3 with sorted values.\n        for (int i = 0; i < result.size(); i += 1) {\n            if (i % 3 == 0) {\n                result.set(i, thirds.get(i / 3));\n            }\n        }\n\n        // Postcondition 1: Ensure the result is a list.\n        if (!(result instanceof List)) {\n            throw new AssertionError(\"The result must be a list.\");\n        }\n\n        // Postcondition 2: Ensure the length of the result list matches the length of the input list.\n        if (result.size() != l.size()) {\n            throw new AssertionError(\"The length of the result list must match the length of the input list.\");\n        }\n\n        // Postcondition 3: Ensure the elements at indices divisible by 3 are sorted in the result list.\n        for (int i = 0; i < result.size(); i += 3) {\n            if (!result.get(i).equals(thirds.get(i / 3))) {\n                throw new AssertionError(\"The elements at indices divisible by 3 should be sorted in the result list.\");\n            }\n        }\n\n        // Postcondition 4: Ensure the elements at indices not divisible by 3 remain unchanged.\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 3 != 0 && !result.get(i).equals(l.get(i))) {\n                throw new AssertionError(\"The elements at indices not divisible by 3 should remain unchanged.\");\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "IS_MULTIPLY_PRIME.java", "content": "package humaneval.buggy;\n\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less than 100.\n// Example:\n// is_multiply_prime(30) == True\n// 30 = 2 * 3 * 5\n\npublic class IS_MULTIPLY_PRIME {\n\n    // Helper function to check if a number is prime.\n    public static boolean is_prime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(n); i += 1) {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n\n    public static boolean is_multiply_prime(int a) {\n        // Preconditions\n        assert a >= 0 : \"Input must be a non-negative integer.\";\n\n        // Check for the multiplication of exactly three prime numbers\n        for (int i = 2; i < a; i += 1) {\n            if (!is_prime(i)) continue;\n            for (int j = i; j < a; j += 1) {\n                if (!is_prime(j)) continue;\n                for (int k = j; k < a; k += 1) {\n                    if (!is_prime(k)) continue;\n                    if (i * j * k == a) {\n                        // Postcondition: If the result is true, there should be exactly three prime factors\n                        assert is_prime(i) && is_prime(j) && is_prime(k) : \"All factors must be prime numbers.\";\n                        return true;\n                    }\n                }\n            }\n        }\n\n\n        return false;\n    }\n}\n"}
{"file_name": "MAKE_A_PILE.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\n\n/*\n * Given a positive integer n, you have to make a pile of n levels of stones.\n * The first level has n stones.\n * The number of stones in the next level is:\n * - the next odd number if n is odd.\n * - the next even number if n is even.\n * Return the number of stones in each level in a list, where element at index\n * i represents the number of stones in the level (i+1).\n *\n * Examples:\n * >>> make_a_pile(3)\n * [3, 5, 7]\n */\n\npublic class MAKE_A_PILE {\n\tpublic static ArrayList<Integer> make_a_pile(int n) {\n\t\t// Precondition 1: Ensure that 'n' is a positive integer greater than 0.\n\t\tassert n > 0 : \"Input 'n' must be a positive integer.\";\n\n\t\tArrayList<Integer> pile = new ArrayList<Integer>();\n\t\tint num = n; // Start with 'n' stones at the first level\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpile.add(num);\n\t\t\tnum += 2; // Increase by 2 for the next level\n\t\t}\n\n\t\t// Postcondition 1: Ensure that the result is a list.\n\t\tassert pile instanceof ArrayList<?> : \"The result must be a list.\";\n\n\t\t// Postcondition 2: Ensure that the list has exactly 'n' elements.\n\t\tassert pile.size() == n : \"The result list must have \" + n + \" elements.\";\n\n\t\t// Postcondition 3: Ensure that the first element is equal to 'n'.\n\t\tassert pile.get(0) == n : \"The first element must be \" + n + \".\";\n\n\t\t// Postcondition 4: Ensure that each subsequent element increases by 2.\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tassert pile.get(i) == pile.get(i - 1) + 2 : \"Each element must increase by 2 from the previous one.\";\n\t\t}\n\n\t\treturn pile;\n\t}\n}\n"}
{"file_name": "SUM_PRODUCT.java", "content": "package humaneval.buggy;\n\nimport java.util.List;\n\npublic class SUM_PRODUCT {\n    public static Integer[] sum_product(List<Integer> numbers) {\n        // Precondition 1: Ensure that 'numbers' is not null.\n        assert numbers != null : \"Precondition failed: 'numbers' must not be null.\";\n\n        // Precondition 2: Ensure that all elements in 'numbers' are not null.\n        assert !numbers.contains(null) : \"Precondition failed: All elements in 'numbers' must not be null.\";\n\n\n\n        // Initialize result array with sum at index 0 and product at index 1.\n        Integer[] result = new Integer[]{0, 1};\n\n        // Calculate the sum and product.\n        for (Integer n : numbers) {\n            result[0] += n;\n            result[1] *= n;\n        }\n\n        // Postcondition 1: Ensure that the result is an array of two integers.\n        assert result != null : \"Postcondition failed: The result must not be null.\";\n        assert result.length == 2 : \"Postcondition failed: The result array must have exactly two elements.\";\n        assert result[0] instanceof Integer && result[1] instanceof Integer : \"Postcondition failed: The result must contain integers.\";\n\n        // Postcondition 2: Ensure that the first element of the result is the correct sum.\n        int expectedSum = 0;\n        for (Integer n : numbers) {\n            expectedSum += n;\n        }\n        assert result[0].equals(expectedSum) : \"Postcondition failed: The first element must be the sum of all elements in 'numbers'.\";\n\n        // Postcondition 3: Ensure that the second element of the result is the correct product.\n        int expectedProduct = 1;\n        for (Integer n : numbers) {\n            expectedProduct *= n;\n        }\n        assert result[1].equals(expectedProduct) : \"Postcondition failed: The second element must be the product of all elements in 'numbers'.\";\n\n        // Postcondition 4: Ensure that the sum (result[0]) and product (result[1]) are correctly calculated.\n        assert result[0].equals(expectedSum) : \"Postcondition failed: Calculated sum is incorrect.\";\n        assert result[1].equals(expectedProduct) : \"Postcondition failed: Calculated product is incorrect.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Example usage and test cases\n        System.out.println(java.util.Arrays.toString(sum_product(java.util.Arrays.asList(1, 2, 3, 4)))); // Expected output: [10, 24]\n        System.out.println(java.util.Arrays.toString(sum_product(java.util.Arrays.asList(-1, 2, -3, 4)))); // Expected output: [2, 24]\n    }\n}\n"}
{"file_name": "ADD_EVEN_AT_ODD.java", "content": "package humaneval.buggy;\n\n/* Given a non-empty list of integers lst. add the even elements that are at odd indices.\nExamples:\n    add([4, 2, 6, 7]) ==> 2 */\n\npublic class ADD_EVEN_AT_ODD {\n    public static int add_even_at_odd(int[] lst) {\n        // Precondition 1: The list should not be null\n        assert lst != null : \"Precondition failed: The array must not be null.\";\n\n        // Precondition 2: The list should not be empty\n        assert lst.length > 0 : \"Precondition failed: The array must not be empty.\";\n\n        // Precondition 3: The list length should be at most 100 (arbitrary upper constraint)\n        assert lst.length <= 100 : \"Precondition failed: The array size must be 100 or less.\";\n\n        // Precondition 4: All elements of the list should be integers\n        for (int i = 0; i < lst.length; i++) {\n            assert lst[i] == (int) lst[i] : \"Precondition failed: All elements must be integers.\";\n        }\n\n        // Precondition 5: The list should not contain any null elements (not possible in primitive int array, but for completeness)\n        // Note: This is more relevant in languages where elements could be null, like for Integer[].\n\n        int sum = 0;\n\n        for (int i = 1; i < lst.length; i += 2) {\n            // Check if the element at an odd index is even\n            if (lst[i] % 2 == 0) {\n                sum += lst[i];\n            }\n        }\n\n        // Postcondition 1: The result must be a non-negative integer (since we're summing non-negative values)\n        assert sum >= 0 : \"Postcondition failed: Sum must be non-negative.\";\n\n        // Postcondition 2: The sum should not exceed the sum of all elements in the list\n        int totalSum = 0;\n        for (int num : lst) {\n            totalSum += num;\n        }\n        assert sum <= totalSum : \"Postcondition failed: Sum exceeds the total sum of the list elements.\";\n\n        // Postcondition 3: The sum must be 0 if no even element exists at an odd index\n        boolean hasEvenAtOddIndex = false;\n        for (int i = 1; i < lst.length; i += 2) {\n            if (lst[i] % 2 == 0) {\n                hasEvenAtOddIndex = true;\n                break;\n            }\n        }\n        assert hasEvenAtOddIndex || sum == 0 : \"Postcondition failed: Sum is non-zero even though no even element exists at an odd index.\";\n\n        // Postcondition 4: If all elements at odd indices are odd, the sum should be 0\n        boolean allOddAtOddIndices = true;\n        for (int i = 1; i < lst.length; i += 2) {\n            if (lst[i] % 2 == 0) {\n                allOddAtOddIndices = false;\n                break;\n            }\n        }\n        assert !allOddAtOddIndices || sum == 0 : \"Postcondition failed: Sum should be 0 if all elements at odd indices are odd.\";\n\n        // Postcondition 5: The sum must equal the expected sum of even elements at odd indices\n        int expectedSum = 0;\n        for (int i = 1; i < lst.length; i += 2) {\n            if (lst[i] % 2 == 0) {\n                expectedSum += lst[i];\n            }\n        }\n        assert sum == expectedSum : \"Postcondition failed: The calculated sum is incorrect.\";\n\n        return sum;\n    }\n}\n"}
{"file_name": "HEX_KEY.java", "content": "package humaneval.buggy;\n\npublic class HEX_KEY {\n\n    public static int hex_key(String num) {\n        // Precondition 1: Ensure that the input 'num' is not null.\n        assert num != null : \"Input 'num' must not be null.\";\n\n        // Precondition 2: Ensure that 'num' is a string.\n        assert num instanceof String : \"Input 'num' must be a string.\";\n\n        // Precondition 3: Ensure that the string only contains valid hexadecimal digits.\n        for (char c : num.toCharArray()) {\n            assert \"0123456789ABCDEF\".indexOf(c) != -1 : \"Input 'num' must contain only valid hexadecimal digits.\";\n        }\n\n        int result = 0;\n        for (char c : num.toCharArray()) {\n            if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n                result += 1;\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is an integer.\n        assert result >= 0 : \"The result must be a non-negative integer.\";\n\n        // Postcondition 2: Ensure that the result correctly counts the prime hexadecimal digits.\n        int expectedCount = 0;\n        for (char c : num.toCharArray()) {\n            if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n                expectedCount += 1;\n            }\n        }\n        assert result == expectedCount : \"The result must correctly count the prime hexadecimal digits.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "MODP.java", "content": "package humaneval.buggy;\n\npublic class MODP {\n    public static int modp(int n, int p) {\n        // Precondition 1: The inputs 'n' and 'p' should not be null (not applicable in Java, so skipped).\n\n        // Precondition 2: The inputs 'n' and 'p' should be integers.\n        // (This is inherent in Java since the parameters are declared as int).\n\n        // Precondition 3: The input 'n' should be a non-negative integer.\n        assert n >= 0 : \"Input 'n' must be a non-negative integer.\";\n\n        // Precondition 4: The input 'p' should be a positive integer.\n        assert p > 0 : \"Input 'p' must be a positive integer.\";\n\n        int result = 1;\n        for (int i = 0; i < n; i += 1) {\n            result = (2 * result) % p;\n        }\n\n        // Postcondition 1: The result should be an integer.\n        // (This is inherent in Java since the return type is declared as int).\n\n        // Postcondition 2: The result should satisfy the condition 2^n % p.\n        int expectedResult = powMod(2, n, p);\n        assert result == expectedResult : \"The result \" + result + \" does not match the expected result \" + expectedResult + \".\";\n\n        return result;\n    }\n\n    // Helper function to calculate (base^exp) % mod using exponentiation by squaring.\n    private static int powMod(int base, int exp, int mod) {\n        int result = 1;\n        int x = base % mod;\n        while (exp > 0) {\n            if (exp % 2 == 1) {\n                result = (result * x) % mod;\n            }\n            x = (x * x) % mod;\n            exp /= 2;\n        }\n        return result;\n    }\n}\n"}
{"file_name": "IS_SORTED.java", "content": "package humaneval.buggy;\n\nimport java.util.HashMap;\n\n/*\n * Given a list of numbers, return whether or not they are sorted\n * in ascending order. If list has more than 1 duplicate of the same\n * number, return False. Assume no negative numbers and only integers.\n *\n * Examples:\n * is_sorted([5]) ➞ True\n * is_sorted([1, 2, 3, 4, 5]) ➞ True\n * is_sorted([1, 3, 2, 4, 5]) ➞ False\n * is_sorted([1, 2, 3, 4, 5, 6]) ➞ True\n * is_sorted([1, 2, 3, 4, 5, 6, 7]) ➞ True\n * is_sorted([1, 3, 2, 4, 5, 6, 7]) ➞ False\n * is_sorted([1, 2, 2, 3, 3, 4]) ➞ True\n * is_sorted([1, 2, 2, 2, 3, 4]) ➞ False\n */\n\npublic class IS_SORTED {\n\n    public static boolean is_sorted(int[] lst) {\n        // Precondition 1: Ensure that the list 'lst' is not null.\n        assert lst != null : \"Input 'lst' must not be null.\";\n\n        // Precondition 2: Ensure that all elements in 'lst' are non-negative integers.\n        for (int num : lst) {\n            assert num >= 0 : \"All elements in 'lst' must be non-negative integers.\";\n        }\n\n        // Check for more than 1 duplicate of the same number\n        HashMap<Integer, Integer> count_num = new HashMap<>();\n        for (int num : lst) {\n            count_num.put(num, count_num.getOrDefault(num, 0) + 1);\n            if (count_num.get(num) > 2) {\n                return false;\n            }\n        }\n\n        // Check if list is sorted in ascending order\n        for (int i = 0; i < lst.length - 1; i++) {\n            if (lst[i] > lst[i + 1]) {\n                return false;\n            }\n        }\n\n        boolean result = true;\n\n        // Postcondition 1: Ensure that the result is a boolean.\n        assert (result == true || result == false) : \"The result must be a boolean.\";\n\n        // Postcondition 2: If the result is true, ensure no more than 1 duplicate and the list is sorted.\n        if (result) {\n            // Check that the list is sorted\n            for (int i = 0; i < lst.length - 1; i++) {\n                assert lst[i] <= lst[i + 1] : \"The list must be sorted in ascending order.\";\n            }\n            // Check that no element has more than 2 occurrences\n            for (int count : count_num.values()) {\n                assert count <= 2 : \"No element should appear more than twice in the list.\";\n            }\n        }\n\n        // Postcondition 3: If the result is false, either the list is not sorted or there are too many duplicates.\n        if (!result) {\n            boolean notSorted = false;\n            boolean tooManyDuplicates = false;\n\n            for (int i = 0; i < lst.length - 1; i++) {\n                if (lst[i] > lst[i + 1]) {\n                    notSorted = true;\n                    break;\n                }\n            }\n            for (int count : count_num.values()) {\n                if (count > 2) {\n                    tooManyDuplicates = true;\n                    break;\n                }\n            }\n\n            assert notSorted || tooManyDuplicates : \"If the result is false, the list is either not sorted or has too many duplicates.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "IS_PALINDROME.java", "content": "package humaneval.buggy;\n\n/* Checks if given string is a palindrome\n>>> is_palindrome('')\nTrue\n>>> is_palindrome('aba')\nTrue\n>>> is_palindrome('aaaaa')\nTrue\n>>> is_palindrome('zbcd')\nFalse */\n\npublic class IS_PALINDROME {\n\n    // Method to check if a string is a palindrome\n    public static boolean is_palindrome(String text) {\n        // Precondition 1: Ensure that 'text' is not null\n        assert text != null : \"Input 'text' must not be null.\";\n\n        // Precondition 2: Ensure that 'text' is a string (implicit in Java, since the input type is String)\n\n        int length = text.length();\n        for (int i = 0; i < length / 2; i += 1) {\n            if (text.charAt(i) != text.charAt(length - i - 1))\n                return false;\n        }\n        return true;\n    }\n\n\n}\n"}
{"file_name": "ROLLING_MAX.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ROLLING_MAX {\n    public static List<Integer> rolling_max(List<Integer> numbers) {\n        // Precondition 1: The input 'numbers' should not be null.\n        assert numbers != null : \"Input list 'numbers' must not be null.\";\n\n        // Precondition 2: The input 'numbers' should be a list of integers.\n        for (Object num : numbers) {\n            assert num instanceof Integer : \"All elements in 'numbers' must be integers.\";\n        }\n\n        // Precondition 3: The length of the 'numbers' list should be within a reasonable boundary.\n        int maxLength = (int) 1e6; // Example boundary condition.\n        assert numbers.size() <= maxLength : \"Input list 'numbers' should not exceed \" + maxLength + \" elements.\";\n\n        List<Integer> result = new ArrayList<>();\n        if (numbers.isEmpty()) {\n            // Postcondition 5: If the input list 'numbers' is empty, the result should also be an empty list.\n            assert result.isEmpty() : \"If the input list 'numbers' is empty, the result should also be an empty list.\";\n            return result;\n        }\n\n        int runningMax = numbers.get(0);\n\n        for (int n : numbers) {\n            runningMax = Math.max(runningMax, n);\n            result.add(runningMax);\n        }\n\n        // Postcondition 1: The result should be a list of integers.\n        for (Object num : result) {\n            assert num instanceof Integer : \"The result must be a list of integers.\";\n        }\n\n        // Postcondition 2: The length of the result list should match the length of the input list.\n        assert result.size() == numbers.size() : \"The length of the result list must match the length of the input list.\";\n\n        // Postcondition 3: Each element in the result should be the maximum of all elements up to that point.\n        for (int i = 0; i < result.size(); i++) {\n            int expectedMax = Integer.MIN_VALUE;\n            for (int j = 0; j <= i; j++) {\n                expectedMax = Math.max(expectedMax, numbers.get(j));\n            }\n            assert result.get(i) == expectedMax : \"Element at index \" + i + \" should be the maximum of elements up to that point.\";\n        }\n\n        // Postcondition 4: The result list should be non-decreasing.\n        for (int i = 1; i < result.size(); i++) {\n            assert result.get(i) >= result.get(i - 1) : \"The result list should be non-decreasing.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "HAS_CLOSE_ELEMENTS.java", "content": "package humaneval.buggy;\n\nimport java.util.List;\nimport java.util.Collections;\n\npublic class HAS_CLOSE_ELEMENTS {\n\n    public static boolean has_close_elements(List<Double> numbers, double threshold) {\n        // Precondition 1: Ensure that the 'numbers' list is not empty.\n        assert numbers != null && !numbers.isEmpty() : \"The list of numbers should not be empty.\";\n\n        // Precondition 2: Ensure that 'threshold' is a positive number.\n        assert threshold > 0 : \"Threshold must be a positive number.\";\n\n        // Precondition 3: Ensure that all elements in 'numbers' are of type Double.\n        assert numbers.stream().allMatch(num -> num instanceof Double) : \"All elements in the list must be of type Double.\";\n\n        // Sort the numbers list\n        Collections.sort(numbers);\n\n        // Check for close elements\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) < threshold) {\n                return true;\n            }\n        }\n\n        // Postcondition 1: The sorted list should have the same length as the original list.\n        assert numbers.size() == numbers.size() : \"Sorted list length should match original list length.\";\n\n        // Postcondition 2: The sorted list should be in non-decreasing order.\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            assert numbers.get(i) <= numbers.get(i + 1) : \"Sorted list should be in non-decreasing order.\";\n        }\n\n        // Postcondition 3: If the result is true, at least one pair of adjacent elements should have a difference less than the threshold.\n        boolean result = false;\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            if (numbers.get(i + 1) - numbers.get(i) < threshold) {\n                result = true;\n                break;\n            }\n        }\n\n        // Postcondition 4: If the result is false, no pair of adjacent elements should have a difference less than the threshold.\n        if (!result) {\n            for (int i = 0; i < numbers.size() - 1; i++) {\n                assert numbers.get(i + 1) - numbers.get(i) >= threshold : \"If false, no pair should have a difference less than the threshold.\";\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "EVEN_ODD_PALINDROME.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n/*\n * Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: [1, 2]\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: [4, 6]\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned ArrayList has the number of even and odd integer palindromes respectively.\n */\n\npublic class EVEN_ODD_PALINDROME {\n\n    // Helper function to check if a number is a palindrome\n    public static boolean is_palindrome(int n) {\n        String n_str = Integer.toString(n);\n        String n_str_rev = new StringBuilder(n_str).reverse().toString();\n        return n_str.equals(n_str_rev);\n    }\n\n    public static ArrayList<Integer> even_odd_palindrome(int n) {\n        // Precondition 1: Ensure that 'n' is not None (in Java, n cannot be null since it's a primitive type).\n        // Precondition 2: Ensure that 'n' is an integer (in Java, n's type is already int).\n        // Precondition 3: Ensure that 'n' is a positive integer.\n        assert n > 0 : \"Input 'n' must be a positive integer.\";\n\n        // Precondition 4: Ensure that 'n' is within the valid range (1 <= n <= 10^3).\n        assert n >= 1 && n <= 1000 : \"Input 'n' must be within the range 1 <= n <= 10^3.\";\n\n        int even_palindrome_count = 0, odd_palindrome_count = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (is_palindrome(i)) {\n                if ((i % 2) == 1) {\n                    odd_palindrome_count++;\n                } else {\n                    even_palindrome_count++;\n                }\n            }\n        }\n\n        ArrayList<Integer> result = new ArrayList<>(Arrays.asList(even_palindrome_count, odd_palindrome_count));\n\n        // Postcondition 1: Ensure that the result is an ArrayList.\n        assert result instanceof ArrayList : \"The result must be an ArrayList.\";\n\n        // Postcondition 2: Ensure that the ArrayList has exactly two elements.\n        assert result.size() == 2 : \"The result must have exactly two elements.\";\n\n        // Postcondition 3: Ensure that both elements in the ArrayList are non-negative integers.\n        assert result.get(0) >= 0 && result.get(1) >= 0 : \"Both elements in the result must be non-negative integers.\";\n\n        // Postcondition 4: Ensure that the counts correctly represent the number of even and odd palindromes.\n        int computed_even_count = 0, computed_odd_count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (is_palindrome(i)) {\n                if ((i % 2) == 1) {\n                    computed_odd_count++;\n                } else {\n                    computed_even_count++;\n                }\n            }\n        }\n        assert result.get(0) == computed_even_count && result.get(1) == computed_odd_count :\n                \"The result does not correctly represent the number of even and odd palindromes.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "STRING_XOR.java", "content": "package humaneval.buggy;\n\npublic class STRING_XOR {\n    public static String string_xor(String a, String b) {\n        // Precondition 1: Ensure that 'a' is not null.\n        assert a != null : \"Precondition failed: Input 'a' must not be null.\";\n\n        // Precondition 2: Ensure that 'b' is not null.\n        assert b != null : \"Precondition failed: Input 'b' must not be null.\";\n\n        // Precondition 3: Ensure that 'a' and 'b' have the same length.\n        assert a.length() == b.length() : \"Precondition failed: Both inputs 'a' and 'b' must have the same length.\";\n\n        // Precondition 4: Ensure that both 'a' and 'b' contain only '0' and '1' characters.\n        assert a.matches(\"[01]*\") : \"Precondition failed: Input 'a' must contain only '0' and '1' characters.\";\n        assert b.matches(\"[01]*\") : \"Precondition failed: Input 'b' must contain only '0' and '1' characters.\";\n\n        // Perform XOR operation.\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < a.length(); i += 1) {\n            if (a.charAt(i) == b.charAt(i)) {\n                result.append(\"0\");\n            } else {\n                result.append(\"1\");\n            }\n        }\n\n        String xorResult = result.toString();\n\n        // Postcondition 1: Ensure that the result is not null.\n        assert xorResult != null : \"Postcondition failed: The result must not be null.\";\n\n        // Postcondition 2: Ensure that the result has the same length as the inputs.\n        assert xorResult.length() == a.length() : \"Postcondition failed: The result must have the same length as the input strings.\";\n\n        // Postcondition 3: Ensure that the result contains only '0' and '1' characters.\n        assert xorResult.matches(\"[01]*\") : \"Postcondition failed: The result must contain only '0' and '1' characters.\";\n\n        // Postcondition 4: Ensure that each bit in the result correctly represents the XOR of the corresponding bits in 'a' and 'b'.\n        for (int i = 0; i < a.length(); i += 1) {\n            char expected = (a.charAt(i) == b.charAt(i)) ? '0' : '1';\n            assert xorResult.charAt(i) == expected :\n                    \"Postcondition failed: XOR result at position \" + i + \" is incorrect. Expected: \" + expected + \" but got: \" + xorResult.charAt(i);\n        }\n\n        return xorResult;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the function\n        System.out.println(string_xor(\"1100\", \"1010\")); // Expected: 0110\n        System.out.println(string_xor(\"1111\", \"0000\")); // Expected: 1111\n        System.out.println(string_xor(\"0000\", \"0000\")); // Expected: 0000\n    }\n}\n"}
{"file_name": "WORDS_IN_SENTENCE.java", "content": "package humaneval.buggy;\n\n/* You are given a string representing a sentence,\nthe sentence contains some words separated by a space,\nand you have to return a string that contains the words from the original sentence,\nwhose lengths are prime numbers,\nthe order of the words in the new string should be the same as the original one.\n\nExample 1:\n    Input: sentence = \"This is a test\"\n    Output: \"is\"\n\nExample 2:\n    Input: sentence = \"lets go for swimming\"\n    Output: \"go for\"\n\nConstraints:\n    * 1 <= len(sentence) <= 100\n    * sentence contains only letters */\n\npublic class WORDS_IN_SENTENCE {\n    public static String words_in_sentence(String sentence) {\n        // Precondition 1: The input sentence should not be null.\n        assert sentence != null : \"Precondition failed: The input sentence must not be null.\";\n\n        // Precondition 2: The length of the input sentence should be between 1 and 100 (inclusive).\n        assert sentence.length() >= 1 && sentence.length() <= 100 :\n                \"Precondition failed: The length of the input sentence must be between 1 and 100.\";\n\n        // Precondition 3: The sentence should contain only letters and spaces.\n        assert sentence.matches(\"[a-zA-Z ]*\") :\n                \"Precondition failed: The sentence should contain only letters and spaces.\";\n\n        String result = \"\";\n\n        for (String word : sentence.split(\" \")) {\n            int flag = 0;\n            if (word.length() <= 1) flag = 1;\n            for (int i = 2; i <= Math.sqrt(word.length()); i += 1){\n                if (word.length() % i == 0) {\n                    flag = 1;\n                    break;\n                }\n            }\n            if (flag == 0)\n                result += word + \" \";\n        }\n\n        result = result.trim();\n\n        // Postcondition 1: The result should not be null.\n        assert result != null : \"Postcondition failed: The result must not be null.\";\n\n\n        return result;\n    }\n\n    // Helper method to check if a given number is prime.\n    private static boolean isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        // Sample test cases to validate the assertions\n        assert words_in_sentence(\"This is a test\").equals(\"is\") : \"Test case 1 failed.\";\n        assert words_in_sentence(\"lets go for swimming\").equals(\"go for\") : \"Test case 2 failed.\";\n        assert words_in_sentence(\"hello world\").equals(\"\") : \"Test case 3 failed.\";\n    }\n}\n"}
{"file_name": "SORT_ARRAY.java", "content": "package humaneval.buggy;\n\nimport java.util.Arrays;\n\n/* Given an array of non-negative integers, return a copy of the given array after sorting,\nyou will sort the given array in ascending order if the sum( first index value, last index value) is odd,\nor sort it in descending order if the sum( first index value, last index value) is even.\n\nNote:\n* don't change the given array.\n\nExamples:\n* sort_array([]) => []\n* sort_array([5]) => [5]\n* sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n* sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0] */\nimport java.util.Arrays;\n\npublic class SORT_ARRAY {\n    public static int[] sort_array(int[] array) {\n        // Precondition 1: Ensure that the input 'array' is not null.\n        assert array != null : \"Input 'array' must not be null.\";\n\n        // Precondition 2: Ensure that all elements in the array are non-negative integers.\n        for (int num : array) {\n            assert num >= 0 : \"All elements in 'array' must be non-negative integers.\";\n        }\n\n        // If the array is empty, return it as is.\n        if (array.length == 0) {\n            // Postcondition 1: The result should be an array.\n            assert array instanceof int[] : \"The result must be an array.\";\n            // Postcondition 2: The result should be an empty array if the input is empty.\n            assert array.length == 0 : \"The result must be an empty array if the input is empty.\";\n            return array;\n        }\n\n        // Make a copy of the array to avoid modifying the original array.\n        int[] result = Arrays.copyOf(array, array.length);\n\n        // Determine if we should sort in ascending or descending order based on the sum of the first and last elements.\n        boolean ascendingOrder = (result[0] + result[result.length - 1]) % 2 == 1;\n\n        // Sort the array in ascending or descending order based on the condition.\n        if (ascendingOrder) {\n            Arrays.sort(result);\n        } else {\n            Arrays.sort(result);\n            // Reverse the array to get descending order.\n            for (int i = 0; i < result.length / 2; i++) {\n                int tmp = result[i];\n                result[i] = result[result.length - i - 1];\n                result[result.length - i - 1] = tmp;\n            }\n        }\n\n        // Postcondition 1: The result should be an array of integers.\n        assert result instanceof int[] : \"The result must be an array of integers.\";\n\n        // Postcondition 2: The length of the result array should match the length of the input array.\n        assert result.length == array.length : \"The length of the result array must match the length of the input array.\";\n\n        // Postcondition 3: The result should be correctly sorted based on the condition.\n        if (ascendingOrder) {\n            assert Arrays.equals(result, Arrays.stream(array).sorted().toArray()) :\n                    \"The result should be sorted in ascending order.\";\n        } else {\n            int[] sortedDesc = Arrays.stream(array).boxed()\n                    .sorted((a, b) -> b - a)\n                    .mapToInt(i -> i)\n                    .toArray();\n            assert Arrays.equals(result, sortedDesc) :\n                    \"The result should be sorted in descending order.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the implementation\n        System.out.println(Arrays.toString(sort_array(new int[]{}))); // Output: []\n        System.out.println(Arrays.toString(sort_array(new int[]{5}))); // Output: [5]\n        System.out.println(Arrays.toString(sort_array(new int[]{2, 4, 3, 0, 1, 5}))); // Output: [0, 1, 2, 3, 4, 5]\n        System.out.println(Arrays.toString(sort_array(new int[]{2, 4, 3, 0, 1, 5, 6}))); // Output: [6, 5, 4, 3, 2, 1, 0]\n    }\n}\n"}
{"file_name": "MULTIPLY.java", "content": "package humaneval.buggy;\n\npublic class MULTIPLY {\n    public static int multiply(int a, int b) {\n        // Precondition 1: Ensure both 'a' and 'b' are integers.\n        // This is inherently ensured by Java's type system as the method signature requires 'a' and 'b' to be integers.\n\n        // Compute the product of the unit digits.\n        int result = Math.abs(a % 10) * Math.abs(b % 10);\n\n        // Postcondition 1: Ensure the result is an integer.\n        // This is inherently ensured as the result is an integer variable.\n\n        // Postcondition 2: Ensure the result is correct.\n        assert result == (Math.abs(a) % 10) * (Math.abs(b) % 10)\n                : \"The result must be the product of the unit digits of 'a' and 'b'.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "GET_ROW.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\n\npublic class GET_ROW {\n\n    public class Tuple {\n        int x;\n        int y;\n\n        public Tuple(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (o instanceof Tuple) {\n                return this.x == ((Tuple) o).x && this.y == ((Tuple) o).y;\n            }\n            return false;\n        }\n\n        @Override\n        public String toString() {\n            return \"(\" + x + \", \" + y + \")\";\n        }\n    }\n\n    public static ArrayList<Tuple> get_row(ArrayList<ArrayList<Integer>> lst, int x) {\n        // Precondition 1: Ensure that 'lst' is not null.\n        assert lst != null : \"Input 'lst' must not be null.\";\n\n        // Precondition 2: Ensure that 'lst' is a list of lists.\n        for (Object row : lst) {\n            assert row instanceof ArrayList<?> : \"Each element in 'lst' must be a list.\";\n        }\n\n        // Precondition 3: Ensure that 'x' is an integer.\n        assert Integer.class.isInstance(x) : \"Input 'x' must be an integer.\";\n\n        ArrayList<Tuple> result = new ArrayList<>();\n\n        // Collecting coordinates\n        for (int i = 0; i < lst.size(); i++) {\n            for (int j = lst.get(i).size() - 1; j >= 0; j--) {\n                if (lst.get(i).get(j) == x) {\n                    result.add(new GET_ROW().new Tuple(i, j));\n                }\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is a list of tuples.\n        assert result instanceof ArrayList<?> : \"The result must be a list.\";\n        for (Tuple coord : result) {\n            assert coord instanceof Tuple : \"Each element in the result must be a Tuple.\";\n        }\n\n        // Postcondition 2: Ensure that the tuples are sorted by rows in ascending order.\n        for (int i = 0; i < result.size() - 1; i++) {\n            assert result.get(i).x <= result.get(i + 1).x : \"The tuples should be sorted by rows in ascending order.\";\n        }\n\n        // Postcondition 3: Within each row, ensure that tuples are sorted by columns in descending order.\n        for (int i = 0; i < result.size() - 1; i++) {\n            if (result.get(i).x == result.get(i + 1).x) {\n                assert result.get(i).y > result.get(i + 1).y : \"Within each row, tuples should be sorted by columns in descending order.\";\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "COUNT_NUMS.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\n\npublic class COUNT_NUMS {\n    public static int count_nums(ArrayList<Integer> arr) {\n        // Preconditions\n// 1. The input array `arr` must not be null\n        assert arr != null : \"Precondition failed: Input array 'arr' must not be null.\";\n\n// 2. The input array may be empty, which is allowed\n        assert arr.size() >= 0 : \"Precondition failed: Input array must be a valid list, even if empty.\";\n\n// 3. All elements in the array must be integers (handled by Java's type system)\n        for (Integer num : arr) {\n            assert num != null : \"Precondition failed: All elements in the array must be valid integers.\";\n        }\n\n        int count = 0;\n        for(int num : arr) {\n            boolean neg = num < 0;\n            if(neg) num *= -1;\n            String num_string = Integer.toString(num);\n            int sum = 0;\n            for(int i = 0; i < num_string.length(); i++) {\n                if((i == 0) && neg) sum -= num_string.charAt(i) - '0';\n                else sum += num_string.charAt(i) - '0';\n            }\n            if(sum > 0) count++;\n        }\n        // Postconditions\n// 1. The result must be a non-negative integer (as the count of numbers)\n        assert count >= 0 : \"Postcondition failed: Result must be a non-negative integer.\";\n\n// 2. If the array is empty, the result must be 0\n        if (arr.isEmpty()) {\n            assert count == 0 : \"Postcondition failed: Result must be 0 if the input array is empty.\";\n        }\n\n// 3. The result must reflect the number of elements in the array that meet the sum condition (sum > 0)\n        int expectedCount = 0;\n        for (int num : arr) {\n            boolean neg = num < 0;\n            if (neg) num *= -1;\n            String num_string = Integer.toString(num);\n            int sum = 0;\n            for (int i = 0; i < num_string.length(); i++) {\n                if ((i == 0) && neg) sum -= num_string.charAt(i) - '0';\n                else sum += num_string.charAt(i) - '0';\n            }\n            if (sum > 0) expectedCount++;\n        }\n        assert count == expectedCount : \"Postcondition failed: The result does not match the expected count of valid elements.\";\n\n// 4. The result must remain consistent across repeated evaluations\n        int repeatedResult = count;\n        assert count == repeatedResult : \"Postcondition failed: The result is inconsistent across evaluations.\";\n\n        return count;\n    }\n}\n"}
{"file_name": "CORRECT_BRACKETING.java", "content": "package humaneval.buggy;\n\n/* brackets is a string of \"<\" and \">\".\nreturn True if every opening bracket has a corresponding closing bracket.\n\n>>> correct_bracketing(\"<\")\nFalse\n>>> correct_bracketing(\"<>\")\nTrue\n>>> correct_bracketing(\"<<><>>\")\nTrue\n>>> correct_bracketing(\"><<>\")\nFalse */\n\npublic class CORRECT_BRACKETING {\n    public static boolean correct_bracketing(String brackets) {\n        // Preconditions\n// 1. The input string `brackets` must not be null\n        assert brackets != null : \"Precondition failed: Input string 'brackets' must not be null.\";\n\n// 2. The input string `brackets` must only contain the characters '<' and '>'\n        for (char b : brackets.toCharArray()) {\n            assert b == '<' || b == '>' : \"Precondition failed: Input string contains invalid characters.\";\n        }\n\n// 3. The input string `brackets` may be empty, which should be allowed\n        assert brackets.length() >= 0 : \"Precondition failed: The input string length must be valid (even if empty).\";\n\n        int depth = 0;\n        for (char b : brackets.toCharArray()) {\n            if (b == '<')\n                depth += 1;\n            else\n                depth -= 1;\n            if (depth < 0)\n                return false;\n        }\n\n        return depth == 0;\n    }\n}\n"}
{"file_name": "ROUNDED_AVG.java", "content": "package humaneval.buggy;\n\n/*\n * You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m).\n    Round the answer to the nearest integer (if the number ends in 0.5 round down)\n    and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"11\"\n    rounded_avg(7, 5) => -1\n */\n\npublic class ROUNDED_AVG {\n    public static String rounded_avg(int n, int m) {\n        if(m < n) return \"-1\";\n        int summation = 0;\n        for(int i = n; i < m + 1; i++) {\n            summation += i;\n        }\n        double avg = ((double) summation)/((double) (m - n + 1));\n        double rem = avg - Math.floor(avg);\n        int avg_rounded = 0;\n        if(rem <= 0.5) {\n            avg_rounded = (int) Math.floor(avg);\n        } else {\n            avg_rounded = (int) Math.ceil(avg);\n        }\n        return Integer.toBinaryString(avg_rounded);\n    }\n}\n"}
{"file_name": "SOLVE.java", "content": "package humaneval.buggy;\n\n/* Given a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N integer\n            Constraints: 0 ≤ N ≤ 10000.\nOutput:\n        a string of binary number */\n\npublic class SOLVE {\n\n    public static String solve(int N) {\n        // Preconditions\n\n        // Precondition 1: Ensure that N is a non-negative integer.\n        assert N >= 0 : \"Input 'N' must be a non-negative integer.\";\n\n        // Precondition 2: Ensure that N is within the specified range.\n        assert N <= 10000 : \"Input 'N' must be less than or equal to 10000.\";\n\n        // Calculate the sum of digits of N.\n        int sum = 0;\n        String numStr = Integer.toString(N);\n        for (int i = 0; i < numStr.length(); i++) {\n            sum += Character.getNumericValue(numStr.charAt(i));\n        }\n\n        // Convert the sum to binary string.\n        String result = Integer.toBinaryString(sum);\n\n        // Postconditions\n\n        // Postcondition 1: Ensure that the result is a string.\n        assert result instanceof String : \"The result must be a string.\";\n\n        // Postcondition 2: Ensure that the result is a valid binary string representation.\n        assert result.matches(\"[01]+\") : \"The result must be a valid binary string.\";\n\n        // Postcondition 3: Ensure that the result correctly represents the binary form of the sum.\n        assert Integer.parseInt(result, 2) == sum : \"The result must correctly represent the binary form of the sum of digits.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the implementation\n        System.out.println(solve(1000)); // Output: \"1\"\n        System.out.println(solve(150));  // Output: \"110\"\n        System.out.println(solve(147));  // Output: \"1100\"\n    }\n}\n"}
{"file_name": "PRIME_FIB.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\n\npublic class PRIME_FIB {\n    public static boolean is_prime(int n) {\n        if (n < 2)\n            return false;\n        for (int i = 2; i < (int)Math.sqrt(n) + 1; i += 1){\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n\n    public static int prime_fib(int n){\n        ArrayList<Integer> fib = new ArrayList<Integer>();\n        fib.add(0);\n        fib.add(1);\n\n        while (true) {\n            int len = fib.size();\n            fib.add(fib.get(len - 1) + fib.get(len - 2));\n            if (is_prime(fib.get(fib.size() - 1)))\n                n -= 1;\n            if (n == 0)\n                return fib.get(fib.size() - 1);\n        }\n    }\n}\n"}
{"file_name": "FILE_NAME_CHECK.java", "content": "package humaneval.buggy;\n\npublic class FILE_NAME_CHECK {\n\n    public static String file_name_check(String file_name) {\n        // Precondition 1: Ensure that 'file_name' is a string.\n        assert file_name != null : \"Input 'file_name' must not be null.\";\n        assert file_name instanceof String : \"Input 'file_name' must be a string.\";\n\n        // Split the file name by dot\n        String[] lst = file_name.split(\"\\\\.\");\n\n        // Check for exactly one dot in the file name\n        if (lst.length != 2)\n            return \"No\";\n\n        // Check if the extension is valid\n        if (!(lst[1].equals(\"txt\") || lst[1].equals(\"exe\") || lst[1].equals(\"dll\")))\n            return \"No\";\n\n        // Check if the substring before the dot is not empty and starts with a letter\n        if (lst[0].length() == 0)\n            return \"No\";\n\n        if (!Character.isLetter(lst[0].charAt(0)))\n            return \"No\";\n\n        // Check for more than three digits in the file name\n        int digit_cnt = 0;\n        for (char c : file_name.toCharArray()) {\n            if (Character.isDigit(c))\n                digit_cnt++;\n        }\n        if (digit_cnt > 3)\n            return \"No\";\n\n        String result = \"Yes\";\n\n        // Postcondition 1: Ensure that the result is a string.\n        assert result instanceof String : \"The result must be a string.\";\n\n        // Postcondition 2: Ensure that the result is either 'Yes' or 'No'.\n        assert result.equals(\"Yes\") || result.equals(\"No\") : \"The result must be either 'Yes' or 'No'.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "FIX_SPACES.java", "content": "package humaneval.buggy;\n\npublic class FIX_SPACES {\n\n    public static String fix_spaces(String text) {\n        // Precondition 1: Ensure that 'text' is a string.\n        assert text != null : \"Input 'text' must not be null.\";\n        assert text instanceof String : \"Input 'text' must be a string.\";\n\n        StringBuilder new_text = new StringBuilder();\n        int i = 0;\n        int start = 0;\n        int end = 0;\n\n        while (i < text.length()) {\n            if (text.charAt(i) == ' ') {\n                end += 1;\n            } else {\n                if (end - start > 2) {\n                    new_text.append(\"-\").append(text.substring(i, i + 1));\n                } else if (end - start > 0) {\n                    for (int j = start; j < end; j++) {\n                        new_text.append(\"_\");\n                    }\n                    new_text.append(text.substring(i, i + 1));\n                } else {\n                    new_text.append(text.substring(i, i + 1));\n                }\n                start = i + 1;\n                end = i + 1;\n            }\n            i += 1;\n        }\n\n        if (end - start > 2) {\n            new_text.append(\"-\");\n        } else if (end - start > 0) {\n            for (int j = start; j < end; j++) {\n                new_text.append(\"_\");\n            }\n        }\n\n        String result = new_text.toString();\n\n        // Postcondition 1: Ensure that the result is a string.\n        assert result instanceof String : \"The result must be a string.\";\n\n        // Postcondition 2: Ensure that there are no sequences of three or more spaces in the result.\n        assert !result.contains(\"   \") : \"The result must not contain three or more consecutive spaces.\";\n\n        // Postcondition 3: Ensure that all single spaces are replaced by underscores.\n        assert !result.contains(\" \") : \"The result must not contain single spaces.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "FILTER_INTEGERS.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FILTER_INTEGERS {\n\n    public static List<Integer> filter_integers(List<Object> values) {\n        // Precondition 1: Ensure that 'values' is not null.\n        assert values != null : \"Input 'values' must not be null.\";\n\n        // Precondition 2: Ensure that 'values' is a list.\n        assert values instanceof List : \"Input 'values' must be a list.\";\n\n        List<Integer> result = new ArrayList<Integer>();\n\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer) value);\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is a list.\n        assert result instanceof List : \"The result must be a list.\";\n\n        // Postcondition 2: Ensure that all elements in the result are integers.\n        for (Object obj : result) {\n            assert obj instanceof Integer : \"All elements in the result must be integers.\";\n        }\n\n        // Postcondition 3: Ensure that if the input contains no integers, the result is an empty list.\n        boolean containsIntegers = false;\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                containsIntegers = true;\n                break;\n            }\n        }\n        if (!containsIntegers) {\n            assert result.isEmpty() : \"If the input list contains no integers, the result should be an empty list.\";\n        }\n\n        return result;\n    }\n}\n"}
{"file_name": "FIND_MAX.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\n\npublic class FIND_MAX {\n    public static String find_max(String[] words) {\n        // Precondition 1: Ensure that 'words' is not null and is an array.\n        assert words != null : \"Input 'words' must not be null.\";\n        assert words instanceof String[] : \"Input 'words' must be an array of strings.\";\n\n        // Precondition 2: Ensure that all elements in 'words' are strings.\n        for (String word : words) {\n            assert word instanceof String : \"All elements in 'words' must be strings.\";\n        }\n\n        // Convert the array to a list for easier sorting\n        ArrayList<String> words_list = new ArrayList<>(Arrays.asList(words));\n\n        // Sort based on the number of unique characters and lexicographical order\n        Collections.sort(\n                words_list,\n                (w1, w2) -> {\n                    HashSet<Character> s1 = new HashSet<>();\n                    for (char c : w1.toCharArray()) {\n                        s1.add(c);\n                    }\n\n                    HashSet<Character> s2 = new HashSet<>();\n                    for (char c : w2.toCharArray()) {\n                        s2.add(c);\n                    }\n\n                    // Compare by unique character size, then lexicographical order if sizes are equal\n                    if (s2.size() != s1.size()) return s2.size() - s1.size();\n                    else return w1.compareTo(w2);\n                }\n        );\n\n        String result = words_list.get(0);\n\n        // Postcondition 1: Ensure that the result is a string.\n        assert result instanceof String : \"The result must be a string.\";\n\n        // Postcondition 2: Ensure that the result is one of the words in the input array.\n        assert Arrays.asList(words).contains(result) : \"The result must be one of the words in the input array.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "LARGEST_SMALLEST_INTEGERS.java", "content": "package humaneval.buggy;\n\n/*\n * Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as 0.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n */\n\npublic class LARGEST_SMALLEST_INTEGERS {\n    public static int[] largest_smallest_integers(int[] lst) {\n        boolean negative = false, positive = false;\n        int max_negative = Integer.MIN_VALUE, min_positive = Integer.MAX_VALUE;\n        for(int i = 0; i < lst.length; i++) {\n            if(lst[i] < 0) {\n                negative = true;\n                max_negative = Math.max(max_negative, lst[i]);\n            } else if(lst[i] > 0) {\n                positive = true;\n                min_positive = Math.min(min_positive, lst[i]);\n            }\n        }\n        if(!negative) max_negative = 0;\n        if(!positive) min_positive = 0;\n        int[] result = {max_negative, min_positive};\n        return result;\n    }\n}\n"}
{"file_name": "GET_CLOSET_VOWEL.java", "content": "package humaneval.buggy;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class GET_CLOSET_VOWEL {\n\n    public static String get_closet_vowel(String word) {\n        // Precondition 1: Ensure that 'word' is not null.\n        assert word != null : \"Input 'word' must not be null.\";\n\n        // Precondition 2: Ensure that 'word' is a valid string.\n        assert word instanceof String : \"Input 'word' must be a string.\";\n\n        // Precondition 3: Ensure that 'word' contains only English letters.\n        assert word.chars().allMatch(Character::isLetter) : \"Input 'word' must contain only English letters.\";\n\n        if (word.length() < 3) return \"\";  // No vowels between consonants possible for words shorter than 3 characters.\n\n        ArrayList<Character> vowels = new ArrayList<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n\n        for (int i = word.length() - 2; i > 0; i--) {\n            if (vowels.contains(word.charAt(i))) {\n                if (!vowels.contains(word.charAt(i + 1)) && !vowels.contains(word.charAt(i - 1))) {\n                    return word.substring(i, i + 1);\n                }\n            }\n        }\n\n        String result = \"\";\n\n        // Postcondition 1: Ensure that the result is a string.\n        assert result instanceof String : \"The result must be a string.\";\n\n        // Postcondition 2: Ensure that the result is either an empty string or a vowel.\n        assert result.equals(\"\") || vowels.contains(result.charAt(0)) : \"The result must be either an empty string or a vowel.\";\n\n        return result;\n    }\n}\n"}
{"file_name": "SEARCH.java", "content": "package humaneval.buggy;\nimport java.util.HashMap;\n\n/*\n * You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n * zero, and has a frequency greater than or equal to the value of the integer itself.\n * The frequency of an integer is the number of times it appears in the list.\n * If no such a value exists, return -1.\n * Examples:\n *     search([4, 1, 2, 2, 3, 1]) == 2\n *     search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n *     search([5, 5, 4, 4, 4]) == -1\n */\n\npublic class SEARCH {\n    public static int search(int[] lst) {\n        // Precondition 1: Ensure the input array is not null.\n        assert lst != null : \"Input 'lst' must not be null.\";\n\n        // Precondition 2: Ensure the input array contains only positive integers.\n        for (int num : lst) {\n            assert num > 0 : \"All elements in 'lst' must be positive integers.\";\n        }\n\n        // Create a frequency map to count occurrences of each number\n        HashMap<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n\n        int result = -1;\n\n        // Iterate through the frequency map to find the greatest integer\n        // that meets the condition of frequency >= value\n        for (int key : frequencyMap.keySet()) {\n            int frequency = frequencyMap.get(key);\n            if (frequency >= key) {\n                result = Math.max(result, key);\n            }\n        }\n\n        // Postcondition 1: Ensure the result is an integer.\n        assert result == (int) result : \"The result must be an integer.\";\n\n        // Postcondition 2: If no number meets the criteria, the result should be -1.\n        if (result == -1) {\n            for (int key : frequencyMap.keySet()) {\n                assert frequencyMap.get(key) < key :\n                        \"If result is -1, no number in 'lst' should meet the criteria.\";\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(search(new int[] {4, 1, 2, 2, 3, 1})); // Should return 2\n        System.out.println(search(new int[] {1, 2, 2, 3, 3, 3, 4, 4, 4})); // Should return 3\n        System.out.println(search(new int[] {5, 5, 4, 4, 4})); // Should return -1\n        System.out.println(search(new int[] {1, 1, 1, 1})); // Should return 1\n    }\n}\n"}
{"file_name": "STARTS_ONE_ENDS.java", "content": "package humaneval.buggy;\n\n/*\n * Given a positive integer n, return the count of the numbers of n-digit\n * positive integers that start or end with 1.\n */\n\npublic class STARTS_ONE_ENDS {\n\n    public static int starts_one_ends(int n) {\n        // Precondition 1: Ensure that 'n' is a positive integer.\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input 'n' must be a positive integer.\");\n        }\n\n        // Precondition 2: Ensure that 'n' is not greater than a reasonable limit.\n        int maxDigits = 9; // Example limit, adjust as needed.\n        if (n > maxDigits) {\n            throw new IllegalArgumentException(\"Input 'n' should not exceed \" + maxDigits + \" digits.\");\n        }\n\n        int result;\n\n        if (n == 1) {\n            result = 1;\n        } else {\n            result = (int) ((10 + 9 - 1) * Math.pow(10, n - 2));\n        }\n\n        // Postcondition 1: Ensure the result is a non-negative integer.\n        if (result < 0) {\n            throw new AssertionError(\"The result must be a non-negative integer.\");\n        }\n\n        // Postcondition 2: Ensure that for n = 1, the result is 1.\n        if (n == 1) {\n            if (result != 1) {\n                throw new AssertionError(\"For n = 1, the result must be 1.\");\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases to validate the function\n        System.out.println(starts_one_ends(1));  // Expected: 1\n        System.out.println(starts_one_ends(2));  // Expected: 18\n        System.out.println(starts_one_ends(3));  // Expected: 180\n    }\n}\n"}

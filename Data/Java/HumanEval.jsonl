{"id": "HumanEval/0", "code": "import java.util.ArrayList;\nimport java.util.Collections;\n\npublic class CloseElementsChecker {\n\n    public static boolean hasCloseElements(ArrayList<Double> numbers, double threshold) {\n        // Precondition 1: The 'numbers' list should not be empty.\n        assert numbers.size() > 0 : \"The list of numbers should not be empty.\";\n\n        // Precondition 2: The 'threshold' should be a positive number.\n        assert threshold > 0 : \"Threshold must be a positive number.\";\n\n        // Precondition 3: All elements in 'numbers' should be of type double.\n        assert numbers.stream().allMatch(num -> num instanceof Double) : \"All elements in the list must be of type double.\";\n\n        ArrayList<Double> sortedNumbers = new ArrayList<>(numbers);\n        Collections.sort(sortedNumbers);\n\n        boolean result = false;\n        for (int i = 0; i < sortedNumbers.size() - 1; i++) {\n            if (sortedNumbers.get(i + 1) - sortedNumbers.get(i) < threshold) {\n                result = true;\n                break;\n            }\n        }\n\n        // Postcondition 1: The sorted list should have the same length as the original list.\n        assert sortedNumbers.size() == numbers.size() : \"Sorted list length should match original list length.\";\n\n        // Postcondition 2: The sorted list should have all elements from the original list.\n        assert sortedNumbers.containsAll(numbers) : \"All elements of the original list must be in the sorted list.\";\n\n        // Postcondition 3: The sorted list should be in non-decreasing order.\n        for (int i = 0; i < sortedNumbers.size() - 1; i++) {\n            assert sortedNumbers.get(i) <= sortedNumbers.get(i + 1) : \"Sorted list should be in non-decreasing order.\";\n        }\n\n        // Postcondition 4: If the result is True, at least one pair of adjacent elements should have a difference less than the threshold.\n        if (result) {\n            for (int i = 0; i < sortedNumbers.size() - 1; i++) {\n                assert sortedNumbers.get(i + 1) - sortedNumbers.get(i) < threshold : \"If True, there must be at least one pair with a difference less than the threshold.\";\n            }\n        }\n\n        // Postcondition 5: If the result is False, no pair of adjacent elements should have a difference less than the threshold.\n        if (!result) {\n            for (int i = 0; i < sortedNumbers.size() - 1; i++) {\n                assert sortedNumbers.get(i + 1) - sortedNumbers.get(i) >= threshold : \"If False, no pair should have a difference less than the threshold.\";\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        ArrayList<Double> input1 = new ArrayList<>();\n        input1.add(1.0);\n        input1.add(2.8);\n        input1.add(3.0);\n        input1.add(4.0);\n        input1.add(5.0);\n        input1.add(2.0);\n        System.out.println(hasCloseElements(input1, 0.3)); // Should output: true\n    }\n}"}
{"id": "HumanEval/1", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ParenthesesSeparator {\n\n    public static List<String> separateParenGroups(String parenString) {\n        assert parenString != null : \"Input must not be null.\";\n        assert parenString instanceof String : \"Input must be a string.\";\n        assert parenString.chars().filter(ch -> ch == '(').count() == parenString.chars().filter(ch -> ch == ')').count() : \"The number of '(' should equal the number of ')' in the input string.\";\n\n        int count = 0;\n        String group = \"\";\n        List<String> results = new ArrayList<>();\n\n        for (char ch : parenString.toCharArray()) {\n            if (ch == '(') count++;\n            if (ch == ')') count--;\n            if (ch != ' ') group += ch;\n            if (count == 0) {\n                if (!group.equals(\"\")) results.add(group);\n                group = \"\";\n            }\n        }\n\n        assert parenString.chars().filter(ch -> ch == '(').count() == results.stream().mapToInt(s -> s.length() / 2).sum() : \"The total number of '(' in input should match the half of the sum of lengths of groups.\";\n        assert results.stream().allMatch(s -> s.length() > 0) : \"All groups in the results should be non-empty strings.\";\n        assert results.stream().allMatch(s -> s.startsWith(\"(\") && s.endsWith(\")\")) : \"Each group should start with '(' and end with ')'.\";\n        assert results.stream().allMatch(s -> s.chars().filter(ch -> ch == '(').count() == s.chars().filter(ch -> ch == ')').count()) : \"Each group should have an equal number of opening and closing parentheses.\";\n        assert String.join(\"\", results).equals(parenString.replace(\" \", \"\")) : \"Concatenation of all results should equal the input string with spaces removed.\";\n\n        if (parenString.trim().isEmpty()) assert results.isEmpty() : \"If the input string is empty or spaces, the result should be an empty list.\";\n        assert parenString.chars().filter(ch -> ch == '(').count() == parenString.chars().filter(ch -> ch == ')').count() : \"The total number of opening and closing parentheses in the input should be equal.\";\n\n        return results;\n    }\n\n    public static void main(String[] args) {\n        assert separateParenGroups(\"( ) (( )) (( )( ))\").equals(List.of(\"()\", \"(())\", \"(()())\"));\n        assert separateParenGroups(\"((()))\").equals(List.of(\"((()))\"));\n        assert separateParenGroups(\"()()()()\").equals(List.of(\"()\", \"()\", \"()\", \"()\"));\n        assert separateParenGroups(\"((()))((()))\").equals(List.of(\"((()))\", \"((()))\"));\n        assert separateParenGroups(\"(())(())(())\").equals(List.of(\"(())\", \"(())\", \"(())\"));\n    }\n}"}
{"id": "HumanEval/2", "code": "public class Main {\n\n    public static void main(String[] args) {\n        assert truncateNumber(3.5) == 0.5;\n        assert truncateNumber(9.75) >= 0 && truncateNumber(9.75) < 1;\n        assert truncateNumber(4.0) == 0.0;\n        assert truncateNumber(0.12345) == 0.12345;\n    }\n\n    public static double truncateNumber(double number) {\n        // Precondition 1: The input should not be null.\n        assert number != null : \"Input must not be null.\";\n\n        // Precondition 2: The input should be a double.\n        assert number instanceof Double : \"Input must be a double.\";\n\n        // Precondition 3: The input number should be positive.\n        assert number > 0 : \"Input number must be positive.\";\n\n        // Precondition 4: The input number should be within a reasonable boundary.\n        double maxValue = Math.pow(10, 6); // Example boundary condition; adjust as needed.\n        assert number <= maxValue : \"Input number should not exceed \" + maxValue + \".\";\n\n        double result = number - Math.floor(number);\n\n        // Postcondition 1: The result should be non-negative.\n        assert result >= 0 : \"The result should be non-negative.\";\n\n        // Postcondition 2: The result should be less than 1.\n        assert result < 1 : \"The result should be less than 1.\";\n\n        // Postcondition 3: The result should be equal to the difference between the number and its integer part.\n        assert result == number - Math.floor(number) : \"The result should match the difference between the input number and its integer part.\";\n\n        // Postcondition 4: The result should be a double.\n        assert result instanceof Double : \"The result should be a double.\";\n\n        // Postcondition 5: If the input number is an integer, the result should be 0.0.\n        if (number == Math.floor(number)) {\n            assert result == 0.0 : \"For integer inputs, the result should be 0.0.\";\n        }\n\n        return result;\n    }\n}"}
{"id": "HumanEval/3", "code": "import java.util.List;\n\npublic class Main {\n\n    public static boolean belowZero(List<Integer> operations) {\n        // Precondition 1\n        assert operations != null : \"Input must not be null.\";\n\n        // Precondition 2\n        assert operations instanceof List : \"Input must be a list.\";\n\n        // Precondition 3\n        for (Object operation : operations) {\n            assert operation instanceof Integer : \"All elements in the list must be integers.\";\n        }\n\n        // Precondition 4\n        assert !operations.isEmpty() : \"Input list must not be empty.\";\n\n        // Precondition 5\n        final long maxOperations = (long) Math.pow(10, 6); // Example boundary condition; adjust as needed.\n        assert operations.size() <= maxOperations : \"Input list should not exceed \" + maxOperations + \" elements.\";\n\n        int account = 0;\n\n        // Postcondition 1\n        assert account == 0 : \"Initial account balance should be zero.\";\n\n        for (int operation : operations) {\n            account += operation;\n            if (account < 0) {\n                // Postcondition 2\n                assert account < 0 : \"If returning True, account balance must be below zero.\";\n                return true;\n            }\n        }\n\n        // Postcondition 3\n        assert account >= 0 : \"If returning False, account balance never went below zero.\";\n\n        // Postcondition 4\n        boolean result = false;\n        assert result instanceof Boolean : \"The result should be a boolean value.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        assert !belowZero(new ArrayList<>()) : false;\n        assert !belowZero(Arrays.asList(1, 2, 3)) : false;\n        assert belowZero(Arrays.asList(-1, -2, -3)) : true;\n        assert belowZero(Arrays.asList(1, 2, -4, 5)) : true;\n        assert belowZero(Arrays.asList(-1, 1, -1, 1)) : true;\n    }\n\n}"}
{"id": "HumanEval/4", "code": "import java.util.List;\n\npublic class MeanAbsoluteDeviation {\n\n    public static double meanAbsoluteDeviation(List<Double> numbers) {\n        // For a given list of input numbers, calculate Mean Absolute Deviation\n        // around the mean of this dataset.\n        // Mean Absolute Deviation is the average absolute difference between each\n        // element and a center point (mean in this case):\n        // MAD = average | x - x_mean |\n\n        double sum = 0;\n        double mean;\n\n        for (Double num : numbers) {\n            sum += num;\n        }\n\n        mean = sum / numbers.size();\n\n        assert numbers instanceof List;\n        assert numbers.stream().allMatch(num -> num instanceof Double);\n        \n        assert Math.abs(mean - sum / numbers.size()) >= 0;\n        assert 0 <= numbers.stream().mapToDouble(x -> Math.abs(x - mean)).sum() / numbers.size();\n\n        return numbers.stream().mapToDouble(x -> Math.abs(x - mean)).sum() / numbers.size();\n    }\n\n    public static void main(String[] args) {\n        List<Double> testData = new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0, 4.0));\n        System.out.println(meanAbsoluteDeviation(testData)); // Output: 1.0\n    }\n}"}
{"id": "HumanEval/5", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    public static List<Integer> intersperse(List<Integer> numbers, int delimeter) {\n        // Precondition 1\n        assert numbers != null : \"Input list 'numbers' must not be null.\";\n\n        // Precondition 2\n        assert numbers instanceof List : \"Input 'numbers' must be a list.\";\n        assert (numbers.size() > 0) ? numbers.get(0) instanceof Integer : \"Input 'number' must be an integer.\";\n\n        // Precondition 3\n        int max_length = 1000000; // Example boundary condition; adjust as needed.\n        assert numbers.size() <= max_length : \"Input list 'numbers' should not exceed \" + max_length + \" elements.\";\n\n        List<Integer> originalNumbers = new ArrayList<>(numbers); // Copy of the original list for postcondition check\n        List<Integer> res = new ArrayList<>();\n\n        for (int i = 0; i < numbers.size(); i++) {\n            res.add(numbers.get(i));\n            if (i != numbers.size() - 1) {\n                res.add(delimeter);\n            }\n        }\n\n        // Postcondition 1\n        assert res instanceof List : \"The result must be a list.\";\n\n        // Postcondition 2\n        int expectedLength = (2 * numbers.size() - 1) > 0 ? (2 * numbers.size() - 1) : 0;\n        assert res.size() == expectedLength : \"The length of the result is incorrect.\";\n\n        // Postcondition 3\n        for (int i = 1; i < res.size() - 1; i += 2) {\n            assert res.get(i) == delimeter : \"The delimiter is not correctly placed between elements.\";\n        }\n\n        // Postcondition 4\n        assert numbers.equals(originalNumbers) : \"The input list 'numbers' should remain unchanged.\";\n\n        // Postcondition 5\n        if (numbers.size() == 0) {\n            assert res.isEmpty() : \"If the input list is empty, the result should also be an empty list.\";\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(intersperse(new ArrayList<>(), 4)); // []\n        System.out.println(intersperse(List.of(1, 2, 3), 4)); // [1, 4, 2, 4, 3]\n    }\n}"}
{"id": "HumanEval/6", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class NestedParensParser {\n\n    public List<Integer> parseNestedParens(String parenString) {\n        // Precondition 1: The input 'parenString' should not be null.\n        assert parenString != null : \"Input string 'parenString' must not be null.\";\n\n        // Precondition 2: The input should be a string.\n        assert parenString instanceof String : \"Input 'parenString' must be a string.\";\n\n        // Precondition 3: The input should only contain '(', ')', and spaces.\n        assert parenString.matches(\"^[() ]+$\") : \"Input string should only contain '(', ')', and spaces.\";\n\n        // Precondition 4: Each group of parentheses in the input string should be balanced.\n        assert parenString.isEmpty() || checkBalanced(parenString) : \"Each group of parentheses must be balanced.\";\n\n        // Precondition 5: The input string length should be within a reasonable boundary.\n        int maxLength = 1000000; // Example boundary condition; adjust as needed.\n        assert parenString.length() <= maxLength : \"Input string should not exceed \" + maxLength + \" characters.\";\n\n        List<Integer> result = new ArrayList<>();\n\n        for (String group : parenString.split(\" \")) {\n            if (!group.isEmpty()) {\n                result.add(getMaxDepth(group));\n            }\n        }\n\n        // Postcondition 1: The result should be a list of integers.\n        assert result.stream().allMatch(d -> d instanceof Integer) : \"The result must be a list of integers.\";\n\n        // Postcondition 2: The length of the result list should match the number of groups in the input string.\n        int numGroups = (int) parenString.chars().filter(ch -> ch == ' ').count() + 1;\n        assert result.size() == numGroups : \"The length of the result list should match the number of groups in the input string.\";\n\n        // Postcondition 3: Each element in the result list should be a non-negative integer.\n        assert result.stream().allMatch(d -> d >= 0) : \"Each depth value in the result list should be non-negative.\";\n\n        // Postcondition 4: The maximum depth should be correct based on the input structure.\n        int index = 0;\n        for (String group : parenString.split(\" \")) {\n            if (!group.isEmpty()) {\n                assert result.get(index++) == Math.max(getMaxDepth(group), 0) : \"The calculated maximum depth should match the input structure.\";\n            }\n        }\n\n        // Postcondition 5: If the input string is empty or contains only spaces, the result should be an empty list.\n        if (parenString.trim().isEmpty()) {\n            assert result.isEmpty() : \"If the input string is empty or spaces, the result should be an empty list.\";\n        }\n\n        return result;\n    }\n\n    private boolean checkBalanced(String s) {\n        int count = 0;\n        for (char ch : s.toCharArray()) {\n            if (ch == '(') count++;\n            if (ch == ')') count--;\n            if (count < 0) return false;\n        }\n        return count == 0;\n    }\n\n    private int getMaxDepth(String s) {\n        int maxDepth = 0;\n        int count = 0;\n        for (char ch : s.toCharArray()) {\n            if (ch == '(') count++;\n            if (ch == ')') count--;\n            maxDepth = Math.max(maxDepth, count);\n        }\n        return maxDepth;\n    }\n}"}
{"id": "HumanEval/7", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class FilterBySubstring {\n\n    public static List<String> filterBySubstring(List<String> strings, String substring) {\n        // Preconditions\n        assert strings != null : \"Input list 'strings' must not be null.\";\n        assert substring != null : \"Input 'substring' must not be null.\";\n        assert strings instanceof List<?> : \"Input 'strings' must be a list.\";\n        assert substring instanceof String : \"Input 'substring' must be a string.\";\n        strings.forEach(s -> assert s instanceof String : \"All elements in 'strings' must be strings.\");\n\n        int maxLength = 1000000; // Example boundary condition; adjust as needed.\n        assert strings.size() <= maxLength : \"Input list 'strings' should not exceed \" + maxLength + \" elements.\";\n\n        List<String> originalStrings = new ArrayList<>(strings); // Copy of the original list for postcondition check\n\n        List<String> result = new ArrayList<>(strings);\n        result.removeIf(s -> !s.contains(substring));\n\n        // Postconditions\n        assert result instanceof List<?> : \"The result must be a list.\";\n        result.forEach(s -> assert s instanceof String : \"All elements in the result must be strings.\");\n        assert result.stream().allMatch(s -> s.contains(substring)) : \"Each string in the result should contain the 'substring'.\";\n        assert strings.equals(originalStrings) : \"The input list 'strings' should remain unchanged.\";\n        if (substring.isEmpty()) {\n            assert result.equals(strings) : \"If 'substring' is empty, the result should be the same as the input 'strings'.\";\n        }\n        if (strings.isEmpty()) {\n            assert result.isEmpty() : \"If the input list 'strings' is empty, the result should also be an empty list.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Sample test cases\n        List<String> test1 = new ArrayList<>();\n        System.out.println(filterBySubstring(test1, \"a\"));  // []\n        \n        List<String> test2 = List.of(\"abc\", \"bacd\", \"cde\", \"array\");\n        System.out.println(filterBySubstring(test2, \"a\"));  // [abc, bacd, array]\n    }\n}"}
{"id": "HumanEval/8", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    public static int[] sumProduct(List<Integer> numbers) {\n        // Precondition 1: The input 'numbers' should not be null.\n        assert numbers != null : \"Input list 'numbers' must not be null.\";\n\n        // Precondition 2: The input 'numbers' should be a list.\n        assert numbers instanceof List : \"Input 'numbers' must be a list.\";\n\n        // Precondition 3: All elements in the list 'numbers' should be integers.\n        assert numbers.stream().allMatch(num -> num instanceof Integer) : \"All elements in 'numbers' must be integers.\";\n\n        // Precondition 4: The length of the 'numbers' list should be within a reasonable boundary.\n        int maxLength = 1000000; // Example boundary condition; adjust as needed.\n        assert numbers.size() <= maxLength : \"Input list 'numbers' should not exceed \" + maxLength + \" elements.\";\n\n        int sum = 0;\n        int product = 1;\n        for (int number : numbers) {\n            sum += number;\n            product *= number;\n        }\n        return new int[]{sum, product};\n    }\n\n    public static void main(String[] args) {\n        List<Integer> test1 = new ArrayList<>();\n        int[] result1 = sumProduct(test1);\n        System.out.println(\"(\" + result1[0] + \", \" + result1[1] + \")\");\n\n        List<Integer> test2 = new ArrayList<>(List.of(1, 2, 3, 4));\n        int[] result2 = sumProduct(test2);\n        System.out.println(\"(\" + result2[0] + \", \" + result2[1] + \")\");\n    }\n}"}
{"id": "HumanEval/9", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class RollingMax {\n\n    public static List<Integer> rollingMax(List<Integer> numbers) {\n        // Precondition 1: The input 'numbers' should not be null.\n        assert numbers != null : \"Input list 'numbers' must not be null.\";\n\n        // Precondition 2: The input 'numbers' should be a list.\n        assert numbers instanceof List : \"Input 'numbers' must be a list.\";\n\n        // Precondition 3: All elements in the list 'numbers' should be integers.\n        for (Integer num : numbers) {\n            assert num instanceof Integer : \"All elements in 'numbers' must be integers.\";\n        }\n\n        // Precondition 4: The length of the 'numbers' list should be within a reasonable boundary.\n        int maxLength = 1000000; // Example boundary condition; adjust as needed.\n        assert numbers.size() <= maxLength : \"Input list 'numbers' should not exceed \" + maxLength + \" elements.\";\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < numbers.size(); i++) {\n            result.add(numbers.subList(0, i + 1).stream().max(Integer::compare).orElseThrow());\n\n        // Postcondition 1: The result should be a list of integers.\n        assert result instanceof List && result.stream().allMatch(x -> x instanceof Integer) : \"The result must be a list of integers.\";\n\n        // Postcondition 2: The length of the result list should match the length of the input list.\n        assert result.size() == numbers.size() : \"The length of the result list must match the length of the input list.\";\n\n        // Postcondition 3: Each element in the result should be the maximum of all elements up to that point.\n        for (int i = 0; i < result.size(); i++) {\n            assert result.get(i) == numbers.subList(0, i + 1).stream().max(Integer::compare).orElseThrow() : \"Element at index \" + i + \" should be the maximum of elements up to that point.\";\n        }\n\n        // Postcondition 4: The result list should be non-decreasing.\n        for (int i = 1; i < result.size(); i++) {\n            assert result.get(i) >= result.get(i - 1) : \"The result list should be non-decreasing.\";\n        }\n\n        // Postcondition 5: If the input list 'numbers' is empty, the result should also be an empty list.\n        if (numbers.isEmpty()) {\n            assert result.isEmpty() : \"If the input list 'numbers' is empty, the result should also be an empty list.\";\n        }\n\n        return result;\n    }\n}"}
{"id": "HumanEval/10", "code": "public class PalindromeUtils {\n    \n    public static boolean isPalindrome(String string) {\n        return string.equals(new StringBuilder(string).reverse().toString());\n    }\n\n    public static String makePalindrome(String string) {\n        // Precondition 1\n        assert string != null : \"Input string 'string' must not be null.\";\n        \n        // Precondition 2\n        assert string instanceof String : \"Input 'string' must be a string.\";\n        \n        // Precondition 3\n        int maxLength = 1000000; // Example boundary condition; adjust as needed.\n        assert string.length() <= maxLength : String.format(\"Input string 'string' should not exceed %d characters.\", maxLength);\n        \n        String result = \"\";\n        \n        if (isPalindrome(string)) {\n            result = string;\n        } else {\n            for (int i = 0; i < string.length(); i++) {\n                if (isPalindrome(string.substring(i))) {\n                    result = string + new StringBuilder(string.substring(0, i)).reverse().toString();\n                    break;\n                }\n            }\n        }\n\n        // Postcondition 1\n        assert result instanceof String : \"The result must be a string.\";\n\n        // Postcondition 2\n        assert isPalindrome(result) : \"The result must be a palindrome.\";\n\n        // Postcondition 3\n        assert result.startsWith(string) : \"The result must start with the original string.\";\n\n        // Postcondition 4\n        for (int i = 1; i < result.length(); i++) {\n            assert !isPalindrome(result.substring(0, result.length() - i)) : \"The result should be the shortest possible palindrome.\";\n        }\n\n        // Postcondition 5\n        if (string.isEmpty()) {\n            assert result.isEmpty() : \"If the input string is empty, the result should also be an empty string.\";\n        }\n        \n        return result;\n    }\n}"}
{"id": "HumanEval/11", "code": "public class StringXOR {\n\n    public static String stringXOR(String a, String b) {\n        // Preconditions\n        assert a != null : \"Input string 'a' must not be null.\";\n        assert b != null : \"Input string 'b' must not be null.\";\n        assert a instanceof String : \"Input 'a' must be a string.\";\n        assert b instanceof String : \"Input 'b' must be a string.\";\n        assert a.length() == b.length() : \"Input strings 'a' and 'b' must have the same length.\";\n        assert a.matches(\"[01]*\") : \"Input string 'a' must only contain '1's and '0's.\";\n        assert b.matches(\"[01]*\") : \"Input string 'b' must only contain '1's and '0's.\";\n        int maxLength = (int) Math.pow(10, 6);\n        assert a.length() <= maxLength : \"Input string 'a' should not exceed \" + maxLength + \" characters.\";\n        assert b.length() <= maxLength : \"Input string 'b' should not exceed \" + maxLength + \" characters.\";\n\n        // Implementation\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < a.length(); i++) {\n            int digitA = Character.getNumericValue(a.charAt(i));\n            int digitB = Character.getNumericValue(b.charAt(i));\n            result.append(digitA ^ digitB);\n        }\n\n        // Postconditions\n        String resultStr = result.toString();\n        assert resultStr instanceof String : \"The result must be a string.\";\n        assert resultStr.length() == a.length() : \"The length of the result must be equal to the length of the input strings.\";\n        assert resultStr.matches(\"[01]*\") : \"The result must only contain '1's and '0's.\";\n        for (int i = 0; i < resultStr.length(); i++) {\n            assert resultStr.charAt(i) == Character.forDigit(Character.getNumericValue(a.charAt(i)) ^ Character.getNumericValue(b.charAt(i)), 10)\n                    : \"The result at index \" + i + \" is incorrect.\";\n        }\n        if (a.isEmpty() && b.isEmpty()) {\n            assert resultStr.isEmpty() : \"If the input strings are empty, the result should also be an empty string.\";\n        }\n\n        return resultStr;\n    }\n}"}
{"id": "HumanEval/12", "code": "import java.util.List;\nimport java.util.Optional;\n\npublic class LongestString {\n\n    public static String longest(List<String> strings) {\n        // Precondition 1: The input 'strings' should not be null.\n        assert strings != null : \"Input list 'strings' must not be null.\";\n\n        // Precondition 2: The input 'strings' should be a list.\n        assert strings instanceof List : \"Input 'strings' must be a list.\";\n\n        // Precondition 3: All elements in the list 'strings' should be strings.\n        strings.forEach(s -> assert s instanceof String : \"All elements in 'strings' must be strings.\");\n\n        // Precondition 4: The length of the 'strings' list should be within a reasonable boundary.\n        int maxLength = 1000000; // Example boundary condition; adjust as needed.\n        assert strings.size() <= maxLength : String.format(\"Input list 'strings' should not exceed %d elements.\", maxLength);\n\n        String result;\n        if (strings.isEmpty()) {\n            result = null;\n        } else {\n            int maxLengthVal = strings.stream().mapToInt(String::length).max().getAsInt();\n            result = strings.stream().filter(s -> s.length() == maxLengthVal).findFirst().orElse(null);\n        }\n\n        // Postcondition 1: The result should be either a string or null.\n        assert result == null || result instanceof String : \"The result must be either a string or null.\";\n\n        // Postcondition 2: The result should be the longest string from the input list, if not null.\n        if (result != null) {\n            assert result.length() == strings.stream().mapToInt(String::length).max().getAsInt() : \"The result must be the longest string from the input list.\";\n        }\n\n        // Postcondition 3: If there are multiple strings of the same maximum length, the result should be the first one.\n        if (result != null) {\n            int maxLengthValue = strings.stream().mapToInt(String::length).max().getAsInt();\n            assert result.equals(strings.stream().filter(s -> s.length() == maxLengthValue).findFirst().orElse(null)) : \"The result must be the first string with the maximum length.\";\n        }\n\n        // Postcondition 4: If the input list is empty, the result should be null.\n        if (strings.isEmpty()) {\n            assert result == null : \"If the input list is empty, the result should be null.\";\n        }\n\n        return result;\n    }\n}"}
{"id": "HumanEval/13", "code": "public class GreatestCommonDivisor {\n\n    public static int greatestCommonDivisor(int a, int b) {\n        // Precondition 1: The input integers 'a' and 'b' should not be null.\n        assert a != null : \"Input 'a' must not be null.\";\n        assert b != null : \"Input 'b' must not be null.\";\n\n        // Precondition 2: The input 'a' and 'b' should be integers.\n        assert a instanceof Integer : \"Input 'a' must be an integer.\";\n        assert b instanceof Integer : \"Input 'b' must be an integer.\";\n\n        // Precondition 3: The input 'a' and 'b' should be non-negative integers.\n        assert a >= 0 : \"Input 'a' must be a non-negative integer.\";\n        assert b >= 0 : \"Input 'b' must be a non-negative integer.\";\n\n        int result = queryGcd(a, b);\n\n        // Postcondition 1: The result should be an integer.\n        assert result instanceof Integer : \"The result must be an integer.\";\n\n        // Postcondition 2: The result should be non-negative.\n        assert result >= 0 : \"The result must be a non-negative integer.\";\n\n        // Postcondition 3: The result should divide both 'a' and 'b' without a remainder.\n        assert a % result == 0 && b % result == 0 : \"The result must divide both 'a' and 'b' without a remainder.\";\n\n        // Postcondition 4: The result should be the greatest common divisor.\n        for (int i = 1; i <= Math.min(a, b); i++) {\n            if (a % i == 0 && b % i == 0) {\n                assert i <= result : \"The result must be the greatest common divisor.\";\n            }\n        }\n\n        return result;\n    }\n\n    private static int queryGcd(int a, int b) {\n        return b == 0 ? a : queryGcd(b, a % b);\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        assert greatestCommonDivisor(3, 5) == 1 : \"Test failed for gcd(3, 5)\";\n        assert greatestCommonDivisor(25, 15) == 5 : \"Test failed for gcd(25, 15)\";\n    }\n}"}
{"id": "HumanEval/14", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PrefixUtilities {\n    \n    public static List<String> allPrefixes(String string) {\n        // Precondition 1: The input 'string' should not be null.\n        assert string != null : \"Input 'string' must not be null.\";\n        \n        // Precondition 2: The input 'string' should be a string.\n        assert string instanceof String : \"Input 'string' must be a string.\";\n        \n        // Precondition 3: The length of the input string should be within a reasonable boundary.\n        int maxLength = 1000000; // Example boundary condition; adjust as needed.\n        assert string.length() <= maxLength : \"Input 'string' should not exceed \" + maxLength + \" characters.\";\n\n        List<String> result = new ArrayList<>();\n        for (int i = 0; i < string.length(); i++) {\n            result.add(string.substring(0, i + 1));\n        }\n\n        // Postcondition 1: The result should be a list of strings.\n        assert result instanceof List : \"The result must be a list.\";\n        assert result.stream().allMatch(prefix -> prefix instanceof String) : \"All elements in the result must be strings.\";\n\n        // Postcondition 2: The length of the result list should match the length of the input string.\n        assert result.size() == string.length() : \"The length of the result list must match the length of the input string.\";\n\n        // Postcondition 3: Each element in the result should be a valid prefix of the input string.\n        for (int i = 0; i < result.size(); i++) {\n            assert result.get(i).equals(string.substring(0, i + 1)) : \"The element at index \" + i + \" should be a valid prefix of the input string.\";\n        }\n\n        // Postcondition 4: If the input string is empty, the result should be an empty list.\n        if (string.isEmpty()) {\n            assert result.isEmpty() : \"If the input string is empty, the result should be an empty list.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<String> prefixes = allPrefixes(\"abc\");\n        System.out.println(prefixes);\n    }\n}"}
{"id": "HumanEval/15", "code": "public class StringSequence {\n    public static String stringSequence(int n) {\n        // Precondition 1: The input 'n' should not be null.\n        assert n != null : \"Input 'n' must not be null.\";\n\n        // Precondition 2: The input 'n' should be an integer.\n        assert n instanceof Integer : \"Input 'n' must be an integer.\";\n\n        // Precondition 3: The input 'n' should be a non-negative integer.\n        assert n >= 0 : \"Input 'n' must be a non-negative integer.\";\n\n        // Precondition 4: The value of 'n' should be within a reasonable boundary.\n        int max_value = (int) Math.pow(10, 6);  // Example boundary condition; adjust as needed.\n        assert n <= max_value : \"Input 'n' should not exceed \" + max_value + \".\";\n\n        String result = String.join(\" \", IntStream.rangeClosed(0, n).mapToObj(Integer::toString).toArray(String[]::new));\n\n        // Postcondition 1: The result should be a string.\n        assert result instanceof String : \"The result must be a string.\";\n\n        // Postcondition 2: The result should contain space-delimited numbers from 0 to 'n' inclusive.\n        String expected_result = String.join(\" \", IntStream.rangeClosed(0, n).mapToObj(Integer::toString).toArray(String[]::new));\n        assert result.equals(expected_result) : \"The result should be '\" + expected_result + \"'.\";\n\n        // Postcondition 3: The length of the result should match the expected length based on 'n'.\n        int expected_length = String.join(\" \", IntStream.rangeClosed(0, n).mapToObj(Integer::toString).toArray(String[]::new)).length();\n        assert result.length() == expected_length : \"The length of the result should be \" + expected_length + \".\";\n\n        // Postcondition 4: If 'n' is 0, the result should be '0'.\n        if (n == 0) {\n            assert result.equals(\"0\") : \"If 'n' is 0, the result should be '0'.\";\n        }\n\n        return result;\n    }\n}"}
{"id": "HumanEval/16", "code": "public class DistinctCharacterCounter {\n    \n    public static int countDistinctCharacters(String string) {\n        // Precondition 1\n        assert string != null : \"Input 'string' must not be null.\";\n        \n        // Precondition 2\n        assert string instanceof String : \"Input 'string' must be a string.\";\n        \n        // Precondition 3\n        int maxLength = 1000000; // Example boundary condition; adjust as needed.\n        assert string.length() <= maxLength : \"Input 'string' should not exceed \" + maxLength + \" characters.\";\n        \n        int result = (int)string.toLowerCase().chars().distinct().count();\n        \n        // Postcondition 1\n        assert result >= 0 : \"The result must be non-negative.\";\n        \n        // Postcondition 2\n        int expected = (int)string.toLowerCase().chars().distinct().count();\n        assert result == expected : \"The result should be \" + expected + \".\";\n        \n        // Postcondition 3\n        if (string.isEmpty()) {\n            assert result == 0 : \"If the input string is empty, the result should be 0.\";\n        }\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n        // Test cases\n        assert countDistinctCharacters(\"xyzXYZ\") == 3;        \n        assert countDistinctCharacters(\"Jerry\") == 4;\n    }\n}"}
{"id": "HumanEval/17", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class MusicParser {\n\n    public static List<Integer> parseMusic(String musicString) {\n        List<Integer> beatsList = new ArrayList<>();\n\n        String[] notes = musicString.split(\" \");\n        for (String note : notes) {\n            beatsList.add(countBeats(note));\n        }\n\n        return beatsList;\n    }\n\n    private static int countBeats(String note) {\n        if (note.equals(\"o\")) return 4;\n        else if (note.equals(\"o|\")) return 2;\n        else if (note.equals(\".|\")) return 1;\n        return 0; // Default return value if note does not match\n    }\n\n    public static void main(String[] args) {\n        List<Integer> beats = parseMusic(\"o o| .| o| o| .| .| .| .| o o\");\n        System.out.println(beats);  // Output: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    }\n}"}
{"id": "HumanEval/18", "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class MusicParser {\n    \n    public static List<Integer> parseMusic(String music_string) {\n        \n        // Precondition 1\n        assert music_string != null : \"Input 'music_string' must not be null.\";\n        \n        // Precondition 2\n        assert music_string instanceof String : \"Input 'music_string' must be a string.\";\n        \n        // Precondition 3\n        Set<String> validNotes = new HashSet<>(Arrays.asList(\"o\", \"o|\", \".|\"));\n        assert Arrays.stream(music_string.split(\" \")).allMatch(validNotes::contains) : \"Input contains invalid musical notes.\";\n        \n        // Precondition 4\n        int maxLength = 1000000; // Example boundary condition; adjust as needed.\n        assert music_string.length() <= maxLength : \"Input 'music_string' should not exceed \" + maxLength + \" characters.\";\n\n        String[] notes = music_string.split(\" \");\n        \n        if (music_string.isEmpty()) return new ArrayList<>();\n        \n        List<Integer> result = new ArrayList<>();\n        \n        for (String note : notes) {\n            result.add(countBeats(note));\n        }\n\n        // Postcondition 1\n        assert result.stream().allMatch(Integer.class::isInstance) : \"The result must be a list of integers.\";\n        \n        // Postcondition 2\n        List<Integer> expectedResults = new ArrayList<>();\n        for (String note : notes) {\n            expectedResults.add(countBeats(note));\n        }\n        assert result.equals(expectedResults) : \"The result does not match the expected beats calculation.\";\n        \n        // Postcondition 3\n        assert result.size() == notes.length : \"The length of the result does not match the number of notes in the input string.\";\n        \n        // Postcondition 4\n        if (music_string.isEmpty()) {\n            assert result.isEmpty() : \"If the input string is empty, the result should be an empty list.\";\n        }\n        \n        return result;\n    }\n    \n    public static int countBeats(String note) {\n        switch(note) {\n            case \"o\": return 4;\n            case \"o|\": return 2;\n            case \".|\": return 1;\n            default: throw new IllegalArgumentException(\"Unexpected note: \" + note);\n        }\n    }\n    \n    public static void main(String[] args) {\n        String musicString = \"o o| .| o| o| .| .| .| .| o o\";\n        List<Integer> beats = parseMusic(musicString);\n        System.out.println(beats);  // Output: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    }\n}"}
{"id": "HumanEval/19", "code": "import java.util.Arrays;\nimport java.util.HashMap;\n\npublic class NumberSorter {\n    \n    public static String sortNumbers(String numbers) {\n        // Preconditions\n        assert numbers != null : \"Input 'numbers' must not be null.\";\n        assert numbers instanceof String : \"Input 'numbers' must be a string.\";\n        \n        String[] validNumbers = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n        assert Arrays.stream(numbers.split(\" \")).allMatch(n -> Arrays.asList(validNumbers).contains(n)) : \"Input contains invalid number words.\";\n        \n        int maxLength = 1000000; // Example boundary condition; adjust as needed.\n        assert numbers.length() <= maxLength : \"Input 'numbers' should not exceed \" + maxLength + \" characters.\";\n        \n        HashMap<String, Integer> toInt = new HashMap<>();\n        toInt.put(\"zero\", 0);\n        toInt.put(\"one\", 1);\n        toInt.put(\"two\", 2);\n        toInt.put(\"three\", 3);\n        toInt.put(\"four\", 4);\n        toInt.put(\"five\", 5);\n        toInt.put(\"six\", 6);\n        toInt.put(\"seven\", 7);\n        toInt.put(\"eight\", 8);\n        toInt.put(\"nine\", 9);\n        \n        String result;\n        if (numbers.equals(\"\")) {\n            result = \"\";\n        } else {\n            result = String.join(\" \", Arrays.stream(numbers.split(\" \")).sorted((n1, n2) -> Integer.compare(toInt.get(n1), toInt.get(n2))).toArray(String[]::new));\n        }\n        \n        // Postconditions\n        assert result instanceof String : \"The result must be a string.\";\n        \n        String[] splitNumbers = numbers.split(\" \");\n        Arrays.sort(splitNumbers, (n1, n2) -> Integer.compare(toInt.get(n1), toInt.get(n2)));\n        String expectedResult = String.join(\" \", splitNumbers);\n        assert result.equals(expectedResult) : \"The result should be '\" + expectedResult + \"'.\";\n        \n        if (numbers.equals(\"\")) {\n            assert result.equals(\"\") : \"If the input string is empty, the result should also be an empty string.\";\n        }\n        \n        return result;\n    }\n    \n}"}
{"id": "HumanEval/20", "code": "import java.util.ArrayList;\nimport java.util.List;\nimport org.apache.commons.lang3.tuple.Pair;\n\npublic class ClosestElementsFinder {\n\n    public static Pair<Double, Double> findClosestElements(List<Double> numbers) {\n        assert numbers != null : \"Input 'numbers' must not be null.\";\n        assert numbers.size() >= 2 : \"Input list 'numbers' must have at least two elements.\";\n\n        List<Double> sortedNumbers = new ArrayList<>(numbers);\n        sortedNumbers.sort(null);\n\n        double minDiff = Double.POSITIVE_INFINITY;\n        Pair<Double, Double> minPair = null;\n\n        for (int i = 0; i < sortedNumbers.size() - 1; i++) {\n            double l = sortedNumbers.get(i);\n            double r = sortedNumbers.get(i + 1);\n            double diff = r - l;\n\n            if (diff < minDiff) {\n                minDiff = diff;\n                minPair = Pair.of(l, r);\n            }\n        }\n\n        Pair<Double, Double> result = minPair;\n        assert result != null : \"No closest pair found in the input list.\";\n\n        assert result.getLeft() <= result.getRight() : \"The first element in the result should be less than or equal to the second element.\";\n\n        double closestDiff = sortedNumbers.stream().mapToDouble(Double::doubleValue).min().getAsDouble();\n        assert result.getRight() - result.getLeft() == closestDiff : \"The result should have the smallest difference between any two elements in the list.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<Double> testData1 = List.of(1.0, 2.0, 3.0, 4.0, 5.0, 2.2);\n        List<Double> testData2 = List.of(1.0, 2.0, 3.0, 4.0, 5.0, 2.0);\n\n        Pair<Double, Double> result1 = findClosestElements(testData1);\n        System.out.println(result1);\n\n        Pair<Double, Double> result2 = findClosestElements(testData2);\n        System.out.println(result2);\n    }\n}"}
{"id": "HumanEval/21", "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Collections;\n\npublic class Rescaler {\n\n    public static List<Float> rescaleToUnit(List<Float> numbers) {\n        // Preconditions\n        assert numbers != null : \"Input 'numbers' must not be null.\";\n        assert numbers.size() >= 2 : \"Input list 'numbers' must have at least two elements.\";\n\n        float maxNum = Collections.max(numbers);\n        float minNum = Collections.min(numbers);\n        float k = 1 / (maxNum - minNum);\n\n        List<Float> result = new ArrayList<>();\n        for (float x : numbers) {\n            result.add((x - minNum) * k);\n        }\n\n        // Postconditions\n        assert result.size() == numbers.size() : \"The length of the result list must match the length of the input list.\";\n\n        float resultMin = Collections.min(result);\n        float resultMax = Collections.max(result);\n        assert resultMin == 0.0f && resultMax == 1.0f : \"The result should have a minimum value of 0.0 and maximum value of 1.0.\";\n\n        // Additional postconditions\n        for (int i = 0; i < result.size() - 1; i++) {\n            assert result.get(i) <= result.get(i + 1) : \"The result list should be monotonically increasing.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<Float> numbers = new ArrayList<>();\n        numbers.add(1.0f);\n        numbers.add(2.0f);\n        numbers.add(3.0f);\n        numbers.add(4.0f);\n        numbers.add(5.0f);\n\n        List<Float> result = rescaleToUnit(numbers);\n\n        for (float rescaledNum : result) {\n            System.out.print(rescaledNum + \" \");\n        }\n    }\n}"}
{"id": "HumanEval/22", "code": "import java.util.List;\nimport java.util.ArrayList;\n\npublic class Main {\n\n    public static List<Integer> filterIntegers(List<Object> values) {\n        /* Filter given list of any Java values only for integers\n         * filterIntegers(List.of(\"a\", 3.14, 5)); -> [5]\n         * filterIntegers(List.of(1, 2, 3, \"abc\", new Object(), new ArrayList<>())); -> [1, 2, 3]\n         */\n\n        // Precondition 1: The input 'values' should not be null.\n        assert values != null : \"Input 'values' must not be null.\";\n\n        // Precondition 2: The input 'values' should be a list.\n        assert values instanceof List : \"Input 'values' must be a list.\";\n\n        List<Integer> result = new ArrayList<>();\n        for (Object value : values) {\n            if (value instanceof Integer) {\n                result.add((Integer) value);\n            }\n        }\n\n        // Postcondition 1: The result should be a list of integers.\n        assert result instanceof List : \"The result must be a list.\";\n        assert result.stream().allMatch(x -> x instanceof Integer) : \"All elements in the result must be integers.\";\n\n        // Postcondition 2: Ensure that the result only contains integers and no non-integer values.\n        assert result.stream().allMatch(x -> x instanceof Integer) : \"The result should only contain integer values.\";\n\n        // Postcondition 3: If the input list contains no integers, the result should be an empty list.\n        if (values.stream().noneMatch(x -> x instanceof Integer)) {\n            assert result.isEmpty() : \"If the input list contains no integers, the result should be an empty list.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(filterIntegers(List.of(\"a\", 3.14, 5)));\n        System.out.println(filterIntegers(List.of(1, 2, 3, \"abc\", new Object(), new ArrayList<>())));\n    }\n}"}
{"id": "HumanEval/23", "code": "public class StringLength {\n    public static int strlen(String string) {\n        // Precondition 1: The input 'string' should not be null.\n        assert string != null : \"Input 'string' must not be null.\";\n\n        // Precondition 2: The input 'string' should be a string.\n        assert string instanceof String : \"Input 'string' must be a string.\";\n\n        int result = string.length();\n\n        // Postcondition 1: The result should be an integer.\n        assert result instanceof Integer : \"The result must be an integer.\";\n\n        // Postcondition 2: The result should accurately represent the length of the input string.\n        assert result == string.length() : \"The result should equal the length of the input string.\";\n\n        // Postcondition 3: The result should be non-negative.\n        assert result >= 0 : \"The result must be non-negative.\";\n\n        // Postcondition 4: If the input string is empty, the result should be 0.\n        if (string.equals(\"\")) {\n            assert result == 0 : \"If the input string is empty, the result should be 0.\";\n        }\n\n        return result;\n    }\n}"}
{"id": "HumanEval/24", "code": "public class Main {\n\n    public static void main(String[] args) {\n        System.out.println(largestDivisor(15)); // Should output 5\n    }\n\n    public static int largestDivisor(int n) {\n        // Precondition 1\n        assert n != null : \"Input 'n' must not be null.\";\n\n        // Precondition 2\n        assert n instanceof Integer : \"Input 'n' must be an integer.\";\n\n        // Precondition 3\n        assert n > 1 : \"Input 'n' must be a positive integer greater than 1.\";\n\n        int result = 0;\n        for (int i = 2; i < n; i++) {\n            if (n % i == 0){\n                result = n / i;\n                break;\n            }\n        }\n\n        // Postcondition 1\n        assert result instanceof Integer : \"The result must be an integer.\";\n\n        // Postcondition 2\n        assert n % result == 0 && result < n : \"The result must be a divisor of 'n' and smaller than 'n'.\";\n\n        // Postcondition 3\n        for (int i = 2; i < n; i++){\n            if (n % i == 0){\n               assert n / i <= result : \"The result should be the largest divisor of 'n' smaller than 'n'.\";\n            }\n        }\n\n        // Postcondition 4\n        if (n > 2) {\n            assert result > 1 : \"The result should be greater than 1 if 'n' is greater than 2.\";\n        }\n\n        return result;\n    }\n}"}
{"id": "HumanEval/25", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Factorize {\n\n    public static List<Integer> factorize(int n) {\n        // Precondition 1: The input 'n' should not be None.\n        assert n != null : \"Input 'n' must not be null.\";\n\n        // Precondition 2: The input 'n' should be an integer.\n        assert n instanceof Integer : \"Input 'n' must be an integer.\";\n\n        // Precondition 3: The input 'n' should be a positive integer greater than 1.\n        assert n > 1 : \"Input 'n' must be a positive integer greater than 1.\";\n\n        List<Integer> fact = new ArrayList<>();\n        int i = 2;\n        while (i <= Math.sqrt(n) + 1) {\n            if (n % i == 0) {\n                fact.add(i);\n                n /= i;\n            } else {\n                i++;\n            }\n        }\n\n        if (n > 1) {\n            fact.add(n);\n        }\n\n        // Postcondition 1: The result should be a list of integers.\n        assert fact instanceof List<Integer> && fact.stream().allMatch(x -> x instanceof Integer) : \"The result must be a list of integers.\";\n\n        // Postcondition 2: The product of all elements in the result list should equal the original input 'n'.\n        int originalN = n;\n        int productOfFactors = 1;\n        for (int factor : fact) {\n            productOfFactors *= factor;\n        }\n        assert originalN == productOfFactors || originalN == n * productOfFactors : \"The product of the factors should equal the original input 'n'.\";\n\n        // Postcondition 3: All elements in the result list should be prime numbers.\n        assert fact.stream().allMatch(x -> isPrime(x)) : \"All elements in the result list must be prime numbers.\";\n\n        // Postcondition 4: The factors in the result list should be sorted in ascending order.\n        assert fact.equals(fact.stream().sorted().collect(Collectors.toList())) : \"The factors should be sorted in ascending order.\";\n\n        return fact;\n    }\n\n    public static boolean isPrime(int x) {\n        if (x <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(x); i++) {\n            if (x % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"id": "HumanEval/26", "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Main {\n\n    public static List<Integer> removeDuplicates(List<Integer> numbers) {\n        // Preconditions\n        assert numbers != null : \"Input 'numbers' must not be null.\";\n        assert numbers instanceof List : \"Input 'numbers' must be a list.\";\n        for (Integer num : numbers) {\n            assert num instanceof Integer : \"All elements in 'numbers' must be integers.\";\n        }\n\n        Map<Integer, Integer> numCnt = new HashMap<>();\n        for (Integer number : numbers) {\n            if (!numCnt.containsKey(number)) {\n                numCnt.put(number, 0);\n            }\n            numCnt.put(number, numCnt.get(number) + 1);\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (Integer number : numbers) {\n            if (numCnt.get(number) == 1) {\n                result.add(number);\n            }\n        }\n\n        // Postconditions\n        List<Integer> originalNumbers = new ArrayList<>(numbers);\n        for (Integer num : result) {\n            assert num instanceof Integer : \"The result must be a list of integers.\";\n            assert originalNumbers.contains(num) : \"All elements in the result should appear exactly once in the input list.\";\n            assert result.indexOf(num) == originalNumbers.indexOf(num) : \"The order of elements in the result should match their order in the input list.\";\n        }\n        if (originalNumbers.stream().allMatch(num -> originalNumbers.indexOf(num) > originalNumbers.lastIndexOf(num))) {\n            assert result.isEmpty() : \"If all elements in the input list occur more than once, the result should be an empty list.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> input = new ArrayList<>();\n        input.add(1);\n        input.add(2);\n        input.add(3);\n        input.add(2);\n        input.add(4);\n\n        List<Integer> output = removeDuplicates(input);\n        System.out.println(output);  // [1, 3, 4]\n    }\n}"}
{"id": "HumanEval/27", "code": "public class FlipCase {\n    \n    public static String flipCase(String string) {\n        // Preconditions\n        assert string != null : \"Input 'string' must not be null.\";\n        assert string instanceof String : \"Input 'string' must be a String.\";\n        \n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < string.length(); i++) {\n            if (Character.isUpperCase(string.charAt(i))) {\n                result.append(Character.toLowerCase(string.charAt(i)));\n            } else if (Character.isLowerCase(string.charAt(i))) {\n                result.append(Character.toUpperCase(string.charAt(i)));\n            } else {\n                result.append(string.charAt(i));\n            }\n        }\n\n        // Postconditions\n        String resultString = result.toString();\n        assert resultString instanceof String : \"The result must be a String.\";\n        \n        for (int i = 0; i < string.length(); i++) {\n            if (Character.isUpperCase(string.charAt(i))) {\n                assert Character.isLowerCase(resultString.charAt(i)) : \"Character '\" + string.charAt(i) + \"' should be flipped to lowercase in the result.\";\n            } else if (Character.isLowerCase(string.charAt(i))) {\n                assert Character.isUpperCase(resultString.charAt(i)) : \"Character '\" + string.charAt(i) + \"' should be flipped to uppercase in the result.\";\n            } else {\n                assert string.charAt(i) == resultString.charAt(i) : \"Non-alphabetical character '\" + string.charAt(i) + \"' should remain unchanged.\";\n            }\n        }\n        \n        assert resultString.length() == string.length() : \"The length of the result must match the length of the input string.\";\n\n        return resultString;\n    }\n\n    public static void main(String[] args) {\n        String input = \"Hello\";\n        String output = flipCase(input);\n        System.out.println(output);\n    }\n}"}
{"id": "HumanEval/28", "code": "import java.util.List;\n\npublic class StringConcatenation {\n\n    public static String concatenate(List<String> strings) {\n        /**\n         * Concatenate list of strings into a single string\n         * \n         * Preconditions:\n         * 1. The input 'strings' should not be null.\n         * 2. The input 'strings' should be a List of Strings.\n         * 3. All elements in 'strings' should be Strings.\n         * \n         * Postconditions:\n         * 1. The result should be a String.\n         * 2. The result should be the correct concatenation of the input strings.\n         * 3. If the input list is empty, the result should be an empty string.\n         * 4. The length of the result should equal the sum of the lengths of the input strings.\n         */\n\n        assert strings != null : \"Input 'strings' must not be null.\";\n        assert strings instanceof List : \"Input 'strings' must be a List.\";\n        strings.forEach(s -> assert s instanceof String : \"All elements in 'strings' must be Strings.\");\n\n        String result = String.join(\"\", strings);\n\n        assert result instanceof String : \"The result must be a String.\";\n        String expected_result = String.join(\"\", strings);\n        assert result.equals(expected_result) : \"The result should be '\" + expected_result + \"'.\";\n\n        if (strings.isEmpty()) {\n            assert result.isEmpty() : \"If the input list is empty, the result should be an empty string.\";\n        }\n\n        assert result.length() == strings.stream().mapToInt(String::length).sum() : \"The length of the result must equal the sum of the lengths of the input strings.\";\n\n        return result;\n    }\n}"}
{"id": "HumanEval/29", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PrefixFilter {\n\n    public List<String> filterByPrefix(List<String> strings, String prefix) {\n        // Preconditions\n        assert strings != null : \"Input 'strings' must not be null.\";\n        assert prefix != null : \"Input 'prefix' must not be null.\";\n        assert strings instanceof List : \"Input 'strings' must be a list.\";\n        assert strings.stream().allMatch(s -> s instanceof String) : \"All elements in 'strings' must be strings.\";\n        assert prefix instanceof String : \"Input 'prefix' must be a string.\";\n\n        List<String> result = new ArrayList<>();\n        for (String str : strings) {\n            if (str.startsWith(prefix)) {\n                result.add(str);\n            }\n        }\n\n        // Postconditions\n        assert result instanceof List : \"The result must be a list.\";\n        assert result.stream().allMatch(s -> s instanceof String) : \"All elements in the result must be strings.\";\n        assert result.stream().allMatch(s -> s.startsWith(prefix)) : \"All strings in the result should start with the specified prefix.\";\n\n        int expectedLength = (int) strings.stream().filter(s -> s.startsWith(prefix)).count();\n        assert result.size() == expectedLength : \"The length of the result does not match the expected number of strings starting with the prefix.\";\n\n        // If the input list is empty or no strings start with the prefix, the result should be an empty list\n        if (strings.isEmpty() || strings.stream().noneMatch(s -> s.startsWith(prefix))) {\n            assert result.isEmpty() : \"If the input list is empty or no strings start with the prefix, the result should be an empty list.\";\n        }\n\n        return result;\n    }\n}"}
{"id": "HumanEval/30", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PositiveNumbers {\n    public List<Double> getPositive(List<? extends Number> list) {\n        // Precondition 1\n        assert list != null : \"Input list 'l' must not be null.\";\n\n        // Precondition 2\n        assert list instanceof List : \"Input 'l' must be a list.\";\n\n        // Precondition 3\n        for (Object num : list) {\n            assert num instanceof Integer || num instanceof Double : \"All elements in 'l' must be integers or floats.\";\n        }\n\n        List<Double> result = new ArrayList<>();\n        for (Number num : list) {\n            if (num.doubleValue() > 0) {\n                result.add(num.doubleValue());\n            }\n        }\n\n        // Postcondition 1\n        assert result instanceof List : \"The result must be a list.\";\n        for (Double num : result) {\n            assert num instanceof Integer || num instanceof Double : \"All elements in the result must be integers or floats.\";\n        }\n\n        // Postcondition 2\n        for (Double num : result) {\n            assert num > 0 : \"All elements in the result should be positive numbers.\";\n        }\n\n        // Postcondition 3\n        int expectedLength = (int) list.stream().filter(num -> num.doubleValue() > 0).count();\n        assert result.size() == expectedLength : \"The length of the result does not match the number of positive numbers in the input list.\";\n\n        // Postcondition 4\n        if (list.stream().noneMatch(num -> num.doubleValue() > 0)) {\n            assert result.isEmpty() : \"If the input list contains no positive numbers, the result should be an empty list.\";\n        }\n\n        return result;\n    }\n}"}
{"id": "HumanEval/31", "code": "public class PrimeChecker {\n\n    public static boolean isPrime(int n) {\n        // Preconditions\n        assert n != null : \"Input 'n' must not be null.\";\n        assert n instanceof Integer : \"Input 'n' must be an integer.\";\n        assert n >= 0 : \"Input 'n' must be a non-negative integer.\";\n\n        if (n <= 1)\n            return false;\n\n        int nSqrt = 1;\n        while (nSqrt * nSqrt < n)\n            nSqrt++;\n\n        for (int i = 2; i < Math.min(nSqrt + 1, n); i++) {\n            if (n % i == 0)\n                return false;\n        }\n\n        boolean result = true;\n\n        // Assertions for postconditions\n        assert result instanceof Boolean : \"The result must be a boolean value.\";\n        if (result) {\n            for (int i = 2; i < n; i++) {\n                assert n % i != 0 : \"If the result is true, 'n' must have no divisors other than 1 and itself.\";\n            }\n        }\n        if (!result) {\n            for (int i = 2; i < n; i++) {\n                assert n % i == 0 : \"If the result is false, 'n' must have at least one divisor other than 1 and itself.\";\n            }\n        }\n        if (n == 0 || n == 1) {\n            assert result == false : \"The result must be false for 'n' = 0 or 'n' = 1.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isPrime(6));     // false\n        System.out.println(isPrime(101));   // true\n        System.out.println(isPrime(11));    // true\n        System.out.println(isPrime(13441)); // true\n        System.out.println(isPrime(61));    // true\n        System.out.println(isPrime(4));     // false\n        System.out.println(isPrime(1));     // false\n    }\n}"}
{"id": "HumanEval/32", "code": "import java.util.List;\n\npublic class Polynomial {\n\n    public static double poly(List<Double> xs, double x) {\n        // Code for evaluating polynomial\n    }\n\n    public static double findZero(List<Double> xs) {\n        // Code for finding zero\n    }\n\n    public static void main(String[] args) {\n        // Test cases can be included here\n    }\n}"}
{"id": "HumanEval/33", "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n    public static List<Integer> sortThird(List<Integer> l) {\n        assert l != null : \"Input list 'l' must not be null.\";\n        assert l instanceof List : \"Input 'l' must be a list.\";\n        for (Integer x : l) {\n            assert x instanceof Integer || x instanceof Double : \"All elements in 'l' must be integers or floats.\";\n        }\n\n        List<Integer> third = new ArrayList<>();\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 3 == 0) {\n                third.add(l.get(i));\n            }\n        }\n        Collections.sort(third);\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 3 == 0) {\n                result.add(third.get(i / 3));\n            } else {\n                result.add(l.get(i));\n            }\n        }\n\n        assert result instanceof List : \"The result must be a list.\";\n        assert result.size() == l.size() : \"The length of the result list must match the length of the input list.\";\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 3 == 0) {\n                assert result.get(i).equals(third.get(i / 3)) : \"The elements at indices divisible by 3 should be sorted in the result list.\";\n            } else {\n                assert result.get(i).equals(l.get(i)) : \"The elements at indices not divisible by 3 should remain unchanged.\";\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> list1 = new ArrayList<>(List.of(1, 2, 3));\n        System.out.println(sortThird(list1));  // [1, 2, 3]\n\n        List<Integer> list2 = new ArrayList<>(List.of(5, 6, 3, 4, 8, 9, 2));\n        System.out.println(sortThird(list2));  // [2, 6, 3, 4, 8, 9, 5]\n    }\n}"}
{"id": "HumanEval/34", "code": "import java.util.*;\n\npublic class Unique {\n\n    public static List<Integer> unique(List<Integer> l) {\n        // Precondition 1: The input list 'l' should not be null.\n        assert l != null : \"Input list 'l' must not be null.\";\n\n        // Precondition 2: The input 'l' should be a list.\n        assert l instanceof List : \"Input 'l' must be a list.\";\n\n        // Precondition 3: All elements in the list 'l' should be hashable.\n        assert l.stream().allMatch(x -> x instanceof Integer) : \"All elements in 'l' must be hashable (e.g., int, float, str, tuple).\";\n\n        List<Integer> result = new ArrayList<>(new HashSet<>(l));\n        Collections.sort(result);\n\n        // Postcondition 1: The result should be a list.\n        assert result instanceof List : \"The result must be a list.\";\n\n        // Postcondition 2: The result should contain only unique elements from the input list, sorted in ascending order.\n        assert new ArrayList<>(new HashSet<>(l)).equals(result) : \"The result should contain only unique elements from the input list, sorted in ascending order.\";\n\n        // Postcondition 3: The length of the result list should be less than or equal to the length of the input list\n        assert result.size() <= l.size() : \"The length of the result list should be less than or equal to the length of the input list.\";\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> list = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        List<Integer> uniqueList = unique(list);\n        System.out.println(uniqueList);\n    }\n}"}
{"id": "HumanEval/35", "code": "public class Main {\n    public static void main(String[] args) {\n        System.out.println(maxElement(new int[] {1, 2, 3}));\n        System.out.println(maxElement(new int[] {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}));\n    }\n\n    static double maxElement(int[] arr) {\n        // Precondition 1\n        assert arr != null : \"Input array 'arr' must not be null.\";\n\n        // Precondition 2\n        assert arr.length > 0 : \"Input array 'arr' must not be empty.\";\n\n        // Precondition 3\n        for (int x : arr) {\n            assert x instanceof Integer || x instanceof Double : \"All elements in 'arr' must be integers or floats.\";\n        }\n\n        double result = Integer.MIN_VALUE;\n        for (int x : arr) {\n            result = Math.max(result, x);\n        }\n\n        // Postcondition 1\n        assert result instanceof Integer || result instanceof Double : \"The result must be an integer or a float.\";\n\n        // Postcondition 2\n        assert result == Arrays.stream(arr).max().orElse(Integer.MIN_VALUE) : \"The result must be the maximum value in the list.\";\n\n        return result;\n    }\n}"}
{"id": "HumanEval/36", "code": "public class FizzBuzz {\n\n    public static int fizzBuzz(int n) {\n        assert n > 0 : \"Input 'n' must be a positive integer greater than 0.\";\n\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                cnt += String.valueOf(i).chars().filter(c -> c == '7').count();\n            }\n        }\n\n        assert cnt >= 0 : \"The result must be a non-negative integer.\";\n\n        return cnt;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        assert fizzBuzz(50) == 0 : \"Test Case 1 failed\";\n        assert fizzBuzz(78) == 2 : \"Test Case 2 failed\";\n        assert fizzBuzz(79) == 3 : \"Test Case 3 failed\";\n    }\n}"}
{"id": "HumanEval/37", "code": "import java.util.*;\n\npublic class SortEven {\n\n    public static List<Integer> sortEven(List<Integer> l) {\n        assert l != null : \"Input list 'l' must not be null.\";\n        assert l instanceof List<?> : \"Input 'l' must be a list.\";\n        assert l.stream().allMatch(x -> x instanceof Integer) : \"All elements in 'l' must be integers.\";\n\n        List<Integer> even = new ArrayList<>();\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 2 == 0) {\n                even.add(l.get(i));\n            }\n        }\n        even.sort(null);\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < l.size(); i++) {\n            if (i % 2 == 0) {\n                result.add(even.get(i / 2));\n            } else {\n                result.add(l.get(i));\n            }\n        }\n\n        assert result instanceof List<?> : \"The result must be a list.\";\n        assert result.size() == l.size() : \"The length of the result list must match the length of the input list.\";\n        for (int i = 0; i < even.size() - 1; i += 2) {\n            assert result.get(i) <= result.get(i + 2) : \"The elements at even indices should be sorted in the result list.\";\n        }\n        for (int i = 1; i < l.size(); i+=2){\n            assert result.get(i).equals(l.get(i)) : \"The elements at odd indices should remain unchanged.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> testList1 = Arrays.asList(1, 2, 3);\n        List<Integer> testList2 = Arrays.asList(5, 6, 3, 4);\n\n        System.out.println(sortEven(testList1));\n        System.out.println(sortEven(testList2));\n    }\n}"}
{"id": "HumanEval/38", "code": "public class CyclicEncoderDecoder {\n\n    public static String encodeCyclic(String s) {\n        // Precondition 1: The input string 's' should not be null.\n        assert s != null : \"Input string 's' must not be null.\";\n\n        // Precondition 2: The input 's' should be a string.\n        assert s instanceof String : \"Input 's' must be a string.\";\n\n        // Split string into groups of three characters.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < (s.length() + 2) / 3; i++) {\n            groups.add(s.substring(3 * i, Math.min(3 * i + 3, s.length())));\n        }\n\n        // Cycle elements in each group, unless the group has fewer than three elements.\n        for (int i = 0; i < groups.size(); i++) {\n            String group = groups.get(i);\n            if (group.length() == 3) {\n                groups.set(i, group.substring(1) + group.charAt(0));\n            }\n        }\n\n        String result = String.join(\"\", groups);\n\n        // Postcondition: The result should be a string.\n        assert result instanceof String : \"The result must be a string.\";\n\n        return result;\n    }\n\n    public static String decodeCyclic(String s) {\n        // Precondition 1: The input string 's' should not be null.\n        assert s != null : \"Input string 's' must not be null.\";\n\n        // Precondition 2: The input 's' should be a string.\n        assert s instanceof String : \"Input 's' must be a string.\";\n\n        // Split string into groups of three characters.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < (s.length() + 2) / 3; i++) {\n            groups.add(s.substring(3 * i, Math.min(3 * i + 3, s.length())));\n        }\n\n        // Reverse the cycle in each group, unless the group has fewer than three elements.\n        for (int i = 0; i < groups.size(); i++) {\n            String group = groups.get(i);\n            if (group.length() == 3) {\n                groups.set(i, group.charAt(2) + group.substring(0, 2));\n            }\n        }\n\n        String result = String.join(\"\", groups);\n\n        // Postcondition: The result should be a string.\n        assert result instanceof String : \"The result must be a string.\";\n\n        return result;\n    }\n}"}
{"id": "HumanEval/39", "code": "public class PrimeFibonacci {\n\n    private static boolean millerRabin(int n, int k) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2 || n == 3) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n\n        int r = 0;\n        int d = n - 1;\n        while (d % 2 == 0) {\n            r++;\n            d /= 2;\n        }\n\n        for (int i = 0; i < k; i++) {\n            int a = (int) (Math.random() * (n - 2)) + 2;\n            int x = (int) Math.pow(a, d) % n;\n            if (x == 1 || x == n - 1) {\n                continue;\n            }\n            for (int j = 0; j < r - 1; j++) {\n                x = (int) Math.pow(x, 2) % n;\n                if (x == n - 1) {\n                    break;\n                }\n            }\n            if (x != n - 1) {\n                return false;\n            }\n\n        }\n        return true;\n    }\n\n    public static int primeFib(int n) {\n        if (n < 1) {\n            throw new IllegalArgumentException(\"Input 'n' must be a positive integer greater than 0.\");\n        }\n\n        int cPrime = 0;\n        int a = 0, b = 1;\n        while (cPrime < n) {\n            int temp = b;\n            b = a + b;\n            a = temp;\n            if (millerRabin(b, 10)) {\n                cPrime++;\n            }\n        }\n\n        return b;\n    }\n\n    public static void main(String[] args) {\n        assert primeFib(1) == 2 : \"Test Case 1 Failed\";\n        assert primeFib(2) == 3 : \"Test Case 2 Failed\";\n        assert primeFib(3) == 5 : \"Test Case 3 Failed\";\n        assert primeFib(4) == 13 : \"Test Case 4 Failed\";\n        assert primeFib(5) == 89 : \"Test Case 5 Failed\";\n    }\n}"}
{"id": "HumanEval/40", "code": "import java.util.Arrays;\n\npublic class Main {\n    public static boolean triplesSumToZero(int[] l) {\n        if (l == null) {\n            throw new IllegalArgumentException(\"Input array 'l' must not be null.\");\n        }\n\n        Arrays.sort(l);\n\n        for (int i = 0; i < l.length - 2; i++) {\n            int left = i + 1, right = l.length - 1;\n            while (left < right) {\n                int total = l[i] + l[left] + l[right];\n                if (total == 0) {\n                    return true;\n                } else if (total < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int[] arr1 = {1, 3, 5, 0};\n        int[] arr2 = {1, 3, -2, 1};\n        int[] arr3 = {1, 2, 3, 7};\n        int[] arr4 = {2, 4, -5, 3, 9, 7};\n        int[] arr5 = {1};\n\n        System.out.println(triplesSumToZero(arr1)); // false\n        System.out.println(triplesSumToZero(arr2)); // true\n        System.out.println(triplesSumToZero(arr3)); // false\n        System.out.println(triplesSumToZero(arr4)); // true\n        System.out.println(triplesSumToZero(arr5)); // false\n    }\n}"}
{"id": "HumanEval/41", "code": "public class CarRaceCollision {\n\n    public static int carRaceCollision(int n) {\n        // Precondition: Ensure n is a positive integer.\n        assert n >= 0 : \"Input 'n' must be a non-negative integer.\";\n        return n * n;\n    }\n\n    public static void main(String[] args) {\n        int n = 5; // Example value for n\n        System.out.println(carRaceCollision(n));\n    }\n}"}
{"id": "HumanEval/42", "code": "import java.util.List;\nimport java.util.ArrayList;\n\npublic class Main {\n\n\tpublic static List<Integer> incrList(List<Integer> l) {\n\t\t// Preconditions\n\t\tassert l != null : \"Input list 'l' must not be null.\";\n\t\tfor (Integer x : l) {\n\t\t\tassert x instanceof Integer : \"All elements in 'l' must be integers.\";\n\t\t}\n\n\t\tList<Integer> result = new ArrayList<>();\n\t\tfor (Integer x : l) {\n\t\t\tresult.add(x + 1);\n\t\t}\n\n\t\t// Postconditions\n\t\tassert result instanceof List : \"The result must be a list.\";\n\t\tfor (int i = 0; i < l.size(); i++) {\n\t\t\tassert result.get(i) == l.get(i) + 1 : \"Each element in the result must be 1 greater than in the input list.\";\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tList<Integer> input1 = List.of(1, 2, 3);\n\t\tList<Integer> input2 = List.of(5, 3, 5, 2, 3, 3, 9, 0, 123);\n\n\t\tSystem.out.println(incrList(input1));\n\t\tSystem.out.println(incrList(input2));\n\t}\n}"}
{"id": "HumanEval/43", "code": "public class Main {\n    public static boolean pairsSumToZero(int[] arr) {\n        if (arr == null) {\n            throw new IllegalArgumentException(\"Input array must not be null.\");\n        }\n\n        HashSet<Integer> seen = new HashSet<>();\n        for (int num : arr) {\n            if (seen.contains(-num)) {\n                return true;\n            }\n            seen.add(num);\n        }\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int[] arr1 = {1, 3, 5, 0};\n        int[] arr2 = {1, 3, -2, 1};\n        int[] arr3 = {1, 2, 3, 7};\n        int[] arr4 = {2, 4, -5, 3, 5, 7};\n        int[] arr5 = {1};\n\n        System.out.println(pairsSumToZero(arr1)); // false\n        System.out.println(pairsSumToZero(arr2)); // false\n        System.out.println(pairsSumToZero(arr3)); // false\n        System.out.println(pairsSumToZero(arr4)); // true\n        System.out.println(pairsSumToZero(arr5)); // false\n    }\n}"}
{"id": "HumanEval/44", "code": "public class ChangeBase {\n\n    public static String changeBase(int x, int base) {\n        if (x == 0) return \"0\";\n        StringBuilder ret = new StringBuilder();\n        while (x != 0) {\n            ret.insert(0, x % base);\n            x /= base;\n        }\n        return ret.toString();\n    }\n\n}"}
{"id": "HumanEval/45", "code": "public class TriangleArea {\n\n    public static double triangleArea(double a, double h) {\n        assert a != null && h != null : \"Inputs 'a' and 'h' must not be null.\";\n        assert a instanceof Number && h instanceof Number : \"Inputs 'a' and 'h' must be numeric (int or double).\";\n        assert a > 0 && h > 0 : \"Inputs 'a' and 'h' must be positive.\";\n\n        double result = a * h / 2.0;\n\n        assert result instanceof Double : \"The result must be a double.\";\n        assert result >= 0 : \"The area of a triangle must be non-negative.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(triangleArea(5, 3));\n    }\n}"}
{"id": "HumanEval/46", "code": "public class Main {\n    public static int fib4(int n) {\n        assert n >= 0 : \"Input 'n' must be a non-negative integer.\";\n        \n        int a, b, c, d;\n        if (n == 0) {\n            return 0;\n        } else if (n == 1) {\n            return 0;\n        } else if (n == 2) {\n            return 2;\n        } else if (n == 3) {\n            return 0;\n        } else {\n            a = 0;\n            b = 0;\n            c = 2;\n            d = 0;\n            for (int i = 4; i <= n; i++) {\n                int temp = d;\n                d = a + b + c + d;\n                a = b;\n                b = c;\n                c = temp;\n            }\n        }\n\n        assert d == 2 : \"For n=4, the result should be 2.\";\n        assert d == 4 : \"For n=5, the result should be 4.\";\n\n        return d;\n    }\n\n    public static void main(String[] args) {\n        assert fib4(5) == 4 : \"Test case failed for n=5.\";\n        assert fib4(6) == 8 : \"Test case failed for n=6.\";\n        assert fib4(7) == 14 : \"Test case failed for n=7.\";\n        System.out.println(\"All test cases passed successfully.\");\n    }\n}"}
{"id": "HumanEval/47", "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class MedianCalculator {\n\n    public static Number median(List<Number> l) {\n        // Precondition 1\n        assert l != null : \"Input list 'l' must not be null.\";\n\n        // Precondition 2\n        assert l instanceof List : \"Input 'l' must be a list.\";\n\n        // Precondition 3\n        assert !l.isEmpty() : \"Input list 'l' must not be empty.\";\n\n        // Precondition 4\n        for (Number x : l) {\n            assert x instanceof Integer || x instanceof Double : \"All elements in 'l' must be numeric (int or double).\";\n        }\n\n        List<Number> sortedList = new ArrayList<>(l);\n        Collections.sort(sortedList);\n\n        if (l.size() % 2 == 1) {\n            return sortedList.get(l.size() / 2);\n        } else {\n            return (sortedList.get(l.size() / 2 - 1).doubleValue() + sortedList.get(l.size() / 2).doubleValue()) / 2;\n        }\n    }\n}"}
{"id": "HumanEval/48", "code": "public class PalindromeChecker {\n    public static boolean isPalindrome(String text) {\n        // Precondition 1: The input 'text' should not be null.\n        assert text != null : \"Input 'text' must not be null.\";\n\n        // Precondition 2: The input 'text' should be a string.\n        assert text instanceof String : \"Input 'text' must be a string.\";\n\n        boolean result = text.equals(new StringBuilder(text).reverse().toString());\n\n        // Postcondition 1: The result should be a boolean value.\n        assert result == true || result == false : \"The result must be a boolean value.\";\n\n        // Postcondition 2: The result should be true if and only if 'text' is a palindrome.\n        assert text.equals(new StringBuilder(text).reverse().toString()) : \"The result must be false if 'text' is not a palindrome.\";\n\n        return result;\n    }\n}"}
{"id": "HumanEval/49", "code": "public class ModuloP {\n    public static int modp(int n, int p) {\n        // Precondition 1\n        assert n != null && p != null : \"Inputs 'n' and 'p' must not be None.\";\n\n        // Precondition 2\n        assert n instanceof Integer && p instanceof Integer : \"Inputs 'n' and 'p' must be integers.\";\n\n        // Precondition 3\n        assert n >= 0 : \"Input 'n' must be a non-negative integer.\";\n\n        // Precondition 4\n        assert p > 0 : \"Input 'p' must be a positive integer.\";\n\n        int res = 1, x = 2;\n        while (n != 0) {\n            if (n % 2 == 1) {\n                res = (res * x) % p;\n            }\n            x = (x * x) % p;\n            n /= 2;\n        }\n\n        int result = res % p;\n\n        // Postcondition 1\n        assert result instanceof Integer : \"The result must be an integer.\";\n\n        // Postcondition 2\n        int expected_result = (int) Math.pow(2, n) % p;\n        assert result == expected_result : \"The result \" + result + \" does not match the expected result \" + expected_result + \".\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        assert modp(3, 5) == 3;\n        assert modp(1101, 101) == 2;\n        assert modp(0, 101) == 1;\n        assert modp(3, 11) == 8;\n        assert modp(100, 101) == 1;\n    }\n}"}
{"id": "HumanEval/50", "code": "public class EncoderDecoder {\n\n    public static String encodeShift(String s) {\n        if (s == null) throw new IllegalArgumentException(\"Input string 's' must not be null.\");\n        if (!(s instanceof String)) throw new IllegalArgumentException(\"Input 's' must be a string.\");\n        if (!s.matches(\"[a-z]+\")) throw new IllegalArgumentException(\"All characters in 's' must be lowercase alphabetic characters.\");\n\n        StringBuilder encoded = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            encoded.append((char) (((ch - 'a' + 5) % 26) + 'a'));\n        }\n        \n        return encoded.toString();\n    }\n\n    public static String decodeShift(String s) {\n        if (s == null) throw new IllegalArgumentException(\"Input string 's' must not be null.\");\n        if (!(s instanceof String)) throw new IllegalArgumentException(\"Input 's' must be a string.\");\n        if (!s.matches(\"[a-z]+\")) throw new IllegalArgumentException(\"All characters in 's' must be lowercase alphabetic characters.\");\n\n        StringBuilder decoded = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            decoded.append((char) ((ch - 'a' - 5 + 26) % 26 + 'a'));\n        }\n\n        return decoded.toString();\n    }\n\n    public static void testEncodeDecodeShift() {\n        String[] originalStrings = {\"abc\", \"xyz\", \"hello\", \"world\", \"az\"};\n        for (String s : originalStrings) {\n            String encoded = encodeShift(s);\n            String decoded = decodeShift(encoded);\n            if (!s.equals(decoded)) {\n                throw new RuntimeException(\"Failed for original string: \" + s + \", decoded as: \" + decoded);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        testEncodeDecodeShift();\n    }\n\n}"}
{"id": "HumanEval/51", "code": "public class VowelRemover {\n\n    public static String removeVowels(String text) {\n        assert text != null : \"Input 'text' must not be null.\";\n        assert text instanceof String : \"Input 'text' must be a string.\";\n\n        String vowels = \"aeiouAEIOU\";\n        StringBuilder resultBuilder = new StringBuilder();\n\n        for (char ch : text.toCharArray()) {\n            if (vowels.indexOf(ch) == -1) {\n                resultBuilder.append(ch);\n            }\n        }\n\n        String result = resultBuilder.toString();\n\n        assert result instanceof String : \"The result must be a string.\";\n        assert result.chars().allMatch(c -> vowels.indexOf(c) == -1) : \"The result should not contain any vowels.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        assert removeVowels(\"\").equals(\"\");\n        assert removeVowels(\"abcdef\\nghijklm\").equals(\"bcdf\\nghjklm\");\n        assert removeVowels(\"abcdef\").equals(\"bcdf\");\n        assert removeVowels(\"aaaaa\").equals(\"\");\n        assert removeVowels(\"aaBAA\").equals(\"B\");\n        assert removeVowels(\"zbcd\").equals(\"zbcd\");\n    }\n}"}
{"id": "HumanEval/52", "code": "public class Main {\n    public static void main(String[] args) {\n        System.out.println(belowThreshold(new int[]{1, 2, 4, 10}, 100)); // true\n        System.out.println(belowThreshold(new int[]{1, 20, 4, 10}, 5)); // false\n    }\n\n    public static boolean belowThreshold(int[] l, int t) {\n        // Precondition 1: The input array 'l' and threshold 't' should not be null.\n        assert l != null && t != null : \"Inputs 'l' and 't' must not be null.\";\n\n        // Precondition 2: The input 'l' should be an array.\n        assert l.getClass().isArray() : \"Input 'l' must be an array.\";\n\n        // Precondition 3: The threshold 't' should be an integer.\n        assert t instanceof Integer : \"Input 't' must be an integer.\";\n\n        // Precondition 4: All elements in the array 'l' should be integers.\n        for (int x : l) {\n            assert x instanceof Integer : \"All elements in 'l' must be integers.\";\n        }\n\n        boolean result = true;\n        \n        for (int x : l) {\n            if (x >= t) {\n                result = false;\n                break;\n            }\n        }\n\n        // Postcondition 1: The result should be a boolean value.\n        assert result instanceof Boolean : \"The result must be a boolean value.\";\n\n        // Postcondition 2: The result should be true if and only if all elements in 'l' are below the threshold 't'.\n        boolean check = true;\n        for (int x : l) {\n            if (!(x < t)) {\n                check = false;\n                break;\n            }\n        }\n        assert result == check : \"The result must correctly reflect whether all elements are below the threshold.\";\n        \n        return result;\n    }\n}"}
{"id": "HumanEval/53", "code": "public class AddNumbers {\n    /**\n     * Add two numbers x and y.\n     * @param x first number\n     * @param y second number\n     * @return sum of x and y\n     */\n    public static int add(int x, int y) {\n        // Precondition 1: The inputs 'x' and 'y' should not be null.\n        assert x != null && y != null : \"Inputs 'x' and 'y' must not be null.\";\n\n        // Precondition 2: The inputs 'x' and 'y' should be integers.\n        assert x instanceof Integer && y instanceof Integer : \"Inputs 'x' and 'y' must be integers.\";\n\n        int result = x + y;\n\n        // Postcondition 1: The result should be an integer.\n        assert result instanceof Integer : \"The result must be an integer.\";\n\n        // Postcondition 2: The result should be equal to the sum of 'x' and 'y'.\n        assert result == x + y : \"The result must equal the sum of 'x' and 'y'.\";\n\n        return result;\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(add(2, 3)); // 5\n        System.out.println(add(5, 7)); // 12\n    }\n}"}
{"id": "HumanEval/54", "code": "public class Main {\n    public static void main(String[] args) {\n        sameChars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\");\n        sameChars(\"abcd\", \"dddddddabc\");\n        sameChars(\"dddddddabc\", \"abcd\");\n        sameChars(\"eabcd\", \"dddddddabc\");\n        sameChars(\"abcd\", \"dddddddabce\");\n        sameChars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\");\n    }\n\n    public static boolean sameChars(String s0, String s1) {\n        // Precondition 1\n        assert s0 != null && s1 != null : \"Inputs 's0' and 's1' must not be null.\";\n\n        // Precondition 2\n        assert s0 instanceof String && s1 instanceof String : \"Inputs 's0' and 's1' must be strings.\";\n\n        boolean result = new HashSet<>(Arrays.asList(s0.split(\"\"))).equals(new HashSet<>(Arrays.asList(s1.split(\"\"))));\n\n        // Postcondition 1\n        assert result == true || result == false : \"The result must be a boolean value.\";\n\n        // Postcondition 2\n        assert (new HashSet<>(Arrays.asList(s0.split(\"\"))).equals(new HashSet<>(Arrays.asList(s1.split(\"\"))))) == result : \"The result must correctly reflect whether both strings have the same unique characters.\";\n\n        return result;\n    }\n}"}
{"id": "HumanEval/55", "code": "public class Fibonacci {\n    public static int fib(int n) {\n        // Precondition 1: The input 'n' should not be null.\n        assert n != null : \"Input 'n' must not be null.\";\n\n        // Precondition 2: The input 'n' should be an integer.\n        assert n instanceof Integer : \"Input 'n' must be an integer.\";\n\n        // Precondition 3: The input 'n' should be a non-negative integer.\n        assert n >= 0 : \"Input 'n' must be a non-negative integer.\";\n\n        if (n == 0) {\n            return 0;\n        }\n        if (n <= 2) {\n            return 1;\n        }\n\n        int a = 1, b = 1;\n        for (int i = 3; i <= n; i++) {\n            int temp = b;\n            b = a + b;\n            a = temp;\n        }\n\n        int result = b;\n\n        // Postcondition 1: The result should be an integer.\n        assert result instanceof Integer : \"The result must be an integer.\";\n\n        // Postcondition 2: The result should be the correct n-th Fibonacci number.\n        // Verifying correctness by checking if the result matches a small set of known Fibonacci numbers\n        int[] knownFibs = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55};\n        if (n < knownFibs.length) {\n            assert result == knownFibs[n] : \"The result must be \" + knownFibs[n] + \" for n=\" + n + \".\";\n        }\n\n        return result;\n    }\n}"}
{"id": "HumanEval/56", "code": "public class BracketChecker {\n    public static boolean correctBracketing(String brackets) {\n        // Precondition 1: The input 'brackets' should not be null.\n        assert brackets != null : \"Input 'brackets' must not be null.\";\n\n        // Precondition 2: The input 'brackets' should be a string.\n        assert brackets instanceof String : \"Input 'brackets' must be a string.\";\n\n        // Precondition 3: The input 'brackets' should contain only '<' and '>'.\n        assert brackets.matches(\"^[<>]*$\") : \"Input 'brackets' must contain only '<' and '>'.\";\n        \n        int count = 0;\n        for (char ch : brackets.toCharArray()) {\n            if (ch == '<') {\n                count++;\n            } else if (ch == '>') {\n                count--;\n            }\n            if (count < 0) {\n                return false;\n            }\n        }\n\n        boolean result = count == 0;\n\n        // Postcondition 1: The result should be a boolean value.\n        assert result == true || result == false : \"The result must be a boolean value.\";\n\n        // Postcondition 2: The result should correctly indicate whether the brackets are balanced.\n        if (result) {\n            assert count == 0 : \"If the result is True, the count of '<' and '>' must be balanced.\";\n        } else {\n            assert count != 0 || brackets.contains(\"<>\") : \"If the result is False, the brackets are unbalanced.\";\n        }\n\n        return result;\n    }\n    \n    public static void main(String[] args) {\n        assert correctBracketing(\"<\") == false;\n        assert correctBracketing(\"<>\") == true;\n        assert correctBracketing(\"<<><>>\") == true;\n        assert correctBracketing(\"><<>\") == false;\n    }\n}"}
{"id": "HumanEval/57", "code": "public class Monotonic {\n    public static boolean isMonotonic(int[] arr) {\n        assert arr != null : \"Input array must not be null.\";\n        assert arr instanceof int[] : \"Input must be an integer array.\";\n        \n        boolean inc = true, dec = true;\n        for (int i = 0; i < arr.length - 1; i++) {\n            if (arr[i] > arr[i + 1]) {\n                inc = false;\n            }\n            if (arr[i] < arr[i + 1]) {\n                dec = false;\n            }\n        }\n        \n        boolean result = inc || dec;\n        \n        assert result == false || (inc || dec) : \"The array must be monotonically increasing or decreasing.\";\n        assert result == true || !(inc || dec) : \"The array must not be monotonically increasing or decreasing.\";\n        assert result == true || arr.length == 0 : \"The result must be true for an empty array.\";\n        assert result == true || arr.length == 1 : \"The result must be true for a single-element array.\";\n        assert result == true || !IntStream.range(0, arr.length - 1).anyMatch(i -> arr[i] >= arr[i + 1]) : \"The result must be true for a strictly increasing array.\";\n        assert result == true || !IntStream.range(0, arr.length - 1).anyMatch(i -> arr[i] <= arr[i + 1]) : \"The result must be true for a strictly decreasing array.\";\n        assert result == false || (IntStream.range(0, arr.length - 1).anyMatch(i -> arr[i] < arr[i + 1]) && IntStream.range(0, arr.length - 1).anyMatch(i -> arr[i] > arr[i + 1])) : \"The result must be false for a non-monotonic array.\";\n        \n        return result;\n    }\n}"}
{"id": "HumanEval/58", "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.Collections;\n\npublic class CommonElements {\n    public static List<Integer> common(List<Integer> l1, List<Integer> l2) {\n        // Precondition 1: The input lists 'l1' and 'l2' should not be null.\n        assert l1 != null && l2 != null : \"Input lists 'l1' and 'l2' must not be null.\";\n\n        // Precondition 2: The inputs 'l1' and 'l2' should be lists.\n        assert l1 instanceof List && l2 instanceof List : \"Inputs 'l1' and 'l2' must be lists.\";\n\n        // Precondition 3: All elements in 'l1' and 'l2' should be hashable.\n        assert l1.stream().allMatch(x -> x instanceof Integer) && l2.stream().allMatch(x -> x instanceof Integer)\n                : \"All elements in 'l1' and 'l2' must be hashable.\";\n\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Integer> set2 = new HashSet<>(l2);\n        set1.retainAll(set2);\n\n        List<Integer> result = new ArrayList<>(set1);\n        Collections.sort(result);\n\n        // Postcondition 1: The result should be a list.\n        assert result instanceof List : \"The result must be a list.\";\n\n        // Postcondition 2: The result should be sorted.\n        assert result.equals(new ArrayList<>(result)) : \"The result must be sorted.\";\n\n        // Postcondition 3: The result should contain only unique elements.\n        assert result.size() == new HashSet<>(result).size() : \"The result must contain only unique elements.\";\n\n        // Postcondition 4: The result should contain only elements common to both 'l1' and 'l2'.\n        assert l1.containsAll(result) && l2.containsAll(result)\n                : \"The result must contain only elements that are common to both 'l1' and 'l2'.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> list1 = List.of(1, 4, 3, 34, 653, 2, 5);\n        List<Integer> list2 = List.of(5, 7, 1, 5, 9, 653, 121);\n        System.out.println(common(list1, list2)); // Test example 1\n    }\n}"}
{"id": "HumanEval/59", "code": "public class Main {\n    public static int largestPrimeFactor(int n) {\n        // Divide n by 2 until it's odd\n        while (n % 2 == 0) {\n            n /= 2;\n        }\n        \n        // If the result is 1, then 2 is the largest prime factor\n        if (n == 1) {\n            return 2;\n        }\n        \n        // Now n is odd. Check divisibility by odd numbers starting from 3.\n        int factor = 3;\n        while (factor * factor <= n) {\n            if (n % factor == 0) {\n                n /= factor;\n            } else {\n                factor += 2;\n            }\n        }\n        \n        // If n is still greater than 2, then it's prime and the largest factor.\n        if (n > 2) {\n            return n;\n        }\n        return factor;\n    }\n\n    public static void main(String[] args) {\n        assert largestPrimeFactor(13195) == 29;\n        assert largestPrimeFactor(2048) == 2;\n    }\n}"}
{"id": "HumanEval/60", "code": "public class SumToN {\n\n    public static int sumToN(int n) {\n        // Precondition 1: The input 'n' should not be null.\n        assert n != null : \"Input 'n' must not be null.\";\n\n        // Precondition 2: The input 'n' should be an integer.\n        assert n instanceof Integer : \"Input 'n' must be an integer.\";\n\n        // Precondition 3: The input 'n' should be a positive integer.\n        assert n > 0 : \"Input 'n' must be a positive integer.\";\n\n        int result = (n + 1) * n / 2;\n\n        // Postcondition 1: The result should be an integer.\n        assert result instanceof Integer : \"The result must be an integer.\";\n\n        // Postcondition 2: The result should match the expected sum.\n        int expectedResult = 0;\n        for (int i = 1; i <= n; i++) {\n            expectedResult += i;\n        }\n        assert result == expectedResult : \"The result \" + result + \" does not match the expected sum \" + expectedResult + \".\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        assert sumToN(30) == 465;\n        assert sumToN(100) == 5050;\n        assert sumToN(5) == 15;\n        assert sumToN(10) == 55;\n        assert sumToN(1) == 1;\n    }\n}"}
{"id": "HumanEval/61", "code": "public class BracketValidity {\n\n    public static boolean correctBracketing(String brackets) {\n        // Precondition 1\n        assert brackets != null : \"Input 'brackets' must not be null.\";\n\n        // Precondition 2\n        assert brackets instanceof String : \"Input 'brackets' must be a string.\";\n\n        // Precondition 3\n        assert brackets.matches(\"[()]*\") : \"Input 'brackets' must contain only '(' and ')'.\";\n\n        int count = 0;\n        for (char ch : brackets.toCharArray()) {\n            if (ch == '(') {\n                count++;\n            }\n            if (ch == ')') {\n                count--;\n            }\n            if (count < 0) {\n                return false;\n            }\n        }\n\n        boolean result = count == 0;\n\n        // Postcondition 1\n        assert result == true || result == false : \"The result must be a boolean value.\";\n\n        // Postcondition 2\n        if (result) {\n            assert count == 0 : \"If the result is true, the count of '(' and ')' must be balanced.\";\n        } else {\n            assert count != 0 : \"If the result is false, the count of '(' and ')' must not be balanced.\";\n        }\n\n        // Postcondition 3\n        if (brackets.equals(\"\")) {\n            assert result == true : \"The result must be true for an empty string.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(correctBracketing(\"(\"));     // false\n        System.out.println(correctBracketing(\"()\"));    // true\n        System.out.println(correctBracketing(\"(()())\"));// true\n        System.out.println(correctBracketing(\")(()\"));  // false\n    }\n}"}
{"id": "HumanEval/62", "code": "import java.util.List;\nimport java.util.ArrayList;\n\npublic class DerivativeCalculator {\n    public List<Double> derivative(List<Double> xs) {\n        // Precondition 1: The input list 'xs' should not be null.\n        assert xs != null : \"Input list 'xs' must not be null.\";\n\n        // Precondition 2: The input 'xs' should be a list.\n        assert xs instanceof List : \"Input 'xs' must be a list.\";\n\n        // Precondition 3: All elements in 'xs' should be numeric (double).\n        for (Double x : xs) {\n            assert x instanceof Double : \"All elements in 'xs' must be numeric (double).\";\n        }\n\n        List<Double> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(xs.get(i) * i);\n        }\n\n        // Postcondition 1: The result should be a list.\n        assert result instanceof List : \"The result must be a list.\";\n\n        // Postcondition 2: The length of the result should be one less than the length of 'xs'.\n        assert result.size() == xs.size() - 1 : \"The length of the result must be one less than the length of 'xs'.\";\n\n        // Postcondition 3: The result should correctly represent the derivative.\n        List<Double> expectedResult = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            expectedResult.add(i * xs.get(i));\n        }\n        assert result.equals(expectedResult) : \"The result must correctly represent the derivative of the polynomial.\";\n\n        return result;\n    }\n}"}
{"id": "HumanEval/63", "code": "public class FibFib {\n\n    public static int fibfib(int n) {\n\n        // Precondition 1: The input 'n' should not be null.\n        assert n >= 0 : \"Input 'n' must not be null.\";\n\n        // Precondition 2: The input 'n' should be an integer.\n        assert n >= 0 : \"Input 'n' must be an integer.\";\n\n        if (n == 0 || n == 1) {\n            return 0;\n        } else if (n == 2) {\n            return 1;\n        }\n\n        int a = 0, b = 0, c = 1;\n        for (int i = 3; i <= n; i++) {\n            int temp = a + b + c;\n            a = b;\n            b = c;\n            c = temp;\n        }\n\n        int result = c;\n\n        // Postcondition 1: The result should be an integer.\n        assert result >= 0 : \"The result must be an integer.\";\n\n        // Postcondition 2: Check base cases\n        if (n == 0 || n == 1) {\n            assert result == 0 : \"For n = \" + n + \", the result should be 0.\";\n        } else if (n == 2) {\n            assert result == 1 : \"For n = 2, the result should be 1.\";\n        }\n\n        // Postcondition 3: Correctness check for larger n.\n        if (n > 2) {\n            assert result == fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3) : \"The result must satisfy the fibfib recurrence relation.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(fibfib(1)); // 0\n        System.out.println(fibfib(5)); // 4\n        System.out.println(fibfib(8)); // 24\n    }\n}"}
{"id": "HumanEval/64", "code": "public class VowelsCounter {\n    public static int vowelsCount(String s) {\n        assert s != null : \"Input string 's' must not be null.\";\n        assert s instanceof String : \"Input 's' must be a string.\";\n\n        if (s.equals(\"\")) {\n            return 0;\n        }\n\n        int cnt = 0;\n        for (char ch : s.toCharArray()) {\n            if (\"aeiouAEIOU\".indexOf(ch) != -1) {\n                cnt++;\n            }\n        }\n        if (s.charAt(s.length() - 1) == 'y' || s.charAt(s.length() - 1) == 'Y') {\n            cnt++;\n        }\n\n        assert cnt >= 0 : \"The result must be non-negative.\";\n        assert cnt == 0 : \"The result must be 0 for an empty string.\";\n\n        int expectedCount = 0;\n        for (char ch : s.toCharArray()) {\n            if (\"aeiouAEIOU\".indexOf(ch) != -1) {\n                expectedCount++;\n            }\n        }\n        if (s.charAt(s.length() - 1) == 'y' || s.charAt(s.length() - 1) == 'Y') {\n            expectedCount++;\n        }\n        assert cnt == expectedCount : \"The count \" + cnt + \" does not match the expected count \" + expectedCount + \".\";\n\n        return cnt;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(vowelsCount(\"abcde\")); // 2\n        System.out.println(vowelsCount(\"ACEDY\")); // 3\n    }\n}"}
{"id": "HumanEval/65", "code": "public class CircularShift {\n    public static String circularShift(int x, int shift) {\n        // Precondition 1\n        if (x == null || shift == null) {\n            throw new IllegalArgumentException(\"Inputs 'x' and 'shift' must not be null.\");\n        }\n\n        // Precondition 2\n        if (!(x instanceof Integer)) {\n            throw new IllegalArgumentException(\"Input 'x' must be an integer.\");\n        }\n        if (!(shift instanceof Integer)) {\n            throw new IllegalArgumentException(\"Input 'shift' must be an integer.\");\n        }\n\n        // Precondition 3\n        if (shift < 0) {\n            throw new IllegalArgumentException(\"Input 'shift' must be a non-negative integer.\");\n        }\n\n        String s = String.valueOf(x);\n        if (shift > s.length()) {\n            return new StringBuilder(s).reverse().toString();\n        } else {\n            shift %= s.length();\n            if (shift == 0) {\n                return s;\n            } else {\n                String result = s.substring(s.length() - shift) + s.substring(0, s.length() - shift);\n                // Postcondition 1\n                if (!(result instanceof String)) {\n                    throw new IllegalArgumentException(\"The result must be a string.\");\n                }\n                // Postcondition 2\n                String expected_result = s.substring(s.length() - shift) + s.substring(0, s.length() - shift);\n                if (shift > s.length()) {\n                    if (!result.equals(new StringBuilder(s).reverse().toString())) {\n                        throw new AssertionError(\"The result should be the reverse of 'x' as a string when shift > number of digits.\");\n                    }\n                } else {\n                    if (!result.equals(expected_result)) {\n                        throw new AssertionError(\"The result should be the correct circular shift of 'x'.\");\n                    }\n                }\n                return result;\n            }\n        }\n    }\n}"}
{"id": "HumanEval/66", "code": "public class Main {\n\n    public static int digitSum(String s) {\n        // Precondition 1: The input string 's' should not be null.\n        assert s != null : \"Input string 's' must not be null.\";\n\n        // Precondition 2: The input 's' should be a string.\n        assert s instanceof String : \"Input 's' must be a string.\";\n\n        int result = s.chars().filter(Character::isUpperCase).map(Character::getNumericValue).sum();\n\n        // Postcondition 1: The result should be an integer.\n        assert result instanceof Integer : \"The result must be an integer.\";\n\n        // Postcondition 2: The result should be the sum of the ASCII codes of uppercase characters in the string.\n        int expectedSum = s.chars().filter(Character::isUpperCase).map(Character::getNumericValue).sum();\n        assert result == expectedSum : \"The result must correctly sum the ASCII codes of the uppercase characters.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(digitSum(\"abAB\"));    // Output: 131\n        System.out.println(digitSum(\"abcCd\"));   // Output: 67\n        System.out.println(digitSum(\"helloE\"));  // Output: 69\n        System.out.println(digitSum(\"woArBld\")); // Output: 131\n        System.out.println(digitSum(\"aAaaaXa\")); // Output: 153\n    }\n}"}
{"id": "HumanEval/67", "code": "public class FruitDistribution {\n    public static int fruitDistribution(String s, int n) {\n        // Precondition 1\n        assert s != null && n != 0 : \"Inputs 's' and 'n' must not be None.\";\n\n        // Precondition 2\n        assert s instanceof String : \"Input 's' must be a string.\";\n        assert n instanceof Integer : \"Input 'n' must be an integer.\";\n\n        // Precondition 3\n        String[] words = s.split(\" \");\n        int c1 = Integer.parseInt(words[0]);\n        int c2 = Integer.parseInt(words[3]);\n        assert c1 >= 0 && c2 >= 0 && n >= 0 : \"The number of fruits must be non-negative integers.\";\n        assert n - c1 - c2 >= 0 : \"The total number of fruits must be at least the sum of apples and oranges.\";\n\n        int result = n - c1 - c2;\n\n        // Postcondition 1\n        assert result instanceof Integer : \"The result must be an integer.\";\n\n        // Postcondition 2\n        assert result >= 0 : \"The number of mangoes cannot be negative.\";\n\n        // Postcondition 3\n        assert c1 + c2 + result == n : \"The sum of apples, oranges, and mangoes must equal the total number of fruits.\";\n\n        return result;\n    }\n}"}
{"id": "HumanEval/68", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Pluck {\n    public static List<Integer> pluck(List<Integer> arr) {\n        if (arr == null || arr.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        Integer minEven = null;\n        Integer minIndex = null;\n\n        for (int i = 0; i < arr.size(); i++) {\n            int val = arr.get(i);\n            if (val % 2 == 0) {\n                if (minEven == null || val < minEven) {\n                    minEven = val;\n                    minIndex = i;\n                }\n            }\n        }\n\n        if (minEven != null) {\n            List<Integer> result = new ArrayList<>();\n            result.add(minEven);\n            result.add(minIndex);\n            return result;\n        } else {\n            return new ArrayList<>();\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Integer> example1 = List.of(4, 2, 3);\n        List<Integer> example2 = List.of(1, 2, 3);\n        List<Integer> example3 = new ArrayList<>();\n        List<Integer> example4 = List.of(5, 0, 3, 0, 4, 2);\n\n        assert pluck(example1).equals(List.of(2, 1)) : \"Test Case 1 Failed\";\n        assert pluck(example2).equals(List.of(2, 1)) : \"Test Case 2 Failed\";\n        assert pluck(example3).isEmpty() : \"Test Case 3 Failed\";\n        assert pluck(example4).equals(List.of(0, 1)) : \"Test Case 4 Failed\";\n        assert pluck(List.of(5, 7, 3)).isEmpty() : \"Test Case 5 Failed\";  // No even numbers\n    }\n}"}
{"id": "HumanEval/69", "code": "public class Main {\n    public static int search(int[] lst) {\n        // Precondition 1: The input 'lst' should not be null.\n        assert lst != null : \"Input 'lst' must not be null.\";\n\n        // Precondition 2: The input 'lst' should be an array.\n        assert lst instanceof int[] : \"Input 'lst' must be an array.\";\n\n        // Precondition 3: All elements in 'lst' should be positive integers.\n        assert Arrays.stream(lst).allMatch(x -> x > 0) : \"All elements in 'lst' must be positive integers.\";\n\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int num : lst) {\n            count.put(num, count.getOrDefault(num, 0) + 1);\n        }\n\n        int ans = -1;\n        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {\n            int num = entry.getKey();\n            int cnt = entry.getValue();\n            if (cnt >= num) {\n                ans = Math.max(ans, num);\n            }\n        }\n\n        // Postcondition 1: The result should be an integer.\n        assert ans instanceof Integer : \"The result must be an integer.\";\n\n        // Postcondition 2: If no number meets the criteria, the result should be -1.\n        if (ans == -1) {\n            assert count.values().stream().allMatch(x -> x < num) : \"If result is -1, no number in 'lst' should meet the criteria.\";\n        }\n\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] input1 = {4, 1, 2, 2, 3, 1};\n        int[] input2 = {1, 2, 2, 3, 3, 3, 4, 4, 4};\n        int[] input3 = {5, 5, 4, 4, 4};\n\n        System.out.println(search(input1)); // Should print 2\n        System.out.println(search(input2)); // Should print 3\n        System.out.println(search(input3)); // Should print -1\n    }\n}"}
{"id": "HumanEval/70", "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class StrangeSort {\n\n    public static List<Integer> strangeSortList(List<Integer> lst) {\n        // Precondition 1: The input 'lst' should not be null.\n        assert lst != null : \"Input 'lst' must not be null.\";\n\n        // Precondition 2: The input 'lst' should be a List.\n        assert lst instanceof List : \"Input 'lst' must be a List.\";\n\n        // Precondition 3: All elements in 'lst' should be Integers.\n        for (Integer x : lst) {\n            assert x instanceof Integer : \"All elements in 'lst' must be Integers.\";\n        }\n\n        List<Integer> sortedList = new ArrayList<>(lst);\n        Collections.sort(sortedList);\n        List<Integer> ans = new ArrayList<>();\n        int i = 0, j = sortedList.size() - 1;\n\n        while (i < j) {\n            ans.add(sortedList.get(i));\n            ans.add(sortedList.get(j));\n            i++;\n            j--;\n        }\n\n        if (i == j) { // If there's one element left in the middle\n            ans.add(sortedList.get(i));\n        }\n\n        // Postcondition 1: The result should be a List.\n        assert ans instanceof List : \"The result must be a List.\";\n\n        // Postcondition 2: Ensure the List is sorted in the strange order.\n        assert ans.size() == lst.size() : \"The result List must have the same number of elements as the input List.\";\n\n        return ans;\n    }\n}"}
{"id": "HumanEval/71", "code": "public class TriangleArea {\n\n    public static double triangleArea(double a, double b, double c) {\n        // Precondition 1\n        if (a == null || b == null || c == null) {\n            throw new IllegalArgumentException(\"Sides 'a', 'b', and 'c' must not be null.\");\n        }\n\n        // Precondition 2\n        if (!(a instanceof Integer || a instanceof Double) ||\n                !(b instanceof Integer || b instanceof Double) ||\n                !(c instanceof Integer || c instanceof Double)) {\n            throw new IllegalArgumentException(\"Sides 'a', 'b', and 'c' must be numeric (int or double).\");\n        }\n\n        // Precondition 3\n        if (a <= 0 || b <= 0 || c <= 0) {\n            throw new IllegalArgumentException(\"Sides 'a', 'b', and 'c' must be positive numbers.\");\n        }\n\n        // Check for a valid triangle\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            return -1;\n        }\n\n        // Calculate the semi-perimeter\n        double p = (a + b + c) / 2;\n\n        // Calculate the area using Heron's formula\n        double area = Math.round(Math.pow(p * (p - a) * (p - b) * (p - c), 0.5) * 100.0) / 100.0;\n\n        // Postcondition 1\n        if (!(Double.isNaN(area) || area == -1)) {\n            throw new IllegalArgumentException(\"The result must be a double (for area) or -1 (for invalid triangle).\");\n        }\n\n        return area;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(triangleArea(3, 4, 5));  // Expected output: 6.0\n        System.out.println(triangleArea(1, 2, 10)); // Expected output: -1\n    }\n}"}
{"id": "HumanEval/72", "code": "public class FlightChecker {\n    public static boolean willItFly(int[] q, double w) {\n        // Precondition 1: The inputs 'q' and 'w' should not be null.\n        assert q != null && w >= 0 : \"Inputs 'q' and 'w' must not be null.\";\n\n        // Precondition 2: The input 'q' should be an array and 'w' should be a double.\n        assert q.getClass().isArray() : \"Input 'q' must be an array.\";\n        assert w instanceof Double || w instanceof Integer : \"Input 'w' must be an integer or double.\";\n\n        // Precondition 3: All elements in 'q' should be integers or doubles.\n        for (int elem : q) {\n            assert elem instanceof Integer || elem instanceof Double : \"All elements in 'q' must be integers or doubles.\";\n        }\n\n        // Precondition 4: The maximum weight 'w' should be non-negative.\n        assert w >= 0 : \"The maximum weight 'w' must be non-negative.\";\n\n        // Check if 'q' is a palindrome and if the sum of elements is less than or equal to 'w'\n        boolean result = isPalindrome(q) && sumArray(q) <= w;\n\n        // Postcondition 1: The result should be a boolean value.\n        assert result == true || result == false : \"The result must be a boolean value.\";\n\n        return result;\n    }\n\n    private static boolean isPalindrome(int[] arr) {\n        int i = 0;\n        int j = arr.length - 1;\n        while (i < j) {\n            if (arr[i] != arr[j]) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    private static double sumArray(int[] arr) {\n        double sum = 0;\n        for (int num : arr) {\n            sum += num;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        int[] test1 = {1, 2};\n        System.out.println(willItFly(test1, 5)); // False\n        \n        int[] test2 = {3, 2, 3};\n        System.out.println(willItFly(test2, 1)); // False\n        \n        int[] test3 = {3, 2, 3};\n        System.out.println(willItFly(test3, 9)); // True\n\n        int[] test4 = {3};\n        System.out.println(willItFly(test4, 5)); // True\n    }\n}"}
{"id": "HumanEval/73", "code": "public class SmallestChange {\n    public static int smallestChange(int[] arr) {\n        // Precondition 1: The input 'arr' should not be null.\n        assert arr != null : \"Input 'arr' must not be null.\";\n\n        // Precondition 2: The input 'arr' should be an array.\n        assert arr instanceof int[] : \"Input 'arr' must be an array.\";\n\n        int cnt = 0;\n        int n = arr.length;\n\n        // Compare elements from the start to the corresponding elements from the end\n        for (int i = 0; i < n / 2; i++) {\n            if (arr[i] != arr[n - i - 1]) {\n                cnt++;\n            }\n        }\n\n        // Postcondition 1: The result should be a non-negative integer.\n        assert cnt >= 0 : \"The result must be a non-negative integer.\";\n\n        return cnt;\n    }\n\n    public static void main(String[] args) {\n        int[] arr1 = {1, 2, 3, 5, 4, 7, 9, 6};\n        int[] arr2 = {1, 2, 3, 4, 3, 2, 2};\n        int[] arr3 = {1, 2, 3, 2, 1};\n\n        System.out.println(smallestChange(arr1)); // Output: 4\n        System.out.println(smallestChange(arr2)); // Output: 1\n        System.out.println(smallestChange(arr3)); // Output: 0\n    }\n}"}
{"id": "HumanEval/74", "code": "import java.util.List;\n\npublic class Main {\n    public static List<String> totalMatch(List<String> lst1, List<String> lst2) {\n        // Preconditions\n        assert lst1 != null && lst1.stream().allMatch(s -> s instanceof String), \"lst1 must be a list of strings.\";\n        assert lst2 != null && lst2.stream().allMatch(s -> s instanceof String), \"lst2 must be a list of strings.\";\n\n        // Compute total character counts\n        int c1 = lst1.stream().mapToInt(String::length).sum();\n        int c2 = lst2.stream().mapToInt(String::length).sum();\n\n        // Determine the result\n        List<String> result = c1 <= c2 ? lst1 : lst2;\n\n        // Postconditions\n        assert result != null, \"Result must not be null.\";\n        assert result.stream().allMatch(s -> s instanceof String), \"All elements in the result list must be strings.\";\n        assert result.stream().mapToInt(String::length).sum() <= Math.max(c1, c2), \"The total number of characters in the result list should be less than or equal to the larger of the two character counts.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test the function here\n    }\n}"}
{"id": "HumanEval/75", "code": "public class Main {\n\n    public static void main(String[] args) {\n        assert isMultiplyPrime(30) == true;\n    }\n\n    public static boolean isMultiplyPrime(int a) {\n        // Preconditions\n        assert a >= 0 : \"Input must be a non-negative integer.\";\n        assert a < 100 : \"Input must be less than 100.\";\n\n        if (a <= 1) {\n            return false;\n        }\n        \n        // Sieve of Eratosthenes to find all primes up to a\n        boolean[] isPrime = new boolean[a + 1];\n        for (int i = 2; i <= a; i++) {\n            isPrime[i] = true;\n        }\n        isPrime[0] = false;\n        isPrime[1] = false;\n\n        for (int i = 2; i <= Math.sqrt(a); i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= a; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n\n        // Count the number of prime factors\n        int cnt = 0;\n        int tmp = a;\n        for (int i = 2; i <= a; i++) {\n            while (isPrime[i] && tmp % i == 0) {\n                tmp /= i;\n                cnt++;\n            }\n        }\n\n        // Postconditions\n        assert cnt >= 0 : \"Count must be a non-negative integer.\";\n\n        // Check the logic of the result\n        boolean result = cnt == 3;\n        if (result) {\n            // If the result is True, cnt must be exactly 3.\n            assert cnt == 3 : \"If result is True, cnt should be exactly 3.\";\n        } else {\n            // If the result is False, cnt should not be 3.\n            assert cnt != 3 : \"If result is False, cnt should not be 3.\";\n        }\n\n        return result;\n    }\n}"}
{"id": "HumanEval/76", "code": "public boolean isSimplePower(int x, int n) {\n    if (x == 1) return true;\n    if (n == 0) return x == 0;\n    if (n == 1) return x == 1;\n    if (n == -1) return Math.abs(x) == 1;\n    int p = n;\n    while (Math.abs(p) <= Math.abs(x)) {\n        if (p == x) return true;\n        p *= n;\n    }\n    return false;\n}"}
{"id": "HumanEval/77", "code": "public class CubeChecker {\n    /**\n     * Write a function that takes an integer a and returns True\n     * if this integer is a cube of some integer number.\n     * Note: you may assume the input is always valid.\n     * Examples:\n     * iscube(1) ==> True\n     * iscube(2) ==> False\n     * iscube(-1) ==> True\n     * iscube(64) ==> True\n     * iscube(0) ==> True\n     * iscube(180) ==> False\n     */\n\n    public static boolean isCube(int a) {\n        // Precondition 1: The input 'a' should be an integer.\n        assert a == (int) a : \"Input 'a' must be an integer.\";\n        \n        int aAbs = Math.abs(a);\n        boolean result = (int) Math.round(Math.pow(aAbs, 1. / 3)) * (int) Math.round(Math.pow(aAbs, 1. / 3)) * (int) Math.round(Math.pow(aAbs, 1. / 3)) == aAbs;\n\n        // Postcondition 1: The result should be a boolean value.\n        assert result == true || result == false : \"The result must be a boolean value.\";\n\n        // Postcondition 2: If the result is True, 'a' should be a perfect cube.\n        if (result) {\n            assert (int) Math.round(Math.pow(aAbs, 1. / 3)) * (int) Math.round(Math.pow(aAbs, 1. / 3)) * (int) Math.round(Math.pow(aAbs, 1. / 3)) == aAbs : \"'a' should be a perfect cube if the result is True.\";\n        }\n\n        return result;\n    }\n}"}
{"id": "HumanEval/78", "code": "public class HexKey {\n\n    public static int hexKey(String num) {\n        // Precondition 1: The input 'num' should not be null.\n        assert num != null : \"Input 'num' must not be null.\";\n\n        // Precondition 2: The input 'num' should be a string.\n        assert num instanceof String : \"Input 'num' must be a string.\";\n\n        // Precondition 3: The string should only contain valid hexadecimal digits.\n        for (char ch : num.toCharArray()) {\n            assert \"0123456789ABCDEF\".contains(String.valueOf(ch)) : \"Input 'num' must contain only valid hexadecimal digits.\";\n        }\n\n        String primeDigits = \"2357BD\";\n        int result = (int) num.chars().filter(ch -> primeDigits.indexOf(ch) != -1).count();\n\n        // Postcondition 1: The result should be an integer.\n        assert result instanceof Integer : \"The result must be an integer.\";\n\n        // Postcondition 2: The result should be non-negative.\n        assert result >= 0 : \"The result must be non-negative.\";\n\n        // Postcondition 3: The result should correctly count the prime hexadecimal digits.\n        int expectedCount = (int) num.chars().filter(ch -> primeDigits.indexOf(ch) != -1).count();\n        assert result == expectedCount : \"The result must correctly count the prime hexadecimal digits.\";\n\n        return result;\n    }\n}"}
{"id": "HumanEval/79", "code": "public class Converter {\n    public static String decimalToBinary(int decimal) {\n        // Precondition 1\n        if (!(decimal instanceof Integer))\n            throw new IllegalArgumentException(\"Input 'decimal' must be an integer.\");\n\n        // Precondition 2\n        if (decimal < 0)\n            throw new IllegalArgumentException(\"Input 'decimal' must be a non-negative integer.\");\n\n        String result = \"db\" + Integer.toBinaryString(decimal) + \"db\";\n\n        // Postcondition 1\n        if (!(result instanceof String))\n            throw new IllegalStateException(\"The result must be a string.\");\n\n        // Postcondition 2\n        if (!result.startsWith(\"db\") || !result.endsWith(\"db\"))\n            throw new IllegalStateException(\"The result must start and end with 'db'.\");\n\n        // Postcondition 3\n        String binaryContent = result.substring(2, result.length() - 2);\n        if (!binaryContent.matches(\"[01]+\"))\n            throw new IllegalStateException(\"The content between 'db' and 'db' must be a valid binary representation.\");\n\n        return result;\n    }\n}"}
{"id": "HumanEval/80", "code": "public class HappyString {\n\n    public static boolean isHappy(String s) {\n        assert s != null : \"Input string 's' must not be null.\";\n        assert s instanceof String : \"Input 's' must be a string.\";\n\n        if (s.length() < 3) {\n            return false;\n        }\n\n        for (int i = 0; i < s.length() - 2; i++) {\n            if (s.charAt(i) == s.charAt(i + 1) || s.charAt(i) == s.charAt(i + 2) || s.charAt(i + 1) == s.charAt(i + 2)) {\n                return false;\n            }\n        }\n\n        boolean result = true;\n\n        assert result instanceof Boolean : \"The result must be a boolean value.\";\n\n        for (int i = 0; i < s.length() - 2; i++) {\n            assert s.charAt(i) != s.charAt(i + 1) && s.charAt(i) != s.charAt(i + 2) && s.charAt(i + 1) != s.charAt(i + 2) :\n                    \"Every three consecutive characters in the string must be distinct.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isHappy(\"a\"));     // false\n        System.out.println(isHappy(\"aa\"));    // false\n        System.out.println(isHappy(\"abcd\"));  // true\n        System.out.println(isHappy(\"aabb\"));  // false\n        System.out.println(isHappy(\"adb\"));   // true\n        System.out.println(isHappy(\"xyy\"));   // false\n    }\n}"}
{"id": "HumanEval/81", "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class GradeConverter {\n    \n    public static List<String> numericalLetterGrade(List<Double> grades) {\n        // Precondition 1: The input 'grades' should not be null.\n        assert grades != null : \"Input 'grades' must not be null.\";\n        \n        // Precondition 2: The input 'grades' should be a list.\n        assert grades instanceof List : \"Input 'grades' must be a list.\";\n        \n        // Precondition 3: All elements in 'grades' should be doubles.\n        assert grades.stream().allMatch(gpa -> gpa instanceof Double) : \"All elements in 'grades' must be doubles.\";\n        \n        // Precondition 4: All GPA values should be in the range [0.0, 4.0].\n        assert grades.stream().allMatch(gpa -> gpa >= 0.0 && gpa <= 4.0) : \"All GPA values must be within the range [0.0, 4.0].\";\n\n        List<String> result = new ArrayList<>();\n        for (Double score : grades) {\n            result.add(toLetterGrade(score));\n        }\n\n        // Postcondition 1: The result should be a list of strings.\n        assert result instanceof List : \"The result must be a list.\";\n        assert result.stream().allMatch(grade -> grade instanceof String) : \"All elements in the result must be strings.\";\n\n        // Postcondition 2: The length of the result list should match the length of the input list.\n        assert result.size() == grades.size() : \"The length of the result list must match the length of the input list.\";\n\n        // Postcondition 3: Ensure each string in the result list is a valid letter grade.\n        List<String> validGrades = Arrays.asList(\"A+\", \"A\", \"A-\", \"B+\", \"B\", \"B-\", \"C+\", \"C\", \"C-\", \"D+\", \"D\", \"D-\", \"E\");\n        assert result.stream().allMatch(grade -> validGrades.contains(grade)) : \"All elements in the result must be valid letter grades.\";\n\n        return result;\n    }\n\n    private static String toLetterGrade(Double score) {\n        if (score == 4.0) {\n            return \"A+\";\n        } else if (score > 3.7) {\n            return \"A\";\n        } else if (score > 3.3) {\n            return \"A-\";\n        } else if (score > 3.0) {\n            return \"B+\";\n        } else if (score > 2.7) {\n            return \"B\";\n        } else if (score > 2.3) {\n            return \"B-\";\n        } else if (score > 2.0) {\n            return \"C+\";\n        } else if (score > 1.7) {\n            return \"C\";\n        } else if (score > 1.3) {\n            return \"C-\";\n        } else if (score > 1.0) {\n            return \"D+\";\n        } else if (score > 0.7) {\n            return \"D\";\n        } else if (score > 0.0) {\n            return \"D-\";\n        } else {\n            return \"E\";\n        }\n    }\n    \n    public static void main(String[] args) {\n        List<Double> grades = Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5);\n        List<String> result = numericalLetterGrade(grades);\n        System.out.println(result);\n    }\n}"}
{"id": "HumanEval/82", "code": "public class PrimeLength {\n\n    public static boolean isPrime(int num) {\n        if (num < 2) return false;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean primeLength(String string) {\n        // Precondition 1: The input 'string' should not be null.\n        assert string != null : \"Input 'string' must not be null.\";\n\n        // Precondition 2: The input 'string' should be a string.\n        assert string instanceof String : \"Input 'string' must be a string.\";\n\n        boolean result = isPrime(string.length());\n\n        // Postcondition 1: The result should be a boolean value.\n        assert result == true || result == false : \"The result must be a boolean value.\";\n\n        // Postcondition 2: If the result is true, the length of the string should be a prime number.\n        if (result) {\n            assert string.length() > 1 && java.util.stream.IntStream.range(2, (int) Math.sqrt(string.length()) + 1).allMatch(i -> string.length() % i != 0) :\n                    \"If the result is true, the length of the string should be a prime number.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        assert primeLength(\"Hello\") == true;\n        assert primeLength(\"abcdcba\") == true;\n        assert primeLength(\"kittens\") == true;\n        assert primeLength(\"orange\") == false;\n    }\n}"}
{"id": "HumanEval/83", "code": "public class NumberCounter {\n\n    static int startsOneEnds(int n) {\n        // Precondition 1: The input 'n' should not be null.\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input 'n' must be a positive integer.\");\n        }\n\n        // Precondition 2: The input 'n' should be an integer.\n        if (!(n instanceof Integer)) {\n            throw new IllegalArgumentException(\"Input 'n' must be an integer.\");\n        }\n\n        int result;\n        if (n == 1) {\n            result = 1;\n        } else {\n            result = 18 * (int) Math.pow(10, n - 2);\n        }\n\n        // Postcondition 1: The result should be an integer.\n        if (!(result instanceof Integer)) {\n            throw new IllegalArgumentException(\"The result must be an integer.\");\n        }\n\n        // Postcondition 2: The result should be non-negative.\n        if (result < 0) {\n            throw new IllegalArgumentException(\"The result must be non-negative.\");\n        }\n\n        // Postcondition 3: Ensure that when 'n' is 1, the result is 1.\n        if (n == 1) {\n            if (result != 1) {\n                throw new IllegalArgumentException(\"For n=1, the result should be 1.\");\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int n = 3;\n        int count = startsOneEnds(n);\n        System.out.println(count);\n    }\n}"}
{"id": "HumanEval/84", "code": "public class BinarySum {\n\n    public static String solve(int N) {\n        // Precondition 1: The input 'N' should not be null.\n        assert N != null : \"Input 'N' must not be null.\";\n\n        // Precondition 2: The input 'N' should be an integer.\n        assert N instanceof Integer : \"Input 'N' must be an integer.\";\n\n        // Precondition 3: The input 'N' should be within the range 0 \u2264 N \u2264 10000.\n        assert N >= 0 && N <= 10000 : \"Input 'N' must be within the range 0 \u2264 N \u2264 10000.\";\n\n        // Calculate the sum of the digits of N\n        int s = 0;\n        String NString = String.valueOf(N);\n        for (int i = 0; i < NString.length(); i++) {\n            s += Character.getNumericValue(NString.charAt(i));\n        }\n\n        // Convert the sum to binary and remove the '0b' prefix\n        String result = Integer.toBinaryString(s);\n\n        // Postcondition 1: The result should be a string.\n        assert result instanceof String : \"The result must be a string.\";\n\n        // Postcondition 2: The result should be a valid binary string.\n        assert result.matches(\"[01]+\") : \"The result must be a valid binary string.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(solve(1000));\n        System.out.println(solve(150));\n        System.out.println(solve(147));\n    }\n}"}
{"id": "HumanEval/85", "code": "public class Main {\n\n    public static int add(int[] lst) {\n        // Precondition 1\n        assert lst != null : \"Input 'lst' must not be null.\";\n        \n        // Precondition 2\n        assert lst.getClass().isArray() : \"Input 'lst' must be an array.\";\n        \n        // Precondition 3\n        assert lst.length > 0 : \"Input 'lst' must be non-empty.\";\n        \n        // Precondition 4\n        for (int element : lst) {\n            assert element instanceof Integer : \"All elements in 'lst' must be integers.\";\n        }\n        \n        // Initialize sum\n        int s = 0;\n        \n        // Iterate over the array and add even elements at odd indices\n        for (int i = 1; i < lst.length; i += 2) {\n            if (lst[i] % 2 == 0) {\n                s += lst[i];\n            }\n        }\n        \n        // Postcondition 1\n        assert s instanceof Integer : \"The result must be an integer.\";\n        \n        // Postcondition 2\n        assert s >= 0 : \"The result must be non-negative.\";\n        \n        return s;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {4, 2, 6, 7};\n        System.out.println(add(arr)); // Output: 2\n    }\n}"}
{"id": "HumanEval/86", "code": "public class AntiShuffle {\n\n    public static String antiShuffle(String s) {\n        // Precondition 1: The input string 's' should not be null.\n        assert s != null : \"Input string 's' must not be null.\";\n        \n        // Precondition 2: The input 's' should be a string.\n        assert s instanceof String : \"Input 's' must be a string.\";\n        \n        // Split the string into words, sort each word, and then join them back together\n        String[] words = s.split(\" \");\n        String result = String.join(\" \", \n                        Arrays.stream(words)\n                            .map(word ->\n                                Arrays.stream(word.split(\"\"))\n                                      .sorted(Comparator.comparingInt(String::codePointAt))\n                                      .reduce(\"\", String::concat))\n                            .toArray(String[]::new));\n        \n        // Postcondition 1: The result should be a string.\n        assert result instanceof String : \"The result must be a string.\";\n        \n        // Postcondition 2: The length of the result string should match the length of the input string.\n        assert result.length() == s.length() : \"The length of the result string must match the length of the input string.\";\n        \n        // Postcondition 3: The order of words in the result should be the same as in the input.\n        assert Arrays.equals(result.split(\" \"), Arrays.stream(s.split(\"\")).map(word -> word.split(\"\")).map(wordArray -> \n                        Arrays.stream(wordArray)\n                              .map(String::valueOf)\n                              .sorted()\n                              .reduce(\"\", String::concat))\n                    .toArray(String[]::new)) :\n                \"The order of words in the result should match the input order, with characters in each word sorted.\";\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(antiShuffle(\"Hi\")); // Hi\n        System.out.println(antiShuffle(\"hello\")); // ehllo\n        System.out.println(antiShuffle(\"Hello World!!!\")); // Hello !!!Wdlor\n    }\n}"}
{"id": "HumanEval/87", "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n    public static List<List<Integer>> getRow(List<List<Integer>> lst, int x) {\n        // Precondition 1\n        assert lst != null : \"Input 'lst' must not be null.\";\n\n        // Precondition 2\n        for (List<Integer> row : lst) {\n            assert row != null && row instanceof List : \"Each element in 'lst' must be a list.\";\n        }\n\n        // Precondition 3\n        assert x instanceof Integer : \"Input 'x' must be an integer.\";\n\n        // Collecting the coordinates\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = lst.get(i);\n            for (int j = row.size() - 1; j >= 0; j--) {\n                if (row.get(j).equals(x)) {\n                    List<Integer> coord = new ArrayList<>();\n                    coord.add(i);\n                    coord.add(j);\n                    res.add(coord);\n                }\n            }\n        }\n\n        // Postcondition 1\n        for (List<Integer> coord : res) {\n            assert coord instanceof List && coord.size() == 2 : \"The result must be a list of lists with size 2.\";\n        }\n\n        // Postcondition 2\n        Collections.sort(res, (a, b) -> a.get(0).compareTo(b.get(0)));\n        assert res.equals(Collections.sorted(res, (a, b) -> a.get(0).compareTo(b.get(0))) : \"The lists should be sorted by row in ascending order.\";\n\n        // Postcondition 3\n        for (int i = 0; i < res.size() - 1; i++) {\n            List<Integer> coord1 = res.get(i);\n            List<Integer> coord2 = res.get(i + 1);\n            if (coord1.get(0).equals(coord2.get(0))) {\n                assert coord1.get(1) > coord2.get(1) : \"Within each row, lists should be sorted by column in descending order.\";\n            }\n        }\n\n        return res;\n    }\n}"}
{"id": "HumanEval/88", "code": "import java.util.Arrays;\n\npublic class ArraySorter {\n    public static int[] sortArray(int[] array) {\n        // Precondition 1\n        if (array == null) {\n            throw new IllegalArgumentException(\"Input 'array' must not be null.\");\n        }\n\n        // Precondition 2\n        if (!(array instanceof int[])) {\n            throw new IllegalArgumentException(\"Input 'array' must be an array of integers.\");\n        }\n\n        // Precondition 3\n        for (int x : array) {\n            if (x < 0) {\n                throw new IllegalArgumentException(\"All elements in 'array' must be non-negative integers.\");\n            }\n        }\n\n        if (array.length == 0) {\n            return new int[0];\n        }\n\n        // Determine the sorting order\n        boolean ascendingOrder = (array[0] + array[array.length - 1]) % 2 != 0;\n        int[] result = array.clone();\n        Arrays.sort(result);\n\n        // Applying descending order\n        if (!ascendingOrder) {\n            for (int i = 0; i < result.length / 2; i++) {\n                int temp = result[i];\n                result[i] = result[result.length - i - 1];\n                result[result.length - i - 1] = temp;\n            }\n        }\n\n        // Postcondition 1\n        if (!(result instanceof int[])) {\n            throw new IllegalArgumentException(\"The result must be an array of integers.\");\n        }\n\n        // Postcondition 2\n        if (result.length != array.length) {\n            throw new IllegalArgumentException(\"The length of the result array must match the length of the input array.\");\n        }\n\n        // Postcondition 3\n        if (ascendingOrder) {\n            for (int i = 0; i < result.length; i++) {\n                if (result[i] != array[i]) {\n                    throw new IllegalArgumentException(\"The result should be sorted in ascending order.\");\n                }\n            }\n        } else {\n            for (int i = 0; i < result.length; i++) {\n                if (result[i] != array[array.length - i - 1]) {\n                    throw new IllegalArgumentException(\"The result should be sorted in descending order.\");\n                }\n            }\n        }\n\n        return result;\n    }\n}"}
{"id": "HumanEval/89", "code": "public class Encrypt {\n\n    public static String encrypt(String s) {\n        // Precondition 1: The input string 's' should not be null.\n        if (s == null) throw new IllegalArgumentException(\"Input string 's' must not be null.\");\n\n        // Precondition 2: The input 's' should be a string.\n        if (!(s instanceof String)) throw new IllegalArgumentException(\"Input 's' must be a string.\");\n\n        // Precondition 3: The input 's' should contain only lowercase alphabetic characters.\n        if (!s.matches(\"[a-z]+\")) throw new IllegalArgumentException(\"Input 's' must contain only lowercase alphabetic characters.\");\n\n        // Define the alphabet string\n        String d = \"abcdefghijklmnopqrstuvwxyz\";\n\n        // Encrypt the string by shifting each character by 4 places\n        StringBuilder result = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (d.indexOf(ch) != -1) {\n                int newPos = (ch - 'a' + 4) % 26 + 'a';\n                result.append((char) newPos);\n            } else {\n                result.append(ch);\n            }\n        }\n        \n        String encryptedResult = result.toString();\n\n        // Postcondition 1: The result should be a string.\n        if (!(encryptedResult instanceof String)) throw new IllegalArgumentException(\"The result must be a string.\");\n\n        // Postcondition 2: The length of the result string should match the length of the input string.\n        if (encryptedResult.length() != s.length()) throw new IllegalArgumentException(\"The length of the result string must match the length of the input string.\");\n\n        // Postcondition 3: Each character in the result should be correctly shifted by four places.\n        for (int i = 0; i < s.length(); i++) {\n            char originalChar = s.charAt(i);\n            char encryptedChar = encryptedResult.charAt(i);\n            char expectedChar = (char) ((originalChar - 'a' + 4) % 26 + 'a');\n            if (encryptedChar != expectedChar) throw new IllegalArgumentException(\n                    \"The character '\" + originalChar + \"' should be encrypted to '\" + expectedChar + \"', but got '\" + encryptedChar + \"'.\");\n        }\n\n        return encryptedResult;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(encrypt(\"hi\")); // Output: \"lm\"\n        System.out.println(encrypt(\"asdfghjkl\")); // Output: \"ewhjklnop\"\n        System.out.println(encrypt(\"gf\")); // Output: \"kj\"\n        System.out.println(encrypt(\"et\")); // Output: \"ix\"\n    }\n}"}
{"id": "HumanEval/90", "code": "public class NextSmallest {\n\n    public static Integer nextSmallest(int[] lst) {\n        if (lst == null) {\n            throw new IllegalArgumentException(\"Input 'lst' must not be null.\");\n        }\n\n        if (lst.length == 0) {\n            return null;\n        }\n\n        // Precondition: All elements in 'lst' should be integers.\n        for (int num : lst) {\n            if (!(num instanceof Integer)) {\n                throw new IllegalArgumentException(\"All elements in 'lst' must be integers.\");\n            }\n        }\n\n        if (lst.length <= 1) {\n            return null;\n        }\n\n        // Sort the list and find the second smallest distinct element\n        TreeSet<Integer> sortedSet = new TreeSet<>();\n        for (int num : lst) {\n            sortedSet.add(num);\n        }\n\n        if (sortedSet.size() < 2) {\n            return null;\n        }\n\n        List<Integer> sortedList = new ArrayList<>(sortedSet);\n        return sortedList.get(1);\n    }\n}"}
{"id": "HumanEval/91", "code": "public class BoredomCounter {\n    public static int isBored(String S) {\n        // Precondition 1: The input string 'S' should not be null.\n        assert S != null : \"Input string 'S' must not be null.\";\n\n        // Precondition 2: The input 'S' should be a string.\n        assert S instanceof String : \"Input 'S' must be a string.\";\n\n        // Normalize sentence delimiters and split into sentences\n        String[] sentences = S.replace(\"?\", \".\").replace(\"!\", \".\").split(\"\\\\.\");\n\n        // Count sentences starting with \"I\"\n        int result = 0;\n        for (String sentence : sentences) {\n            if (sentence.trim().startsWith(\"I\")) {\n                result++;\n            }\n        }\n\n        // Postcondition 1: The result should be an integer.\n        assert result >= 0 : \"The result must be non-negative.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(isBored(\"Hello world\")); // 0\n        System.out.println(isBored(\"The sky is blue. The sun is shining. I love this weather\")); // 1\n    }\n}"}
{"id": "HumanEval/92", "code": "public class AnyInt {\n    public static boolean anyInt(int x, int y, int z) {\n        // Precondition 1: Ensure all inputs are integers.\n        if (!(x instanceof Integer && y instanceof Integer && z instanceof Integer)) {\n            return false;\n        }\n\n        // Check if one of the numbers equals the sum of the other two.\n        boolean result = (x == y + z || y == x + z || z == x + y);\n\n        // Postcondition 1: Ensure the result is a boolean.\n        assert result instanceof Boolean : \"The result must be a boolean.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Testing the function\n        assert anyInt(5, 2, 7) == true;\n        assert anyInt(3, 2, 2) == false;\n        assert anyInt(3, -2, 1) == true;\n        assert anyInt(3.6, -2.2, 2) == false;\n    }\n}"}
{"id": "HumanEval/93", "code": "public class MessageEncoder {\n\n    public static String encode(String message) {\n        // Precondition 1: The input 'message' should not be null.\n        assert message != null : \"Input 'message' must not be null.\";\n\n        // Precondition 2: The input 'message' should be a string.\n        assert message instanceof String : \"Input 'message' must be a string.\";\n\n        // Define a function to handle vowel changes\n        String encodeVowels(String ch) {\n            if (\"aeiou\".contains(ch)) {\n                return String.valueOf((char) (ch.charAt(0) + 2));\n            } else if (\"AEIOU\".contains(ch)) {\n                return String.valueOf((char) (ch.charAt(0) + 2));\n            } else {\n                return ch;\n            }\n        }\n\n        // Swap the case of the message\n        String m = message.swapCase();\n\n        // Apply vowel changes\n        StringBuilder result = new StringBuilder();\n        for (char c : m.toCharArray()) {\n            result.append(encodeVowels(String.valueOf(c)));\n        }\n\n        // Postcondition 1: The result should be a string.\n        assert result instanceof String : \"The result must be a string.\";\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(encode(\"test\"));\n        System.out.println(encode(\"This is a message\"));\n    }\n}"}
{"id": "HumanEval/94", "code": "public class Main {\n    public static void main(String[] args) {\n        int largestPrimeDigitSum(int[] lst) {\n            // Precondition 1\n            assert lst != null : \"Input list 'lst' must not be null.\";\n\n            // Precondition 2\n            for(int x : lst) {\n                assert x instanceof Integer : \"All elements in 'lst' must be integers.\";\n            }\n\n            // Helper function to check if a number is prime\n            boolean isPrime(int a) {\n                if (a < 2) return false;\n                for (int x = 2; x <= Math.sqrt(a); x++) {\n                    if (a % x == 0) return false;\n                }\n                return true;\n            }\n\n            // Sort the list in descending order\n            Arrays.sort(lst);\n            int[] sortedList = new int[lst.length];\n            for (int i = 0, j = lst.length - 1; i < lst.length; i++, j--) {\n                sortedList[i] = lst[j];\n            }\n\n            // Find the largest prime and return the sum of its digits\n            for (int x : sortedList) {\n                if (isPrime(x)) {\n                    int result = 0;\n                    String numStr = String.valueOf(x);\n                    for (char ch : numStr.toCharArray()) {\n                        result += Character.getNumericValue(ch);\n                    }\n\n                    // Postcondition 1\n                    assert result instanceof Integer : \"The result must be an integer.\";\n\n                    // Postcondition 2\n                    assert result >= 0 : \"The result must be a non-negative integer.\";\n\n                    return result;\n                }\n            }\n            // If no prime number is found, return -1\n            return -1;\n        }\n    }\n}"}
{"id": "HumanEval/95", "code": "import java.util.HashMap;\n\npublic class DictCaseChecker {\n    public static boolean checkDictCase(HashMap<String, String> d) {\n        // Precondition 1: The input 'dict' should not be null.\n        assert d != null : \"Input 'dict' must not be null.\";\n\n        // Precondition 2: The input 'dict' should be a HashMap.\n        assert d instanceof HashMap : \"Input 'dict' must be a HashMap.\";\n\n        // If the dictionary is empty, return false.\n        if (d.isEmpty()) {\n            return false;\n        }\n\n        boolean allLower = true;\n        boolean allUpper = true;\n\n        for (String key : d.keySet()) {\n            // Non-string keys make the dictionary invalid for this check.\n            if (!(key instanceof String)) {\n                return false;\n            }\n            if (!key.equals(key.toLowerCase())) {\n                allLower = false;\n            }\n            if (!key.equals(key.toUpperCase())) {\n                allUpper = false;\n            }\n        }\n\n        boolean result = allLower || allUpper;\n\n        // Postcondition 1: The result should be a boolean value.\n        assert result == true || result == false : \"The result must be a boolean value.\";\n\n        // Postcondition 2: If the dictionary is empty, the result should be false.\n        if (d.isEmpty()) {\n            assert result == false : \"The result must be false if the dictionary is empty.\";\n        }\n\n        // Postcondition 3: If the result is true, all keys should either be lower or upper case.\n        if (result) {\n            assert allLower == true || allUpper == true : \"If the result is true, all keys must be consistently lowercase or uppercase.\";\n        }\n\n        // Postcondition 4: If there are mixed-case keys, the result should be false.\n        if (d.keySet().stream().anyMatch(key -> key.matches(\".*[a-z].*\")) && d.keySet().stream().anyMatch(key -> key.matches(\".*[A-Z].*\"))) {\n            assert result == false : \"The result must be false if there are mixed-case keys.\";\n        }\n\n        // Postcondition 5: If the dictionary contains non-string keys, the result should be false.\n        if (d.keySet().stream().anyMatch(key -> !(key instanceof String))) {\n            assert result == false : \"The result must be false if the dictionary contains non-string keys.\";\n        }\n\n        // Postcondition 6: If all keys are lowercase, the result should be true.\n        if (allLower) {\n            assert result == true : \"The result must be true if all keys are lowercase.\";\n        }\n\n        // Postcondition 7: If all keys are uppercase, the result should be true.\n        if (allUpper) {\n            assert result == true : \"The result must be true if all keys are uppercase.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        HashMap<String, String> testDict = new HashMap<>();\n        testDict.put(\"a\", \"apple\");\n        testDict.put(\"b\", \"banana\");\n        System.out.println(checkDictCase(testDict)); // Should return true\n    }\n}"}
{"id": "HumanEval/96", "code": "import java.util.ArrayList;\n\npublic class PrimeNumbers {\n\n    public ArrayList<Integer> countUpTo(int n) {\n        // Precondition 1\n        if (n < 0) throw new IllegalArgumentException(\"Input 'n' must be a non-negative integer.\");\n\n        // Precondition 2\n        if (!(n instanceof Integer)) throw new IllegalArgumentException(\"Input 'n' must be an integer.\");\n\n        // Precondition 3\n        if (n < 0) throw new IllegalArgumentException(\"Input 'n' must be a non-negative integer.\");\n\n        ArrayList<Integer> ans = new ArrayList<>();\n        boolean[] isPrime = new boolean[n + 1];\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) {\n                ans.add(i);\n                for (int j = i + i; j < n; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n\n        // Postcondition 1\n        if (!(ans instanceof ArrayList)) throw new AssertionError(\"The result must be a list.\");\n\n        // Postcondition 2\n        for (int num : ans) {\n            if (!isPrime(num)) throw new AssertionError(\"All elements in the result must be prime numbers.\");\n        }\n\n        // Postcondition 3\n        if (ans.stream().anyMatch(num -> num >= n)) throw new AssertionError(\"All elements in the result must be less than 'n'.\");\n\n        return ans;\n    }\n\n    private boolean isPrime(int x) {\n        if (x < 2) return false;\n        for (int i = 2; i <= Math.sqrt(x); i++) {\n            if (x % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        PrimeNumbers primeNumbers = new PrimeNumbers();\n        System.out.println(primeNumbers.countUpTo(5)); // [2, 3]\n        System.out.println(primeNumbers.countUpTo(11)); // [2, 3, 5, 7]\n        System.out.println(primeNumbers.countUpTo(0)); // []\n        System.out.println(primeNumbers.countUpTo(20)); // [2, 3, 5, 7, 11, 13, 17, 19]\n        System.out.println(primeNumbers.countUpTo(1)); // []\n        System.out.println(primeNumbers.countUpTo(18)); // [2, 3, 5, 7, 11, 13, 17]\n    }\n}"}
{"id": "HumanEval/97", "code": "public class Main {\n    public static void main(String[] args) {\n        // Test assertions and function\n        assert multiply(148, 412) == 16 : \"Test Case 1 Failed\";\n        assert multiply(19, 28) == 72 : \"Test Case 2 Failed\";\n        assert multiply(2020, 1851) == 0 : \"Test Case 3 Failed\";\n        assert multiply(14, -15) == 20 : \"Test Case 4 Failed\";\n    }\n\n    public static int multiply(int a, int b) {\n        // Precondition 1\n        assert a instanceof Integer : \"Input 'a' must be an integer.\";\n        assert b instanceof Integer : \"Input 'b' m\n        // Compute the product of unit digits\n        int result = Character.getNumericValue(Integer.toString(Math.abs(a)).charAt(Integer.toString(Math.abs(a)).length() - 1)) \n            * Character.getNumericValue(Integer.toString(Math.abs(b)).charAt(Integer.toString(Math.abs(b)).length() - 1));\n        \n        // Postcondition 1\n        assert result instanceof Integer : \"The result must be an integer.\";\n        \n        // Postcondition 2\n        assert result == (Math.abs(a) % 10) * (Math.abs(b) % 10) : \"The result must be the product of the unit digits of 'a' and 'b'.\";\n        \n        return result;\n    }\n}"}
{"id": "HumanEval/98", "code": "public class CountUpper {\n\n    public static int countUpper(String s) {\n        // Precondition 1: Ensure that 's' is not null.\n        assert s != null : \"Input 's' must not be null.\";\n\n        // Precondition 2: Ensure that 's' is a string.\n        assert s instanceof String : \"Input 's' must be a string.\";\n\n        // Precondition 3: Ensure that 's' is not an empty string (optional, based on requirements).\n        assert s.length() >= 0 : \"Input 's' can be empty but must be a string.\";\n\n        int cnt = 0;\n        for (int i = 0; i < s.length(); i += 2) {\n            if (\"AEIOU\".contains(String.valueOf(s.charAt(i)))) {\n                cnt++;\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is an integer.\n        assert cnt >= 0 : \"The result must be non-negative.\";\n\n        // Postcondition 2: Ensure that the result correctly counts uppercase vowels at even indices.\n        int vowelsCount = 0;\n        for (int i = 0; i < s.length(); i += 2) {\n            if (\"AEIOU\".contains(String.valueOf(s.charAt(i)))) {\n                vowelsCount++;\n            }\n        }\n        assert cnt == vowelsCount : \"The result does not correctly count uppercase vowels at even indices.\";\n\n        // Postcondition 3: Ensure that if the input string is empty, the result is 0.\n        if (s.isEmpty()) {\n            assert cnt == 0 : \"If the input string is empty, the result should be 0.\";\n        }\n\n        // Postcondition 4: Ensure that if there are no uppercase vowels at even indices, the result is 0.\n        boolean hasUppercaseVowels = false;\n        for (int i = 0; i < s.length(); i += 2) {\n            if (\"AEIOU\".contains(String.valueOf(s.charAt(i)))) {\n                hasUppercaseVowels = true;\n                break;\n            }\n        }\n        if (!hasUppercaseVowels) {\n            assert cnt == 0 : \"If there are no uppercase vowels at even indices, the result should be 0.\";\n        }\n\n        return cnt;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(countUpper(\"aBCdEf\")); // Output: 1\n        System.out.println(countUpper(\"abcdefg\")); // Output: 0\n        System.out.println(countUpper(\"dBBE\")); // Output: 0\n    }\n}"}
{"id": "HumanEval/99", "code": "public class ClosestInteger {\n\n    public static int closestInteger(String value) {\n        // Precondition 1\n        assert value != null : \"Input 'value' must not be null.\";\n        \n        // Precondition 2\n        assert value instanceof String : \"Input 'value' must be a string.\";\n        \n        // Precondition 3\n        double num;\n        try {\n            num = Double.parseDouble(value);\n        } catch (NumberFormatException e) {\n            assert false : \"Input 'value' must be a valid number string.\";\n            return 0; // Return default value\n        }\n\n        int rounding(double val) {\n            if (Math.abs(val - (int) val) != 0.5) {\n                return Math.round((float) val);\n            }\n            if (val > 0) {\n                return (int) val + 1;\n            } else {\n                return (int) val - 1;\n            }\n        }\n\n        int result = rounding(num);\n\n        // Postcondition 1\n        assert result instanceof Integer : \"The result must be an integer.\";\n\n        // Postcondition 2\n        if (Math.abs(num - (int) num) == 0.5) {\n            if (num > 0) {\n                assert result == (int) num + 1 : \"The result should be rounded away from zero.\";\n            } else {\n                assert result == (int) num - 1 : \"The result should be rounded away from zero.\";\n            }\n        } else {\n            assert result == Math.round((float) num) : \"The result should be the closest integer.\";\n        }\n\n        return result;\n    }\n}"}
{"id": "HumanEval/100", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class StonePile {\n    public static List<Integer> makeAPile(int n) {\n        // Precondition 1: Ensure that 'n' is not null.\n        assert n != null : \"Input 'n' must not be null.\";\n\n        // Precondition 2: Ensure that 'n' is an integer.\n        assert n instanceof Integer : \"Input 'n' must be an integer.\";\n\n        // Precondition 3: Ensure that 'n' is a positive integer.\n        assert n > 0 : \"Input 'n' must be a positive integer.\";\n\n        List<Integer> ans = new ArrayList<>();\n        int num = n;\n        for (int i = 0; i < n; i++) {\n            ans.add(num);\n            num += 2;\n        }\n\n        // Postcondition 1: Ensure that the result is a list.\n        assert ans instanceof List : \"The result must be a list.\";\n\n        // Postcondition 2: Ensure that the list has exactly 'n' elements.\n        assert ans.size() == n : \"The result list must have \" + n + \" elements.\";\n\n        // Postcondition 3: Ensure that the first element is equal to 'n'.\n        assert ans.get(0) == n : \"The first element must be \" + n + \".\";\n\n        // Postcondition 4: Ensure that each subsequent element increases by 2.\n        for (int i = 1; i < n; i++) {\n            assert ans.get(i) == ans.get(i - 1) + 2 : \"Each element must increase by 2 from the previous one.\";\n        }\n\n        return ans;\n    }\n}"}
{"id": "HumanEval/101", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class WordProcessor {\n\n    public List<String> wordsString(String s) {\n        // Precondition 1\n        assert s != null : \"Input 's' must not be null.\";\n\n        // Precondition 2\n        assert s instanceof String : \"Input 's' must be a string.\";\n\n        // Precondition 3\n        assert s.length() > 0 : \"Input 's' must not be an empty string.\";\n\n        // Replace commas with spaces and split the string into words\n        String[] wordsArray = s.replace(\",\", \" \").split(\"\\\\s+\");\n\n        List<String> words = new ArrayList<>();\n\n        for (String word : wordsArray) {\n            if (!word.isEmpty()) {\n                words.add(word);\n            }\n        }\n\n        // Postcondition 1\n        assert words instanceof List : \"The result must be a list.\";\n\n        // Postcondition 2\n        assert words.stream().noneMatch(String::isEmpty) : \"The result list must not contain empty strings.\";\n\n        // Postcondition 3\n        assert words.equals(List.of(wordsArray)) : \"The result list does not match the expected words.\";\n\n        // Postcondition 4\n        assert words.equals(List.of(wordsArray)) : \"The words in the result list must maintain the original order.\";\n\n        return words;\n    }\n\n    public static void main(String[] args) {\n        WordProcessor wordProcessor = new WordProcessor();\n        List<String> result = wordProcessor.wordsString(\"Hi, my name is John\");\n        System.out.println(result);\n    }\n}"}
{"id": "HumanEval/102", "code": "public class Main {\n\n    public static int chooseNum(int x, int y) {\n        assert x != null && y != null : \"Inputs 'x' and 'y' must not be null.\";\n        assert x > 0 && y > 0 : \"Inputs 'x' and 'y' must be positive integers.\";\n\n        int result;\n        if (x > y) {\n            result = -1;\n        } else if (x == y) {\n            result = (y % 2 == 0) ? y : -1;\n        } else {\n            result = (y % 2 == 0) ? y : y - 1;\n        }\n\n        assert result != null : \"The result must not be null.\";\n        assert (result != -1) ? (x <= result && result <= y) : true : \"The result must be within the range [x, y].\";\n        assert (result != -1) ? (result % 2 == 0) : true : \"The result must be an even number.\";\n        assert (result == -1) ? IntStream.rangeClosed(x, y).allMatch(num -> num % 2 != 0) : true : \"The result should be -1 if no even number is in the range.\";\n        assert (result != -1) ? (result == IntStream.rangeClosed(x, y).filter(num -> num % 2 == 0).max().getAsInt()) : true : \"The result must be the largest even number in the range.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(chooseNum(12, 15));  // Output: 14\n        System.out.println(chooseNum(13, 12));  // Output: -1\n    }\n}"}
{"id": "HumanEval/103", "code": "public String roundedAvg(int n, int m) {\n    if (n > m) {\n        return \"-1\";\n    } else {\n        int avg = Math.round((n + m) / 2.0f);\n        String result = Integer.toBinaryString(avg);\n\n        assert result.startsWith(\"0b\") : \"The binary result must start with '0b'.\";\n        assert Integer.parseInt(result, 2) == avg : \"The result must correctly represent the rounded average in binary form.\";\n        assert n <= Integer.parseInt(result, 2) && Integer.parseInt(result, 2) <= m : \"The result in decimal must lie within the range [n, m].\";\n\n        return \"0b\" + result;\n    }\n}"}
{"id": "HumanEval/104", "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class UniqueDigits {\n\n    public static List<Integer> uniqueDigits(List<Integer> x) {\n        // Precondition 1: Ensure that 'x' is not null.\n        assert x != null : \"Input 'x' must not be null.\";\n\n        // Precondition 2: Ensure that 'x' is a list.\n        assert x instanceof List : \"Input 'x' must be a list.\";\n\n        // Precondition 3: Ensure that all elements in 'x' are positive integers.\n        assert x.stream().allMatch(i -> i instanceof Integer && i > 0) : \"All elements in 'x' must be positive integers.\";\n\n        List<Integer> result = new ArrayList<>();\n\n        for (int num : x) {\n            if (judge(num)) {\n                result.add(num);\n            }\n        }\n\n        Collections.sort(result);\n\n        // Postcondition 1: Ensure that the result is a list.\n        assert result instanceof List : \"The result must be a list.\";\n\n        // Postcondition 2: Ensure that all elements in the result list contain only odd digits.\n        assert result.stream().allMatch(num -> allOddDigits(num)) : \"All elements in the result list must contain only odd digits.\";\n\n        // Postcondition 3: Ensure that the result list is sorted in increasing order.\n        assert result.equals(new ArrayList<>(result)) : \"The result list must be sorted in increasing order.\";\n\n        // Postcondition 4: Ensure that if no elements meet the criteria, the result is an empty list.\n        if (result.isEmpty()) {\n            assert result.isEmpty() : \"\";\n        }\n\n        return result;\n    }\n\n    private static boolean judge(int num) {\n        for (char ch : String.valueOf(num).toCharArray()) {\n            if (Character.getNumericValue(ch) % 2 == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean allOddDigits(int num) {\n        return String.valueOf(num).chars().allMatch(ch -> Character.getNumericValue(ch) % 2 != 0);\n    }\n}"}
{"id": "HumanEval/105", "code": "import java.util.*;\n\npublic class Main {\n\n    public static List<String> byLength(List<Integer> arr) {\n        if (arr == null) {\n            throw new IllegalArgumentException(\"Input 'arr' must not be null.\");\n        }\n\n        if (!(arr instanceof List)) {\n            throw new IllegalArgumentException(\"Input 'arr' must be a list.\");\n        }\n\n        for (Object obj : arr) {\n            if (!(obj instanceof Integer)) {\n                throw new IllegalArgumentException(\"All elements in 'arr' must be integers.\");\n            }\n        }\n\n        List<String> ans = new ArrayList<>();\n        List<Integer> sortedList = new ArrayList<>(arr);\n        sortedList.sort(Collections.reverseOrder());\n\n        Map<Integer, String> numberToWordMap = new HashMap<>();\n        numberToWordMap.put(1, \"One\");\n        numberToWordMap.put(2, \"Two\");\n        numberToWordMap.put(3, \"Three\");\n        numberToWordMap.put(4, \"Four\");\n        numberToWordMap.put(5, \"Five\");\n        numberToWordMap.put(6, \"Six\");\n        numberToWordMap.put(7, \"Seven\");\n        numberToWordMap.put(8, \"Eight\");\n\n        for (Integer x : sortedList) {\n            if (x >= 1 && x <= 9) {\n                ans.add(numberToWordMap.get(x));\n            }\n        }\n\n        if (arr.isEmpty()) {\n            if (!ans.isEmpty()) {\n                throw new IllegalStateException(\"The result should be an empty list if the input is an empty array.\");\n            }\n        }\n\n        Set<String> validWordsSet = new HashSet<>(Arrays.asList(\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"));\n        for (String word : ans) {\n            if (!validWordsSet.contains(word)) {\n                throw new IllegalStateException(\"All elements in the result list must be valid words.\");\n            }\n        }\n\n        List<String> expected = new ArrayList<>();\n        for (Integer i : arr) {\n            if (i >= 1 && i <= 9) {\n                expected.add(numberToWordMap.get(i));\n            }\n        }\n        Collections.sort(expected, Collections.reverseOrder());\n\n        for (int i = 0; i < ans.size(); i++) {\n            if (!ans.get(i).equals(expected.get(i))) {\n                throw new IllegalStateException(\"The result list must be correctly sorted and reversed.\");\n            }\n        }\n\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> arr = Arrays.asList(2, 1, 1, 4, 5, 8, 2, 3);\n        System.out.println(byLength(arr)); \n    }\n}"}
{"id": "HumanEval/106", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class FactorialSum {\n    public static List<Integer> f(int n) {\n        // Precondition 1: Ensure that 'n' is not null.\n        assert n != null : \"Input 'n' must not be null.\";\n\n        // Precondition 2: Ensure that 'n' is an integer.\n        assert n instanceof Integer : \"Input 'n' must be an integer.\";\n\n        // Precondition 3: Ensure that 'n' is a non-negative integer.\n        assert n >= 0 : \"Input 'n' must be a non-negative integer.\";\n\n        if (n == 0) {\n            return new ArrayList<>();\n        }\n        if (n == 1) {\n            return List.of(1);\n        }\n        if (n == 2) {\n            return List.of(1, 2);\n        }\n\n        List<Integer> ans = new ArrayList<>(List.of(1, 2));\n        for (int i = 3; i <= n; i++) {\n            if (i % 2 == 1) {\n                ans.add(ans.get(ans.size() - 2) + (i - 1) + i);\n            } else {\n                ans.add(ans.get(ans.size() - 2) * (i - 1) * i);\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is a list.\n        assert ans instanceof List : \"The result must be a list.\";\n\n        // Postcondition 2: Ensure that the length of the result list is equal to 'n'.\n        assert ans.size() == n : \"The length of the result list must be \" + n + \".\";\n\n        // Postcondition 3: Ensure that for even indices, the value is the factorial of that index.\n        for (int i = 2; i < n; i += 2) {\n            int factorial = 1;\n            for (int j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            assert ans.get(i - 1).equals(factorial) : \"Element at index \" + i + \" must be the factorial of \" + i + \".\";\n        }\n\n        // Postcondition 4: Ensure that for odd indices, the value is the sum of numbers from 1 to that index.\n        for (int i = 1; i < n; i += 2) {\n            int expectedSum = 0;\n            for (int j = 1; j <= i; j++) {\n                expectedSum += j;\n            }\n            assert ans.get(i - 1).equals(expectedSum) : \"Element at index \" + i + \" must be the sum of numbers from 1 to \" + i + \".\";\n        }\n\n        // Postcondition 5: Ensure that the function correctly handles edge cases like 'n = 0'.\n        if (n == 0) {\n            assert ans.isEmpty() : \"The result should be an empty list if 'n' is 0.\";\n        }\n\n        return ans;\n    }\n}"}
{"id": "HumanEval/107", "code": "import java.util.*;\n\npublic class PalindromeCount {\n\n    public static int[] evenOddPalindrome(int n) {\n        // Precondition 1\n        assert n != null : \"Input 'n' must not be None.\";\n        // Precondition 2\n        assert n instanceof Integer : \"Input 'n' must be an integer.\";\n        // Precondition 3\n        assert n > 0 : \"Input 'n' must be a positive integer.\";\n        // Precondition 4\n        assert n >= 1 && n <= Math.pow(10, 3) : \"Input 'n' must be within the range 1 <= n <= 10^3.\";\n\n        int oddCount = 0, evenCount = 0;\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 1)\n                    oddCount++;\n                else\n                    evenCount++;\n            }\n        }\n\n        int[] result = new int[]{evenCount, oddCount};\n\n        // Postcondition 1\n        assert result instanceof int[] : \"The result must be an int array.\";\n        // Postcondition 2\n        assert result.length == 2 : \"The result array must have exactly two elements.\";\n        // Postcondition 3\n        assert result[0] >= 0 && result[1] >= 0 : \"Both elements in the result array must be non-negative integers.\";\n        // Postcondition 4\n        assert validateCounts(n, result) : \"The result does not correctly represent the number of even and odd palindromes.\";\n\n        return result;\n    }\n\n    public static boolean isPalindrome(int num) {\n        return String.valueOf(num).equals(new StringBuilder(String.valueOf(num)).reverse().toString());\n    }\n\n    public static boolean validateCounts(int n, int[] counts) {\n        int computedOddCount = 0, computedEvenCount = 0;\n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 1)\n                    computedOddCount++;\n                else\n                    computedEvenCount++;\n            }\n        }\n        return counts[0] == computedEvenCount && counts[1] == computedOddCount;\n    }\n\n    public static void main(String[] args) {\n        int n = 12;\n        int[] result = evenOddPalindrome(n);\n        System.out.println(Arrays.toString(result)); // Output: [4, 6]\n    }\n}"}
{"id": "HumanEval/108", "code": "public class Main {\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(countNums(new int[]{}));   // Output: 0\n        System.out.println(countNums(new int[]{-1, 11, -11}));  // Output: 1\n        System.out.println(countNums(new int[]{1, 1, 2}));  // Output: 3\n    }\n\n    public static int countNums(int[] arr) {\n        assert arr != null : \"Input 'arr' must not be null.\";\n        assert arr instanceof int[] : \"Input 'arr' must be an array of integers.\";\n\n        int result = 0;\n        for (int num : arr) {\n            if (calculateSumOfDigits(num) > 0) {\n                result++;\n            }\n        }\n\n        assert result >= 0 : \"The result must be a non-negative integer.\";\n        assert result == computeResult(arr) : \"The result does not correctly count elements with a sum of digits > 0.\";\n\n        return result;\n    }\n\n    private static int calculateSumOfDigits(int num) {\n        char[] numArray = String.valueOf(num).toCharArray();\n        int sum = 0;\n\n        if (numArray[0] == '-') {\n            for (int i = 1; i < numArray.length; i++) {\n                sum += Character.getNumericValue(numArray[i]);\n            }\n            sum *= -1;\n        } else {\n            for (char c : numArray) {\n                if (Character.isDigit(c)) {\n                    sum += Character.getNumericValue(c);\n                }\n            }\n        }\n\n        return sum;\n    }\n\n    private static int computeResult(int[] arr) {\n        int computedResult = 0;\n        for (int num : arr) {\n            if (calculateSumOfDigits(num) > 0) {\n                computedResult++;\n            }\n        }\n        return computedResult;\n    }\n}"}
{"id": "HumanEval/109", "code": "public class BallMovement {\n\n    public static boolean moveOneBall(int[] arr) {\n        // Precondition 1: Ensure that 'arr' is not null.\n        assert arr != null : \"Input 'arr' must not be null.\";\n\n        // Precondition 2: Ensure that 'arr' is an array.\n        assert arr.getClass().isArray() : \"Input 'arr' must be an array.\";\n\n        // Precondition 3: Ensure that all elements in 'arr' are integers.\n        // Assuming 'arr' is an array of integers.\n\n        // Precondition 4: Ensure that all elements in 'arr' are unique.\n        assert hasUniqueElements(arr) : \"All elements in 'arr' must be unique.\";\n\n        // Postcondition 1: If the array is empty, return true.\n        if (arr.length == 0) {\n            assert true : \"The result must be true if the input array is empty.\";\n            return true;\n        }\n\n        int[] sortedArr = arr.clone();\n        Arrays.sort(sortedArr);\n\n        // Postcondition 2: Ensure that the array is not already sorted.\n        if (Arrays.equals(arr, sortedArr)) {\n            assert Arrays.equals(arr, sortedArr) : \"If the array is already sorted, the result must be true.\";\n            return true;\n        }\n\n        // Check if the array can be sorted by any number of right shifts\n        for (int i = 1; i < arr.length; i++) {\n            if (Arrays.equals(concatArrays(Arrays.copyOfRange(arr, i, arr.length), Arrays.copyOfRange(arr, 0, i), sortedArr)) {\n                // Postcondition 3: Ensure that a valid right shift results in a sorted array.\n                assert Arrays.equals(concatArrays(Arrays.copyOfRange(arr, i, arr.length), Arrays.copyOfRange(arr, 0, i), sortedArr)) : \"A valid right shift should result in a sorted array.\";\n                return true;\n            }\n        }\n\n        // Postcondition 4: Ensure that no possible right shift results in a sorted array.\n        assert Arrays.stream(IntStream.range(1, arr.length).mapToObj(i -> concatArrays(Arrays.copyOfRange(arr, i, arr.length), Arrays.copyOfRange(arr, 0, i), sortedArr)).noneMatch(Arrays::equals)) : \"No possible right shift should result in a sorted array if the result is false.\";\n        return false;\n    }\n\n    private static boolean hasUniqueElements(int[] arr) {\n        Set<Integer> set = new HashSet<>();\n        for (int num : arr) {\n            if (!set.add(num)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static int[] concatArrays(int[] arr1, int[] arr2, int[] sortedArr) {\n        int[] concatenated = new int[arr1.length + arr2.length];\n        System.arraycopy(arr1, 0, concatenated, 0, arr1.length);\n        System.arraycopy(arr2, 0, concatenated, arr1.length, arr2.length);\n        return concatenated;\n    }\n}"}
{"id": "HumanEval/110", "code": "public class Main {\n    public static String exchange(int[] lst1, int[] lst2) {\n        // Preconditions\n        if (lst1 == null || lst2 == null) {\n            throw new IllegalArgumentException(\"Input lists 'lst1' and 'lst2' must not be null.\");\n        }\n        if (lst1.length == 0 || lst2.length == 0) {\n            throw new IllegalArgumentException(\"Input lists 'lst1' and 'lst2' must be non-empty.\");\n        }\n        for (int val : lst1) {\n            if (!(val instanceof Integer)) {\n                throw new IllegalArgumentException(\"All elements in 'lst1' must be integers.\");\n            }\n        }\n        for (int val : lst2) {\n            if (!(val instanceof Integer)) {\n                throw new IllegalArgumentException(\"All elements in 'lst2' must be integers.\");\n            }\n        }\n\n        int cntOdd = 0;\n        for (int num : lst1) {\n            if (num % 2 == 1) {\n                cntOdd++;\n            }\n        }\n        int cntEven = 0;\n        for (int num : lst2) {\n            if (num % 2 == 0) {\n                cntEven++;\n            }\n        }\n\n        String result = (cntOdd <= cntEven) ? \"YES\" : \"NO\";\n\n        // Postconditions\n        if (!(result instanceof String)) {\n            throw new IllegalArgumentException(\"The result must be a string.\");\n        }\n        if (!result.equals(\"YES\") && !result.equals(\"NO\")) {\n            throw new IllegalArgumentException(\"The result must be either 'YES' or 'NO'.\");\n        }\n\n        return result;\n    }\n}"}
{"id": "HumanEval/111", "code": "import java.util.HashMap;\n\npublic class Histogram {\n\n    public static HashMap<String, Integer> histogram(String test) {\n        // Precondition 1\n        assert test != null : \"Input 'test' must not be null.\";\n\n        // Precondition 2\n        assert test instanceof String : \"Input 'test' must be a string.\";\n\n        // Precondition 3\n        assert test.matches(\"[a-z ]+\") : \"Input 'test' must contain only lowercase letters and spaces.\";\n\n        if (test.isEmpty()) {\n            return new HashMap<>();\n        }\n\n        String[] words = test.split(\" \");\n        HashMap<String, Integer> count = new HashMap<>(), ans = new HashMap<>();\n\n        for (String word : words) {\n            if (!word.isEmpty()) {\n                count.put(word, count.getOrDefault(word, 0) + 1);\n            }\n        }\n\n        // Postcondition 1\n        assert !count.isEmpty() : \"The count dictionary should not be empty if the input is not empty.\";\n\n        int mx = count.values().stream().max(Integer::compare).get();\n        for (String ch : count.keySet()) {\n            if (count.get(ch) == mx) {\n                ans.put(ch, mx);\n            }\n        }\n\n        // Postcondition 2\n        assert ans instanceof HashMap : \"The result must be a HashMap.\";\n\n        // Postcondition 3\n        assert ans.values().stream().allMatch(v -> v == mx) : \"All values in the result must equal the maximum frequency.\";\n\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(histogram(\"a b c\"));  // {'a': 1, 'b': 1, 'c': 1}\n        System.out.println(histogram(\"a b b a\"));  // {'a': 2, 'b': 2}\n        System.out.println(histogram(\"a b c a b\"));  // {'a': 2, 'b': 2}\n        System.out.println(histogram(\"b b b b a\"));  // {'b': 4}\n        System.out.println(histogram(\"\"));  // {}\n    }\n}"}
{"id": "HumanEval/112", "code": "import java.util.Arrays;\n\npublic class PalindromeCheck {\n\n    public static String reverseDelete(String s, String c) {\n        // Check preconditions\n        assert s != null && c != null : \"Inputs 's' and 'c' must not be null.\";\n        assert s.getClass() == String.class && c.getClass() == String.class : \"Inputs 's' and 'c' must be strings.\";\n        assert s.matches(\"[a-zA-Z]+\") && c.matches(\"[a-zA-Z]+\") : \"Inputs 's' and 'c' must contain only alphabetic characters.\";\n\n        // Perform the reverse delete operation\n        StringBuilder sb = new StringBuilder();\n        for (char ch : s.toCharArray()) {\n            if (c.indexOf(ch) == -1) {\n                sb.append(ch);\n            }\n        }\n        String ss = sb.toString();\n\n        // Check postconditions\n        boolean isPalindrome = ss.equals(new StringBuilder(ss).reverse().toString());\n        assert (ss + \"Palindrome condition must be correct\") : isPalindrome == (ss.equals(new StringBuilder(ss).reverse().toString()));\n\n        return ss + \" \" + isPalindrome;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(reverseDelete(\"abcde\", \"ae\"));       // Should output \"bcd false\"\n        System.out.println(reverseDelete(\"abcdef\", \"b\"));      // Should output \"acdef false\"\n        System.out.println(reverseDelete(\"abcdedcba\", \"ab\"));  // Should output \"cdedc true\"\n    }\n}"}
{"id": "HumanEval/113", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class OddCounter {\n\n    public static List<String> oddCount(List<String> lst) {\n        // Precondition 1\n        assert lst != null : \"Input 'lst' must not be null.\";\n\n        // Precondition 2\n        assert lst instanceof List : \"Input 'lst' must be a list.\";\n\n        // Precondition 3\n        assert lst.stream().allMatch(s -> s instanceof String) : \"All elements in 'lst' must be strings.\";\n\n        // Precondition 4\n        assert lst.stream().allMatch(s -> s.matches(\"\\\\d+\")) : \"All strings in 'lst' must contain only digits.\";\n\n        List<String> ans = new ArrayList<>();\n        String template = \"the number of odd elements in the string %s of the input.\";\n\n        for (String s : lst) {\n            long oddCnt = s.chars().filter(ch -> ch % 2 == 1).count();\n            ans.add(template.replace(\"%s\", Long.toString(oddCnt)));\n        }\n\n        // Postcondition 1\n        assert ans instanceof List : \"The result must be a list.\";\n\n        // Postcondition 2\n        assert ans.size() == lst.size() : \"The result list must have the same length as the input list.\";\n\n        // Postcondition 3\n        for (int i = 0; i < lst.size(); i++) {\n            long oddCnt = lst.get(i).chars().filter(ch -> ch % 2 == 1).count();\n            String expectedOutput = \"the number of odd elements \" + oddCnt + \"n the str\" + oddCnt + \"ng \" + oddCnt + \" of the \" + oddCnt + \"nput.\";\n            assert ans.get(i).equals(expectedOutput) : \"The output string for input \" + lst.get(i) + \" does not match the expected format.\";\n        }\n\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        List<String> input1 = List.of(\"1234567\");\n        List<String> input2 = List.of(\"3\", \"11111111\");\n\n        System.out.println(oddCount(input1)); // [\"the number of odd elements in the string 4 of the input.\"]\n        System.out.println(oddCount(input2)); // [\"the number of odd elements in the string 1 of the input.\", \"the number of odd elements in the string 8 of the input.\"]\n    }\n}"}
{"id": "HumanEval/114", "code": "import java.util.List;\n\npublic class MinimumSubArraySum {\n    public static int minSubArraySum(List<Integer> nums) {\n        // Precondition 1: Ensure that 'nums' is not null.\n        if (nums == null) {\n            throw new IllegalArgumentException(\"Input 'nums' must not be null.\");\n        }\n\n        // Precondition 2: Ensure that 'nums' is a list.\n        if (!(nums instanceof List<?>)) {\n            throw new IllegalArgumentException(\"Input 'nums' must be a list.\");\n        }\n\n        // Precondition 3: Ensure that 'nums' is non-empty.\n        if (nums.isEmpty()) {\n            throw new IllegalArgumentException(\"Input 'nums' must be a non-empty list.\");\n        }\n\n        // Precondition 4: Ensure that all elements in 'nums' are integers.\n        for (Integer x : nums) {\n            if (x == null || !(x instanceof Integer)) {\n                throw new IllegalArgumentException(\"All elements in 'nums' must be integers.\");\n            }\n        }\n\n        // If all elements are non-negative, return the smallest element.\n        boolean allNonNegative = nums.stream().allMatch(x -> x >= 0);\n        if (allNonNegative) {\n            int result = nums.stream().min(Integer::compare).get();\n\n            // Postcondition 1: Ensure that the result is an integer.\n            if (!(result instanceof Integer)) {\n                throw new IllegalArgumentException(\"The result must be an integer.\");\n            }\n\n            // Postcondition 2: Ensure that the result is one of the elements in 'nums'.\n            if (!nums.contains(result)) {\n                throw new IllegalArgumentException(\"The result must be one of the elements in 'nums'.\");\n            }\n\n            return result;\n        }\n\n        int sum = 0, ans = 0;\n        for (Integer x : nums) {\n            sum += x;\n            ans = Math.min(ans, sum);\n            if (sum >= 0) {\n                sum = 0;\n            }\n        }\n\n        // Postcondition 3: Ensure that the result is an integer.\n        if (!(ans instanceof Integer)) {\n            throw new IllegalArgumentException(\"The result must be an integer.\");\n        }\n\n        // Postcondition 4: Ensure that the result is less than or equal to the sum of 'nums'.\n        if (ans > sum(nums)) {\n            throw new IllegalArgumentException(\"The result must be less than or equal to the sum of the entire array.\");\n        }\n\n        return ans;\n    }\n}"}
{"id": "HumanEval/115", "code": "public class WaterBucket {\n\n    public static int maxFill(int[][] grid, int capacity) {\n        // Precondition 1\n        if (grid == null)\n            throw new IllegalArgumentException(\"Input 'grid' must not be null.\");\n\n        // Precondition 2\n        for (int[] row : grid) {\n            if (!(row instanceof int[]))\n                throw new IllegalArgumentException(\"Input 'grid' must be a list of lists.\");\n        }\n\n        // Precondition 3\n        for (int[] row : grid) {\n            for (int cell : row) {\n                if (cell != 0 && cell != 1)\n                    throw new IllegalArgumentException(\"All elements in 'grid' must be either 0 or 1.\");\n            }\n        }\n\n        // Precondition 4\n        if (!(capacity >= 1 && capacity <= 10))\n            throw new IllegalArgumentException(\"Input 'capacity' must be an integer between 1 and 10.\");\n\n        int ans = 0;\n        for (int[] l : grid) {\n            ans += Math.ceil(Arrays.stream(l).sum() / (double) capacity);\n        }\n\n        // Postcondition 1\n        if (!(ans >= 0))\n            throw new IllegalArgumentException(\"The result must be a non-negative integer.\");\n\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[][] grid1 = {{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}};\n        int[][] grid2 = {{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}};\n        int[][] grid3 = {{0, 0, 0}, {0, 0, 0}};\n        \n        int capacity1 = 1;\n        int capacity2 = 2;\n        int capacity3 = 5;\n\n        System.out.println(maxFill(grid1, capacity1)); // Output: 6\n        System.out.println(maxFill(grid2, capacity2)); // Output: 5\n        System.out.println(maxFill(grid3, capacity3)); // Output: 0\n    }\n}"}
{"id": "HumanEval/116", "code": "import java.util.Arrays;\n\npublic class SortingArray {\n\n    public static int[] sortArray(int[] arr) {\n        if (arr == null) {\n            throw new IllegalArgumentException(\"Input 'arr' must not be null.\");\n        }\n        \n        for (int x : arr) {\n            if (!(x instanceof Integer)) {\n                throw new IllegalArgumentException(\"All elements in 'arr' must be integers.\");\n            }\n        }\n\n        Arrays.sort(arr, (x, y) -> {\n            int x1 = Integer.bitCount(x);\n            int y1 = Integer.bitCount(y);\n            if (x1 != y1) {\n                return x1 - y1;\n            }\n            return x - y;\n        });\n\n        int[] result = Arrays.copyOf(arr, arr.length);\n\n        if (result.length != arr.length) {\n            throw new IllegalStateException(\"The result list must have the same length as the input list.\");\n        }\n\n        for (int i = 0; i < result.length - 1; i++) {\n            if (Integer.bitCount(result[i]) > Integer.bitCount(result[i + 1])) {\n                throw new IllegalStateException(\"The list is not sorted according to the number of ones in binary representation.\");\n            }\n            if (Integer.bitCount(result[i]) == Integer.bitCount(result[i + 1]) && result[i] > result[i + 1]) {\n                throw new IllegalStateException(\"The list is not sorted correctly for elements with the same number of ones.\");\n            }\n        }\n\n        return result;\n    }\n}"}
{"id": "HumanEval/117", "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class WordSelector {\n\n    public static List<String> selectWords(String s, int n) {\n        // Precondition 1\n        if (s == null) throw new IllegalArgumentException(\"Input 's' must not be null.\");\n\n        // Precondition 2\n        if (!(s instanceof String)) throw new IllegalArgumentException(\"Input 's' must be a string.\");\n\n        // Precondition 3\n        if (n <= 0) throw new IllegalArgumentException(\"Input 'n' must be a natural number (positive integer).\");\n\n        // Precondition 4\n        if (!s.matches(\"^[a-zA-Z\\\\s]*$\")) throw new IllegalArgumentException(\"Input 's' must contain only letters and spaces.\");\n\n        List<String> ans = new ArrayList<>();\n        for (String word : s.split(\" \")) {\n            if (!word.isEmpty()) {\n                long c_cnt = word.chars().filter(ch -> \"aeiouAEIOU\".indexOf(ch) == -1).count();\n                if (c_cnt == n) {\n                    ans.add(word);\n                }\n            }\n        }\n\n        // Postcondition 1\n        if (!(ans instanceof List)) throw new AssertionError(\"The result must be a list.\");\n\n        // Postcondition 2\n        if (!ans.stream().allMatch(word -> word instanceof String)) throw new AssertionError(\"All elements in the result list must be strings.\");\n\n        // Postcondition 3\n        if (!ans.stream().allMatch(word -> word.chars().filter(ch -> \"aeiouAEIOU\".indexOf(ch) == -1).count() == n))\n            throw new AssertionError(\"All words in the result list must have exactly 'n' consonants.\");\n\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(selectWords(\"Mary had a little lamb\", 4));\n        System.out.println(selectWords(\"Mary had a little lamb\", 3));\n        System.out.println(selectWords(\"simple white space\", 2));\n        System.out.println(selectWords(\"Hello world\", 4));\n        System.out.println(selectWords(\"Uncle sam\", 3));\n    }\n}"}
{"id": "HumanEval/118", "code": "public class ClosestVowel {\n    public static String getClosestVowel(String word) {\n        // Precondition 1\n        assert word != null : \"Input 'word' must not be null.\";\n\n        // Precondition 2\n        assert word instanceof String : \"Input 'word' must be a string.\";\n\n        // Precondition 3\n        assert word.matches(\"[a-zA-Z]+\") : \"Input 'word' must contain only English letters.\";\n\n        // Helper function to check if a character is a vowel\n        // Java does not have built-in string 'in' operation like Python\n        // So, we will check manually\n        boolean isVowel(char ch) {\n            return \"aeiouAEIOU\".contains(Character.toString(ch));\n        }\n\n        for (int i = word.length() - 2; i > 0; i--) {\n            if (isVowel(word.charAt(i)) && !isVowel(word.charAt(i - 1)) && !isVowel(word.charAt(i + 1))) {\n                return Character.toString(word.charAt(i));\n            }\n        }\n\n        // Postcondition 1\n        String result = \"\";\n        assert result instanceof String : \"The result must be a string.\";\n\n        // Postcondition 2\n        assert result.equals(\"\") || result.matches(\"[aeiouAEIOU]\") : \"The result must be either an empty string or a vowel.\";\n\n        return \"\";\n    }\n}"}
{"id": "HumanEval/119", "code": "public class ParenthesesMatcher {\n\n    public static String matchParens(String[] lst) {\n        // Precondition 1\n        if (lst == null) throw new IllegalArgumentException(\"Input 'lst' must not be null.\");\n\n        // Precondition 2\n        if (lst.length != 2) throw new IllegalArgumentException(\"Input 'lst' must be an array of two strings.\");\n\n        // Precondition 3\n        for (String s : lst) {\n            if (s == null || !s.matches(\"[()]*\")) {\n                throw new IllegalArgumentException(\"Both elements in 'lst' must be strings with only '(' and ')'.\");\n            }\n        }\n\n        boolean validParens = false;\n        validParens = isValid(lst[0] + lst[1]) || isValid(lst[1] + lst[0]);\n\n        // Postcondition 1\n        if (!validParens) throw new IllegalStateException(\"The result must be a string.\");\n\n        // Postcondition 2\n        if (!validParens) throw new IllegalStateException(\"The result must be either 'Yes' or 'No'.\");\n\n        return validParens ? \"Yes\" : \"No\";\n    }\n\n    private static boolean isValid(String s) {\n        int count = 0;\n        for (char ch : s.toCharArray()) {\n            count += (ch == '(') ? 1 : -1;\n            if (count < 0) {\n                return false;\n            }\n        }\n        return count == 0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(matchParens(new String[]{\"()(\", \")\"})); // Yes\n        System.out.println(matchParens(new String[]{\")\", \")\"})); // No\n    }\n}"}
{"id": "HumanEval/120", "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class MaximumNumbers {\n\n    public List<Integer> maximum(int[] arr, int k) {\n        // Precondition 1: Ensure that 'arr' is not null.\n        assert arr != null : \"Input 'arr' must not be null.\";\n\n        // Precondition 2: Ensure that 'arr' is an array.\n        assert arr instanceof int[] : \"Input 'arr' must be an array.\";\n\n        // Precondition 3: Ensure that all elements in 'arr' are integers.\n        for (int x : arr) {\n            assert Math.floor(x) == x : \"All elements in 'arr' must be integers.\";\n        }\n\n        // Precondition 4: Ensure that 'k' is a non-negative integer within the valid range.\n        assert k >= 0 && k <= arr.length : \"Input 'k' must be a non-negative integer within the valid range.\";\n\n        int[] result = Arrays.stream(arr).boxed().sorted((a, b) -> Integer.compare(b, a))\n                                         .limit(k).sorted().mapToInt(Integer::intValue).toArray();\n\n        // Postcondition 1: Ensure that the result is an array.\n        assert result != null : \"The result must not be null.\";\n\n        // Postcondition 2: Ensure that the length of the result array is equal to 'k'.\n        assert result.length == k : \"The result array must have a length equal to 'k'.\";\n\n        // Postcondition 3: Ensure that the result array is sorted in ascending order.\n        for (int i = 0; i < result.length - 1; i++) {\n            assert result[i] <= result[i + 1] : \"The result array must be sorted in ascending order.\";\n        }\n\n        return Arrays.stream(result).boxed().collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        MaximumNumbers maximumNumbers = new MaximumNumbers();\n\n        int[] arr1 = {-3, -4, 5};\n        int k1 = 3;\n        System.out.println(maximumNumbers.maximum(arr1, k1)); // [-4, -3, 5]\n\n        int[] arr2 = {4, -4, 4};\n        int k2 = 2;\n        System.out.println(maximumNumbers.maximum(arr2, k2)); // [4, 4]\n\n        int[] arr3 = {-3, 2, 1, 2, -1, -2, 1};\n        int k3 = 1;\n        System.out.println(maximumNumbers.maximum(arr3, k3)); // [2]\n    }\n}"}
{"id": "HumanEval/121", "code": "public class Solution {\n    public static int solution(int[] lst) {\n        // Precondition 1: Ensure that 'lst' is not null\n        assert lst != null : \"Input 'lst' must not be null.\";\n\n        // Precondition 2: Ensure that 'lst' is an array\n        assert lst.getClass().isArray() : \"Input 'lst' must be an array.\";\n\n        // Precondition 3: Ensure that 'lst' is non-empty\n        assert lst.length > 0 : \"Input 'lst' must be a non-empty array.\";\n\n        // Precondition 4: Ensure that all elements in 'lst' are integers\n        for (int num : lst) {\n            assert num instanceof Integer : \"All elements in 'lst' must be integers.\";\n        }\n\n        int result = 0;\n        for (int i = 0; i < lst.length; i++) {\n            if (i % 2 == 0 && lst[i] % 2 == 1) {\n                result += lst[i];\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is an integer\n        assert result instanceof Integer : \"The result must be an integer.\";\n\n        // Postcondition 2: Ensure that the result is non-negative\n        assert result >= 0 : \"The result must be a non-negative integer.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(solution(new int[]{5, 8, 7, 1}));  // Output: 12\n        System.out.println(solution(new int[]{3, 3, 3, 3, 3}));  // Output: 9\n        System.out.println(solution(new int[]{30, 13, 24, 321}));  // Output: 0\n    }\n}"}
{"id": "HumanEval/122", "code": "public class ArraySum {\n\n    public static int addElements(int[] arr, int k) {\n        // Precondition 1: Ensure that 'arr' is not null.\n        assert arr != null : \"Input 'arr' must not be null.\";\n\n        // Precondition 2: Ensure that 'arr' is an array.\n        assert arr.getClass().isArray() : \"Input 'arr' must be an array.\";\n\n        // Precondition 3: Ensure that all elements in 'arr' are integers.\n        for (int x : arr) {\n            assert x instanceof Integer : \"All elements in 'arr' must be integers.\";\n        }\n\n        // Precondition 4: Ensure that 'k' is an integer within the valid range.\n        assert k >= 1 && k <= arr.length : \"Input 'k' must be an integer within the valid range.\";\n\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            if (String.valueOf(arr[i]).length() <= 2) {\n                sum += arr[i];\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is an integer.\n        assert sum instanceof Integer : \"The result must be an integer.\";\n\n        // Postcondition 2: Ensure that the result is non-negative or equal to zero.\n        assert sum >= 0 : \"The result must be non-negative or equal to zero.\";\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n        int k = 4;\n        System.out.println(addElements(arr, k)); // Output: 24\n    }\n}"}
{"id": "HumanEval/123", "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Collections;\n\npublic class Collatz {\n\n    public static List<Integer> getOddCollatz(int n) {\n        // Precondition 1: Ensure that 'n' is a positive integer.\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input 'n' must be a positive integer.\");\n        }\n\n        List<Integer> ans = new ArrayList<>();\n        int x = n;\n\n        while (x != 1) {\n            if (x % 2 == 1) {\n                ans.add(x);\n            }\n            x = (x % 2 == 0) ? x / 2 : x * 3 + 1;\n        }\n\n        ans.add(1);\n        Collections.sort(ans);\n\n        // Postcondition 1: Ensure that the result is a list.\n        if (!(ans instanceof List)) {\n            throw new AssertionError(\"The result must be a list.\");\n        }\n\n        // Postcondition 2: Ensure that all elements in the result are odd integers.\n        for (int num : ans) {\n            if (num % 2 != 1) {\n                throw new AssertionError(\"All elements in the result list must be odd integers.\");\n            }\n        }\n\n        // Postcondition 3: Ensure that the result list is sorted in increasing order.\n        List<Integer> resultCopy = new ArrayList<>(ans);\n        Collections.sort(resultCopy);\n        if (!ans.equals(resultCopy)) {\n            throw new AssertionError(\"The result list must be sorted in increasing order.\");\n        }\n\n        // Postcondition 4: Ensure that the result contains 1, as the sequence always ends at 1.\n        if (!ans.contains(1)) {\n            throw new AssertionError(\"The result list must contain the number 1.\");\n        }\n\n        return ans;\n    }\n}"}
{"id": "HumanEval/124", "code": "public class DateValidator {\n\n    public static boolean validDate(String date) {\n        assert date != null : \"Input 'date' must not be null.\";\n        assert date instanceof String : \"Input 'date' must be a string.\";\n\n        int[] days = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n        if (date.length() != 10) return false;\n        if (date.charAt(2) != '-' || date.charAt(5) != '-') return false;\n\n        String[] parts = date.split(\"-\");\n        if (parts.length != 3) return false;\n\n        String m = parts[0];\n        String d = parts[1];\n        String y = parts[2];\n\n        if (!m.matches(\"\\\\d+\") || !d.matches(\"\\\\d+\") || !y.matches(\"\\\\d+\")) return false;\n\n        int month = Integer.parseInt(m);\n        int day = Integer.parseInt(d);\n\n        if (month < 1 || month > 12) return false;\n        if (day < 1 || day > days[month - 1]) return false;\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(validDate(\"03-11-2000\")); // true\n        System.out.println(validDate(\"15-01-2012\")); // false\n        System.out.println(validDate(\"04-0-2040\")); // false\n        System.out.println(validDate(\"06-04-2020\")); // true\n        System.out.println(validDate(\"06/04/2020\")); // false\n    }\n}"}
{"id": "HumanEval/125", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class WordSplitter {\n\n    public static Object splitWords(String txt) {\n        // Precondition 1: Ensure that 'txt' is not null.\n        assert txt != null : \"Input 'txt' must not be null.\";\n\n        // Precondition 2: Ensure that 'txt' is a string.\n        assert txt instanceof String : \"Input 'txt' must be a string.\";\n\n        char[] whitespace = {' ', '\\n', '\\r', '\\t'};\n        if (txt.contains(\" \") || txt.contains(\"\\n\") || txt.contains(\"\\r\") || txt.contains(\"\\t\")) {\n            String[] result = txt.split(\"\\\\s+\");\n            return result;\n        } else if (txt.contains(\",\")) {\n            String[] result = txt.split(\",\");\n            return result;\n        } else {\n            int cnt = 0;\n            for (char ch : txt.toCharArray()) {\n                if (Character.isLowerCase(ch) && (ch - 'a') % 2 == 1) {\n                    cnt++;\n                }\n            }\n            return cnt;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Test the splitWords method\n        assert splitWords(\"Hello world!\").equals(new String[]{\"Hello\", \"world!\"});\n        assert splitWords(\"Hello,world!\").equals(new String[]{\"Hello\", \"world!\"});\n        assert splitWords(\"abcdef\").equals(3);\n    }\n}"}
{"id": "HumanEval/126", "code": "public class Main {\n    public static void main(String[] args) {\n        System.out.println(isSorted(new int[]{5})); // true\n        System.out.println(isSorted(new int[]{1, 2, 3, 4, 5})); // true\n        System.out.println(isSorted(new int[]{1, 3, 2, 4, 5})); // false\n        System.out.println(isSorted(new int[]{1, 2, 3, 4, 5, 6})); // true\n        System.out.println(isSorted(new int[]{1, 2, 3, 4, 5, 6, 7})); // true\n        System.out.println(isSorted(new int[]{1, 3, 2, 4, 5, 6, 7})); // false\n        System.out.println(isSorted(new int[]{1, 2, 2, 3, 3, 4})); // true\n        System.out.println(isSorted(new int[]{1, 2, 2, 2, 3, 4})); // false\n    }\n\n    public static boolean isSorted(int[] lst) {\n        // Precondition 1: Ensure that 'lst' is not null.\n        assert lst != null : \"Input 'lst' must not be null.\";\n\n        // Precondition 2: Ensure that 'lst' is an array.\n        assert lst.getClass().isArray() : \"Input 'lst' must be an array.\";\n\n  \t    // Precondition 3: Ensure that all elements in 'lst' are non-negative integers.\n        for (int x : lst) {\n            assert x >= 0 : \"All elements in 'lst' must be non-negative integers.\";\n        }\n\n        java.util.HashMap<Integer, Integer> count = new java.util.HashMap<>();\n        for (int x : lst) {\n            if (!count.containsKey(x)) {\n                count.put(x, 0);\n            }\n            count.put(x, count.get(x) + 1);\n            if (count.get(x) > 2) {\n                return false;\n            }\n        }\n\n        int[] sorted = lst.clone(); // Create a sorted copy\n        java.util.Arrays.sort(sorted);\n        boolean result = java.util.Arrays.equals(lst, sorted);\n\n        // Postcondition: Ensure that the result is a boolean.\n        assert result == true || result == false : \"The result must be a boolean.\";\n\n        return result;\n    }\n}"}
{"id": "HumanEval/127", "code": "public class IntervalIntersection {\n\n    public static String intersection(int[] interval1, int[] interval2) {\n        // Precondition 1\n        if (interval1.length != 2 || interval2.length != 2)\n            throw new IllegalArgumentException(\"Both intervals must contain exactly two elements.\");\n        if (!(interval1[0] instanceof Integer) || !(interval1[1] instanceof Integer) || !(interval2[0] instanceof Integer) || !(interval2[1] instanceof Integer))\n            throw new IllegalArgumentException(\"All elements in intervals must be integers.\");\n\n        // Precondition 2\n        if (interval1[0] > interval1[1] || interval2[0] > interval2[1])\n            throw new IllegalArgumentException(\"Start of respective interval must be less than or equal to its end.\");\n\n        // Helper method to check for prime numbers\n        boolean isPrime(int a) {\n            return a < 2 || IntStream.range(2, (int) Math.sqrt(a) + 1).anyMatch(x -> a % x == 0);\n        }\n\n        // Ensure interval1 starts before or at the same time as interval2\n        if (interval1[0] > interval2[0]) {\n            int[] temp = interval1;\n            interval1 = interval2;\n            interval2 = temp;\n        }\n\n        int l = interval2[0];\n        int r = Math.min(interval1[1], interval2[1]);\n\n        // Postcondition 1\n        int intersectionLength = r - l;\n        if (intersectionLength < 0)\n            throw new IllegalStateException(\"Intersection length must be a non-negative integer.\");\n\n        // Postcondition 2\n        String result = isPrime(intersectionLength) ? \"YES\" : \"NO\";\n        if (!result.equals(\"YES\") && !result.equals(\"NO\"))\n            throw new IllegalStateException(\"The result must be either 'YES' or 'NO'.\");\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(intersection(new int[]{1, 2}, new int[]{2, 3})); // \"NO\"\n        System.out.println(intersection(new int[]{-1, 1}, new int[]{0, 4})); // \"NO\"\n        System.out.println(intersection(new int[]{-3, -1}, new int[]{-5, 5})); // \"YES\"\n    }\n}"}
{"id": "HumanEval/128", "code": "public class Main {\n    public static Integer prodSigns(int[] arr) {\n        if (arr.length == 0) {\n            return null;\n        }\n\n        boolean containsZero = false;\n        int sum = 0;\n        int sign = 1;\n        for (int x : arr) {\n            sum += Math.abs(x);\n            sign *= x == 0 ? 0 : x / Math.abs(x);\n            if (x == 0) {\n                containsZero = true;\n            }\n        }\n\n        Integer result = sum * sign;\n\n        // Postcondition 1: Ensure that the result is an integer or null.\n        assert result instanceof Integer || result == null : \"The result must be an integer or null.\";\n\n        // Postcondition 2: Ensure that if the array contains 0, the result is 0.\n        if (containsZero) {\n            assert result.equals(0) : \"The result must be 0 if the array contains 0.\";\n        }\n\n        // Postcondition 3: Ensure that if the array is empty, the result is null.\n        if (arr.length == 0) {\n            assert result == null : \"The result must be null if the array is empty.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(prodSigns(new int[]{1, 2, 2, -4}));  // -9\n        System.out.println(prodSigns(new int[]{0, 1}));          // 0\n        System.out.println(prodSigns(new int[]{}));              // null\n    }\n}"}
{"id": "HumanEval/129", "code": "import java.util.*;\n\npublic class MinimumPath {\n\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        // Precondition 1\n        for (List<Integer> row : grid) {\n            if (!(row instanceof List<?>)) throw new IllegalArgumentException(\"Input 'grid' must be a list of lists.\");\n        }\n        int N = grid.size();\n        for (List<Integer> row : grid) {\n            if (row.size() != N) throw new IllegalArgumentException(\"Grid must be NxN in dimensions.\");\n        }\n\n        // Precondition 2\n        if (N < 2) throw new IllegalArgumentException(\"Grid size N must be at least 2.\");\n\n        // Precondition 3\n        if (k <= 0) throw new IllegalArgumentException(\"Input 'k' must be a positive integer.\");\n\n        // Precondition 4\n        Set<Integer> uniqueValues = new HashSet<>();\n        for (List<Integer> row : grid) {\n            for (int val : row) {\n                if (val < 1 || val > N * N || !uniqueValues.add(val)) {\n                    throw new IllegalArgumentException(\"All values in the grid must be unique and within the valid range.\");\n                }\n            }\n        }\n\n        // Find the starting position\n        int x = 0, y = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (grid.get(i).get(j) == 1) {\n                    x = i;\n                    y = j;\n                    break;\n                }\n            }\n        }\n\n        int mn = N * N;\n        if (x > 0) mn = Math.min(mn, grid.get(x - 1).get(y));\n        if (x < N - 1) mn = Math.min(mn, grid.get(x + 1).get(y));\n        if (y > 0) mn = Math.min(mn, grid.get(x).get(y - 1));\n        if (y < N - 1) mn = Math.min(mn, grid.get(x).get(y + 1));\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < k; i++) {\n            result.add((i % 2 == 0) ? 1 : mn);\n        }\n\n        // Postcondition 1\n        if (!(result instanceof List<?>)) throw new IllegalArgumentException(\"The result must be a list.\");\n\n        // Postcondition 2\n        if (result.size() != k) throw new IllegalArgumentException(\"The result list must have length k.\");\n\n        // Postcondition 3\n        for (int val : result) {\n            if (!uniqueValues.contains(val)) {\n                throw new IllegalArgumentException(\"The result list must contain valid values from the grid.\");\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        MinimumPath mp = new MinimumPath();\n\n        List<List<Integer>> grid1 = new ArrayList<>();\n        grid1.add(Arrays.asList(1, 2, 3));\n        grid1.add(Arrays.asList(4, 5, 6));\n        grid1.add(Arrays.asList(7, 8, 9));\n\n        List<Integer> result1 = mp.minPath(grid1, 3);\n        System.out.println(result1);\n\n        List<List<Integer>> grid2 = new ArrayList<>();\n        grid2.add(Arrays.asList(5, 9, 3));\n        grid2.add(Arrays.asList(4, 1, 6));\n        grid2.add(Arrays.asList(7, 8, 2));\n\n        List<Integer> result2 = mp.minPath(grid2, 1);\n        System.out.println(result2);\n    }\n}"}
{"id": "HumanEval/130", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Tribonacci {\n\n    public List<Integer> tri(int n) {\n        // Precondition 1: Ensure that 'n' is a non-negative integer.\n        assert n >= 0 : \"Input 'n' must be a non-negative integer.\";\n\n        List<Integer> ans = new ArrayList<>();\n        ans.add(1);\n        if (n >= 1) {\n            ans.add(3);\n        }\n\n        for (int i = 2; i <= n; i++) {\n            if (i % 2 == 0) {\n                ans.add(1 + i / 2);\n            } else {\n                ans.add(ans.get(ans.size() - 1) + ans.get(ans.size() - 2) + 1 + (i + 1) / 2);\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is a list.\n        assert ans instanceof List : \"The result must be a list.\";\n\n        // Postcondition 2: Ensure that the list has length n + 1.\n        assert ans.size() == n + 1 : \"The result list must have length n + 1.\";\n\n        // Postcondition 3: Ensure that all elements in the list are integers.\n        for (Integer x : ans) {\n            assert x instanceof Integer : \"All elements in the result list must be integers.\";\n        }\n\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        Tribonacci t = new Tribonacci();\n        System.out.println(t.tri(3));\n    }\n}"}
{"id": "HumanEval/131", "code": "public class Digits {\n    /**\n     * Given a positive integer n, return the product of the odd digits.\n     * Return 0 if all digits are even.\n     * For example:\n     * digits(1)  == 1\n     * digits(4)  == 0\n     * digits(235) == 15\n     */\n    public static int digits(int n) {\n        // Precondition: Ensure that 'n' is a positive integer.\n        assert n > 0 : \"Input 'n' must be a positive integer.\";\n\n        boolean hasOdd = false;\n        int prod = 1;\n        for (char ch : String.valueOf(n).toCharArray()) {\n            int digit = Character.getNumericValue(ch);\n            if (digit % 2 == 1) {\n                hasOdd = true;\n                prod *= digit;\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is a non-negative integer.\n        int result = hasOdd ? prod : 0;\n        assert result >= 0 : \"The result must be a non-negative integer.\";\n\n        // Postcondition 2: If the input has odd digits, ensure the result is not zero.\n        if (hasOdd) {\n            assert result != 0 : \"The result must not be zero if there are odd digits in the input.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(digits(1));    // Output: 1\n        System.out.println(digits(4));    // Output: 0\n        System.out.println(digits(235));  // Output: 15\n    }\n}"}
{"id": "HumanEval/132", "code": "public class NestedBrackets {\n\n    public static boolean isNested(String string) {\n        // Precondition 1: Ensure that 'string' is not null.\n        assert string != null : \"Input 'string' must not be null.\";\n\n        // Precondition 2: Ensure that 'string' is a string.\n        assert string instanceof String : \"Input 'string' must be a string.\";\n\n        // Precondition 3: Ensure that 'string' contains only square brackets.\n\n        for (int i = 0; i < string.length(); i++) {\n            if (string.charAt(i) == ']') {\n                continue;\n            }\n            int cnt = 0, max_nest = 0;\n            for (int j = i; j < string.length(); j++) {\n                if (string.charAt(j) == '[') {\n                    cnt++;\n                } else {\n                    cnt--;\n                }\n                max_nest = Math.max(max_nest, cnt);\n                if (cnt == 0) {\n                    if (max_nest >= 2)\n                        return true;\n                    break;\n                }\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is a boolean.\n        boolean result = false;\n        assert result == false : \"The result must be a boolean.\";\n      \n        return false;\n    }\n}"}
{"id": "HumanEval/133", "code": "import java.util.List;\nimport java.util.ArrayList;\nimport java.lang.Math;\n\npublic class Main {\n\n    public static int sumSquares(List<Number> lst) {\n        // Precondition 1: Ensure that 'lst' is not null.\n        assert lst != null : \"Input 'lst' must not be null.\";\n\n        // Precondition 2: Ensure that 'lst' is a list.\n        if (!(lst instanceof List<?>)) throw new AssertionError(\"Input 'lst' must be a list.\");\n\n        // Precondition 3: Ensure that all elements in 'lst' are numbers (integers or floats).\n        lst.forEach(x -> {\n            if (!(x instanceof Integer || x instanceof Float)) {\n                throw new AssertionError(\"All elements in 'lst' must be integers or floats.\");\n            }\n        });\n\n        int result = lst.stream().mapToInt(x -> (int) Math.ceil(x.doubleValue()) * Math.ceil(x.doubleValue())).sum();\n\n        // Postcondition 1: Ensure that the result is an integer.\n        if (!(result instanceof Integer)) throw new AssertionError(\"The result must be an integer.\");\n\n        // Postcondition 2: Ensure that the result is non-negative.\n        if (result < 0) throw new AssertionError(\"The result must be non-negative.\");\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<Number> list = new ArrayList<>();\n        list.add(1);\n        list.add(4.2);\n        list.add(0);\n        System.out.println(sumSquares(list));\n    }\n}"}
{"id": "HumanEval/134", "code": "public class LastCharCheck {\n    public static boolean checkIfLastCharIsALetter(String txt) {\n        // Precondition 1: Ensure that 'txt' is not null.\n        assert txt != null : \"Input 'txt' must not be null.\";\n\n        // Precondition 2: Ensure that 'txt' is a string.\n        assert txt instanceof String : \"Input 'txt' must be a string.\";\n\n        // Postcondition 1: Return false for empty string.\n        if (txt.length() == 0) {\n            return false;\n        }\n\n        // Postcondition 2: If the string has one character, check if it's a letter.\n        if (txt.length() == 1) {\n            boolean result = Character.isLetter(txt.charAt(0));\n            assert result == true || result == false : \"The result must be a boolean.\";\n            return result;\n        }\n\n        // Postcondition 3: Ensure that the last character is a letter and the second last character is a space.\n        boolean result = Character.isLetter(txt.charAt(txt.length() - 1)) && txt.charAt(txt.length() - 2) == ' ';\n        assert result == true || result == false : \"The result must be a boolean.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(checkIfLastCharIsALetter(\"apple pie\")); // false\n        System.out.println(checkIfLastCharIsALetter(\"apple pi e\")); // true\n        System.out.println(checkIfLastCharIsALetter(\"apple pi e \")); // false\n        System.out.println(checkIfLastCharIsALetter(\"\")); // false\n    }\n}"}
{"id": "HumanEval/135", "code": "public class Main {\n    public static int canArrange(int[] arr) {\n        // Precondition 1: Ensure that 'arr' is not null.\n        assert arr != null : \"Input 'arr' must not be null.\";\n\n        // Precondition 2: Ensure that 'arr' is an array.\n        assert arr instanceof int[] : \"Input 'arr' must be an array.\";\n\n        // Precondition 3: Ensure that all elements in 'arr' are integers.\n        for (int x : arr) {\n            assert x instanceof Integer : \"All elements in 'arr' must be integers.\";\n        }\n\n        // Precondition 4: Ensure that the array does not contain duplicate values.\n        Set<Integer> set = new HashSet<>();\n        for (int x : arr) {\n            assert set.add(x) : \"Input 'arr' must not contain duplicate values.\";\n        }\n\n        int result = -1;\n        for (int i = arr.length - 1; i > 0; i--) {\n            if (!(arr[i] >= arr[i - 1])) {\n                result = i;\n                break;\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is an integer.\n        assert result instanceof Integer : \"The result must be an integer.\";\n\n        // Postcondition 2: Ensure that the result is a valid index or -1.\n        assert result == -1 || (result >= 0 && result < arr.length) : \"The result must be -1 or a valid index within the range of 'arr'.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] arr1 = {1, 2, 4, 3, 5};\n        System.out.println(\"Result for arr1: \" + canArrange(arr1)); // Output: 3\n\n        int[] arr2 = {1, 2, 3};\n        System.out.println(\"Result for arr2: \" + canArrange(arr2)); // Output: -1\n    }\n}"}
{"id": "HumanEval/136", "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Collections;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(largestSmallestIntegers(List.of(2, 4, 1, 3, 5, 7))); // (null, 1)\n        System.out.println(largestSmallestIntegers(List.of())); // (null, null)\n        System.out.println(largestSmallestIntegers(List.of(0))); // (null, null)\n    }\n\n    public static List<Integer> largestSmallestIntegers(List<Integer> lst) {\n        if (lst == null) {\n            throw new IllegalArgumentException(\"Input 'lst' must not be null.\");\n        }\n\n        if (lst.isEmpty()) {\n            return List.of(null, null);\n        }\n\n        List<Integer> neg = new ArrayList<>();\n        List<Integer> pos = new ArrayList<>();\n        \n        for (int num : lst) {\n            if (num < 0) {\n                neg.add(num);\n            } else if (num > 0) {\n                pos.add(num);\n            }\n        }\n\n        Integer maxNeg = neg.isEmpty() ? null : Collections.max(neg);\n        Integer minPos = pos.isEmpty() ? null : Collections.min(pos);\n\n        if (maxNeg == null && minPos == null) {\n            return List.of(null, null);\n        } else {\n            return List.of(maxNeg, minPos);\n        }\n    }\n}"}
{"id": "HumanEval/137", "code": "public class NumberComparator {\n\n    public static Object compareOne(Object a, Object b) {\n        if (!(a instanceof Integer || a instanceof Double || a instanceof String)) {\n            throw new IllegalArgumentException(\"Input 'a' must be an integer, double, or string.\");\n        }\n        if (!(b instanceof Integer || b instanceof Double || b instanceof String)) {\n            throw new IllegalArgumentException(\"Input 'b' must be an integer, double, or string.\");\n        }\n\n        double num_a = Double.parseDouble(String.valueOf(a).replace(\",\", \".\"));\n        double num_b = Double.parseDouble(String.valueOf(b).replace(\",\", \".\"));\n\n        if (num_a == num_b) {\n            return null;\n        } else {\n            return num_a > num_b ? a : b;\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(compareOne(1, 2.5));    // 2.5\n        System.out.println(compareOne(1, \"2,3\"));  // \"2,3\"\n        System.out.println(compareOne(\"5,1\", \"6\")); // \"6\"\n        System.out.println(compareOne(\"1\", 1));    // null\n    }\n}"}
{"id": "HumanEval/138", "code": "public class Main {\n    public static boolean isEqualToSumEven(int n) {\n        // Precondition 1: Ensure that 'n' is a positive integer.\n        if (!(n > 0 && n % 1 == 0)) {\n            throw new IllegalArgumentException(\"Input 'n' must be a positive integer.\");\n        }\n\n        boolean result = n >= 8 && n % 2 == 0;\n\n        // Postcondition 1: Ensure that the result is a boolean.\n        if (!(result == true || result == false)) {\n            throw new AssertionError(\"The result must be a boolean.\");\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isEqualToSumEven(4)); // false\n        System.out.println(isEqualToSumEven(6)); // false\n        System.out.println(isEqualToSumEven(8)); // true\n    }\n}"}
{"id": "HumanEval/139", "code": "public class SpecialFactorial {\n\n    public static int specialFactorial(int n) {\n        // Precondition 1: Ensure that 'n' is a positive integer.\n        if (!(n > 0)) {\n            throw new IllegalArgumentException(\"Input 'n' must be a positive integer.\");\n        }\n\n        int fac = 1;\n        int ans = 1;\n        for (int i = 2; i <= n; i++) {\n            fac *= i;\n            ans *= fac;\n        }\n\n        // Postcondition 1: Ensure that the result is a non-negative integer.\n        if (!(ans >= 0)) {\n            throw new IllegalStateException(\"The result must be a non-negative integer.\");\n        }\n\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(specialFactorial(4)); // Output: 288\n    }\n}"}
{"id": "HumanEval/140", "code": "public class TextFixer {\n\n    public static String fixSpaces(String text) {\n        // Precondition 1: Ensure that 'text' is a string.\n        if (!(text instanceof String)) {\n            throw new IllegalArgumentException(\"Input 'text' must be a string.\");\n        }\n\n        String result = text;\n        for (int i = text.length(); i > 2; i--) {\n            result = result.replaceAll(\" \".repeat(i), \"-\");\n        }\n        result = result.replace(\" \", \"_\");\n\n        // Postcondition 1: Ensure that the result is a string.\n        if (!(result instanceof String)) {\n            throw new IllegalStateException(\"The result must be a string.\");\n        }\n\n        // Postcondition 2: Ensure that there are no sequences of three or more spaces in the result.\n        if (result.contains(\"   \")) {\n            throw new IllegalStateException(\"The result must not contain three or more consecutive spaces.\");\n        }\n\n        // Postcondition 3: Ensure that all single spaces are replaced by underscores.\n        if (result.contains(\" \")) {\n            throw new IllegalStateException(\"The result must not contain single spaces.\");\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(fixSpaces(\"Example\")); // Output: \"Example\"\n        System.out.println(fixSpaces(\"Example 1\")); // Output: \"Example_1\"\n        System.out.println(fixSpaces(\" Example 2\")); // Output: \"_Example_2\"\n        System.out.println(fixSpaces(\" Example   3\")); // Output: \"_Example-3\"\n    }\n}"}
{"id": "HumanEval/141", "code": "public class FileNameCheck {\n    public static String file_name_check(String file_name) {\n        // Precondition 1: Ensure that 'file_name' is a string.\n        assert file_name instanceof String : \"Input 'file_name' must be a string.\";\n\n        // Check for more than three digits in the file name\n        if (file_name.chars().filter(Character::isDigit).count() > 3) {\n            return \"No\";\n        }\n\n        // Split the file name by dot\n        String[] f_list = file_name.split(\"\\\\.\");\n\n        // Check for exactly one dot in the file name\n        if (f_list.length != 2) {\n            return \"No\";\n        }\n\n        // Check if the substring before the dot is not empty and starts with a letter\n        if (f_list[0].length() == 0 || !Character.isLetter(f_list[0].charAt(0))) {\n            return \"No\";\n        }\n\n        // Check if the extension is valid\n        if (!f_list[1].equals(\"txt\") && !f_list[1].equals(\"exe\") && !f_list[1].equals(\"dll\")) {\n            return \"No\";\n        }\n\n        String result = \"Yes\";\n\n        // Postcondition 1: Ensure that the result is a string.\n        assert result instanceof String : \"The result must be a string.\";\n\n        // Postcondition 2: Ensure that the result is either 'Yes' or 'No'.\n        assert result.equals(\"Yes\") || result.equals(\"No\") : \"The result must be either 'Yes' or 'No'.\";\n\n        return result;\n    }\n}"}
{"id": "HumanEval/142", "code": "public class Main {\n    \n    public static int sumSquares(int[] lst) {\n        // Precondition 1: Ensure that 'lst' is an array.\n        assert lst != null && lst.length > 0 : \"Input 'lst' must not be empty.\";\n\n        int ans = 0;\n        for (int i = 0; i < lst.length; i++) {\n            int num = lst[i];\n            if (i % 3 == 0) {\n                ans += Math.pow(num, 2);\n            } else if (i % 4 == 0) {\n                ans += Math.pow(num, 3);\n            } else {\n                ans += num;\n            }\n        }\n\n        // Postcondition 1: Ensure that the result is an integer.\n        assert ans != null : \"The result must not be null.\";\n        \n        return ans;\n    }\n\n    public static void main(String[] args) {\n        int[] list = {1, 2, 3};\n        System.out.println(sumSquares(list)); // Output: 6\n    }\n}"}
{"id": "HumanEval/143", "code": "public class WordProcessor {\n    public static String wordsInSentence(String sentence) {\n        // Precondition 1: Ensure that 'sentence' is a string.\n        if (!(sentence instanceof String)) {\n            throw new IllegalArgumentException(\"Input 'sentence' must be a string.\");\n        }\n\n        // Precondition 2: Ensure that the length of 'sentence' is within the valid range.\n        if (sentence.length() < 1 || sentence.length() > 100) {\n            throw new IllegalArgumentException(\"Length of 'sentence' must be between 1 and 100.\");\n        }\n\n        // Precondition 3: Ensure that 'sentence' contains only letters and spaces.\n        if (!sentence.matches(\"^[a-zA-Z ]+$\")) {\n            throw new IllegalArgumentException(\"Sentence must contain only letters and spaces.\");\n        }\n\n        // Check if a number is prime\n        boolean isPrime(int a) {\n            if (a < 2) return false;\n            for (int x = 2; x <= Math.floor(Math.sqrt(a)); x++) {\n                if (a % x == 0) return false;\n            }\n            return true;\n        }\n\n        String[] words = sentence.split(\" \");\n        StringBuilder result = new StringBuilder();\n        \n        for(String word : words) {\n            if (isPrime(word.length())) {\n                result.append(word).append(\" \");\n            }\n        }\n        \n        // Postcondition 1: Ensure that the result is a string.\n        if (!(result instanceof String)) {\n            throw new IllegalArgumentException(\"The result must be a string.\");\n        }\n\n        // Postcondition 2: Ensure that the result only contains words from the original sentence.\n        String[] resultWords = result.toString().split(\" \");\n        for(String word : resultWords) {\n            if (!sentence.contains(word)) {\n                throw new IllegalArgumentException(\"The result must only contain words from the original sentence.\");\n            }\n        }\n\n        // Postcondition 3: Ensure that the result preserves the order of the original sentence.\n        String[] filteredWords = result.toString().split(\" \");\n        for (int i = 0; i < filteredWords.length; i++) {\n            if (!filteredWords[i].equals(words[i])) {\n                throw new IllegalArgumentException(\"The order of words in the result must be the same as in the original sentence.\");\n            }\n        }\n\n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(wordsInSentence(\"This is a test\")); // Output: \"is\"\n        System.out.println(wordsInSentence(\"lets go for swimming\")); // Output: \"go for\"\n    }\n}"}
{"id": "HumanEval/144", "code": "public class SimplifyFunction {\n    public static boolean simplify(String x, String n) {\n        String[] xArray = x.split(\"/\");\n        int x1 = Integer.parseInt(xArray[0]);\n        int x2 = Integer.parseInt(xArray[1]);\n        \n        String[] nArray = n.split(\"/\");\n        int n1 = Integer.parseInt(nArray[0]);\n        int n2 = Integer.parseInt(nArray[1]);\n\n        return (x1 * n1) % (x2 * n2) == 0;\n    }\n\n    public static void main(String[] args) {\n        assert simplify(\"1/5\", \"5/1\") == true;\n        assert simplify(\"1/6\", \"2/1\") == false;\n        assert simplify(\"7/10\", \"10/2\") == false;\n    }\n}"}
{"id": "HumanEval/145", "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class OrderByPoints {\n\n    public List<Integer> orderByPoints(List<Integer> nums) {\n        // Precondition 1: Ensure that 'nums' is a list.\n        if (!(nums instanceof List)) {\n            throw new IllegalArgumentException(\"Input 'nums' must be a list.\");\n        }\n\n        // Precondition 2: Ensure that all elements in 'nums' are integers.\n        if (!(nums.stream().allMatch(x -> x instanceof Integer))) {\n            throw new IllegalArgumentException(\"All elements in 'nums' must be integers.\");\n        }\n\n        List<Integer> result = new ArrayList<>(nums);\n\n        Collections.sort(result, (a, b) -> {\n            int weightA = calculateWeight(a);\n            int weightB = calculateWeight(b);\n            return Integer.compare(weightA, weightB) != 0 ? Integer.compare(weightA, weightB) : Integer.compare(nums.indexOf(a), nums.indexOf(b));\n        });\n\n        // Postcondition 1: Ensure that the result is a list.\n        if (!(result instanceof List)) {\n            throw new IllegalStateException(\"The result must be a list.\");\n        }\n\n        // Postcondition 2: Ensure that the result has the same length as the input list.\n        if (result.size() != nums.size()) {\n            throw new IllegalStateException(\"The result list must have the same length as the input list.\");\n        }\n\n        // Postcondition 3: Ensure that the result list contains the same elements as the input list.\n        List<Integer> inputCopy = new ArrayList<>(nums);\n        Collections.sort(inputCopy);\n        Collections.sort(result);\n        if (!result.equals(inputCopy)) {\n            throw new IllegalStateException(\"The result list must contain the same elements as the input list.\");\n        }\n\n        return result;\n    }\n\n    private int calculateWeight(int x) {\n        char[] xArr = String.valueOf(x).toCharArray();\n        int sum = 0;\n        for (char c : xArr) {\n            if (c != '-') {\n                sum += Character.getNumericValue(c);\n            }\n        }\n        return sum;\n    }\n}"}
{"id": "HumanEval/146", "code": "public class SpecialFilter {\n    public static int specialFilter(int[] nums) {\n        // Preconditions\n        assert nums != null : \"Input 'nums' must not be null.\";\n\n        int ans = 0;\n        String[] odd = {\"1\", \"3\", \"5\", \"7\", \"9\"};\n        for (int num : nums) {\n            String numStr = String.valueOf(Math.abs(num));\n            if (num > 10 && contains(odd, String.valueOf(numStr.charAt(0)) && contains(odd, String.valueOf(numStr.charAt(numStr.length() - 1)))) {\n                ans++;\n            }\n        }\n\n        // Postconditions\n        assert ans >= 0 : \"The result must be non-negative.\";\n\n        return ans;\n    }\n\n    public static boolean contains(String[] arr, String target) {\n        for (String s : arr) {\n            if (s.equals(target)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"}
{"id": "HumanEval/147", "code": "public class MaxTriples {\n    public static int getMaxTriples(int n) {\n        // Precondition 1: Ensure that 'n' is a positive integer.\n        assert n > 0 : \"Input 'n' must be a positive integer.\";\n\n        // Handle cases where n is too small to form any triples.\n        if (n <= 2) {\n            return 0;\n        }\n\n        // Calculating counts of elements where (a[i] % 3 == 1) and (a[i] % 3 == 0)\n        int oneCnt = 1 + (n - 2) / 3 * 2 + (n - 2) % 3;\n        int zeroCnt = n - oneCnt;\n\n        // Calculating the number of valid triples\n        int result = oneCnt * (oneCnt - 1) * (oneCnt - 2) / 6 + zeroCnt * (zeroCnt - 1) * (zeroCnt - 2) / 6;\n\n        // Postcondition 1: Ensure that the result is a non-negative integer.\n        assert result >= 0 : \"The result must be a non-negative integer.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        System.out.println(getMaxTriples(n)); // Output: 1\n    }\n}"}
{"id": "HumanEval/148", "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class PlanetOrbits {\n\n    public static List<String> bf(String planet1, String planet2) {\n        List<String> planets = new ArrayList<>(Arrays.asList(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"));\n\n        // Precondition 1: Ensure that 'planet1' and 'planet2' are strings.\n        assert planet1 != null && planet2 != null : \"Input 'planet1' and 'planet2' must not be null.\";\n\n        // Precondition 2: Ensure that 'planet1' and 'planet2' are valid planet names.\n        assert planets.contains(planet1) : planet1 + \" is not a valid planet name.\";\n        assert planets.contains(planet2) : planet2 + \" is not a valid planet name.\";\n\n        // Determine the indices of the planets\n        int i1 = planets.indexOf(planet1);\n        int i2 = planets.indexOf(planet2);\n\n        // Ensure the indices are in ascending order\n        if (i1 > i2) {\n            int temp = i1;\n            i1 = i2;\n            i2 = temp;\n        }\n\n        // Determine the planets between the two given planets\n        List<String> result = new ArrayList<>(planets.subList(i1 + 1, i2));\n\n        // Postcondition 1: Ensure that the result is a tuple (represented as a list here).\n        assert result != null : \"The result must not be null.\";\n\n        // Postcondition 2: Ensure that the result contains the correct planets.\n        if (i2 - i1 > 1) {\n            for (String planet : result) {\n                assert planets.contains(planet) : \"The result must contain valid planet names.\";\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(bf(\"Jupiter\", \"Neptune\"));  // Output: [Saturn, Uranus]\n        System.out.println(bf(\"Earth\", \"Mercury\"));   // Output: [Venus]\n        System.out.println(bf(\"Mercury\", \"Uranus\"));  // Output: [Venus, Earth, Mars, Jupiter, Saturn]\n    }\n}"}
{"id": "HumanEval/149", "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class SortedListSum {\n\n    public static List<String> sortedListSum(List<String> lst) {\n        // Precondition 1\n        if (!(lst instanceof List)) {\n            throw new IllegalArgumentException(\"Input 'lst' must be a list.\");\n        }\n\n        // Precondition 2\n        for (String s : lst) {\n            if (!(s instanceof String)) {\n                throw new IllegalArgumentException(\"All elements in 'lst' must be strings.\");\n            }\n        }\n\n        // Filter out strings with odd lengths and sort\n        lst.removeIf(s -> s.length() % 2 != 0);\n\n        Collections.sort(lst, (s, t) -> {\n            return s.length() != t.length() ? s.length() - t.length() : s.compareTo(t);\n        });\n\n        // Postcondition 1\n        if (!(lst instanceof List)) {\n            throw new IllegalArgumentException(\"The result must be a list.\");\n        }\n\n        // Postcondition 2\n        for (String s : lst) {\n            if (s.length() % 2 != 0) {\n                throw new IllegalArgumentException(\"All elements in the result must have even lengths.\");\n            }\n        }\n\n        // Postcondition 3\n        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i - 1).length() > lst.get(i).length()) {\n                throw new IllegalArgumentException(\"The list must be sorted by length.\");\n            }\n            if (lst.get(i - 1).length() == lst.get(i).length() && lst.get(i - 1).compareTo(lst.get(i)) > 0) {\n                throw new IllegalArgumentException(\"The list must be sorted alphabetically for words of the same length.\");\n            }\n        }\n\n        return lst;\n    }\n}"}
{"id": "HumanEval/150", "code": "public class XYProgram {\n\n    public static int xOrY(int n, int x, int y) {\n        // Precondition 1: Ensure that 'n', 'x', and 'y' are integers.\n        if (!(n instanceof Integer))\n            throw new IllegalArgumentException(\"Input 'n' must be an integer.\");\n        if (!(x instanceof Integer))\n            throw new IllegalArgumentException(\"Input 'x' must be an integer.\");\n        if (!(y instanceof Integer))\n            throw new IllegalArgumentException(\"Input 'y' must be an integer.\");\n\n        boolean isPrime = isPrime(n);\n        int result = isPrime ? x : y;\n\n        // Postcondition 1: Ensure that the result is an integer.\n        if (!(result instanceof Integer))\n            throw new IllegalArgumentException(\"The result must be an integer.\");\n\n        // Postcondition 2: Ensure that the result is either 'x' or 'y'.\n        if (result != x && result != y)\n            throw new IllegalArgumentException(\"The result must be either 'x' or 'y'.\");\n\n        return result;\n    }\n\n    private static boolean isPrime(int a) {\n        if (a < 2)\n            return false;\n        for (int i = 2; i <= Math.sqrt(a); i++) {\n            if (a % i == 0)\n                return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        // Examples\n        System.out.println(xOrY(7, 34, 12));  // Should print 34\n        System.out.println(xOrY(15, 8, 5));    // Should print 5\n    }\n}"}
{"id": "HumanEval/151", "code": "public class DoubleTheDifference {\n\n    public static int doubleTheDifference(Object[] lst) {\n        // Precondition 1: Ensure that 'lst' is an array\n        if (!(lst instanceof Object[]))\n            throw new IllegalArgumentException(\"Input 'lst' must be an array.\");\n\n        // Precondition 2: Ensure that all elements in 'lst' are either integers or floats.\n        for (Object obj : lst) {\n            if (!(obj instanceof Integer) && !(obj instanceof Double))\n                throw new IllegalArgumentException(\"All elements in 'lst' must be integers or floats.\");\n        }\n\n        int ans = 0;\n        for (Object obj : lst) {\n            if (obj instanceof Integer) {\n                int num = (int) obj;\n                // Postcondition 1: Ensure that 'num' is a non-negative integer if considered.\n                if (num % 2 == 1 && num > 0) {\n                    ans += num * num;\n                }\n            }\n        }\n\n        // Postcondition 2: Ensure that the result is a non-negative integer.\n        if (ans < 0)\n            throw new IllegalArgumentException(\"The result must be a non-negative integer.\");\n\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        Object[] input1 = {1, 3, 2, 0};\n        System.out.println(doubleTheDifference(input1)); // Output: 10\n\n        Object[] input2 = {-1, -2, 0};\n        System.out.println(doubleTheDifference(input2)); // Output: 0\n\n        Object[] input3 = {9, -2};\n        System.out.println(doubleTheDifference(input3)); // Output: 81\n\n        Object[] input4 = {0};\n        System.out.println(doubleTheDifference(input4)); // Output: 0\n    }\n}"}
{"id": "HumanEval/152", "code": "import java.util.Arrays;\n\npublic class MatchResults {\n\n    public static int[] compare(int[] game, int[] guess) {\n        // Precondition 1\n        // assert game instanceof int[] : \"Input 'game' must be an array of integers.\";\n        // assert guess instanceof int[] : \"Input 'guess' must be an array of integers.\";\n\n        // Precondition 2\n        assert game.length == guess.length : \"Input arrays 'game' and 'guess' must have the same length.\";\n\n        // Precondition 3\n        for (int score : game) {\n            assert score instanceof Integer : \"All elements in 'game' must be integers.\";\n        }\n        for (int predicted : guess) {\n            assert predicted instanceof Integer : \"All elements in 'guess' must be integers.\";\n        }\n\n        int[] result = new int[game.length];\n        for (int i = 0; i < game.length; i++) {\n            result[i] = Math.abs(game[i] - guess[i]);\n        }\n\n        // Postcondition 1\n        // assert result instanceof int[] : \"The result must be an array of integers.\";\n\n        // Postcondition 2\n        assert result.length == game.length : \"The result array must have the same length as the input arrays.\";\n\n        // Postcondition 3\n        for (int outcome : result) {\n            assert outcome instanceof Integer && outcome >= 0 : \"All elements in the result array must be non-negative integers.\";\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test the function\n        int[] testResult1 = compare(new int[]{1, 2, 3, 4, 5, 1}, new int[]{1, 2, 3, 4, 2, -2});\n        System.out.println(Arrays.toString(testResult1)); // Expected output: [0, 0, 0, 0, 3, 3]\n\n        int[] testResult2 = compare(new int[]{0, 5, 0, 0, 0, 4}, new int[]{4, 1, 1, 0, 0, -2});\n        System.out.println(Arrays.toString(testResult2)); // Expected output: [4, 4, 1, 0, 0, 6]\n    }\n}"}
{"id": "HumanEval/153", "code": "public class StrongestExtension {\n\n    public static String strongestExtension(String className, String[] extensions) {\n        // Precondition 1\n        if (!(className instanceof String)) {\n            throw new IllegalArgumentException(\"Input 'className' must be a string.\");\n        }\n\n        // Precondition 2\n        if (!(extensions instanceof String[])) {\n            throw new IllegalArgumentException(\"Input 'extensions' must be an array of strings.\");\n        }\n\n        for (String extension : extensions) {\n            if (!(extension instanceof String)) {\n                throw new IllegalArgumentException(\"All elements in 'extensions' must be strings.\");\n            }\n        }\n\n        int strength(String s) {\n            int CAP = 0, SM = 0;\n            for (char ch : s.toCharArray()) {\n                if (Character.isUpperCase(ch)) {\n                    CAP++;\n                } else if (Character.isLowerCase(ch)) {\n                    SM++;\n                }\n            }\n            return CAP - SM;\n        }\n\n        int maxStrength = Arrays.stream(extensions).mapToInt(StrongestExtension::strength).max().getAsInt();\n\n        // Postcondition 1\n        if (!(maxStrength instanceof Integer)) {\n            throw new IllegalArgumentException(\"The maximum strength must be an integer.\");\n        }\n\n        for (String e : extensions) {\n            if (strength(e) == maxStrength) {\n                // Postcondition 2\n                String result = className + \".\" + e;\n                if (!(result instanceof String) || !result.startsWith(className + \".\")) {\n                    throw new IllegalArgumentException(\"The result must be a string in the format 'ClassName.ExtensionName'.\");\n                }\n                return result;\n            }\n        }\n        return \"\";\n    }\n}"}
{"id": "HumanEval/154", "code": "public class CycpatternCheck {\n\n    public static boolean cycpatternCheck(String a, String b) {\n        assert a instanceof String : \"Input 'a' must be a string.\";\n        assert b instanceof String : \"Input 'b' must be a string.\";\n\n        // Check if 'b' or any of its rotations is a substring of 'a'\n        if (a.equals(b)) {\n            return true;\n        }\n        if (b.equals(\"\")) {\n            return true;\n        }\n        for (int i = 0; i < b.length(); i++) {\n            if (a.contains(b.substring(i) + b.substring(0, i))) {\n                return true;\n            }\n        }\n        boolean result = false;\n\n        // Postcondition 1: Ensure that the result is a boolean.\n        assert result instanceof Boolean : \"The result must be a boolean.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(cycpatternCheck(\"abcd\", \"abd\"));\n        System.out.println(cycpatternCheck(\"hello\", \"ell\"));\n        System.out.println(cycpatternCheck(\"whassup\", \"psus\"));\n        System.out.println(cycpatternCheck(\"abab\", \"baa\"));\n        System.out.println(cycpatternCheck(\"efef\", \"eeff\"));\n        System.out.println(cycpatternCheck(\"himenss\", \"simen\"));\n    }\n}"}
{"id": "HumanEval/155", "code": "public class EvenOddCount {\n    public static int[] evenOddCount(int num) {\n        assert num instanceof Integer : \"Input 'num' must be an integer.\";\n\n        int even = 0, odd = 0;\n        for (char ch : Math.abs(num).toString().toCharArray()) {\n            if (\"02468\".contains(String.valueOf(ch))) {\n                even++;\n            } else if (\"13579\".contains(String.valueOf(ch))) {\n                odd++;\n            }\n        }\n\n        assert new int[] {even, odd} instanceof int[] : \"The result must be an array.\";\n        assert even >= 0 : \"The number of even digits must be a non-negative integer.\";\n        assert odd >= 0 : \"The number of odd digits must be a non-negative integer.\";\n\n        return new int[] {even, odd};\n    }\n}"}
{"id": "HumanEval/156", "code": "public class MiniRomanConverter {\n\n    public static String intToMiniRoman(int number) {\n        // Precondition 1: Ensure that 'number' is an integer.\n        if (!(number instanceof Integer)) {\n            throw new IllegalArgumentException(\"Input 'number' must be an integer.\");\n        }\n\n        // Precondition 2: Ensure that 'number' is within the valid range.\n        if (number < 1 || number > 1000) {\n            throw new IllegalArgumentException(\"Input 'number' must be between 1 and 1000, inclusive.\");\n        }\n\n        String[] m = {\"\", \"m\"};\n        String[] c = {\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"};\n        String[] x = {\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"};\n        String[] i = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"};\n        \n        String thousands = m[number / 1000];\n        String hundreds = c[(number % 1000) / 100];\n        String tens = x[(number % 100) / 10];\n        String ones = i[number % 10];\n        \n        String result = thousands + hundreds + tens + ones;\n\n        // Postcondition 1: Ensure that the result is a string.\n        if (!(result instanceof String)) {\n            throw new IllegalStateException(\"The result must be a string.\");\n        }\n\n        // Postcondition 2: Ensure that the result is in lowercase.\n        if (!result.equals(result.toLowerCase())) {\n            throw new IllegalStateException(\"The result must be in lowercase.\");\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        assert intToMiniRoman(19).equals(\"xix\");\n        assert intToMiniRoman(152).equals(\"clii\");\n        assert intToMiniRoman(426).equals(\"cdxxvi\");\n    }\n}"}
{"id": "HumanEval/157", "code": "public class Triangle {\n\n    public static boolean rightAngleTriangle(double a, double b, double c) {\n        // Precondition 1\n        if (a <= 0 || b <= 0 || c <= 0) {\n            throw new IllegalArgumentException(\"'a', 'b', and 'c' must be positive numbers.\");\n        }\n\n        // Check if the sides form a right-angled triangle\n        boolean result = a * a + b * b == c * c || a * a + c * c == b * b || b * b + c * c == a * a;\n\n        // Postcondition 1\n        if (result != true && result != false) {\n            throw new IllegalStateException(\"The result must be a boolean value.\");\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        assert rightAngleTriangle(3, 4, 5) == true;\n        assert rightAngleTriangle(1, 2, 3) == false;\n    }\n}"}
{"id": "HumanEval/158", "code": "public class Main {\n\n    public static String findMax(String[] words) {\n        // Precondition 1\n        assert words != null && words.length > 0 : \"Input 'words' must be a non-empty array.\";\n\n        int maxCharCount = 0;\n        String result = \"\";\n        \n        for (String word : words) {\n            int charCount = (int) word.chars().distinct().count();\n            if (charCount > maxCharCount || (charCount == maxCharCount && word.compareTo(result) < 0)) {\n                maxCharCount = charCount;\n                result = word;\n            }\n        }\n        \n        // Postcondition 1\n        assert result != null : \"The result must not be null.\";\n        \n        // Postcondition 2\n        boolean containsResult = false;\n        for (String word : words) {\n            if (word.equals(result)) {\n                containsResult = true;\n                break;\n            }\n        }\n        assert containsResult : \"The result must be one of the words in the input array.\";\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        String[] words1 = {\"name\", \"of\", \"string\"};\n        System.out.println(findMax(words1)); // Output: string\n\n        String[] words2 = {\"name\", \"enam\", \"game\"};\n        System.out.println(findMax(words2)); // Output: enam\n\n        String[] words3 = {\"aaaaaaa\", \"bb\", \"cc\"};\n        System.out.println(findMax(words3)); // Output: aaaaaaa\n    }\n}"}
{"id": "HumanEval/159", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Rabbit {\n    public static int[] eat(int number, int need, int remaining) {\n        // Precondition 1\n        assert number >= 0 && need >= 0 && remaining >= 0 : \"Inputs must be non-negative integers.\";\n\n        // Precondition 2\n        assert number <= 1000 && need <= 1000 && remaining <= 1000 : \"Inputs must be between 0 and 1000, inclusive.\";\n\n        List<Integer> result = new ArrayList<>();\n        \n        if (need <= remaining) {\n            result.add(number + need);\n            result.add(remaining - need);\n        } else {\n            result.add(number + remaining);\n            result.add(0);\n        }\n\n        // Postcondition 1\n        assert result.size() == 2 : \"The result list must contain exactly two elements.\";\n\n        // Postcondition 2\n        assert result.get(0) == number + Math.min(need, remaining) : \"The first element must be the total number of eaten carrots.\";\n\n        // Postcondition 3\n        assert result.get(1) == Math.max(0, remaining - need) : \"The second element must be the number of carrots left after the meal.\";\n\n        return result.stream().mapToInt(i -> i).toArray();\n    }\n}"}
{"id": "HumanEval/160", "code": "import java.util.List;\nimport java.util.Arrays;\n\npublic class Algebra {\n\n    public static int doAlgebra(List<String> operator, List<Integer> operand) {\n        // Precondition 1\n        assert operator instanceof List : \"Input 'operator' must be a list.\";\n        assert operand instanceof List : \"Input 'operand' must be a list.\";\n\n        // Precondition 2\n        List<String> validOperators = Arrays.asList(\"+\", \"-\", \"*\", \"//\", \"**\");\n        for (String op : operator) {\n            assert validOperators.contains(op) : \"All elements in 'operator' must be valid algebraic operators.\";\n        }\n        for (Integer num : operand) {\n            assert num >= 0 : \"All elements in 'operand' must be non-negative integers.\";\n        }\n\n        // Precondition 3\n        assert operator.size() == operand.size() - 1 : \"The length of 'operator' must be equal to the length of 'operand' minus one.\";\n\n        // Precondition 4\n        assert operand.size() >= 2 : \"'operand' must contain at least two integers.\";\n\n        // Build the algebraic expression as a string\n        StringBuilder exp = new StringBuilder();\n        for (int i = 0; i < operator.size(); i++) {\n            exp.append(operand.get(i)).append(operator.get(i));\n        }\n        exp.append(operand.get(operand.size() - 1));\n\n        // Evaluate the expression\n        int result = evaluateExpression(exp.toString());\n\n        // Postcondition 1\n        assert result == (int)result : \"The result must be an integer.\";\n\n        return result;\n    }\n\n    private static int evaluateExpression(String exp) {\n        return (int) new Object() { int eval() { return (int) (Object) Math.round(new java.util.Scanner(exp).nextInt()); } }.eval();\n    }\n}"}
{"id": "HumanEval/161", "code": "public class Solution {\n    public static String solve(String s) {\n        // Precondition 1: Ensure that 's' is a string.\n        if (!(s instanceof String)) {\n            throw new IllegalArgumentException(\"Input 's' must be a string.\");\n        }\n\n        StringBuffer ans = new StringBuffer();\n        boolean hasLetter = false;\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetter(ch)) {\n                hasLetter = true;\n                ans.append(Character.isUpperCase(ch) ? Character.toLowerCase(ch) : Character.toUpperCase(ch));\n            } else {\n                ans.append(ch);\n            }\n        }\n\n        String result = hasLetter ? ans.toString() : new StringBuilder(s).reverse().toString();\n\n        // Postcondition 1: Ensure that the result is a string.\n        if (!(result instanceof String)) {\n            throw new IllegalArgumentException(\"The result must be a string.\");\n        }\n\n        // Postcondition 2: If the original string 's' contains letters, ensure that all letters have their case swapped in the result.\n        if (s.chars().anyMatch(Character::isLetter)) {\n            for (int i = 0; i < s.length(); i++) {\n                char ch = s.charAt(i);\n                if (Character.isLetter(ch)) {\n                    if ((Character.isUpperCase(ch) ? Character.toLowerCase(ch) : Character.toUpperCase(ch)) != result.charAt(i)) {\n                        throw new AssertionError(\"All letters must have their case swapped.\");\n                    }\n                } else {\n                    if (ch != result.charAt(i)) {\n                        throw new AssertionError(\"All letters must have their case swapped.\");\n                    }\n                }\n            }\n        }\n\n        // Postcondition 3: If the original string 's' contains no letters, ensure the result is the reversed string.\n        if (s.chars().noneMatch(Character::isLetter)) {\n            if (!result.equals(new StringBuilder(s).reverse().toString())) {\n                throw new AssertionError(\"If the string contains no letters, it should be reversed.\");\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(solve(\"1234\"));  // Output: \"4321\"\n        System.out.println(solve(\"ab\"));    // Output: \"AB\"\n        System.out.println(solve(\"#a@C\"));  // Output: \"#A@c\"\n    }\n}"}
{"id": "HumanEval/162", "code": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class MD5Converter {\n    public static String stringToMD5(String text) {\n        // Precondition 1: Ensure that 'text' is a string.\n        if (!(text instanceof String)) {\n            throw new IllegalArgumentException(\"Input 'text' must be a string.\");\n        }\n\n        if (text.equals(\"\")) {\n            // Postcondition 1: Ensure that the result is None when the input is an empty string.\n            if (text.equals(\"\")) {\n                return null;\n            }\n        }\n\n        String result = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] messageDigest = md.digest(text.getBytes());\n            BigInteger no = new BigInteger(1, messageDigest);\n            result = no.toString(16);\n            while (result.length() < 32) {\n                result = \"0\" + result;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n\n        // Postcondition 2: Ensure that the result is a string.\n        if (!(result instanceof String)) {\n            throw new IllegalArgumentException(\"The result must be a string.\");\n        }\n\n        // Postcondition 3: Ensure that the result is a 32-character hexadecimal string.\n        if (result.length() != 32 || !result.matches(\"[0-9a-f]+\")) {\n            throw new IllegalArgumentException(\"The result must be a 32-character hexadecimal string.\");\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        assert stringToMD5(\"Hello world\").equals(\"3e25960a79dbc69b674cd4ec67a72c62\");\n    }\n}"}
{"id": "HumanEval/163", "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class IntegerGenerator {\n    public static List<Integer> generateIntegers(int a, int b) {\n        // Precondition 1\n        assert a > 0 : \"Input 'a' must be a positive integer.\";\n        assert b > 0 : \"Input 'b' must be a positive integer.\";\n\n        if (a > b) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = a; i <= Math.min(b, 9); i++) {\n            if (i % 2 == 0) {\n                result.add(i);\n            }\n        }\n\n        // Postcondition 1\n        assert result instanceof List : \"The result must be a list.\";\n        \n        // Postcondition 2\n        for (int num : result) {\n            assert num % 2 == 0 : \"All elements in the result must be even digits.\";\n        }\n\n        // Postcondition 3\n        for (int num : result) {\n            assert num >= 2 && num <= 8 : \"All elements in the result must be between 2 and 8.\";\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(generateIntegers(2, 8));\n        System.out.println(generateIntegers(8, 2));\n        System.out.println(generateIntegers(10, 14));\n    }\n}"}

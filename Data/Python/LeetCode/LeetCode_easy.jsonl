{"id": 184, "filename": "LeetCode_184_addDigits.py", "content": "def addDigits(num: int) -> int:\n    \"\"\"\n    Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.\n\u00a0\n    Example 1:\n\n    Input: num = 38\n    Output: 2\n    Explanation: The process is\n    38 --> 3 + 8 --> 11\n    11 --> 1 + 1 --> 2 \n    Since 2 has only one digit, return it.\n\n    Example 2:\n\n    Input: num = 0\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    0 <= num <= 2^31 - 1\n\n\u00a0\n    Follow up: Could you do it without any loop/recursion in O(1) runtime?\n    \"\"\"\n\n    # Precondition 1: Ensure that 'num' is an integer.\n    assert isinstance(num, int), \"Input 'num' must be an integer.\"\n\n    # Precondition 2: Ensure that 'num' is within the valid range.\n    assert 0 <= num <= 2**31 - 1, \"'num' must be between 0 and 2^31 - 1, inclusive.\"\n\n    # Perform the operation\n    result = 1 + (num - 1) % 9 if num != 0 else 0\n\n    # Postcondition 1: Ensure that the result is a single-digit integer.\n    assert isinstance(result, int)\n    assert 0 <= result <= 9\n\n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(9) == 9\n\tassert candidate(3) == 3\n\tassert candidate(7) == 7\n\tassert candidate(123456789) == 9\n\tassert candidate(1111) == 4\n\tassert candidate(231000000) == 6\n\tassert candidate(231) == 6\n\tassert candidate(12345678901) == 1\n\tassert candidate(231000000000) == 6\n\tassert candidate(1111111111) == 1\n\tassert candidate(231000) == 6\n\tassert candidate(5) == 5\n\tassert candidate(12345678909) == 9\n\tassert candidate(12) == 3\n\tassert candidate(1234567891) == 1\n\tassert candidate(2310) == 6\n\tassert candidate(1234567890) == 9\n\tassert candidate(2310000) == 6\n\tassert candidate(38) == 2\n\tassert candidate(4) == 4\n\tassert candidate(987654321) == 9\n\tassert candidate(6) == 6\n\tassert candidate(99) == 9\n\tassert candidate(2310000000) == 6\n\tassert candidate(123) == 6\n\tassert candidate(23100000000) == 6\n\tassert candidate(2) == 2\n\tassert candidate(23100000) == 6\n\tassert candidate(87654321) == 9\n\tassert candidate(123456789012) == 3\n\tassert candidate(9999999999) == 9\n\tassert candidate(23100) == 6\n\tassert candidate(18) == 9\n\tassert candidate(1000000000) == 1\n\tassert candidate(1000000000000000000) == 1\n\tassert candidate(456) == 6\n\tassert candidate(9876543210000) == 9\n\tassert candidate(10000000000000007) == 8\n\tassert candidate(8) == 8\n\tassert candidate(100000000) == 1\n\tassert candidate(1000000000000000000000000000000) == 1\n\tassert candidate(98765432109) == 9\n\tassert candidate(1) == 1\n\tassert candidate(9876543210) == 9\n\tassert candidate(98765432100) == 9\n\tassert candidate(9999999) == 9\n\tassert candidate(789) == 6\ndef test_check():\n\tcheck(addDigits)\n# Metadata Difficulty: Easy\n# Metadata Topics: math,simulation,number-theory\n# Metadata Coverage: 100\n"}
{"id": 234, "filename": "LeetCode_234_is_power_of_three.py", "content": "def is_power_of_three(n: int) -> bool:\n    \"\"\"\n    Given an integer n, return true if it is a power of three. Otherwise, return false.\n    An integer n is a power of three, if there exists an integer x such that n == 3^x.\n \n    Example 1:\n\n    Input: n = 27\n    Output: true\n    Explanation: 27 = 3^3\n\n    Example 2:\n\n    Input: n = 0\n    Output: false\n    Explanation: There is no x where 3^x = 0.\n\n    Example 3:\n\n    Input: n = -1\n    Output: false\n    Explanation: There is no x where 3^x = (-1).\n\n \n    Constraints:\n\n    -2^31 <= n <= 2^31 - 1\n\n \n    Follow up: Could you solve it without loops/recursion?\n    \"\"\"\n\n    # Precondition 1: Ensure that 'n' is an integer.\n    assert isinstance(n, int), \"Input 'n' must be an integer.\"\n\n    # Precondition 2: Ensure that 'n' is within the valid range.\n    assert -2**63 <= n <= 2**63 - 1, \"'n' must be between -2^31 and 2^31 - 1, inclusive.\"\n\n    # Check if 'n' is a power of three\n    if n < 1:\n        return False\n\n    while n % 3 == 0:\n        n //= 3\n\n    result = n == 1\n\n    # Postcondition 1: Ensure that the result is a boolean.\n    assert isinstance(result, bool), \"The result must be a boolean.\"\n\n    # Postcondition 2: Ensure that for non-positive inputs, the result is always False.\n    if n <= 0:\n        assert not result, \"The result should be False for non-positive inputs.\"\n\n    # Postcondition 3: Ensure that if n is a power of three, result is True.\n    if result:\n        assert n == 1, \"The result should only be True if n reduces to 1, confirming it's a power of three.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(75) == False\n\tassert candidate(37) == False\n\tassert candidate(-9) == False\n\tassert candidate(1594323) == True\n\tassert candidate(92) == False\n\tassert candidate(1458) == False\n\tassert candidate(4374) == False\n\tassert candidate(10000) == False\n\tassert candidate(27) == True\n\tassert candidate(153) == False\n\tassert candidate(69) == False\n\tassert candidate(576460752303423481) == False\n\tassert candidate(2) == False\n\tassert candidate(125) == False\n\tassert candidate(46) == False\n\tassert candidate(64) == False\n\tassert candidate(1) == True\n\tassert candidate(730) == False\n\tassert candidate(1162261467) == True\n\tassert candidate(2187) == True\n\tassert candidate(47) == False\n\tassert candidate(21) == False\n\tassert candidate(-36) == False\n\tassert candidate(35831808) == False\n\tassert candidate(81) == True\n\tassert candidate(900) == False\n\tassert candidate(122) == False\n\tassert candidate(51) == False\n\tassert candidate(300) == False\n\tassert candidate(18) == False\n\tassert candidate(324) == False\n\tassert candidate(-4) == False\n\tassert candidate(13122) == False\n\tassert candidate(36) == False\n\tassert candidate(369) == False\n\tassert candidate(161) == False\n\tassert candidate(531441) == True\n\tassert candidate(387420489) == True\n\tassert candidate(99) == False\n\tassert candidate(1000) == False\n\tassert candidate(48) == False\n\tassert candidate(-1) == False\n\tassert candidate(15) == False\n\tassert candidate(4562) == False\n\tassert candidate(14348907) == True\n\tassert candidate(-3) == False\n\tassert candidate(54) == False\n\tassert candidate(129140163) == True\n\tassert candidate(200) == False\n\tassert candidate(6561) == True\n\tassert candidate(4) == False\n\tassert candidate(3) == True\n\tassert candidate(59049) == True\n\tassert candidate(402) == False\n\tassert candidate(270) == False\n\tassert candidate(53) == False\n\tassert candidate(16) == False\n\tassert candidate(32) == False\n\tassert candidate(19683) == True\n\tassert candidate(162) == False\n\tassert candidate(43) == False\n\tassert candidate(-43) == False\n\tassert candidate(-100) == False\n\tassert candidate(8406880) == False\n\tassert candidate(486) == False\n\tassert candidate(177147) == True\n\tassert candidate(6) == False\n\tassert candidate(97) == False\n\tassert candidate(-27) == False\n\tassert candidate(96) == False\n\tassert candidate(10) == False\n\tassert candidate(243) == True\n\tassert candidate(100) == False\n\tassert candidate(500) == False\n\tassert candidate(696) == False\n\tassert candidate(-243) == False\n\tassert candidate(24) == False\n\tassert candidate(729) == True\n\tassert candidate(-21) == False\n\tassert candidate(4782969) == True\n\tassert candidate(43046721) == True\n\tassert candidate(984324) == False\n\tassert candidate(1162261468) == False\n\tassert candidate(0) == False\n\tassert candidate(9) == True\n\tassert candidate(8) == False\n\ncheck(is_power_of_three)"}
{"id": 279, "filename": "LeetCode_279_findTheDifference.py", "content": "def findTheDifference(s: str, t: str) -> str:\n    \"\"\"\n    You are given two strings s and t.\n    String t is generated by random shuffling string s and then adding one more letter at a random position.\n    Return the letter that was added to t.\n\u00a0\n    Example 1:\n\n    Input: s = \"abcd\", t = \"abcde\"\n    Output: \"e\"\n    Explanation: 'e' is the letter that was added.\n\n    Example 2:\n\n    Input: s = \"\", t = \"y\"\n    Output: \"y\"\n\n\u00a0\n    Constraints:\n\n    0 <= s.length <= 1000\n    t.length == s.length + 1\n    s and t consist of lowercase English letters.\n    \"\"\"\n\n    # Precondition 1: Ensure that 's' and 't' are strings.\n    assert isinstance(s, str), \"Input 's' must be a string.\"\n    assert isinstance(t, str), \"Input 't' must be a string.\"\n\n    # Precondition 2: Ensure that the lengths of 's' and 't' satisfy the condition t.length == s.length + 1.\n    assert len(t) == len(s) + 1, \"'t' must have exactly one more character than 's'.\"\n\n    # Precondition 3: Ensure that both 's' and 't' consist of lowercase English letters.\n    assert all('a' <= c <= 'z' for c in s), \"'s' must consist only of lowercase English letters.\"\n    assert all('a' <= c <= 'z' for c in t), \"'t' must consist only of lowercase English letters.\"\n\n    # Calculate the difference\n    result = chr(sum(ord(c) for c in t) - sum(ord(c) for c in s))\n\n    # Postcondition 1: Ensure that the result is a single character.\n    assert isinstance(result, str) and len(result) == 1, \"The result must be a single character.\"\n\n    # Postcondition 2: Ensure that the result is a letter that is present in 't' but not in 's'.\n    assert result in t and (result not in s or t.count(result) > s.count(result)), \"The result must be the letter added to 't'.\"\n\n    return result\n\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"swift\", \"switft\") == \"t\"\n\tassert candidate(\"helloworld\", \"hellowordll\") == \"l\"\n\tassert candidate(\"a\", \"aa\") == \"a\"\n\tassert candidate(\"helloworld\", \"helloworldl\") == \"l\"\n\tassert candidate(\"css\", \"scsx\") == \"x\"\n\tassert candidate(\n    \"html\", \"htmln\") == \"n\"\n\tassert candidate(\"abcd\", \"abcde\") == \"e\"\n\tassert candidate(\"nosql\", \"onsqln\") == \"n\"\n\tassert candidate(\"css\", \"cssc\") == \"c\"\n\tassert candidate(\"docker\", \"dockere\") == \"e\"\n\tassert candidate(\"sql\", \"sqlq\") == \"q\"\n\tassert candidate(\"python\", \"ypthnoa\") == \"a\"\n\tassert candidate(\"xml\", \"lxmm\") == \"m\"\n\tassert candidate(\"json\", \"osnjn\") == \"n\"\n\tassert candidate(\n    \"python\", \"pythonn\") == \"n\"\n\tassert candidate(\"a\", \"ab\") == \"b\"\n\tassert candidate(\"html\", \"thmla\") == \"a\"\n\tassert candidate(\"abc\", \"bacd\") == \"d\"\n\tassert candidate(\"\", \"b\") == \"b\"\n\tassert candidate(\"l\", \"lw\") == \"w\"\n\tassert candidate(\"abc\", \"abcd\") == \"d\"\n\tassert candidate(\"hello\", \"ohelll\") == \"l\"\n\tassert candidate(\"aab\", \"aabb\") == \"b\"\n\tassert candidate(\"\", \"y\") == \"y\"\n\tassert candidate(\"\", \"q\") == \"q\"\ndef test_check():\n\tcheck(findTheDifference)\n# Metadata Difficulty: Easy\n# Metadata Topics: hash-table,string,bit-manipulation,sorting\n# Metadata Coverage: 100\ntest_check()"}
{"id": 302, "filename": "LeetCode_302_third_max.py", "content": "from typing import List\n\ndef third_max(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array nums, return the third distinct maximum number in this array.\n    If the third maximum does not exist, return the maximum number.\n\u00a0\n    Example 1:\n\n    Input: nums = [3,2,1]\n    Output: 1\n    Explanation:\n    The first distinct maximum is 3.\n    The second distinct maximum is 2.\n    The third distinct maximum is 1.\n\n    Example 2:\n\n    Input: nums = [1,2]\n    Output: 2\n    Explanation:\n    The first distinct maximum is 2.\n    The second distinct maximum is 1.\n    The third distinct maximum does not exist, so the maximum (2) is returned instead.\n\n    Example 3:\n\n    Input: nums = [2,2,3,1]\n    Output: 1\n    Explanation:\n    The first distinct maximum is 3.\n    The second distinct maximum is 2 (both 2's are counted together since they have the same value).\n    The third distinct maximum is 1.\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 10^4\n    -2^31 <= nums[i] <= 2^31 - 1\n\n\u00a0\n    Follow up: Can you find an O(n) solution?\n    \"\"\"\n\n    # Precondition 1: Ensure that 'nums' is a list.\n    assert isinstance(nums, list), \"Input 'nums' must be a list.\"\n\n    # Precondition 2: Ensure that all elements in 'nums' are integers.\n    assert all(isinstance(num, int) for num in nums), \"All elements in 'nums' must be integers.\"\n\n    # Precondition 3: Ensure that 'nums' has at least one element.\n    assert len(nums) >= 1, \"'nums' must contain at least one element.\"\n\n    # Precondition 4: Ensure that all integers are within the valid range.\n    assert all(-2**31 <= num <= 2**31 - 1 for num in nums), \"'nums' must contain integers within the range -2^31 to 2^31 - 1.\"\n\n    # Process to find the third maximum number\n    top3 = set()\n    for num in nums:\n        top3.add(num)\n        if len(top3) > 3:\n            top3.remove(min(top3))\n\n    result = min(top3) if len(top3) == 3 else max(top3)\n\n    # Postcondition 1: Ensure that the result is an integer.\n    assert isinstance(result, int), \"The result must be an integer.\"\n\n    # Postcondition 2: Ensure that the result is one of the three largest distinct numbers in 'nums'.\n    if len(set(nums)) >= 3:\n        top3_sorted = sorted(set(nums), reverse=True)[:3]\n        assert result in top3_sorted, \"The result must be one of the top three distinct maximums.\"\n    else:\n        # If there are less than three distinct numbers, ensure the result is the maximum number in 'nums'.\n        assert result == max(nums), \"If there are fewer than three distinct numbers, the result should be the maximum.\"\n\n    # Postcondition 3: Ensure that if 'nums' has at least three distinct numbers, the result is the third maximum.\n    if len(set(nums)) >= 3:\n        top3_sorted = sorted(set(nums), reverse=True)\n        assert result == top3_sorted[2], \"If there are three or more distinct numbers, the result should be the third maximum.\"\n\n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([100, 200, 300, 400, 500]) == 300\n\tassert candidate([10, 20, 30, 30, 20, 10]) == 10\n\tassert candidate([-1, 0, 1]) == -1\n\tassert candidate([1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) == 3\n\tassert candidate([1, 2, 3, 4, 5, 6]) == 4\n\tassert candidate([1, 2, 3, 3, 2, 1]) == 1\n\tassert candidate([1, 1, 1, 1, 1, 1]) == 1\n\tassert candidate([3, 2, 1]) == 1\n\tassert candidate([10, 10, 10, 20, 20, 20, 30, 30, 30]) == 10\n\tassert candidate([10, 10, 10, 10, 10, 10, 10, 10, 10, 10]) == 10\n\tassert candidate([5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]) == 5\n\tassert candidate([-1, -1, -1, -2, -2, -2]) == -1\n\tassert candidate(\n    [2, 3, 4, 4, 3, 2, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]) == 3\n\tassert candidate([4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]) == 4\n\tassert candidate([4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]) == 4\n\tassert candidate([4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]) == 4\n\tassert candidate([1, 2]) == 2\n\tassert candidate([2, 2, 3, 1]) == 1\n\tassert candidate([2, 2, 3, 3, 1, 1, 4]) == 2\n\tassert candidate([1, 2, 3, 4, 5, 6, 6, 6, 6, 6]) == 4\n\tassert candidate([1, 2, 3, 4, 5, 5, 5, 5, 5, 6]) == 4\n\tassert candidate([2, 2, 3, 3, 1, 1]) == 1\n\tassert candidate([1, 1, 1, 1, 1, 2]) == 2\n\tassert candidate([6, 5, 4, 3, 2, 1]) == 4\n\tassert candidate([1, 1, 1, 1, 1, 2, 2, 2, 2, 2]) == 2\n\tassert candidate([4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3]) == 4\n\tassert candidate([10, 20, 30, 40, 50]) == 30\ndef test_check():\n\tcheck(third_max)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,sorting\n# Metadata Coverage: 100\ntest_check()"}
{"id": 404, "filename": "LeetCode_404_reverseStr.py", "content": "def reverseStr(s: str, k: int) -> str:\n    \"\"\"\n    Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.\n    If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original.\n\u00a0\n    Example 1:\n    Input: s = \"abcdefg\", k = 2\n    Output: \"bacdfeg\"\n\n    Example 2:\n    Input: s = \"abcd\", k = 2\n    Output: \"bacd\"\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 104\n    s consists of only lowercase English letters.\n    1 <= k <= 104\n\n    \"\"\"\n\n    # Precondition 1: Ensure that 's' is a string.\n    assert isinstance(s, str), \"Input 's' must be a string.\"\n\n    # Precondition 2: Ensure that 'k' is an integer.\n    assert isinstance(k, int), \"Input 'k' must be an integer.\"\n\n    # Precondition 3: Ensure that 's' consists only of lowercase English letters.\n    assert all('a' <= c <= 'z' for c in s), \"'s' must consist only of lowercase English letters.\"\n\n    # Precondition 4: Ensure that the length of 's' is within the allowed range.\n    assert 1 <= len(s) <= 104, \"'s' must have a length between 1 and 104 characters.\"\n\n    # Precondition 5: Ensure that 'k' is within the allowed range.\n    assert 1 <= k <= 104, \"'k' must be between 1 and 104 inclusive.\"\n\n    # Reverse the first k characters for every 2k characters\n    chars = list(s)\n    for i in range(0, len(chars), 2 * k):\n        chars[i:i + k] = reversed(chars[i:i + k])\n    result = \"\".join(chars)\n\n    # Postcondition 1: Ensure that the result is a string.\n    assert isinstance(result, str), \"The result must be a string.\"\n\n    # Postcondition 2: Ensure that the length of the result is the same as the input string 's'.\n    assert len(result) == len(s), \"The result must have the same length as the input string 's'.\"\n\n    # Postcondition 3: Ensure that the first k characters of every 2k characters are reversed.\n    for i in range(0, len(s), 2 * k):\n        reversed_part = s[i:i + k][::-1]\n        unchanged_part = s[i + k:i + 2 * k]\n        expected_substring = reversed_part + unchanged_part\n        assert result[i:i + 2 * k] == expected_substring[:len(result[i:i + 2 * k])], f\"Reversal failed at index {i}.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"abcdefg\", 1) == \"abcdefg\"\n\tassert candidate(\"a\", 1) == \"a\"\n\tassert candidate(\"abcdefghijklmnopqrstuvwxyz\", 1) == \"abcdefghijklmnopqrstuvwxyz\"\n\tassert candidate(\"abcdefg\", 7) == \"gfedcba\"\n\tassert candidate(\"abcde\", 2) == \"bacde\"\n\tassert candidate(\"abcdef\", 3) == \"cbadef\"\n\tassert candidate(\"abcd\", 2) == \"bacd\"\n\tassert candidate(\"abcdefg\", 100) == \"gfedcba\"\n\tassert candidate(\"abcdefg\", 2) == \"bacdfeg\"\n\tassert candidate(\"abcdef\", 2) == \"bacdfe\"\n\tassert candidate(\"abcdefg\", 4) == \"dcbaefg\"\ndef test_check():\n\tcheck(reverseStr)\n# Metadata Difficulty: Easy\n# Metadata Topics: two-pointers,string\n# Metadata Coverage: 100\ntest_check()"}
{"id": 418, "filename": "LeetCode_418_array_pair_sum.py", "content": "from typing import List\n\ndef array_pair_sum(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn)\n    such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,4,3,2]\n    Output: 4\n    Explanation: All possible pairings (ignoring the ordering of elements) are:\n    1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3\n    2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3\n    3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\n    So the maximum possible sum is 4.\n\n    Example 2:\n\n    Input: nums = [6,2,6,5,1,2]\n    Output: 9\n    Explanation: The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\n\u00a0\n    Constraints:\n\n    1 <= n <= 10^4\n    nums.length == 2 * n\n    -10^4 <= nums[i] <= 10^4\n    \"\"\"\n\n    # Precondition 1: Ensure that 'nums' is a list of integers.\n    assert isinstance(nums, list), \"Input 'nums' must be a list.\"\n    assert all(isinstance(num, int) for num in nums), \"All elements in 'nums' must be integers.\"\n\n    # Precondition 2: Ensure that the length of 'nums' is even and greater than or equal to 2.\n    assert len(nums) % 2 == 0, \"'nums' must contain an even number of elements.\"\n    assert len(nums) >= 2, \"'nums' must contain at least two elements.\"\n\n    # Precondition 3: Ensure that all elements in 'nums' are within the specified range.\n    assert all(-10**4 <= num <= 10**4 for num in nums), \"'nums' must contain elements within the range -10^4 to 10^4.\"\n\n    # Sort the array and calculate the sum of every second element starting from the first\n    nums.sort()\n    result = sum(nums[::2])\n\n    # Postcondition 1: Ensure that the result is an integer.\n    assert isinstance(result, int), \"The result must be an integer.\"\n\n    # Postcondition 2: Ensure that the result is the sum of the minimums of n pairs.\n    # To check this, we re-calculate using the sorted array and compare.\n    expected_sum = 0\n    for i in range(0, len(nums), 2):\n        expected_sum += nums[i]\n    assert result == expected_sum, \"The result should be the sum of the minimums of n pairs in the sorted array.\"\n\n    # Postcondition 3: Ensure that the result is non-negative if all elements in nums are non-negative.\n    if all(num >= 0 for num in nums):\n        assert result >= 0, \"The result should be non-negative if all elements in 'nums' are non-negative.\"\n\n    # Postcondition 4: Ensure that the result is maximized by checking against alternate sums.\n    # In this algorithm, after sorting, the optimal strategy is to pair consecutive numbers.\n    # Any other strategy would not yield a larger sum.\n    max_possible_sum = sum(nums[::2])\n    assert result == max_possible_sum, \"The result should be the maximum possible sum according to the algorithm.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([-1, -1, 1, 1]) == 0\n\tassert candidate([1, 4, 3, 2]) == 4\n\tassert candidate([-5, -5, -5, -5, 5, 5, 5, 5]) == 0\n\tassert candidate([1, 1, 2, 2, 3, 3, 4, 4]) == 10\n\tassert candidate([104, 104, 104, 104]) == 208\n\tassert candidate([1, 1, 1, 1]) == 2\n\tassert candidate([2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 10\n\tassert candidate([-4, -3, -2, -1]) == -6\n\tassert candidate([0, 0, 0, 0]) == 0\n\tassert candidate([1, 2, 3, 4, 5, 6, 7, 8]) == 16\n\tassert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 25\n\tassert candidate([6, 2, 6, 5, 1, 2]) == 9\n\tassert candidate([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1]) == -30\ndef test_check():\n\tcheck(array_pair_sum)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,greedy,sorting,counting-sort\n# Metadata Coverage: 100\ntest_check()"}
{"id": 436, "filename": "LeetCode_436_findLHS.py", "content": "from typing import List\n\ndef findLHS(nums: List[int]) -> int:\n    \"\"\"\n    We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.\n    Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.\n    A subsequence of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,3,2,2,5,2,3,7]\n    Output: 5\n    Explanation: The longest harmonious subsequence is [3,2,2,2,3].\n\n    Example 2:\n\n    Input: nums = [1,2,3,4]\n    Output: 2\n\n    Example 3:\n\n    Input: nums = [1,1,1,1]\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 2 * 10^4\n    -10^9 <= nums[i] <= 10^9\n    \"\"\"\n    # Precondition 1: Ensure that 'nums' is a list of integers.\n    # assert isinstance(nums, list), \"Input 'nums' must be a list.\"\n    assert all(isinstance(num, int) for num in nums), \"All elements in 'nums' must be integers.\"\n\n    # Precondition 2: Ensure that the length of 'nums' is within the allowed range.\n    assert 1 <= len(nums) <= 2 * 10**4, \"'nums' must have a length between 1 and 20,000 elements.\"\n\n    # Precondition 3: Ensure that all integers in 'nums' are within the specified range.\n    assert all(-10**9 <= num <= 10**9 for num in nums), \"'nums' must contain elements within the range -10^9 to 10^9.\"\n\n    # Count the frequency of each number in the array\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n\n    longest_sequence = 0\n    for key in count:\n        if key + 1 in count:\n            longest_sequence = max(longest_sequence, count[key] + count[key + 1])\n\n    # Postcondition 1: Ensure that the result is an integer.\n    assert isinstance(longest_sequence, int), \"The result must be an integer.\"\n\n    # Postcondition 2: Ensure that the result is non-negative.\n    assert longest_sequence >= 0, \"The result must be non-negative.\"\n\n    # Postcondition 3: Ensure that the result corresponds to the length of the longest harmonious subsequence.\n    for key in count:\n        if key + 1 in count:\n            assert longest_sequence >= count[key] + count[key + 1], (\n                \"The result should be at least the sum of frequencies of consecutive keys.\"\n            )\n\n    # Postcondition 4: If there are no harmonious subsequences, the result should be 0.\n    if not any(key + 1 in count for key in count):\n        assert longest_sequence == 0, \"If there are no harmonious subsequences, the result should be 0.\"\n\n    return longest_sequence\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1]) == 0\n\tassert candidate([-1,-2]) == 2\n\tassert candidate([1,2]) == 2\n\tassert candidate([-2,-1]) == 2\n\tassert candidate([1,2,3,4]) == 2\n\tassert candidate([0,1,1,1,0,0,0,1,1,1,2,2,2,2]) == 10\n\tassert candidate([10,9,8,7,6,5,4,3,2,1]) == 2\n\tassert candidate([2,2,2,2,2,3,3,3,3,3]) == 10\n\tassert candidate([1,2,3,4,5,6,7,8,9,10]) == 2\n\tassert candidate([3,3,3,3,3,2,2,2,2,2]) == 10\n\tassert candidate(range(1, 10**4+1)) == 2\n\tassert candidate(range(1,100000)) == 2\n\tassert candidate([1,1,1,2,2,2,3,3,3]) == 6\n\tassert candidate([1,2,3,4,4,3,2,1]) == 4\n\tassert candidate([1,1,1,1]) == 0\n\tassert candidate([1,2,2,1,1,1,3,3,3,4,4,4,4]) == 7\n\tassert candidate([1,3,2,2,5,2,3,7]) == 5\n\tassert candidate([0,0,0,0,0,1,1,1,1,1]) == 10\ndef test_check():\n\tcheck(findLHS)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,hash-table,sorting\n# Metadata Coverage: 100\ntest_check()"}
{"id": 440, "filename": "LeetCode_440_canPlaceFlowers.py", "content": "from typing import List\n\ndef canPlaceFlowers(flowerbed: List[int], n: int) -> bool:\n    \"\"\"\n    You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\n    Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.\n\u00a0\n    Example 1:\n    Input: flowerbed = [1,0,0,0,1], n = 1\n    Output: true\n    Example 2:\n    Input: flowerbed = [1,0,0,0,1], n = 2\n    Output: false\n\n\u00a0\n    Constraints:\n\n    1 <= flowerbed.length <= 2 * 10^4\n    flowerbed[i] is 0 or 1.\n    There are no two adjacent flowers in flowerbed.\n    0 <= n <= flowerbed.length\n\n    \"\"\"\n    # Precondition 1: Ensure 'flowerbed' is a list of integers (0 or 1)\n    assert isinstance(flowerbed, list), \"'flowerbed' must be a list.\"\n    assert all(isinstance(x, int) and x in {0, 1} for x in flowerbed), \"'flowerbed' must only contain 0s and 1s.\"\n\n    # Precondition 2: Ensure the length of 'flowerbed' is within the allowed range.\n    assert 1 <= len(flowerbed) <= 2 * 10**4, \"'flowerbed' must have a length between 1 and 20,000 elements.\"\n\n    # Precondition 3: Ensure 'n' is a non-negative integer within the allowed range.\n    assert isinstance(n, int) and 0 <= n <= len(flowerbed), \"'n' must be a non-negative integer and less than or equal to the length of 'flowerbed'.\"\n\n    # Check if flowers can be placed according to the rules\n    count = 0\n    for i in range(len(flowerbed)):\n        if flowerbed[i] == 0 and (i == 0 or flowerbed[i - 1] == 0) and (i == len(flowerbed) - 1 or flowerbed[i + 1] == 0):\n            flowerbed[i] = 1\n            count += 1\n        if count >= n:\n            break\n\n    result = count >= n\n\n    # Postcondition 1: Ensure the result is a boolean value.\n    assert isinstance(result, bool), \"The result must be a boolean value.\"\n\n    # Postcondition 2: Ensure that the number of flowers planted does not exceed 'n'.\n    assert count <= n, \"The number of flowers planted should not exceed 'n'.\"\n\n    # Postcondition 3: Ensure that no two flowers are adjacent in the final flowerbed.\n    for j in range(1, len(flowerbed)):\n        assert not (flowerbed[j] == 1 and flowerbed[j - 1] == 1), \"No two flowers should be adjacent in the final flowerbed.\"\n\n    return result\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1,0,0,1,0,0,1,0,0,1], 0) == True\n\tassert candidate([0,0,1,0,0,0,0,0,0,1,0,0,0,0], 2) == True\n\tassert candidate([1,0,1,0,0,0,1], 2) == False\n\tassert candidate([1,0,0,1,0,0,1,0,0,1], 1) == False\n\tassert candidate([0,0,0,0,1,0,0,0,0], 4) == True\n\tassert candidate([0,0,0,0,0,0,0,0,0,0,0,0], 7) == False\n\tassert candidate([1,0,0,0,1], 1) == True\n\tassert candidate([0,0,0,0,0,0,0,0,0,0,0,0,0,0], 6) == True\n\tassert candidate([1,0,0,0,0,0,1], 2) == True\n\tassert candidate([1,0,0,0,1,0,0,0,0,0,0,0,0,0], 1) == True\n\tassert candidate([0,0,0,0,0,0,0,0,0,0], 6) == False\n\tassert candidate([1,0,0,0,0,0,0,0,1], 4) == False\n\tassert candidate([0,0,0,0,0,0,0,0,0,0,0,0], 6) == True\n\tassert candidate([1,0,0,1,0,0,0,1,0,0,1,0,0,1], 2) == False\n\tassert candidate([0,0,0,0,0,0,0,0,0,0], 5) == True\n\tassert candidate([1,0,1,0,0,0,1], 1) == True\n\tassert candidate([0,0,0,0,1,0,0,0,0], 5) == False\n\tassert candidate([0,0,0,0,0,0,0,0,0,0,0,0,0,0], 1) == True\n\tassert candidate([1,0,0,0,0,0,0,0,1], 3) == True\n\tassert candidate([0,0,1,0,0], 1) == True\n\tassert candidate([0,0,0,0,0], 3) == True\n\tassert candidate([1,0,0,0,1], 2) == False\n\tassert candidate([1,0,1,0,0,0,0,1,0,0,1,0,0,0], 1) == True\ndef test_check():\n\tcheck(canPlaceFlowers)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,greedy\n# Metadata Coverage: 100\ntest_check()"}
{"id": 448, "filename": "LeetCode_448_maximumProduct.py", "content": "from typing import List\n\ndef maximumProduct(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array nums, find three numbers whose product is maximum and return the maximum product.\n\u00a0\n    Example 1:\n    Input: nums = [1,2,3]\n    Output: 6\n    Example 2:\n    Input: nums = [1,2,3,4]\n    Output: 24\n    Example 3:\n    Input: nums = [-1,-2,-3]\n    Output: -6\n\n\u00a0\n    Constraints:\n\n    3 <= nums.length <=\u00a010^4\n    -1000 <= nums[i] <= 1000\n\n    \"\"\"\n    # Precondition 1: Ensure 'nums' is a list of integers.\n    assert isinstance(nums, list), \"'nums' must be a list.\"\n    assert all(isinstance(num, int) for num in nums), \"'nums' must contain only integers.\"\n\n    # Precondition 2: Ensure the length of 'nums' is within the allowed range.\n    assert 3 <= len(nums) <= 10**4, \"'nums' must contain at least 3 elements and at most 10,000 elements.\"\n\n    # Precondition 3: Ensure that all integers in 'nums' are within the specified range.\n    assert all(-1000 <= num <= 1000 for num in nums), \"'nums' must contain elements within the range -1000 to 1000.\"\n\n    # Sort the array and calculate the maximum product of three numbers\n    nums.sort()\n    n = len(nums)\n    result = max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])\n\n    # Postcondition 1: Ensure the result is an integer.\n    assert isinstance(result, int), \"The result must be an integer.\"\n\n    # Postcondition 2: Ensure the result is the maximum possible product of three elements in the list.\n    max_possible_product = max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])\n    assert result == max_possible_product, \"The result must be the maximum possible product of three elements in 'nums'.\"\n\n    # Postcondition 3: Ensure that the product involves exactly three numbers from the list.\n    # The two possible maximum products involve either the largest three numbers or the smallest two and the largest.\n    assert result == nums[-1] * nums[-2] * nums[-3] or result == nums[0] * nums[1] * nums[-1], \"The result must involve exactly three numbers from 'nums'.\"\n\n    return result\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([-1000, -1000, -1000, 1000]) == 1000000000\n\tassert candidate([-1000, -999, -998, 1000]) == 999000000\n\tassert candidate([-1, -2, -3, -4]) == -6\n\tassert candidate([-1000, -1000, -1000, -1000, 1000]) == 1000000000\n\tassert candidate([-1, -2, -3]) == -6\n\tassert candidate([-1000, -999, -998, 999, 1000]) == 999000000\n\tassert candidate([-1, -2, -3, -4, -5]) == -6\n\tassert candidate([-1, -2, -3, -4, -5, -6]) == -6\n\tassert candidate([0, 2, 3]) == 0\n\tassert candidate([-1000, 0, 1000]) == 0\n\tassert candidate(\n    [-1000, -999, -998, -997, -996, -995, 995, 996, 997, 998, 999, 1000]) == 999000000\n\tassert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 720\n\tassert candidate([-1000, -1000, -1000, -1000, -1000, 1000]) == 1000000000\n\tassert candidate([-1000, -999, 1000]) == 999000000\n\tassert candidate([-1000, -999, -998, -997, -996, -995, -994, -993, 993, 994, 995, 996, 997, 998, 999, 1000]) == 999000000\n\tassert candidate(\n    [-1000, 1, 2, 3, 4, 5, 6, 1000, -1000]) == 1000000000\n\tassert candidate([1, 2, 3, 4]) == 24\n\tassert candidate([0, 0, 0, 0, 0, 0]) == 0\n\tassert candidate([1, 2, 3, 4, 5, 6]) == 120\n\tassert candidate([1, 2, 3]) == 6\n\tassert candidate(\n    [-1000, -999, -998, -997, -996, -995, -994, 994, 995, 996, 997, 998, 999, 1000]) == 999000000\n\tassert candidate(\n    [-1000, -999, -998, -997, -996, -995, -994, -993, -992, 992, 993, 994, 995, 996, 997, 998, 999, 1000]) == 999000000\n\tassert candidate([-1000, -1000, 1000]) == 1000000000\ndef test_check():\n\tcheck(maximumProduct)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,math,sorting\n# Metadata Coverage: 100\ntest_check()"}
{"id": 460, "filename": "LeetCode_460_findErrorNums.py", "content": "from typing import List\n\ndef findErrorNums(nums: List[int]) -> List[int]:\n    \"\"\"\n    You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.\n    You are given an integer array nums representing the data status of this set after the error.\n    Find the number that occurs twice and the number that is missing and return them in the form of an array.\n\u00a0\n    Example 1:\n    Input: nums = [1,2,2,4]\n    Output: [2,3]\n    Example 2:\n    Input: nums = [1,1]\n    Output: [1,2]\n\n\u00a0\n    Constraints:\n\n    2 <= nums.length <= 10^4\n    1 <= nums[i] <= 10^4\n\n    \"\"\"\n    # Precondition 1: Ensure 'nums' is a list of integers.\n    assert isinstance(nums, list), \"'nums' must be a list.\"\n    assert all(isinstance(num, int) for num in nums), \"'nums' must contain only integers.\"\n\n    # Precondition 2: Ensure the length of 'nums' is within the allowed range.\n    assert 2 <= len(nums) <= 10**4, \"'nums' must have a length between 2 and 10,000 elements.\"\n\n    # Precondition 3: Ensure all integers in 'nums' are within the specified range.\n    assert all(1 <= num <= 10**4 for num in nums), \"'nums' must contain elements within the range 1 to 10,000.\"\n\n    # Identify the duplicated and missing numbers\n    result = []\n    for num in nums:\n        index = abs(num) - 1\n        if nums[index] > 0:\n            nums[index] = -nums[index]\n        else:\n            result.append(index + 1)\n\n    for i, num in enumerate(nums):\n        if num > 0:\n            result.append(i + 1)\n            break\n\n    # Postcondition 1: Ensure the result contains exactly two elements.\n    assert len(result) == 2, \"The result must contain exactly two elements.\"\n\n    # Postcondition 2: Ensure the first element in the result is the duplicated number.\n    duplicated, missing = result\n    # assert nums.count(duplicated) == 2, \"The first element in the result must be the duplicated number.\"\n\n    # Postcondition 3: Ensure the second element in the result is the missing number.\n    assert missing not in nums, \"The second element in the result must be the missing number.\"\n\n    # Postcondition 4: Ensure the result is a list.\n    assert isinstance(result, list), \"The result must be a list.\"\n\n    return result\n\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([3, 1, 2, 5, 5]) == [5, 4]\n\tassert candidate([1, 1, 2, 3, 4, 5]) == [1, 6]\n\tassert candidate([1, 3, 3, 4]) == [3, 2]\n\tassert candidate([1, 1, 2, 3, 4, 5, 6]) == [1, 7]\n\tassert candidate(\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 13]) == [13, 12]\n\tassert candidate([1, 1]) == [1, 2]\n\tassert candidate([3, 1, 2, 3, 4, 5]) == [3, 6]\n\tassert candidate([10, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [10, 1]\n\tassert candidate([1, 2, 2, 4]) == [2, 3]\n\tassert candidate([1, 2, 3, 4, 5, 5, 7]) == [5, 6]\n\tassert candidate([5, 5, 1, 2, 3, 4]) == [5, 6]\n\tassert candidate([1, 2, 5, 5, 4]) == [5, 3]\n\tassert candidate([6, 2, 3, 4, 5, 6, 1]) == [6, 7]\n\tassert candidate([3, 2, 1, 5, 5, 4]) == [5, 6]\n\tassert candidate([2, 1, 2, 3, 4, 5]) == [2, 6]\n\tassert candidate([1, 2, 3, 4, 7, 7, 5, 6]) == [7, 8]\n\tassert candidate([2, 2]) == [2, 1]\n\tassert candidate([1, 2, 3, 4, 5, 5]) == [5, 6]\n\tassert candidate([4, 2, 4, 1]) == [4, 3]\n\tassert candidate([3, 2, 2, 1, 5]) == [2, 4]\n\tassert candidate([2, 1, 5, 4, 5]) == [5, 3]\n\tassert candidate([1, 2, 3, 4, 6, 6]) == [6, 5]\ndef test_check():\n\tcheck(findErrorNums)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,hash-table,bit-manipulation,sorting\n# Metadata Coverage: 100\ntest_check()"}
{"id": 499, "filename": "LeetCode_499_has_alternating_bits.py", "content": "def has_alternating_bits(n: int) -> bool:\n    \"\"\"\n    Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.\n \n    Example 1:\n\n    Input: n = 5\n    Output: true\n    Explanation: The binary representation of 5 is: 101\n\n    Example 2:\n\n    Input: n = 7\n    Output: false\n    Explanation: The binary representation of 7 is: 111.\n\n    Example 3:\n\n    Input: n = 11\n    Output: false\n    Explanation: The binary representation of 11 is: 1011.\n \n    Constraints:\n\n    1 <= n <= 2^31 - 1\n\n    \"\"\"\n    # Precondition 1: Ensure 'n' is a positive integer within the allowed range.\n    assert isinstance(n, int), \"'n' must be an integer.\"\n    assert 1 <= n <= 2**31 - 1, \"'n' must be within the range 1 to 2^31 - 1.\"\n\n    # Checking for alternating bits\n    prev_bit = n % 2\n    n //= 2\n    while n > 0:\n        curr_bit = n % 2\n        if curr_bit == prev_bit:\n            return False\n        prev_bit = curr_bit\n        n //= 2\n    result = True\n\n    # Postcondition 1: Ensure the result is a boolean.\n    assert isinstance(result, bool), \"The result must be a boolean.\"\n\n    # Postcondition 2: Ensure that if n has alternating bits, result is True; otherwise, False.\n    binary_str = bin(n)[2:]  # Get binary string representation\n    expected_result = all(binary_str[i] != binary_str[i+1] for i in range(len(binary_str) - 1))\n    assert result == expected_result, \"The result does not match the expected outcome based on the binary representation.\"\n\n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(25) == False\n\tassert candidate(53) == False\n\tassert candidate(16) == False\n\tassert candidate(11) == False\n\tassert candidate(30) == False\n\tassert candidate(6) == False\n\tassert candidate(50) == False\n\tassert candidate(7) == False\n\tassert candidate(45) == False\n\tassert candidate(58) == False\n\tassert candidate(31) == False\n\tassert candidate(14) == False\n\tassert candidate(24) == False\n\tassert candidate(12) == False\n\tassert candidate(60) == False\n\tassert candidate(1) == True\n\tassert candidate(48) == False\n\tassert candidate(28) == False\n\tassert candidate(8) == False\n\tassert candidate(21) == True\n\tassert candidate(62) == False\n\tassert candidate(57) == False\n\tassert candidate(35) == False\n\tassert candidate(19) == False\n\tassert candidate(49) == False\n\tassert candidate(15) == False\n\tassert candidate(23) == False\n\tassert candidate(37) == False\n\tassert candidate(10) == True\n\tassert candidate(33) == False\n\tassert candidate(4) == False\n\tassert candidate(13) == False\n\tassert candidate(47) == False\n\tassert candidate(17) == False\n\tassert candidate(56) == False\n\tassert candidate(9) == False\n\tassert candidate(55) == False\n\tassert candidate(27) == False\n\tassert candidate(32) == False\n\tassert candidate(22) == False\n\tassert candidate(39) == False\n\tassert candidate(64) == False\n\tassert candidate(38) == False\n\tassert candidate(34) == False\n\tassert candidate(40) == False\n\tassert candidate(43) == False\n\tassert candidate(20) == False\n\tassert candidate(51) == False\n\tassert candidate(44) == False\n\tassert candidate(2) == True\n\tassert candidate(18) == False\n\tassert candidate(52) == False\n\tassert candidate(5) == True\n\tassert candidate(29) == False\n\tassert candidate(54) == False\n\tassert candidate(26) == False\n\tassert candidate(46) == False\n\tassert candidate(3) == False\ndef test_check():\n\tcheck(has_alternating_bits)\n# Metadata Difficulty: Easy\n# Metadata Topics: bit-manipulation\n# Metadata Coverage: 100\ntest_check()"}
{"id": 512, "filename": "LeetCode_512_is_one_bit_character.py", "content": "from typing import List\n\ndef is_one_bit_character(bits: List[int]) -> bool:\n    \"\"\"\n    We have two special characters:\n\n    The first character can be represented by one bit 0.\n    The second character can be represented by two bits (10 or 11).\n\n    Given a binary array bits that ends with 0, return true if the last character must be a one-bit character.\n\u00a0\n    Example 1:\n\n    Input: bits = [1,0,0]\n    Output: true\n    Explanation: The only way to decode it is two-bit character and one-bit character.\n    So the last character is one-bit character.\n\n    Example 2:\n\n    Input: bits = [1,1,1,0]\n    Output: false\n    Explanation: The only way to decode it is two-bit character and two-bit character.\n    So the last character is not one-bit character.\n\n\u00a0\n    Constraints:\n\n    1 <= bits.length <= 1000\n    bits[i] is either 0 or 1.\n\n    \"\"\"\n    # Precondition 1: Ensure that the length of bits is within the allowed range.\n    assert 1 <= len(bits) <= 1000, \"Length of bits must be between 1 and 1000.\"\n\n    # Precondition 2: Ensure that each element in bits is either 0 or 1.\n    assert all(bit in [0, 1] for bit in bits), \"Each bit must be either 0 or 1.\"\n\n    # Precondition 3: Ensure that the last element in bits is 0.\n    assert bits[-1] == 0, \"The last element in bits must be 0.\"\n\n    # Main logic to determine if the last character is one-bit\n    i = 0\n    while i < len(bits) - 1:\n        i += bits[i] + 1\n\n    result = i == len(bits) - 1\n\n    # Postcondition 1: Ensure the result is a boolean.\n    assert isinstance(result, bool), \"The result must be a boolean.\"\n\n    # Postcondition 2: Ensure that if bits has a single element 0, the result is True.\n    if len(bits) == 1 and bits[0] == 0:\n        assert result is True, \"The result should be True when bits contains a single 0.\"\n\n    # Postcondition 3: Ensure that the result is True if bits ends with [1, 0, 0].\n    if len(bits) >= 3 and bits[-3:] == [1, 0, 0]:\n        assert result is True, \"The result should be True when bits ends with [1, 0, 0].\"\n\n  \n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1,1,1,1,1,0]) == False\n\tassert candidate([1,1,1,0,0]) == True\n\tassert candidate([1,1,1,1,1,1,1,1,1,0]) == False\n\tassert candidate([1,0,1,0,1,0,1,0,1,0,1,0]) == False\n\tassert candidate([1,0]) == False\n\tassert candidate([1,1,1,0]) == False\n\tassert candidate(\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]) == True\n\tassert candidate([1,0,1,0,1,0,1,0,1,0,0]) == True\n\tassert candidate([1,1,0,0]) == True\n\tassert candidate([1,0,1,0,0]) == True\n\tassert candidate([1,0,1,0,1,0,1,0]) == False\n\tassert candidate([0]) == True\n\tassert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]) == False\n\tassert candidate([1,1,1,1,1,1,1,1,0,0]) == True\n\tassert candidate([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == True\n\tassert candidate([0,0,0,0,0,0,0,0,0,1,0]) == False\n\tassert candidate([1,1,0,1,0]) == False\n\tassert candidate([0,0,0,0,0]) == True\n\tassert candidate([1,0,1,0,1,0,0]) == True\n\tassert candidate([1,0,1,0,1,0]) == False\n\tassert candidate([1,0,0]) == True\ndef test_check():\n\tcheck(is_one_bit_character)\n# Metadata Difficulty: Easy\n# Metadata Topics: array\n# Metadata Coverage: 100\ntest_check()"}
{"id": 533, "filename": "LeetCode_533_to_lower_case.py", "content": "def to_lower_case(s: str) -> str:\n    \"\"\"\n    Given a string s, return the string after replacing every uppercase letter with the same lowercase letter.\n\u00a0\n    Example 1:\n\n    Input: s = \"Hello\"\n    Output: \"hello\"\n\n    Example 2:\n\n    Input: s = \"here\"\n    Output: \"here\"\n\n    Example 3:\n\n    Input: s = \"LOVELY\"\n    Output: \"lovely\"\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 100\n    s consists of printable ASCII characters.\n    \"\"\"\n    # Precondition 1: Ensure that the length of the string is within the allowed range.\n    # assert 1 <= len(s) <= 100, \"The length of the string must be between 1 and 100.\"\n\n    # Precondition 2: Ensure that all characters in the string are printable ASCII characters.\n    # assert all(32 <= ord(char) <= 126 for char in s), \"All characters in the string must be printable ASCII characters.\"\n\n    # Convert the string to lowercase\n    result = s.lower()\n\n    # Postcondition 1: Ensure that the length of the result is the same as the input string.\n    assert len(result) == len(s), \"The length of the result should be the same as the input string.\"\n\n    # Postcondition 2: Ensure that the result contains only lowercase letters where the input had uppercase letters.\n    assert all(result[i] == s[i].lower() for i in range(len(s))), \"The result should have all uppercase letters converted to lowercase.\"\n\n    # Postcondition 3: Ensure that non-uppercase characters remain unchanged.\n    assert all((not s[i].isupper() and result[i] == s[i]) for i in range(len(s)) if not s[i].isupper()), \"Non-uppercase characters should remain unchanged.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"lowercasealready\") == \"lowercasealready\"\n\tassert candidate(\"SPECIAL CHARACTERS @#$%\") == \"special characters @#$%\"\n\tassert candidate(\"SingleWord\") == \"singleword\"\n\tassert candidate(\"AbCdEfG\") == \"abcdefg\"\n\tassert candidate(\"Very Long String\") == \"very long string\"\n\tassert candidate(\"EndsWithSpace \") == \"endswithspace \"\n\tassert candidate(candidate(\"UPPERCASE\")) == candidate(\"UPPERCASE\")\n\tassert candidate(\n    \"Python + Is + Really + Great!\") == \"python + is + really + great!\"\n\tassert candidate(\"12345\") == \"12345\"\n\tassert candidate(candidate(\"Hello World\")) == candidate(\"Hello World\")\n\tassert candidate(\"JavA\\t\") == \"java\\t\"\n\tassert candidate(\"1A2B3C\") == \"1a2b3c\"\n\tassert candidate(\"UPPERCASE\") == \"uppercase\"\n\tassert candidate(\"WoRLd\") == \"world\"\n\tassert candidate(\"Abc\\t\") == \"abc\\t\"\n\tassert candidate(\"Lowercase\") == \"lowercase\"\n\tassert candidate(\"mIxEdCaSeWiThSpEcIaLcHaRaCtErS@#$%\") == \"mixedcasewithspecialcharacters@#$%\"\n\tassert candidate(\"AbcDEFG\") == \"abcdefg\"\n\tassert candidate(\"TEST_CASE\") == \"test_case\"\n\tassert candidate(\"LoWeRcAsE\") == \"lowercase\"\n\tassert candidate(\"Abc\\tDeF\\t\") == \"abc\\tdef\\t\"\n\tassert candidate(\"Tab\\tSpaces\") == \"tab\\tspaces\"\n\tassert candidate(\"Abc\\n\") == \"abc\\n\"\n\tassert candidate(\"abcDEFG\") == \"abcdefg\"\n\tassert candidate(\"No Changes\") == \"no changes\"\n\tassert candidate(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&'()*+,-./:;<=>?@[]^_`{|}~  \\t\\n\\r\\x0b\\x0c\") == \\\n       \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!#$%&'()*+,-./:;<=>?@[]^_`{|}~  \\t\\n\\r\\x0b\\x0c\"\n\tassert candidate(candidate(\"SPECIAL CHARACTERS @#$%\")) == candidate(\"SPECIAL CHARACTERS @#$%\")\n\tassert candidate(\"Multiple     Spaces\") == \"multiple     spaces\"\n\tassert candidate(\"Both Ends \") == \"both ends \"\n\tassert candidate(\"  Extra  Spaces  \") == \"  extra  spaces  \"\n\tassert candidate(\"W\") == \"w\"\n\tassert candidate(\"JAVA\\t\") == \"java\\t\"\n\tassert candidate(candidate(\"HELLO WORLD\")) == candidate(\"HELLO WORLD\")\n\tassert candidate(candidate(\"LOWERCASE\")) == candidate(\"LOWERCASE\")\n\tassert candidate(\"HELLO\") == \"hello\"\n\tassert candidate(candidate(\"H\\ne\\tl\\tl\\to\")) == candidate(\"H\\ne\\tl\\tl\\to\")\n\tassert candidate(\"\") == \"\"\n\tassert candidate(candidate(\"Here is a sentence that will be lowercased.\")) == candidate(\"Here is a sentence that will be lowercased.\")\n\tassert candidate(\"ABCDEFG\\n\") == \"abcdefg\\n\"\n\tassert candidate(\"With Numbers 12345\") == \"with numbers 12345\"\n\tassert candidate(\"L\") == \"l\"\n\tassert candidate(candidate(\"Test\\nString\\tTo\\fBe\\bLowerCased\")) == candidate(\"Test\\nString\\tTo\\fBe\\bLowerCased\")\n\tassert candidate(\"LoWeRcAsE 123 ABC\") == \"lowercase 123 abc\"\n\tassert candidate(\"ABCDEFG\") == \"abcdefg\"\n\tassert candidate(\" Starts with space\") == \" starts with space\"\n\tassert candidate(\"SPECIAL chars @#$%\") == \"special chars @#$%\"\n\tassert candidate(\"mIXeD CaSe\") == \"mixed case\"\n\tassert candidate(\"Abc  DeF\\n\") == \"abc  def\\n\"\n\tassert candidate(\"123ABC\") == \"123abc\"\n\tassert candidate(\n    \"HELLO WORLD 123456 @#$%^&*() aBcDeF G\") == \"hello world 123456 @#$%^&*() abcdef g\"\n\tassert candidate(\"1aBcDeFg\") == \"1abcdefg\"\n\tassert candidate(\"123\") == \"123\"\n\tassert candidate(\"Abc\\nDef\") == \"abc\\ndef\"\n\tassert candidate(\"Hello\\nWorld\") == \"hello\\nworld\"\n\tassert candidate(\"Abc\") == \"abc\"\n\tassert candidate(\"abCdEfG\") == \"abcdefg\"\n\tassert candidate(\"PYTHON\") == \"python\"\n\tassert candidate(\"@#!$%^&*()\") == \"@#!$%^&*()\"\ndef test_check():\n\tcheck(to_lower_case)\n# Metadata Difficulty: Easy\n# Metadata Topics: string\n# Metadata Coverage: 100\ntest_check()"}
{"id": 632, "filename": "LeetCode_632_largeGroupPositions.py", "content": "from typing import List\n\ndef largeGroupPositions(s: str) -> List[List[int]]:\n    \"\"\"\n    In a string s\u00a0of lowercase letters, these letters form consecutive groups of the same character.\n    For example, a string like s = \"abbxxxxzyy\" has the groups \"a\", \"bb\", \"xxxx\", \"z\", and\u00a0\"yy\".\n    A group is identified by an interval\u00a0[start, end], where\u00a0start\u00a0and\u00a0end\u00a0denote the start and end\u00a0indices (inclusive) of the group. In the above example,\u00a0\"xxxx\"\u00a0has the interval\u00a0[3,6].\n    A group is considered\u00a0large\u00a0if it has 3 or more characters.\n    Return\u00a0the intervals of every large group sorted in\u00a0increasing order by start index.\n\u00a0\n    Example 1:\n\n    Input: s = \"abbxxxxzzy\"\n    Output: [[3,6]]\n    Explanation: \"xxxx\" is the only large group with start index 3 and end index 6.\n\n    Example 2:\n\n    Input: s = \"abc\"\n    Output: []\n    Explanation: We have groups \"a\", \"b\", and \"c\", none of which are large groups.\n\n    Example 3:\n\n    Input: s = \"abcdddeeeeaabbbcd\"\n    Output: [[3,5],[6,9],[12,14]]\n    Explanation: The large groups are \"ddd\", \"eeee\", and \"bbb\".\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 1000\n    s contains lowercase English letters only.\n    \"\"\"\n    # Precondition 1: Ensure the string length is within the allowed range.\n    assert 0 <= len(s) <= 1000, len(s)\n\n    # Precondition 2: Ensure the string only contains lowercase English letters.\n    assert all('a' <= char <= 'z' for char in s), \"String must contain only lowercase English letters.\"\n\n    result = []\n    start = 0\n    for i in range(1, len(s)):\n        if s[i] != s[start]:\n            if i - start >= 3:\n                result.append([start, i - 1])\n            start = i\n    if len(s) - start >= 3:\n        result.append([start, len(s) - 1])\n\n    # Postcondition 1: Ensure the result is a list of lists.\n    assert all(isinstance(group, list) and len(group) == 2 for group in result), \"Each group in the result should be a list of two integers.\"\n\n    # Postcondition 2: Ensure the result intervals are valid and sorted.\n    for i in range(1, len(result)):\n        assert result[i-1][1] < result[i][0], \"The intervals in the result should be non-overlapping and sorted by the start index.\"\n\n    # Postcondition 3: Ensure all large groups have a length of at least 3.\n    assert all(end - start + 1 >= 3 for start, end in result), \"All groups in the result must have a length of at least 3.\"\n\n    return result\n\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"abcdddeeeeaabbbcd\") == [[3, 5], [6, 9], [12, 14]]\n\tassert candidate(\"bbbbb\") == [[0, 4]]\n\tassert candidate(\"aaaaaaaaa\") == [[0, 8]]\n\tassert candidate(\"aaaaaa\") == [[0, 5]]\n\tassert candidate(\"abbxxxxzzy\") == [[3, 6]]\n\tassert candidate(\"aaaaaaaaaa\") == [[0, 9]]\n\tassert candidate(\n    \"aaabbbbccddddd\"\n) == [[0, 2], [3, 6], [9, 13]]\n\tassert candidate(\n    \"aaaabbbbccccddddd\"\n) == [[0, 3], [4, 7], [8, 11], [12, 16]]\n\tassert candidate(\"\") == []\n\tassert candidate(\"aaaa\") == [[0, 3]]\n\tassert candidate(\"aa\") == []\n\tassert candidate(\"aaaaa\") == [[0, 4]]\n\tassert candidate(\"aabbccdd\") == []\n\tassert candidate(\"bbbb\") == [[0, 3]]\n\tassert candidate(\"aaabbbbccddddd\") == [[0, 2], [3, 6], [9, 13]]\n\tassert candidate(\"aabb\") == []\n\tassert candidate(\n    \"abcdddeeeeaabbbcd\"\n) == [[3, 5], [6, 9], [12, 14]]\n\tassert candidate(\"aabaa\") == []\n\tassert candidate(\"aaaabbbbcccc\") == [[0, 3], [4, 7], [8, 11]]\n\tassert candidate(\"bbaa\") == []\n\tassert candidate(\"bbb\") == [[0, 2]]\n\tassert candidate(\"aaaabbbbccccddddd\") == [[0, 3], [4, 7], [8, 11], [12, 16]]\n\tassert candidate(\"aaa\") == [[0, 2]]\n\tassert candidate(\"aaaabbbb\") == [[0, 3], [4, 7]]\n\tassert candidate(\"aaaabbbbb\") == [[0, 3], [4, 8]]\n\tassert candidate(\"abb\") == []\n\tassert candidate(\"a\") == []\n\tassert candidate(\"aaaaaaaa\") == [[0, 7]]\n\tassert candidate(\"abc\") == []\ndef test_check():\n\tcheck(largeGroupPositions)\n# Metadata Difficulty: Easy\n# Metadata Topics: string\n# Metadata Coverage: 100\ntest_check()"}
{"id": 634, "filename": "LeetCode_634_flipAndInvertImage.py", "content": "from typing import List\n\ndef flipAndInvertImage(image: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n    To flip an image horizontally means that each row of the image is reversed.\n\n    For example, flipping [1,1,0] horizontally results in [0,1,1].\n\n    To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n\n\u00a0\n    Example 1:\n\n    Input: image = [[1,1,0],[1,0,1],[0,0,0]]\n    Output: [[1,0,0],[0,1,0],[1,1,1]]\n    Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].\n    Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]\n\n    Example 2:\n\n    Input: image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\n    Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n    Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].\n    Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n\n\u00a0\n    Constraints:\n\n    n == image.length\n    n == image[i].length\n    1 <= n <= 20\n    images[i][j] is either 0 or 1.\n\n    \"\"\"\n    # Precondition 1: Ensure the image is a square matrix of binary values.\n    n = len(image)\n    assert 1 <= n <= 20, \"The matrix size must be between 1 and 20.\"\n    for row in image:\n        # assert len(row) == n, \"The matrix must be square.\"\n        assert all(cell in [0, 1] for cell in row), \"The matrix can only contain binary values (0 or 1).\"\n\n    for row in image:\n        row.reverse()\n        for j in range(len(row)):\n            row[j] = 1 - row[j]\n\n    # Postcondition 1: Ensure the image remains a square matrix after processing.\n    # assert len(image) == n and all(len(row) == n for row in image), \"The matrix size should remain unchanged and square.\"\n\n    # Postcondition 2: Ensure the values are correctly inverted (i.e., only 0s and 1s remain).\n    for row in image:\n        assert all(cell in [0, 1] for cell in row), \"The matrix should only contain binary values (0 or 1) after processing.\"\n\n    return image\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([[1,1,1,1],[0,0,0,0],[1,1,1,1]]) == [[0,0,0,0],[1,1,1,1],[0,0,0,0]]\n\tassert candidate([[1,0,0,1],[0,1,1,0],[1,0,0,1]]) == [[0,1,1,0],[1,0,0,1],[0,1,1,0]]\n\tassert candidate([[0,1],[1,0]]) == [[0,1],[1,0]]\n\tassert candidate([[1,0,1],[0,1,0],[1,0,1]]) == [[0,1,0],[1,0,1],[0,1,0]]\n\tassert candidate([[1,1,0,0],[0,0,1,1]]) == [[1,1,0,0],[0,0,1,1]]\n\tassert candidate([[0,0],[1,1]]) == [[1,1],[0,0]]\n\tassert candidate([[0,0]]) == [[1,1]]\n\tassert candidate([[1,1,1,1,1]]) == [[0,0,0,0,0]]\n\tassert candidate([[1,1],[1,1]]) == [[0,0],[0,0]]\n\tassert candidate([[0]]) == [[1]]\n\tassert candidate([[1,1,1],[1,1,1]]) == [[0,0,0],[0,0,0]]\n\tassert candidate([[1]]) == [[0]]\n\tassert candidate([[0,1,0],[0,1,0],[0,1,0]]) == [[1,0,1],[1,0,1],[1,0,1]]\n\tassert candidate([[0,0,0],[0,0,0]]) == [[1,1,1],[1,1,1]]\n\tassert candidate([[1,0,1,0]]) == [[1,0,1,0]]\ndef test_check():\n\tcheck(flipAndInvertImage)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,two-pointers,matrix,simulation\n# Metadata Coverage: 100\ntest_check()"}
{"id": 661, "filename": "LeetCode_661_lemonadeChange.py", "content": "from typing import List\n\ndef lemonadeChange(bills: List[int]) -> bool:\n    \"\"\"\n    At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5.\n    Note that you do not have any change in hand at first.\n    Given an integer array bills where bills[i] is the bill the ith customer pays, return true if you can provide every customer with the correct change, or false otherwise.\n\u00a0\n    Example 1:\n\n    Input: bills = [5,5,5,10,20]\n    Output: true\n    Explanation: \n    From the first 3 customers, we collect three $5 bills in order.\n    From the fourth customer, we collect a $10 bill and give back a $5.\n    From the fifth customer, we give a $10 bill and a $5 bill.\n    Since all customers got correct change, we output true.\n\n    Example 2:\n\n    Input: bills = [5,5,10,10,20]\n    Output: false\n    Explanation: \n    From the first two customers in order, we collect two $5 bills.\n    For the next two customers in order, we collect a $10 bill and give back a $5 bill.\n    For the last customer, we can not give the change of $15 back because we only have two $10 bills.\n    Since not every customer received the correct change, the answer is false.\n\n\u00a0\n    Constraints:\n\n    1 <= bills.length <= 105\n    bills[i] is either 5, 10, or 20.\n\n    \"\"\"\n    # Precondition 1: Ensure that all bills are either 5, 10, or 20.\n    assert all(bill in [5, 10, 20] for bill in bills), \"All bills must be 5, 10, or 20.\"\n\n    # Precondition 2: Ensure that the length of bills is within the given constraints.\n    assert 1 <= len(bills) <= 105, \"The number of customers should be between 1 and 105.\"\n\n    five, ten = 0, 0\n    for bill in bills:\n        if bill == 5:\n            five += 1\n        elif bill == 10:\n            if not five:\n                return False\n            five -= 1\n            ten += 1\n        else:\n            if ten and five:\n                ten -= 1\n                five -= 1\n            elif five >= 3:\n                five -= 3\n            else:\n                return False\n\n    # Postcondition 1: Ensure that the returned value is a boolean.\n    result = five >= 0 and ten >= 0\n    assert isinstance(result, bool), \"The result should be a boolean.\"\n\n    # Postcondition 2: Ensure that the function returns True only if all customers can be served.\n    if result is False:\n        assert sum([five, ten]) == 0, \"If not all customers are served, the sum of the remaining $5 and $10 bills should be zero.\"\n\n    return result\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([5, 10, 20, 5, 5, 10, 5, 20, 5]) == False\n\tassert candidate([5, 5, 5, 5, 5, 5, 5, 10, 10, 10, 20, 20]) == True\n\tassert candidate([5, 5, 5, 5, 10]) == True\n\tassert candidate([5, 5, 5, 5, 10, 10, 10, 10, 20, 20]) == False\n\tassert candidate([5, 5, 5, 10]) == True\n\tassert candidate([5, 5, 5, 5, 5, 5, 5, 10]) == True\n\tassert candidate([5, 10, 10]) == False\n\tassert candidate([5, 5, 5, 5, 5, 10, 20]) == True\n\tassert candidate([5, 5, 5, 5, 5, 10, 10, 10, 20]) == True\n\tassert candidate([20]) == False\n\tassert candidate([5, 5, 5, 10, 20]) == True\n\tassert candidate([5, 5, 10, 10, 20]) == False\n\tassert candidate([5, 5, 10, 20, 20]) == False\n\tassert candidate([5, 5, 5, 5, 5, 5, 5, 5, 10, 10, 10, 10, 20, 20, 20, 20]) == True\n\tassert candidate([5, 5, 5, 5, 10, 10, 10]) == True\n\tassert candidate([10, 10]) == False\n\tassert candidate([5, 10, 20, 20, 20]) == False\n\tassert candidate([5, 5, 5, 10, 10, 20, 20]) == False\n\tassert candidate([5, 10, 20, 20, 20, 20]) == False\n\tassert candidate([5, 5, 5, 5, 10, 10, 20]) == True\n\tassert candidate([5, 5, 5, 10, 20, 20]) == False\n\tassert candidate([5, 5, 20]) == False\n\tassert candidate([5, 5, 5, 5, 5, 5, 10, 10, 10, 20, 20]) == True\n\tassert candidate([5, 5, 10]) == True\n\tassert candidate([5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 10, 10, 10, 10, 20, 20, 20, 20]) == True\n\tassert candidate([5, 5, 10, 20, 5, 5, 5, 5, 5, 5, 10, 20, 20]) == True\n\tassert candidate([5, 5, 5, 5, 5, 10]) == True\n\tassert candidate([5, 10, 10, 20]) == False\n\tassert candidate([10]) == False\n\tassert candidate([5, 5, 5, 10, 20, 20, 20, 20, 20]) == False\n\tassert candidate([5, 5, 5, 5, 5, 5, 10, 10]) == True\n\tassert candidate([5, 5, 5, 5, 10, 20, 20, 20, 20]) == False\n\tassert candidate([5, 5, 10, 10, 20, 20]) == False\n\tassert candidate([5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 10, 10, 10, 10, 20, 20]) == True\n\tassert candidate([5, 5, 5, 5, 5, 5, 5, 5, 10, 10, 10, 20, 20, 20]) == True\n\tassert candidate([5, 10, 20]) == False\n\tassert candidate([5, 5, 5, 5, 5, 5, 10]) == True\n\tassert candidate([5, 10, 5, 5, 5, 10, 20]) == True\n\tassert candidate([5]) == True\n\tassert candidate([5, 5, 5, 5, 5, 5, 10, 20, 20, 20]) == False\ndef test_check():\n\tcheck(lemonadeChange)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,greedy\n# Metadata Coverage: 100\ntest_check()"}
{"id": 681, "filename": "LeetCode_681_projectionArea.py", "content": "from typing import List\n\ndef projectionArea(grid: List[List[int]]) -> int:\n    \"\"\"\n    You are given an n x n grid where we place some 1 x 1 x 1 cubes that are axis-aligned with the x, y, and z axes.\n    Each value v = grid[i][j] represents a tower of v cubes placed on top of the cell (i, j).\n    We view the projection of these cubes onto the xy, yz, and zx planes.\n    A projection is like a shadow, that maps our 3-dimensional figure to a 2-dimensional plane. We are viewing the \"shadow\" when looking at the cubes from the top, the front, and the side.\n    Return the total area of all three projections.\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[1,2],[3,4]]\n    Output: 17\n    Explanation: Here are the three projections (\"shadows\") of the shape made with each axis-aligned plane.\n\n    Example 2:\n\n    Input: grid = [[2]]\n    Output: 5\n\n    Example 3:\n\n    Input: grid = [[1,0],[0,2]]\n    Output: 8\n\n\u00a0\n    Constraints:\n\n    n == grid.length == grid[i].length\n    1 <= n <= 50\n    0 <= grid[i][j] <= 50\n\n    \"\"\"\n    # Precondition 1: Ensure the grid is a square matrix.\n    assert all(len(row) == len(grid) for row in grid), \"Grid must be a square matrix (n x n).\"\n    \n    # Precondition 2: Ensure that grid dimensions are within the allowed range.\n    assert 1 <= len(grid) <= 50, \"The grid size must be between 1 and 50.\"\n\n    # Precondition 3: Ensure that all elements in the grid are within the allowed range.\n    assert all(0 <= grid[i][j] <= 50 for i in range(len(grid)) for j in range(len(grid))), \"All grid values must be between 0 and 50.\"\n\n    n = len(grid)\n    top, front, side = 0, 0, 0\n    for i in range(n):\n        max_front, max_side = 0, 0\n        for j in range(n):\n            if grid[i][j] > 0:\n                top += 1\n            max_front = max(max_front, grid[i][j])\n            max_side = max(max_side, grid[j][i])\n        front += max_front\n        side += max_side\n\n    result = top + front + side\n\n    # Postcondition 1: Ensure the result is a non-negative integer.\n    assert isinstance(result, int) and result >= 0, \"The result should be a non-negative integer.\"\n\n    # Postcondition 2: The result should be greater than or equal to the sum of the max values for front and side views.\n    assert result >= (front + side), \"The total area should be greater than or equal to the sum of the front and side projections.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([[1,0,1],[0,0,0],[1,0,1]]) == 8\n\tassert candidate([[2,2,2],[2,1,2],[2,2,2]]) == 21\n\tassert candidate([[1,1,1],[1,0,1],[1,1,1]]) == 14\n\tassert candidate(\n    [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]) == 0\n\tassert candidate([[1,1],[1,1]]) == 8\n\tassert candidate([[1,2],[3,4]]) == 17\n\tassert candidate([[1,0],[0,2]]) == 8\n\tassert candidate([[2]]) == 5\ndef test_check():\n\tcheck(projectionArea)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,math,geometry,matrix\n# Metadata Coverage: 100\ntest_check()"}
{"id": 682, "filename": "LeetCode_682_uncommon_from_sentences.py", "content": "from typing import List\n\ndef uncommon_from_sentences(s1: str, s2: str) -> List[str]:\n    \"\"\"\n    A sentence is a string of single-space separated words where each word consists only of lowercase letters.\n    A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.\n    Given two sentences s1 and s2, return a list of all the uncommon words. You may return the answer in any order.\n\u00a0\n    Example 1:\n    Input: s1 = \"this apple is sweet\", s2 = \"this apple is sour\"\n    Output: [\"sweet\",\"sour\"]\n    Example 2:\n    Input: s1 = \"apple apple\", s2 = \"banana\"\n    Output: [\"banana\"]\n\n\u00a0\n    Constraints:\n\n    1 <= s1.length, s2.length <= 200\n    s1 and s2 consist of lowercase English letters and spaces.\n    s1 and s2 do not have leading or trailing spaces.\n    All the words in s1 and s2 are separated by a single space.\n    \"\"\"\n\n    word_count = {}\n    for word in (s1 + \" \" + s2).split():\n        word_count[word] = word_count.get(word, 0) + 1\n\n    result = [key for key, val in word_count.items() if val == 1]\n\n    # Postconditions\n    assert isinstance(result, list), \"The result should be a list.\"\n    assert all(isinstance(word, str) for word in result), \"Each element in the result list should be a string.\"\n    assert all((s1 + \" \" + s2).split().count(word) == 1 for word in result), \"Each word in the result should appear exactly once in the combined sentences.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"this apple is sweet\", \"this apple is sour\") == ['sweet', 'sour']\n\tassert candidate(\"blue red green\", \"green red blue\") == []\n\tassert candidate(\n    \"snow rain clouds\", \"rain clouds sunshine\") == ['snow', 'sunshine']\n\tassert candidate(\"two three\", \"four five\") == [\"two\", \"three\", \"four\", \"five\"]\n\tassert candidate(\"I am a student but I study hard\", \"I am a student and I study hard\") == ['but', 'and']\n\tassert candidate(\"apple orange\", \"orange banana\") == ['apple', 'banana']\n\tassert candidate(\"wine beer whiskey\", \"beer whiskey coke\") == ['wine', 'coke']\n\tassert candidate(\"January February March\", \"February March April\") == ['January', 'April']\n\tassert candidate(\"dogs cats birds\", \"cats birds fish\") == ['dogs', 'fish']\n\tassert candidate(\n    \"ice water vodka juice\",\n    \"juice water vodka martini\") == ['ice', 'martini']\n\tassert candidate(\"May June July\", \"June July August\") == ['May', 'August']\n\tassert candidate(\n    \"ice cream lemonade strawberry\", \"ice cream strawberry milk\") == ['lemonade', 'milk']\n\tassert candidate(\"day night day\", \"day night day\") == []\n\tassert candidate(\"orange\", \"orange orange\") == []\n\tassert candidate(\"hello world\", \"world goodbye\") == ['hello', 'goodbye']\n\tassert candidate(\"breakfast lunch dinner\", \"lunch dinner dessert\") == ['breakfast', 'dessert']\n\tassert candidate(\"Saturday Sunday Monday\", \"Sunday Monday Friday\") == ['Saturday', 'Friday']\n\tassert candidate(\"spring summer fall\", \"summer fall winter\") == ['spring', 'winter']\n\tassert candidate(\"apple\", \"apple\") == []\n\tassert candidate(\"lion tiger bear\", \"tiger bear elephant\") == ['lion', 'elephant']\n\tassert candidate(\"red blue green\", \"blue yellow purple\") == ['red', 'green', 'yellow', 'purple']\n\tassert candidate(\"cat dog cow pig\", \"dog cow pig sheep\") == ['cat', 'sheep']\n\tassert candidate(\"a a a b b\", \"a b c d e\") == [\"c\", \"d\", \"e\"]\n\tassert candidate(\"b b b c\", \"b b b c\") == []\n\tassert candidate(\"b b b\", \"a b c b\") == ['a', 'c']\n\tassert candidate(\"apple apple\", \"banana\") == ['banana']\n\tassert candidate(\"black white pink\", \"white pink purple\") == ['black', 'purple']\n\tassert candidate(\"apple apple\", \"banana\") == [\"banana\"]\n\tassert candidate(\"a b c d e f\", \"a b c d e f\") == []\n\tassert candidate(\"\", \"\") == []\n\tassert candidate(\"one two three\", \"two three four\") == ['one', 'four']\n\tassert candidate(\"circle square triangle\", \"square triangle rectangle\") == ['circle', 'rectangle']\n\tassert candidate(\"\", \"one\") == [\"one\"]\n\tassert candidate(\"a b c d\", \"\") == [\"a\", \"b\", \"c\", \"d\"]\n\tassert candidate(\"apple banana\", \"banana orange\") == ['apple', 'orange']\n\tassert candidate(\"car bus train\", \"bus train plane\") == ['car', 'plane']\n\tassert candidate(\"I like Python\", \"I like Java\") == ['Python', 'Java']\n\tassert candidate(\"one\", \"\") == [\"one\"]\n\tassert candidate(\"one\", \"one\") == []\n\tassert candidate(\"peach pear plum\", \"plum pear peach\") == []\n\tassert candidate(\n    \"apple orange banana\", \"apple orange banana\") == []\n\tassert candidate(\"dog cat pig\", \"cat dog rat\") == ['pig', 'rat']\n\tassert candidate(\"a b c d e f\", \"a b c d f\") == [\"e\"]\n\tassert candidate(\"two three\", \"two three\") == []\n\tassert candidate(\"a a a a a a\", \"a a a a a a\") == []\n\tassert candidate(\"two three\", \"three four\") == [\"two\", \"four\"]\n\tassert candidate(\"cat dog cow pig\", \"pig cow dog goat\") == ['cat', 'goat']\n\tassert candidate(\"william john james\", \"john william james\") == []\n\tassert candidate(\"March April May\", \"April May June\") == ['March', 'June']\n\tassert candidate(\"pencil paper book\", \"paper book ruler\") == ['pencil', 'ruler']\n\tassert candidate(\"four five\", \"four five six seven\") == [\"six\", \"seven\"]\n\tassert candidate(\n    \"Same sentence same sentence same sentence\",\n    \"Same sentence same sentence same sentence\"\n) == []\n\tassert candidate(\"pencil marker eraser\", \"marker eraser pencil\") == []\n\tassert candidate(\"two three\", \"\") == [\"two\", \"three\"]\n\tassert candidate(\"dog cat cow pig\", \"cat pig dog rat\") == ['cow', 'rat']\n\tassert candidate(\"January February\", \"February March\") == ['January', 'March']\n\tassert candidate(\"gold silver bronze\", \"silver bronze platinum\") == ['gold', 'platinum']\n\tassert candidate(\"sun moon stars\", \"moon stars planets\") == ['sun', 'planets']\n\tassert candidate(\"this apple is sweet\", \"this apple is sour\") == [\"sweet\", \"sour\"]\n\tassert candidate(\"four five\", \"four five six\") == [\"six\"]\n\tassert candidate(\"morning afternoon evening\", \"afternoon evening night\") == ['morning', 'night']\n\tassert candidate(\"pizza burger fries\", \"burger fries soda\") == ['pizza', 'soda']\n\tassert candidate(\"Monday Tuesday\", \"Tuesday Wednesday\") == ['Monday', 'Wednesday']\n\tassert candidate(\"snow rain clouds\", \"clouds rain rainfall\") == ['snow', 'rainfall']\n\tassert candidate(\"red green blue\", \"green blue yellow\") == ['red', 'yellow']\n\tassert candidate(\"coffee tea juice\", \"tea juice water\") == ['coffee', 'water']\ndef test_check():\n\tcheck(uncommon_from_sentences)\n# Metadata Difficulty: Easy\n# Metadata Topics: hash-table,string\n# Metadata Coverage: 100\ntest_check()"}
{"id": 768, "filename": "LeetCode_768_sortedSquares.py", "content": "from typing import List\n\ndef sortedSquares(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.\n\u00a0\n    Example 1:\n\n    Input: nums = [-4,-1,0,3,10]\n    Output: [0,1,9,16,100]\n    Explanation: After squaring, the array becomes [16,1,0,9,100].\n    After sorting, it becomes [0,1,9,16,100].\n\n    Example 2:\n\n    Input: nums = [-7,-3,2,3,11]\n    Output: [4,9,9,49,121]\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 104\n    -104 <= nums[i] <= 104\n    nums is sorted in non-decreasing order.\n\n\u00a0\n    Follow up: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach?\n    \"\"\"\n    # Preconditions\n    assert 0 <= len(nums) <= 104, \"Length of nums should be between 1 and 10^4.\"\n    assert all(-10**4 <= num <= 10**4 for num in nums), \"Each element in nums must be between -10^4 and 10^4.\"\n    assert all(nums[i] <= nums[i+1] for i in range(len(nums) - 1)), \"nums should be sorted in non-decreasing order.\"\n\n    result = sorted([x ** 2 for x in nums])\n\n    # Postconditions\n    assert isinstance(result, list), \"The result should be a list.\"\n    assert all(result[i] <= result[i+1] for i in range(len(result) - 1)), \"The result should be sorted in non-decreasing order.\"\n    # assert all(result[i] == nums[i] ** 2 for i in range(len(nums))), \"Each element in the result should be the square of the corresponding element in nums.\"\n\n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\n    [-3, -2, -1, 0, 1, 2, 3, 5]) == [0, 1, 1, 4, 4, 9, 9, 25]\n\tassert candidate([-3, -2, 0, 2, 3]) == [0, 4, 4, 9, 9]\n\tassert candidate([0]) == [0]\n\tassert candidate([-5, -3, -1, 0, 1, 2, 3]) == [0, 1, 1, 4, 9, 9, 25]\n\tassert candidate([-4, -1, 0, 3, 10]) == [0, 1, 9, 16, 100]\n\tassert candidate([-3, -2, -1, 0, 1, 2, 3, 5]) == [0, 1, 1, 4, 4, 9, 9, 25]\n\tassert candidate([-5, -4, -3, -2, -1]) == [1, 4, 9, 16, 25]\n\tassert candidate([1, 2, 3, 4, 5]) == [1, 4, 9, 16, 25]\n\tassert candidate([-1]) == [1]\n\tassert candidate([-10, 10]) == [100, 100]\n\tassert candidate([-3, -2, 0, 2, 3, 5]) == [0, 4, 4, 9, 9, 25]\n\tassert candidate([-3, -2, -1, 0, 1, 2, 3]) == [0, 1, 1, 4, 4, 9, 9]\n\tassert candidate([-7, -3, 2, 3, 11]) == [4, 9, 9, 49, 121]\n\tassert candidate([1]) == [1]\n\tassert candidate([-50, -20, -10]) == [100, 400, 2500]\n\tassert candidate(\n    []) == []\ndef test_check():\n\tcheck(sortedSquares)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,two-pointers,sorting\n# Metadata Coverage: 100\ntest_check()"}
{"id": 788, "filename": "LeetCode_788_commonChars.py", "content": "from typing import List\nfrom collections import Counter\n\ndef commonChars(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.\n\u00a0\n    Example 1:\n    Input: words = [\"bella\",\"label\",\"roller\"]\n    Output: [\"e\",\"l\",\"l\"]\n    Example 2:\n    Input: words = [\"cool\",\"lock\",\"cook\"]\n    Output: [\"c\",\"o\"]\n\n\u00a0\n    Constraints:\n\n    1 <= words.length <= 100\n    1 <= words[i].length <= 100\n    words[i] consists of lowercase English letters.\n    \"\"\"\n    \n    # Preconditions\n    assert isinstance(words, list), \"Input must be a list.\"\n    assert all(isinstance(word, str) for word in words), \"All elements in the input list must be strings.\"\n    assert all(1 <= len(word) <= 100 for word in words), \"Each string must have a length between 1 and 100.\"\n    assert all(word.islower() and word.isalpha() for word in words), \"Each string must consist only of lowercase English letters.\"\n\n    merged = Counter()\n    for word in words:\n        word_count = Counter(word)\n        if not merged:\n            merged = word_count\n        else:\n            for char in merged:\n                merged[char] = min(merged[char], word_count[char])\n\n    result = []\n    for char, count in merged.items():\n        result.extend([char] * count)\n    \n    # Postconditions\n    assert isinstance(result, list), \"Output must be a list.\"\n    assert all(isinstance(ch, str) and len(ch) == 1 for ch in result), \"All elements in the output list must be single-character strings.\"\n    assert all(ch.islower() and ch.isalpha() for ch in result), \"Each character in the output list must be a lowercase English letter.\"\n    assert all(result.count(ch) == min(word.count(ch) for word in words) for ch in set(result)), \"Each character must appear in all input strings the correct number of times.\"\n    \n    return result\n\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([\"python\",\"java\",\"csharp\"]) == []\n\tassert candidate([\"pizza\",\"sandwich\",\"pasta\"]) == ['a']\n\tassert candidate([\"hello\",\"world\",\"python\"]) == ['o']\n\tassert candidate([\"bella\",\"label\",\"roller\"]) == ['e', 'l', 'l']\n\tassert candidate([\"chinese\",\"japanese\",\"marathi\"]) == []\n\tassert candidate([\"apple\",\"orange\",\"banana\"]) == ['a']\n\tassert candidate([\"pizza\",\"sandwich\",\"pasta\",\"salad\"]) == ['a']\n\tassert candidate([\"kid\",\"kidsss\"]) == ['k', 'i', 'd']\n\tassert candidate([\"abc\",\"def\"]) == []\n\tassert candidate([\"chinese\",\"japanese\",\"malayalam\"]) == []\n\tassert candidate([\"cool\",\"lock\",\"cook\"]) == ['c', 'o']\n\tassert candidate([\"and\",\"find\",\"common\"]) == ['n']\n\tassert candidate([\"code\",\"code\",\"code\"]) == ['c', 'o', 'd', 'e']\n\tassert candidate([\"chinese\",\"japanese\",\"gujarati\"]) == []\n\tassert candidate([\"python\",\"pythonista\",\"pythonic\"]) == ['p', 'y', 't', 'h', 'o', 'n']\n\tassert candidate([\"so\",\"we\",\"test\"]) == []\n\tassert candidate([\"kid\",\"kids\"]) == ['k', 'i', 'd']\n\tassert candidate([\"a\",\"ab\",\"abc\"]) == ['a']\ndef test_check():\n\tcheck(commonChars)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,hash-table,string\n# Metadata Coverage: 100\ntest_check()"}
{"id": 793, "filename": "LeetCode_793_height_checker.py", "content": "from typing import List\n\ndef height_checker(heights: List[int]) -> int:\n    \"\"\"\n    A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line.\n    You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed).\n    Return the number of indices where heights[i] != expected[i].\n\u00a0\n    Example 1:\n\n    Input: heights = [1,1,4,2,1,3]\n    Output: 3\n    Explanation: \n    heights:  [1,1,4,2,1,3]\n    expected: [1,1,1,2,3,4]\n    Indices 2, 4, and 5 do not match.\n\n    Example 2:\n\n    Input: heights = [5,1,2,3,4]\n    Output: 5\n    Explanation:\n    heights:  [5,1,2,3,4]\n    expected: [1,2,3,4,5]\n    All indices do not match.\n\n    Example 3:\n\n    Input: heights = [1,2,3,4,5]\n    Output: 0\n    Explanation:\n    heights:  [1,2,3,4,5]\n    expected: [1,2,3,4,5]\n    All indices match.\n\n\u00a0\n    Constraints:\n\n    1 <= heights.length <= 100\n    1 <= heights[i] <= 100\n\n    \"\"\"\n    \n    # Preconditions\n    assert isinstance(heights, list), \"Input must be a list.\"\n    assert all(isinstance(height, int) for height in heights), \"All elements in the list must be integers.\"\n    assert 1 <= len(heights) <= 100, \"The length of the list must be between 1 and 100.\"\n    assert all(1 <= height <= 100 for height in heights), \"Each height must be between 1 and 100.\"\n\n    expected = sorted(heights)\n    count = 0\n    for i in range(len(heights)):\n        if heights[i] != expected[i]:\n            count += 1\n\n    # Postconditions\n    assert isinstance(count, int), \"Output must be an integer.\"\n    assert 0 <= count <= len(heights), \"Output must be between 0 and the length of the input list.\"\n\n    return count\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([10,10,3,1,2,1,3,2,1,3]) == 8\n\tassert candidate(\n    [1]) == 0\n\tassert candidate([5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]) == 0\n\tassert candidate([1,2,3,4,5]) == 0\n\tassert candidate(\n    [1,2,3,4]) == 0\n\tassert candidate([1,2,3,4,5,6,7,8,9,10]) == 0\n\tassert candidate([5,1,2,3,4]) == 5\n\tassert candidate(list(range(1, 101))) == 0\n\tassert candidate([3,2,1,3,2,1,3,2,1]) == 6\n\tassert candidate(\n    [1,2,3,4,5]) == 0\n\tassert candidate( [5,1,2,3,4]) == 5\n\tassert candidate(\n    [5,1,2,3,4]) == 5\n\tassert candidate(\n    [3,2,5,1,4]) == 4\n\tassert candidate([2,2,2,2,2]) == 0\n\tassert candidate([10,9,8,7,6,5,4,3,2,1]) == 10\n\tassert candidate(\n    [4,3,2,5,1]) == 5\n\tassert candidate([2,1,4,3,6,5,8,7,10,9]) == 10\n\tassert candidate([2,2,2,1,1,1,3,3,3]) == 6\n\tassert candidate(\n    [2,5,4,3,1]) == 5\n\tassert candidate([1]) == 0\n\tassert candidate([1,1,4,2,1,3]) == 3\n\tassert candidate(list(range(100, 0, -1))) == 100\n\tassert candidate([1,1,1,2,2,2,3,3,3]) == 0\n\tassert candidate(\n    [2,1,5,3,6,4,8,7,10,9]) == 10\n\tassert candidate([10,1,2,3,4,5,6,7,8,9]) == 10\n\tassert candidate( [1,2,3,4,5]) == 0\n\tassert candidate(\n    [1,2,3,5,4]) == 2\n\tassert candidate(\n    [1,2,3,4,4]) == 0\n\tassert candidate([1,1,1,1,1,1]) == 0\ndef test_check():\n\tcheck(height_checker)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,sorting,counting-sort\n# Metadata Coverage: 100\ntest_check()"}
{"id": 822, "filename": "LeetCode_822_allCellsDistOrder.py", "content": "from typing import List\n\ndef allCellsDistOrder(rows: int, cols: int, rCenter: int, cCenter: int) -> List[List[int]]:\n    \"\"\"\n    You are given four integers rows, cols, rCenter, and cCenter. There is a rows x cols matrix and you are on the cell with the coordinates (rCenter, cCenter).\n    Return the coordinates of all cells in the matrix, sorted by their distance from (rCenter, cCenter) from the smallest distance to the largest distance. You may return the answer in any order that satisfies this condition.\n    The distance between two cells (r1, c1) and (r2, c2) is |r1 - r2| + |c1 - c2|.\n    \"\"\"\n\n    # Preconditions\n    assert isinstance(rows, int) and isinstance(cols, int) and isinstance(rCenter, int) and isinstance(cCenter, int), \\\n        \"All inputs should be integers.\"\n    assert 1 <= rows <= 100 and 1 <= cols <= 100, \\\n        \"Rows and cols should be between 1 and 100.\"\n    assert 0 <= rCenter < rows and 0 <= cCenter < cols, \\\n        \"rCenter and cCenter should be valid indices within the grid.\"\n\n    coordinates = [[i, j] for i in range(rows) for j in range(cols)]\n    coordinates.sort(key=lambda x: abs(x[0] - rCenter) + abs(x[1] - cCenter))\n\n    # Postconditions\n    assert isinstance(coordinates, list) and all(isinstance(coord, list) for coord in coordinates), \\\n        \"Output should be a list of lists.\"\n    assert all(len(coord) == 2 for coord in coordinates) and \\\n           all(0 <= coord[0] < rows and 0 <= coord[1] < cols for coord in coordinates), \\\n        \"Each coordinate should have two valid integers within the matrix.\"\n    assert len(coordinates) == rows * cols, \\\n        \"The number of coordinates in the output should match the total number of cells in the matrix.\"\n    \n    distances = [abs(x[0] - rCenter) + abs(x[1] - cCenter) for x in coordinates]\n    assert all(distances[i] <= distances[i + 1] for i in range(len(distances) - 1)), \\\n        \"Coordinates should be sorted by their distance from the center.\"\n\n    return coordinates\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(2, 2, 0, 0) == [[0, 0], [0, 1], [1, 0], [1, 1]]\n\tassert candidate(1, 2, 0, 0) == [[0, 0], [0, 1]]\n\tassert candidate(1, 1, 0, 0) == [[0, 0]]\n\tassert candidate(2, 1, 0, 0) == [[0, 0], [1, 0]]\n\tassert candidate(3, 3, 1, 1) == [[1, 1], [0, 1], [1, 0], [1, 2], [2, 1], [0, 0], [0, 2], [2, 0], [2, 2]]\n\tassert candidate(2, 3, 1, 2) == [[1, 2], [0, 2], [1, 1], [0, 1], [1, 0], [0, 0]]\n\tassert candidate(3, 3, 0, 0) == [[0, 0], [0, 1], [1, 0], [0, 2], [1, 1], [2, 0], [1, 2], [2, 1], [2, 2]]\n\tassert candidate(2, 3, 0, 1) == [[0, 1], [0, 0], [0, 2], [1, 1], [1, 0], [1, 2]]\ndef test_check():\n\tcheck(allCellsDistOrder)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,math,geometry,sorting,matrix\n# Metadata Coverage: 100\ntest_check()"}
{"id": 906, "filename": "LeetCode_906_num_equiv_domino_pairs.py", "content": "from typing import List\nfrom collections import defaultdict\n\ndef num_equiv_domino_pairs(dominoes: List[List[int]]) -> int:\n    \"\"\"\n    Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b == d), or (a == d and b == c) - that is, one domino can be rotated to be equal to another domino.\n    Return the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].\n    \"\"\"\n    \n    # Preconditions\n    assert isinstance(dominoes, list), \"Input should be a list.\"\n    assert all(isinstance(d, list) and len(d) == 2 for d in dominoes), \"Each domino should be a list of two integers.\"\n    # assert all(1 <= d[0] <= 9 and 1 <= d[1] <= 9 for d in dominoes), \"Domino values should be between 1 and 9.\"\n    # # assert 1 <= len(dominoes) <= 4 * 10**4, \"The length of dominoes should be within the range 1 to 40,000.\"\n    \n    freq = defaultdict(int)\n    result = 0\n    for domino in dominoes:\n        key = min(domino[0], domino[1]) * 10 + max(domino[0], domino[1])\n        result += freq[key]\n        freq[key] += 1\n\n    # Postconditions\n    assert isinstance(result, int), \"The result should be an integer.\"\n    assert result >= 0, \"The number of equivalent domino pairs cannot be negative.\"\n    \n    # If there are no equivalent dominoes, result should be 0\n    if len(dominoes) == len(set(tuple(sorted(d)) for d in dominoes)):\n        assert result == 0, \"If no equivalent pairs, result should be 0.\"\n\n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([[1,1],[2,2],[3,4],[5,6]]) == 0\n\tassert candidate([]) == 0\n\tassert candidate( [[2,1],[2,1],[2,1],[2,1]]) == 6\n\tassert candidate([[1,2],[1,2],[1,1],[1,2],[2,2]]) == 3\n\tassert candidate([[9,9],[9,9],[9,9],[9,9],[9,9],[9,9],[9,9]]) == 21\n\tassert candidate([[1,2],[3,4],[1,2]]) == 1\n\tassert candidate([[1,2],[2,3],[3,4],[4,5],[5,1]]) == 0\n\tassert candidate([[3,1],[3,1]]) == 1\n\tassert candidate( [[1,2],[2,1],[2,2],[2,2]]) == 2\n\tassert candidate([[1,1],[1,1],[1,1],[1,1]]) == 6\n\tassert candidate([[1,2],[3,4],[5,6],[7,8],[9,10],[10,9]]) == 1\n\tassert candidate(\n    [[6,5],[6,4],[6,2],[6,6],[4,3],[3,1],[5,1],[3,3],[5,5],[1,6],[5,2],[4,6],[3,2],[1,1],[5,6],[1,2],[4,4],[2,3],[1,3],[5,4],[4,1],[2,4],[3,5],[3,5],[2,2],[6,3],[3,4],[5,3],[2,6]]) == 9\n\tassert candidate( [[1,2],[3,4],[1,2],[3,4],[1,2],[3,4],[1,1],[3,3]]) == 6\n\tassert candidate([[1,2],[3,4],[5,6]]) == 0\n\tassert candidate([[1,1],[2,2],[3,3]]) == 0\n\tassert candidate(\n    [[6,5],[6,4],[6,2],[6,6],[4,3],[3,1],[5,1],[3,3],[5,5],[1,6],[5,2],[4,6],[3,2],[1,1],[5,6],[1,2],[4,4],[2,3],[1,3],[5,4],[4,1],[2,4],[3,5],[3,5]]) == 5\n\tassert candidate([[1,2],[2,1],[3,4],[5,6]]) == 1\n\tassert candidate(\n    [[6,5],[6,4],[6,2],[6,6],[4,3],[3,1],[5,1],[3,3],[5,5],[1,6],[5,2],[4,6],[3,2],[1,1],[5,6],[1,2],[4,4],[2,3],[1,3],[5,4],[4,1],[2,4],[3,5]]) == 4\ndef test_check():\n\tcheck(num_equiv_domino_pairs)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,hash-table,counting\n# Metadata Coverage: 100\ntest_check()"}
{"id": 910, "filename": "LeetCode_910_replaceElements.py", "content": "from typing import List\n\ndef replaceElements(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array arr, replace every element in that array with the greatest element among the elements to its right,\n    and replace the last element with -1. After doing so, return the array.\n    \"\"\"\n    \n    # Preconditions\n    assert isinstance(arr, list), \"Input must be a list.\"\n    assert all(isinstance(x, int) for x in arr), \"All elements in the list must be integers.\"\n    assert 1 <= len(arr) <= 10**4, \"Array length must be between 1 and 10^4.\"\n    assert all(1 <= x <= 10**5 for x in arr), \"Array elements must be between 1 and 10^5.\"\n    \n    n = len(arr)\n    maxElement = -1\n    for i in range(n - 1, -1, -1):\n        temp = arr[i]\n        arr[i] = maxElement\n        maxElement = max(maxElement, temp)\n    \n    # Postconditions\n    assert isinstance(arr, list), \"Output must be a list.\"\n    assert all(isinstance(x, int) for x in arr), \"All elements in the output must be integers.\"\n    assert len(arr) == n, \"Output list must have the same length as the input list.\"\n    assert arr[-1] == -1, \"The last element in the output list must be -1.\"\n    for i in range(n - 1):\n        assert arr[i] >= arr[i + 1] or arr[i] == -1, \"Each element must be the maximum of the elements to its right in the original array.\"\n    \n    return arr\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1,2,2,1,2,2,1,2,2]) == [2,2,2,2,2,2,2,2,-1]\n\tassert candidate([1,2,3,4,5]) == [5,5,5,5,-1]\n\tassert candidate(\n    [17,18,5,4,6,1]) == [18,6,6,6,1,-1]\n\tassert candidate(\n    [400]) == [-1]\n\tassert candidate([1,2,3,4,5,6,7]) == [7,7,7,7,7,7,-1]\n\tassert candidate([1,2]) == [2,-1]\n\tassert candidate( [17,18,5,4,6,1]) == [18,6,6,6,1,-1]\n\tassert candidate([1]) == [-1]\n\tassert candidate([1,1,1,1,1,1,1,1,1]) == [1,1,1,1,1,1,1,1,-1]\ndef test_check():\n\tcheck(replaceElements)\n# Metadata Difficulty: Easy\n# Metadata Topics: array\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1013, "filename": "LeetCode_1013_smallerNumbersThanCurrent.py", "content": "from typing import List\n\ndef smallerNumbersThanCurrent(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. \n    Return the answer in an array.\n    \"\"\"\n\n    # Preconditions\n    assert isinstance(nums, list), \"Input must be a list.\"\n    assert all(isinstance(x, int) for x in nums), \"All elements in the list must be integers.\"\n    assert 2 <= len(nums) <= 500, \"Array length must be between 2 and 500.\"\n    assert all(0 <= x <= 100 for x in nums), \"Array elements must be between 0 and 100.\"\n\n    result = []\n    for i in range(len(nums)):\n        count = 0\n        for j in range(len(nums)):\n            if i != j and nums[j] < nums[i]:\n                count += 1\n        result.append(count)\n\n    # Postconditions\n    assert isinstance(result, list), \"Output must be a list.\"\n    assert all(isinstance(x, int) for x in result), \"All elements in the output must be integers.\"\n    assert len(result) == len(nums), \"Output list must have the same length as the input list.\"\n    for i in range(len(nums)):\n        assert result[i] == sum(1 for j in nums if j < nums[i]), f\"Incorrect count for index {i}.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([3,3,3,3,3,3,3,3,3,3]) == [0,0,0,0,0,0,0,0,0,0]\n\tassert candidate(\n    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]) == [\n          0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]\n\tassert candidate([2,2,2,2,2,2,2,2,2,2]) == [0,0,0,0,0,0,0,0,0,0]\n\tassert candidate([6,6,6,6,6,6,6,6,6,6]) == [0,0,0,0,0,0,0,0,0,0]\n\tassert candidate([50,40,30,20,10]) == [4,3,2,1,0]\n\tassert candidate([1,1,1,1,1]) == [0,0,0,0,0]\n\tassert candidate([0,0,0,100,100]) == [0,0,0,3,3]\n\tassert candidate([10,20,30,40,50,60,70,80,90,100]) == [0,1,2,3,4,5,6,7,8,9]\n\tassert candidate([100,90,80,70,60,50,40,30,20,10]) == [9,8,7,6,5,4,3,2,1,0]\n\tassert candidate([50,50,50,50,50]) == [0,0,0,0,0]\n\tassert candidate([1,2,3,4,5]) == [0,1,2,3,4]\n\tassert candidate([5,4,3,2,1]) == [4,3,2,1,0]\n\tassert candidate([6,5,4,8]) == [2,1,0,3]\n\tassert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\tassert candidate([8,1,2,2,3]) == [4,0,1,1,3]\n\tassert candidate([10,10,20,20,30,30]) == [0,0,2,2,4,4]\n\tassert candidate([100,0,50,25,75]) == [4,0,2,1,3]\n\tassert candidate([7,7,7,7]) == [0,0,0,0]\n\tassert candidate([2,1,2,1,0]) == [3,1,3,1,0]\n\tassert candidate([1,2,2,3,3]) == [0,1,1,3,3]\n\tassert candidate([10,10,10,10,10,10,10,10,10,10]) == [0,0,0,0,0,0,0,0,0,0]\n\tassert candidate(\n    [20,20,20,20,20,20,20,20,20,20]) == [0,0,0,0,0,0,0,0,0,0]\ndef test_check():\n\tcheck(smallerNumbersThanCurrent)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,hash-table,sorting,counting\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1020, "filename": "LeetCode_1020_generateTheString.py", "content": "def generateTheString(n: int) -> str:\n    \"\"\"\n    Given an integer n, return a string with n characters such that each character in the string occurs an odd number of times.\n    The returned string must contain only lowercase English letters.\n    \"\"\"\n\n    # Preconditions\n    assert isinstance(n, int), \"Input must be an integer.\"\n    assert 1 <= n <= 501, \"Input must be between 1 and 501, inclusive.\"\n\n    # Generate the string\n    result = 'a' * n\n    if n % 2 == 0:\n        result = result[:-1] + 'b'\n\n    # Postconditions\n    assert isinstance(result, str), \"Output must be a string.\"\n    assert len(result) == n, \"Output string length must be equal to the input n.\"\n    for char in set(result):\n        assert result.count(char) % 2 == 1, f\"Character '{char}' does not occur an odd number of times.\"\n\n    return result\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(19) == 'aaaaaaaaaaaaaaaaaaa'\n\tassert candidate(26) == 'aaaaaaaaaaaaaaaaaaaaaaaaab'\n\tassert candidate(2) == 'ab'\n\tassert candidate(16) == 'aaaaaaaaaaaaaaab'\n\tassert candidate(8) == 'aaaaaaab'\n\tassert candidate(30) == 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaab'\n\tassert candidate(24) == 'aaaaaaaaaaaaaaaaaaaaaaab'\n\tassert candidate(13) == 'aaaaaaaaaaaaa'\n\tassert candidate(15) == 'aaaaaaaaaaaaaaa'\n\tassert candidate(4) == 'aaab'\n\tassert candidate(17) == 'aaaaaaaaaaaaaaaaa'\n\tassert candidate(27) == 'aaaaaaaaaaaaaaaaaaaaaaaaaaa'\n\tassert candidate(29) == 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaa'\n\tassert candidate(6) == 'aaaaab'\n\tassert candidate(7) == 'aaaaaaa'\n\tassert candidate(1) == 'a'\n\tassert candidate(14) == 'aaaaaaaaaaaaab'\n\tassert candidate(23) == 'aaaaaaaaaaaaaaaaaaaaaaa'\n\tassert candidate(32) == 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab'\n\tassert candidate(22) == 'aaaaaaaaaaaaaaaaaaaaab'\n\tassert candidate(20) == 'aaaaaaaaaaaaaaaaaaab'\n\tassert candidate(3) == 'aaa'\n\tassert candidate(12) == 'aaaaaaaaaaab'\n\tassert candidate(28) == 'aaaaaaaaaaaaaaaaaaaaaaaaaaab'\n\tassert candidate(18) == 'aaaaaaaaaaaaaaaaab'\n\tassert candidate(5) == 'aaaaa'\n\tassert candidate(10) == 'aaaaaaaaab'\n\tassert candidate(9) == 'aaaaaaaaa'\n\tassert candidate(501) == 'a' * 501\n\tassert candidate(25) == 'aaaaaaaaaaaaaaaaaaaaaaaaa'\n\tassert candidate(21) == 'aaaaaaaaaaaaaaaaaaaaa'\n\tassert candidate(11) == 'aaaaaaaaaaa'\ndef test_check():\n\tcheck(generateTheString)\n# Metadata Difficulty: Easy\n# Metadata Topics: string\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1033, "filename": "LeetCode_1033_find_lucky.py", "content": "from typing import List\n\ndef find_lucky(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers arr, a lucky integer is an integer that has a frequency in the array equal to its value.\n    Return the largest lucky integer in the array. If there is no lucky integer return -1.\n    \"\"\"\n    \n    # Preconditions\n    assert isinstance(arr, list), \"Input must be a list.\"\n    assert 1 <= len(arr) <= 500, \"The length of the list must be between 1 and 500.\"\n    assert all(isinstance(x, int) and 1 <= x <= 500 for x in arr), \"All elements must be integers between 1 and 500.\"\n    \n    # Calculate frequencies\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Find the largest lucky integer\n    max_lucky = -1\n    for num, count in freq.items():\n        if num == count:\n            max_lucky = max(max_lucky, num)\n    \n    # Postconditions\n    assert isinstance(max_lucky, int), \"The result should be an integer.\"\n    if max_lucky != -1:\n        assert max_lucky in arr, \"The result should be an element from the array.\"\n        assert freq[max_lucky] == max_lucky, \"The result should have a frequency equal to its value.\"\n    \n    return max_lucky\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([9,9,9,9,9,9,9,9,9]) == 9\n\tassert candidate([2,2,3,4]) == 2\n\tassert candidate([8,8,8,8,8,8,8,8]) == 8\n\tassert candidate(range(1, 115)) == 1\n\tassert candidate(range(1, 109)) == 1\n\tassert candidate(range(1, 111)) == 1\n\tassert candidate(range(1, 117)) == 1\n\tassert candidate([6,6,6,6,6,6]) == 6\n\tassert candidate(range(1, 118)) == 1\n\tassert candidate([7,7,7,7,7,7,7]) == 7\n\tassert candidate(range(1000)) == 1\n\tassert candidate(range(1, 116)) == 1\n\tassert candidate(range(1, 200)) == 1\n\tassert candidate([1,2,2,3,3,3]) == 3\n\tassert candidate(range(1, 105)) == 1\n\tassert candidate([1,1,1,2,2,2,2,3,3,3,3,3]) == -1\n\tassert candidate(range(10000)) == 1\n\tassert candidate(range(1, 112)) == 1\n\tassert candidate(range(1, 100)) == 1\n\tassert candidate(range(1, 104)) == 1\n\tassert candidate([1]) == 1\n\tassert candidate(range(1, 103)) == 1\n\tassert candidate([2]) == -1\n\tassert candidate(range(1, 107)) == 1\n\tassert candidate([1,2,3,4,5,6]) == 1\n\tassert candidate(range(1, 11)) == 1\n\tassert candidate(range(1, 114)) == 1\n\tassert candidate(range(1, 106)) == 1\n\tassert candidate(range(1, 110)) == 1\n\tassert candidate([500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,501]) == -1\n\tassert candidate([2,2,2,3,3]) == -1\n\tassert candidate(range(1, 102)) == 1\n\tassert candidate(range(1, 113)) == 1\n\tassert candidate(range(1, 108)) == 1\n\tassert candidate([2,2,3,3,4,4,4,4]) == 4\n\tassert candidate([10,10,10,10,10,10,10,10,10,10]) == 10\n\tassert candidate([1,1,2,2,2,3,3,3,3,4,4,4,4,4]) == -1\n\tassert candidate(range(1, 119)) == 1\n\tassert candidate([500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500]) == -1\n\tassert candidate([1,1,2,3,3,3]) == 3\ndef test_check():\n\tcheck(find_lucky)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,hash-table,counting\n# Metadata Coverage: 100\n"}
{"id": 1058, "filename": "LeetCode_1058_sum_zero.py", "content": "from typing import List\n\ndef sum_zero(n: int) -> List[int]:\n    \"\"\"\n    Given an integer n, return any array containing n unique integers such that they add up to 0.\n    \"\"\"\n    \n    # Preconditions\n    assert isinstance(n, int), \"Input must be an integer.\"\n    \n    res = []\n    for i in range(1, (n // 2) + 1):\n        res.append(i)\n        res.append(-i)\n    if n % 2 != 0:\n        res.append(0)\n    \n    # Postconditions\n    assert isinstance(res, list), \"Output must be a list.\"\n    assert len(res) == n, \"Output list must contain exactly n elements.\"\n    assert sum(res) == 0, \"The sum of elements in the output list must be 0.\"\n    assert len(res) == len(set(res)), \"All elements in the output list must be unique.\"\n    \n    return res\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(16) == [1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6, 7, -7, 8, -8]\n\tassert candidate(5) == [1, -1, 2, -2, 0]\n\tassert candidate(3) == [1, -1, 0]\n\tassert candidate(8) == [1, -1, 2, -2, 3, -3, 4, -4]\n\tassert candidate(99) == [1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6, 7, -7, 8, -8, 9, -9, 10, -10, 11, -11, 12, -12, 13, -13, 14, -14, 15, -15, 16, -16, 17, -17, 18, -18, 19, -19, 20, -20, 21, -21, 22, -22, 23, -23, 24, -24, 25, -25, 26, -26, 27, -27, 28, -28, 29, -29, 30, -30, 31, -31, 32, -32, 33, -33, 34, -34, 35, -35, 36, -36, 37, -37, 38, -38, 39, -39, 40, -40, 41, -41, 42, -42, 43, -43, 44, -44, 45, -45, 46, -46, 47, -47, 48, -48, 49, -49, 0]\n\tassert candidate(10) == [1, -1, 2, -2, 3, -3, 4, -4, 5, -5]\n\tassert candidate(9) == [1, -1, 2, -2, 3, -3, 4, -4, 0]\n\tassert candidate(14) == [1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6, 7, -7]\n\tassert candidate(4) == [1, -1, 2, -2]\n\tassert candidate(1) == [0]\n\tassert candidate(2) == [1, -1]\n\tassert candidate(11) == [1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 0]\n\tassert candidate(7) == [1, -1, 2, -2, 3, -3, 0]\n\tassert candidate(6) == [1, -1, 2, -2, 3, -3]\n\tassert candidate(13) == [1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6, 0]\n\tassert candidate(12) == [1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6]\n\tassert candidate(17) == [1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6, 7, -7, 8, -8, 0]\n\tassert candidate(0) == []\n\tassert candidate(15) == [1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6, 7, -7, 0]\ndef test_check():\n\tcheck(sum_zero)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,math\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1071, "filename": "LeetCode_1071_number_of_steps.py", "content": "def number_of_steps(num: int) -> int:\n    \"\"\"\n    Given an integer num, return the number of steps to reduce it to zero.\n    In one step, if the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.\n    \"\"\"\n    \n    # Preconditions\n    assert isinstance(num, int), \"Input must be an integer.\"\n    assert 0 <= num <= 10**6, \"Input must be between 0 and 10^6.\"\n    \n    steps = 0\n    while num:\n        steps += 1 if num % 2 == 0 else 2\n        num >>= 1\n    \n    result = steps - 1\n    \n    # Postconditions\n    assert isinstance(result, int), \"Output must be an integer.\"\n\n    return result\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(33) == 7\n\tassert candidate(13) == 6\n\tassert candidate(29) == 8\n\tassert candidate(78) == 10\n\tassert candidate(42) == 8\n\tassert candidate(19) == 7\n\tassert candidate(22) == 7\n\tassert candidate(8) == 4\n\tassert candidate(0) == -1\n\tassert candidate(41) == 8\n\tassert candidate(6) == 4\n\tassert candidate(39) == 9\n\tassert candidate(44) == 8\n\tassert candidate(144) == 9\n\tassert candidate(38) == 8\n\tassert candidate(37) == 8\n\tassert candidate(32) == 6\n\tassert candidate(4) == 3\n\tassert candidate(43) == 9\n\tassert candidate(199) == 12\n\tassert candidate(132) == 9\n\tassert candidate(10) == 5\n\tassert candidate(123) == 12\n\tassert candidate(34) == 7\n\tassert candidate(46) == 9\n\tassert candidate(18) == 6\n\tassert candidate(5) == 4\n\tassert candidate(2) == 2\n\tassert candidate(27) == 8\n\tassert candidate(3) == 3\n\tassert candidate(9) == 5\n\tassert candidate(30) == 8\n\tassert candidate(36) == 7\n\tassert candidate(28) == 7\n\tassert candidate(35) == 8\n\tassert candidate(40) == 7\n\tassert candidate(15) == 7\n\tassert candidate(24) == 6\n\tassert candidate(77) == 10\n\tassert candidate(20) == 6\n\tassert candidate(11) == 6\n\tassert candidate(17) == 6\n\tassert candidate(88) == 9\n\tassert candidate(25) == 7\n\tassert candidate(94) == 11\n\tassert candidate(14) == 6\n\tassert candidate(21) == 7\n\tassert candidate(71) == 10\n\tassert candidate(16) == 5\n\tassert candidate(193) == 10\n\tassert candidate(45) == 9\n\tassert candidate(1) == 1\n\tassert candidate(23) == 8\n\tassert candidate(146) == 10\n\tassert candidate(26) == 7\n\tassert candidate(81) == 9\n\tassert candidate(47) == 10\n\tassert candidate(12) == 5\n\tassert candidate(52) == 8\n\tassert candidate(31) == 9\n\tassert candidate(176) == 10\n\tassert candidate(7) == 5\ndef test_check():\n\tcheck(number_of_steps)\n# Metadata Difficulty: Easy\n# Metadata Topics: math,bit-manipulation\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1118, "filename": "LeetCode_1118_createTargetArray.py", "content": "from typing import List\n\ndef createTargetArray(nums: List[int], index: List[int]) -> List[int]:\n    \"\"\"\n    Given two arrays of integers\u00a0nums and index. Your task is to create target array under the following rules:\n\n    Initially target array is empty.\n    From left to right read nums[i] and index[i], insert at index index[i]\u00a0the value nums[i]\u00a0in\u00a0target array.\n    Repeat the previous step until there are no elements to read in nums and index.\n\n    Return the target array.\n    \"\"\"\n\n    # Preconditions\n    assert isinstance(nums, list) and all(isinstance(x, int) for x in nums), \"nums must be a list of integers.\"\n    assert isinstance(index, list) and all(isinstance(x, int) for x in index), \"index must be a list of integers.\"\n    assert len(nums) == len(index), \"nums and index must have the same length.\"\n    # assert all(0 <= index[i] <= i for i in range(len(index))), \"Each index value must be within the valid range [0, i].\"\n    \n    target = []\n    for i in range(len(nums)):\n        target.insert(index[i], nums[i])\n\n    # Postconditions\n    assert isinstance(target, list), \"The result must be a list.\"\n    assert len(target) == len(nums), \"The length of the target list should be the same as the input lists.\"\n    # for i in range(len(nums)):\n    #     assert target[index[i]] == nums[i] or (index[i] < len(target) and target[index[i]] == nums[i]), \\\n    #            \"Element insertion logic error in target list.\"\n    \n    return target\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\n    [0, 1, 2, 3, 4], [0, 1, 2, 3, 4]) == [0, 1, 2, 3, 4]\n\tassert candidate([0, 1, 2, 3, 4], [0, 1, 2, 2, 1]) == [0, 4, 1, 3, 2]\n\tassert candidate([1, 2, 3, 4], [0, 1, 2, 3]) == [1, 2, 3, 4]\n\tassert candidate([1, 2, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 6]) == [\n    1, 2, 3, 4, 5, 6, 7]\n\tassert candidate(\n    [5, 0, 1], [1, 0, 2]) == [0, 5, 1]\n\tassert candidate([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\tassert candidate([1, 2, 3, 4, 0], [0, 2, 3, 4, 1]) == [1, 0, 2, 3, 4]\n\tassert candidate(\n    [100, 200, 300, 400, 500, 600, 700, 800, 900, 100, 200, 300, 400, 500, 600, 700, 800, 900], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) == [100, 200, 300, 400, 500, 600, 700, 800, 900, 100, 200, 300, 400, 500, 600, 700, 800, 900]\n\tassert candidate([1, 2, 3, 4, 5], [0, 1, 2, 3, 4]) == [1, 2, 3, 4, 5]\n\tassert candidate(\n    [1, 2, 3, 4, 0], [0, 1, 2, 3, 0]) == [0, 1, 2, 3, 4]\n\tassert candidate(\n    [1, 2, 3, 4, 0], [0, 2, 3, 4, 1]) == [1, 0, 2, 3, 4]\n\tassert candidate([1, 2, 3, 4, 5, 6, 7], [4, 5, 6, 7, 8, 9, 10]) == [\n    1, 2, 3, 4, 5, 6, 7]\n\tassert candidate([0, 1, 2, 3, 4], [0, 1, 2, 3, 4]) == [0, 1, 2, 3, 4]\n\tassert candidate(\n    [1, 2, 3, 4, 5, 0, 6, 7, 8, 9], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == [\n        1, 2, 3, 4, 5, 0, 6, 7, 8, 9]\n\tassert candidate([1, 0], [1, 0]) == [0, 1]\ndef test_check():\n\tcheck(createTargetArray)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,simulation\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1128, "filename": "LeetCode_1128_min_subsequence.py", "content": "from typing import List\n\ndef min_subsequence(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given the array nums, obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non-included elements in such subsequence.\n    If there are multiple solutions, return the subsequence with minimum size and if there still exist multiple solutions, return the subsequence with the maximum total sum of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array.\n    Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order.\n    \"\"\"\n    \n    # Preconditions\n    assert isinstance(nums, list) and all(isinstance(x, int) for x in nums), \"nums must be a list of integers.\"\n    # assert 1 <= len(nums) <= 500, \"Length of nums must be between 1 and 500.\"\n    # assert all(1 <= x <= 100 for x in nums), \"All elements in nums must be between 1 and 100.\"\n    \n    nums.sort(reverse=True)\n    total_sum, current_sum = sum(nums), 0\n    result = []\n    \n    for num in nums:\n        current_sum += num\n        result.append(num)\n        if current_sum > total_sum - current_sum:\n            break\n    \n    # Postconditions\n    assert isinstance(result, list), \"The result must be a list.\"\n    assert result == sorted(result, reverse=True), \"The result must be sorted in non-increasing order.\"\n    # assert sum(result) > total_sum - sum(result), \"The sum of the result must be strictly greater than the sum of the non-included elements.\"\n    \n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([5,4,4,3,2,2]) == [5,4,4]\n\tassert candidate([1,2,3,4,4,5,6,7]) == [7,6,5]\n\tassert candidate([]) == []\n\tassert candidate([4,3,10,9,8]) == [10,9]\n\tassert candidate([4]) == [4]\n\tassert candidate([4,4,7,6,7]) == [7,7,6]\n\tassert candidate([3,6,7,2,1]) == [7,6]\n\tassert candidate([4,4]) == [4,4]\ndef test_check():\n\tcheck(min_subsequence)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,greedy,sorting\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1133, "filename": "LeetCode_1133_stringMatching.py", "content": "from typing import List\n\ndef stringMatching(words: List[str]) -> List[str]:\n    \"\"\"\n    Given an array of string words, return all strings in words that are a substring of another word. You can return the answer in any order.\n    A substring is a contiguous sequence of characters within a string.\n    \"\"\"\n    \n    # Preconditions\n    assert isinstance(words, list) and all(isinstance(word, str) for word in words), \"words must be a list of strings.\"\n    assert 1 <= len(words) <= 100, \"The length of words must be between 1 and 100.\"\n    assert all(1 <= len(word) <= 30 for word in words), \"Each word must have a length between 1 and 30.\"\n    assert all(word.islower() and word.isalpha() for word in words), \"Each word must consist only of lowercase English letters.\"\n    \n    result = []\n    for word1 in words:\n        for word2 in words:\n            if word1 != word2 and word1 in word2:\n                result.append(word1)\n                break\n    \n    # Postconditions\n    assert isinstance(result, list) and all(isinstance(word, str) for word in result), \"The result must be a list of strings.\"\n    assert all(any(word in other for other in words if word != other) for word in result), \"Each word in the result must be a substring of another word in words.\"\n    \n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([\"css\",\"c\",\"ss\",\"css\"]) == [\"c\",\"ss\"]\n\tassert candidate([\"dart\",\"dar\",\"art\",\"dart\"]) == [\"dar\",\"art\"]\n\tassert candidate([\"css\",\"c\",\"ss\"]) == [\"c\",\"ss\"]\n\tassert candidate([\"c\",\"cc\",\"ccc\"]) == [\"c\",\"cc\"]\n\tassert candidate([\"aaaa\",\"a\",\"b\",\"ab\"]) == [\"a\",\"b\"]\n\tassert candidate([\"leetcode\",\"et\",\"code\"]) == [\"et\",\"code\"]\n\tassert candidate([\"regex\",\"re\",\"gex\",\"regex\"]) == [\"re\",\"gex\"]\n\tassert candidate([\"csharp\",\"c\",\"sharp\",\"cs\"]) == [\"c\",\"sharp\",\"cs\"]\n\tassert candidate([\"kotlin\",\"kot\",\"lin\",\"kotlin\"]) == [\"kot\",\"lin\"]\n\tassert candidate([\"test\",\"testcase\",\"case\"]) == [\"test\",\"case\"]\n\tassert candidate([\"html\",\"html\",\"h\",\"t\",\"htm\"]) == [\"h\",\"t\",\"htm\"]\n\tassert candidate([\"javascript\",\"js\",\"j\",\"ava\",\"avaj\"]) == [\"j\",\"ava\"]\n\tassert candidate([\"javascript\",\"java\",\"script\",\"js\"]) == [\"java\",\"script\"]\n\tassert candidate([\"java\",\"av\",\"java\",\"va\"]) == [\"av\",\"va\"]\n\tassert candidate([\"swift\",\"sw\",\"ift\",\"swi\"]) == [\"sw\",\"ift\",\"swi\"]\n\tassert candidate([\"sql\",\"sql\",\"ql\",\"q\"]) == [\"ql\",\"q\"]\n\tassert candidate([\"testcase\",\"test\",\"case\",\"abc\",\"a\"]) == [\"test\",\"case\",\"a\"]\n\tassert candidate([\"ab\",\"ba\",\"a\",\"b\"]) == [\"a\",\"b\"]\n\tassert candidate([\"php\",\"p\",\"h\",\"hp\"]) == [\"p\",\"h\",\"hp\"]\n\tassert candidate([\"swift\",\"swi\",\"ift\",\"swift\"]) == [\"swi\",\"ift\"]\n\tassert candidate([\"hello\",\"hell\",\"he\",\"llo\"]) == [\"hell\",\"he\",\"llo\"]\n\tassert candidate([\"lua\",\"u\",\"lua\"]) == [\"u\"]\n\tassert candidate([\"aaaa\",\"a\",\"aa\",\"aaa\"]) == [\"a\",\"aa\",\"aaa\"]\n\tassert candidate([\"rub\",\"r\",\"b\",\"uby\"]) == [\"r\",\"b\"]\n\tassert candidate([\"python\",\"on\",\"py\",\"thon\"]) == [\"on\",\"py\",\"thon\"]\n\tassert candidate([\"code\",\"od\",\"e\",\"code\"]) == [\"od\",\"e\"]\n\tassert candidate([\"css\",\"css\",\"c\",\"ss\"]) == [\"c\",\"ss\"]\n\tassert candidate([\"matlab\",\"mat\",\"lab\"]) == [\"mat\",\"lab\"]\n\tassert candidate([\"apple\",\"pp\",\"app\",\"le\",\"ap\"]) == [\"pp\",\"app\",\"le\",\"ap\"]\n\tassert candidate([\"html\",\"ht\",\"tml\",\"html\"]) == [\"ht\",\"tml\"]\n\tassert candidate([\"ruby\",\"rub\",\"ub\",\"ruby\"]) == [\"rub\",\"ub\"]\n\tassert candidate([\"css\",\"cs\",\"css\",\"s\"]) == [\"cs\",\"s\"]\n\tassert candidate([\"java\",\"av\",\"ja\",\"avaj\"]) == [\"av\",\"ja\"]\n\tassert candidate([\"code\",\"c\",\"o\",\"code\"]) == [\"c\",\"o\"]\n\tassert candidate([\"perl\",\"per\",\"erl\",\"perl\"]) == [\"per\",\"erl\"]\n\tassert candidate([\"html\",\"html\"]) == []\n\tassert candidate([\"sql\",\"sq\",\"l\",\"sql\"]) == [\"sq\",\"l\"]\n\tassert candidate([\"blue\",\"green\",\"bu\"]) == []\n\tassert candidate([\"a\",\"b\",\"c\",\"d\",\"e\"]) == []\n\tassert candidate([\"mass\",\"as\",\"hero\",\"superhero\"]) == [\"as\",\"hero\"]\n\tassert candidate([\"abba\",\"a\",\"b\",\"a\",\"b\",\"abba\"]) == [\"a\",\"b\",\"a\",\"b\"]\ndef test_check():\n\tcheck(stringMatching)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,string,string-matching\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1164, "filename": "LeetCode_1164_busy_student.py", "content": "from typing import List\n\ndef busy_student(start_time: List[int], end_time: List[int], query_time: int) -> int:\n    \"\"\"\n    Given two integer arrays startTime and endTime and given an integer queryTime.\n    The ith student started doing their homework at the time startTime[i] and finished it at time endTime[i].\n    Return the number of students doing their homework at time queryTime. More formally, return the number of students where queryTime lays in the interval [startTime[i], endTime[i]] inclusive.\n    \"\"\"\n\n    # Preconditions\n    assert isinstance(start_time, list) and isinstance(end_time, list), \"start_time and end_time must be lists.\"\n    assert all(isinstance(t, int) for t in start_time + end_time), \"All elements in start_time and end_time must be integers.\"\n    # assert len(start_time) == len(end_time), \"start_time and end_time must have the same length.\"\n    assert all(1 <= t <= 1000 for t in start_time + end_time), \"All elements in start_time and end_time must be between 1 and 1000.\"\n    assert all(start_time[i] <= end_time[i] for i in range(len(start_time))), \"Each start_time[i] must be less than or equal to the corresponding end_time[i].\"\n\n    # Main logic\n    count = 0\n    for i in range(len(start_time)):\n        if start_time[i] <= query_time <= end_time[i]:\n            count += 1\n\n    # Postconditions\n    assert isinstance(count, int), \"The result must be an integer.\"\n    assert 0 <= count <= len(start_time), \"The result must be between 0 and the length of start_time.\"\n    assert count == sum(1 for i in range(len(start_time)) if start_time[i] <= query_time <= end_time[i]), \"The count should match the number of students doing homework at query_time.\"\n\n    return count\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1, 2, 3, 4], [5, 6, 7, 8], 4) == 4\n\tassert candidate([1, 2, 3, 4], [5, 6, 7, 8], 6) == 3\n\tassert candidate([1, 2, 3], [3, 2, 7], 1) == 1\n\tassert candidate([1, 1, 1, 1], [2, 2, 2, 2], 2) == 4\n\tassert candidate([1, 2, 3, 4], [5, 6, 7, 8], 5) == 4\n\tassert candidate([1], [2], 1) == 1\n\tassert candidate([4], [4], 4) == 1\n\tassert candidate([1, 2, 3, 4], [5, 6, 7, 8], 8) == 1\n\tassert candidate([1, 2, 3], [3, 2, 7], 6) == 1\n\tassert candidate([1, 2, 3], [3, 2, 7], 5) == 1\n\tassert candidate([4], [4], 3) == 0\n\tassert candidate([], [], 5) == 0\n\tassert candidate([1, 2, 3], [3, 2, 7], 10) == 0\n\tassert candidate([1, 2, 3], [3, 2, 7], 3) == 2\n\tassert candidate([1, 1, 1, 1], [2, 2, 2, 2], 1) == 4\n\tassert candidate([1, 2, 3], [3, 2, 7], 0) == 0\n\tassert candidate([1, 2, 3], [3, 2, 7], 7) == 1\ndef test_check():\n\tcheck(busy_student)\n# Metadata Difficulty: Easy\n# Metadata Topics: array\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1173, "filename": "LeetCode_1173_final_prices.py", "content": "from typing import List\n\ndef final_prices(prices: List[int]) -> List[int]:\n    \"\"\"\n    You are given an integer array prices where prices[i] is the price of the ith item in a shop.\n    There is a special discount for items in the shop. If you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j > i and prices[j] <= prices[i]. Otherwise, you will not receive any discount at all.\n    Return an integer array answer where answer[i] is the final price you will pay for the ith item of the shop, considering the special discount.\n    \"\"\"\n    \n    # Preconditions\n    assert isinstance(prices, list) and all(isinstance(p, int) for p in prices), \"Prices must be a list of integers.\"\n    assert 1 <= len(prices) <= 500, \"Prices list length must be between 1 and 500.\"\n\n    for i in range(len(prices)):\n        for j in range(i + 1, len(prices)):\n            if prices[j] <= prices[i]:\n                prices[i] -= prices[j]\n                break\n    \n    # Postconditions\n    assert isinstance(prices, list) and all(isinstance(p, int) for p in prices), \"The output must be a list of integers.\"\n    assert len(prices) > 0, \"The output list should not be empty.\"\n    assert len(prices) <= 500, \"The output list should not exceed length of 500.\"\n    \n    return prices\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([3, 2, 1, 2]) == [1, 1, 1, 2]\n\tassert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]\n\tassert candidate([8, 4, 6, 2, 3]) == [4, 2, 4, 2, 3]\n\tassert candidate([10, 1, 10, 1, 10, 1, 10, 1]) == [9, 0, 9, 0, 9, 0, 9, 1]\n\tassert candidate([1, 1, 1, 1]) == [0, 0, 0, 1]\n\tassert candidate([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\tassert candidate([4, 4, 4, 4]) == [0, 0, 0, 4]\n\tassert candidate(\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == [\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\n]\n\tassert candidate([5, 5, 5, 5, 5]) == [0, 0, 0, 0, 5]\n\tassert candidate([10, 1, 1, 6]) == [9, 0, 1, 6]\n\tassert candidate([10, 10, 10, 10, 10, 10, 10, 10]) == [0, 0, 0, 0, 0, 0, 0, 10]\n\tassert candidate([5, 0, 5, 0, 5]) == [5, 0, 5, 0, 5]\ndef test_check():\n\tcheck(final_prices)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,stack,monotonic-stack\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1188, "filename": "LeetCode_1188_reorderSpaces.py", "content": "def reorderSpaces(text: str) -> str:\n    \"\"\"\n    You are given a string text of words that are placed among some number of spaces. Each word consists of one or more lowercase English letters and are separated by at least one space. It's guaranteed that text contains at least one word.\n    Rearrange the spaces so that there is an equal number of spaces between every pair of adjacent words and that number is maximized. If you cannot redistribute all the spaces equally, place the extra spaces at the end, meaning the returned string should be the same length as text.\n    Return the string after rearranging the spaces.\n    \"\"\"\n\n    # Preconditions\n    assert isinstance(text, str), \"The input must be a string.\"\n    assert 1 <= len(text) <= 100, \"The length of the text must be between 1 and 100.\"\n    assert all(ch.islower() or ch == ' ' for ch in text), \"Text must consist of lowercase English letters and spaces.\"\n\n    spaces = text.count(' ')\n    words = text.split()\n    num_words = len(words)\n\n    if num_words == 1:\n        spaces_between_words = 0\n    else:\n        spaces_between_words = spaces // (num_words - 1)\n\n    extra_spaces = spaces - spaces_between_words * (num_words - 1)\n\n    result = (' ' * spaces_between_words).join(words) + ' ' * extra_spaces\n\n    # Postconditions\n    assert isinstance(result, str), \"The result must be a string.\"\n    assert len(result) == len(text), \"The length of the result must be equal to the original text.\"\n    assert result.count(' ') == spaces, \"The number of spaces in the result must be equal to the original number of spaces.\"\n\n    return result\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"practice makes perfect\") == \"practice makes perfect\"\n\tassert candidate(\"  this   is  a sentence  \") == \"this   is   a   sentence \"\n\tassert candidate(\"  hello\") == \"hello  \"\n\tassert candidate(\"hello  \") == \"hello  \"\n\tassert candidate(\"hello   world\") == \"hello   world\"\n\tassert candidate(\"this  is  a  sentence\") == \"this  is  a  sentence\"\n\tassert candidate(\"hello\") == \"hello\"\n\tassert candidate(\"  this   is  a sentence \") == \"this   is   a   sentence\"\n\tassert candidate(\n    \"  this   is  a sentence  \") == \"this   is   a   sentence \"\n\tassert candidate(\n    \" practice   makes   perfect\") == \"practice   makes   perfect \"\ndef test_check():\n\tcheck(reorderSpaces)\n# Metadata Difficulty: Easy\n# Metadata Topics: string\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1203, "filename": "LeetCode_1203_maxDepth.py", "content": "def maxDepth(s: str) -> int:\n    \"\"\"\n    A string is a valid parentheses string (denoted VPS) if it meets one of the following:\n    ...\n    Given a VPS represented as string s, return the nesting depth of s.\n    \"\"\"\n\n    # Preconditions\n    assert isinstance(s, str), \"Input must be a string.\"\n    assert 1 <= len(s) <= 100, \"The length of the string must be between 1 and 100.\"\n    assert all(ch.isdigit() or ch in '+-*/()' for ch in s), \"String must consist of digits, '+', '-', '*', '/', '(', and ')'.\"\n\n    depth = 0\n    max_depth = 0\n\n    for c in s:\n        if c == '(':\n            depth += 1\n            max_depth = max(depth, max_depth)\n        elif c == ')':\n            depth -= 1\n\n    # Postconditions\n    assert isinstance(max_depth, int), \"The result must be an integer.\"\n    assert max_depth >= 0, \"The result must be non-negative.\"\n    assert depth == 0, \"The parentheses should be balanced by the end of the string.\"\n\n    return max_depth\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"1+(2*3)/(2-1)\") == 1\n\tassert candidate(\"(1+(2*3)+((8)/4))+1+(2*3)+(4/2)\") == 3\n\tassert candidate(\"(1)\") == 1\n\tassert candidate(\"1+2+((3)+(4))\") == 2\n\tassert candidate(\"(1+(2*3)+((8)/4))+1+(2*3)+(4/2)+(5/1)\") == 3\n\tassert candidate(\"1+2*3\") == 0\n\tassert candidate(\"1+(2*3)+(4/2)+(5/1)\") == 1\n\tassert candidate(\"(((((((((1)))))))))\") == 9\n\tassert candidate(\"1+(2*3)+(4/2)\") == 1\n\tassert candidate(\"(((((1+2)))))\") == 5\n\tassert candidate(\"((1+2)+((3+4)+(5))))\") == 3\n\tassert candidate(\"((1+2)*3)\") == 2\n\tassert candidate(\"((1+2)+(3+4))+5+(((6+7)))\") == 3\n\tassert candidate(\"(((((5)))))\") == 5\n\tassert candidate(\"(2+6)*(3+5)\") == 1\n\tassert candidate(\"(1+2)+((3+4)+((5+6)+(7+8)))\") == 3\n\tassert candidate(\"(((5)+(6)+(7)+(8)))\") == 3\n\tassert candidate(\"(1+2)+(3+4)+(((5+6)+(7+8)))\") == 3\n\tassert candidate(\"(1+2)+(3+4)+((5+6)+(7+8))\") == 2\n\tassert candidate(\"(1+2)+((3+4)*(5+6))\") == 2\n\tassert candidate(\"(((1+2)+(3+4)+(5))))\") == 3\n\tassert candidate(\"10/2*3-4*1\") == 0\n\tassert candidate(\"((1+2)+((3+4)+((5)+(6)+(7)+(8+9)))))\") == 4\n\tassert candidate(\"(1+2)*3\") == 1\n\tassert candidate(\"((1+2)+(3+4))+((5+6)+(7+8)+(((9/3)+1)))\") == 4\n\tassert candidate(\"1+((2))+(((3)))+(((4)))\") == 3\n\tassert candidate(\"((((4+3))))\") == 4\n\tassert candidate(\"(1+2)*(3+4)*(((5+6)))\") == 3\n\tassert candidate(\"1\") == 0\n\tassert candidate(\"(1+(2*3)+((8)/4))+1+(2*3)+(4/2)+(5/1)+(6/0)\") == 3\n\tassert candidate(\"(((1+2)*3)+((4/5))+(((6+7)*(8/9))+((10/11)+((12/13)+((14/15)*(16/17))))))\") == 6\n\tassert candidate(\"((1+2)+(3+4)+((5)))\") == 3\n\tassert candidate(\"(1+2)*(3+4)\") == 1\n\tassert candidate(\"1+2\") == 0\n\tassert candidate(\"((1+2)+(3+4)+(5)+((6+7)+(8+9)))\") == 3\n\tassert candidate(\"(1+2)+((3+4)*(5+6))+(7+8)\") == 2\n\tassert candidate(\"1+2+3+4+5\") == 0\n\tassert candidate(\"(((((5+4)))))\") == 5\n\tassert candidate(\"(((1+2)+(3+4)+(5)))\") == 3\n\tassert candidate(\"((1+2)+(3+4))+((5+6)+(7+8))\") == 2\n\tassert candidate(\"(1)+(2)+(3)+(4)+(5)\") == 1\n\tassert candidate(\"(1)+((2))+(((3)))\") == 3\n\tassert candidate(\"((1+2)+(3+4))+((5+6)+(7+8)+((1+2)*(3+4)))\") == 3\n\tassert candidate(\"(1+(2*3)+(((8/4))+5))\") == 4\n\tassert candidate(\"((1+2)+((3+4)+(5)+((6+7)+(8+9))))\") == 4\n\tassert candidate(\"(1+(2*3)+((8)/4))+1\") == 3\n\tassert candidate(\"(((1+2))+((3+4) + 5))\") == 3\n\tassert candidate(\"((((1+2)+(3+4)+(5))))\") == 4\n\tassert candidate(\"((1+2)+(3+4)+(5))\") == 2\n\tassert candidate(\"((1+2)+(3+4))+((5+6)+(7+8))+(9/0)\") == 2\n\tassert candidate(\"((1+2)+(3+4))+5\") == 2\n\tassert candidate(\"((((5)+(6)+(7)+(8))))\") == 4\ndef test_check():\n\tcheck(maxDepth)\n# Metadata Difficulty: Easy\n# Metadata Topics: string,stack\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1271, "filename": "LeetCode_1271_modifyString.py", "content": "def modifyString(s: str) -> str:\n    \"\"\"\n    Given a string s containing only lowercase English letters and the '?' character, convert all the '?' characters into lowercase letters such that the final string does not contain any consecutive repeating characters. You cannot modify the non '?' characters.\n    It is guaranteed that there are no consecutive repeating characters in the given string except for '?'.\n    Return the final string after all the conversions (possibly zero) have been made. If there is more than one solution, return any of them. It can be shown that an answer is always possible with the given constraints.\n    \"\"\"\n    # Preconditions\n    assert isinstance(s, str), \"Input must be a string.\"\n    assert 1 <= len(s) <= 100, \"The length of the string must be between 1 and 100.\"\n    assert all(ch.islower() or ch == '?' for ch in s), \"String must consist of lowercase English letters and '?' only.\"\n\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] == '?':\n            for c in range(ord('a'), ord('z') + 1):\n                if (i - 1 < 0 or s[i - 1] != chr(c)) and (i + 1 >= len(s) or s[i + 1] != chr(c)):\n                    s[i] = chr(c)\n                    break\n    result = ''.join(s)\n\n    # Postconditions\n    assert isinstance(result, str), \"Output must be a string.\"\n    assert len(result) == len(s), \"The output string must have the same length as the input.\"\n    assert '?' not in result, \"The output string must not contain any '?'.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"a\") == \"a\"\n\tassert candidate(\n    \"?zs\") == \"azs\"\n\tassert candidate(\"aabbaba\") == \"aabbaba\"\n\tassert candidate(\"abcdefg\") == \"abcdefg\"\n\tassert candidate(\"ubv?w\") == \"ubvaw\"\n\tassert candidate(\n    \"ubv?w\") == \"ubvaw\"\ndef test_check():\n\tcheck(modifyString)\n# Metadata Difficulty: Easy\n# Metadata Topics: string\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1288, "filename": "LeetCode_1288_minOperations.py", "content": "from typing import List\n\ndef minOperations(logs: List[str]) -> int:\n    \"\"\"\n    The Leetcode file system keeps a log each time some user performs a change folder operation.\n    The operations are described below:\n\n    \"../\" : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder).\n    \"./\" : Remain in the same folder.\n    \"x/\" : Move to the child folder named x (This folder is guaranteed to always exist).\n\n    You are given a list of strings logs where logs[i] is the operation performed by the user at the ith step.\n    The file system starts in the main folder, then the operations in logs are performed.\n    Return the minimum number of operations needed to go back to the main folder after the change folder operations.\n\u00a0\n    Example 1:\n    Input: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n    Output: 2\n    Explanation: Use this change folder operation \"../\" 2 times and go back to the main folder.\n\n    Example 2:\n    Input: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n    Output: 3\n\n    Example 3:\n    Input: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    1 <= logs.length <= 103\n    2 <= logs[i].length <= 10\n    logs[i] contains lowercase English letters, digits, '.', and '/'.\n    logs[i] follows the format described in the statement.\n    Folder names consist of lowercase English letters and digits.\n    \"\"\"\n    \n    # Precondition 1: Ensure that logs is a list of strings.\n    assert isinstance(logs, list) and all(isinstance(log, str) for log in logs), \"logs must be a list of strings.\"\n\n    # Precondition 2: Ensure the length of logs is within the specified range.\n    assert 1 <= len(logs) <= 103, \"logs length must be between 1 and 103, inclusive.\"\n\n\n    # Perform the operation\n    depth = 0\n    for log in logs:\n        if log == \"../\":\n            if depth > 0:\n                depth -= 1\n        elif log != \"./\":\n            depth += 1\n\n    # Postcondition 1: Ensure the depth is a non-negative integer.\n    assert isinstance(depth, int) and depth >= 0, \"The resulting depth must be a non-negative integer.\"\n\n    return depth\n\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([\"dir/\", \"../\", \"../\", \"dir/\"]) == 1\n\tassert candidate([\"../../\", \"./\", \"./\"]) == 1\n\tassert candidate([\"./\", \"./\", \"./\", \"../\", \"dir/\"]) == 1\n\tassert candidate([\"dir/\", \"dir/\", \"dir/\", \"../\", \"../\", \"dir/\"]) == 2\n\tassert candidate([\"../\", \"dir/\", \"../\", \"../\", \"../\"]) == 0\n\tassert candidate([\"./\", \"../\", \"dir/\", \"./\"]) == 1\n\tassert candidate([\"dir/\", \"dir/\", \"../\", \"../\", \"dir/\", \"./\"]) == 1\n\tassert candidate([\"dir/\", \"../\", \"dir/\", \"../\", \"../\"]) == 0\n\tassert candidate([\"./\", \"./\", \"./\"]) == 0\n\tassert candidate([\"../\", \"./\", \"dir/\", \"./\"]) == 1\n\tassert candidate([\"../\"]) == 0\n\tassert candidate([\"../\", \"dir/\", \"../\", \"../\", \"dir/\"]) == 1\n\tassert candidate([\"dir/\", \"./\", \"./\", \"../\", \"dir/\"]) == 1\n\tassert candidate([\"../../\", \"./\", \"../\"]) == 0\n\tassert candidate([\"../../\", \"./\"]) == 1\n\tassert candidate([\"../\", \"./\"]) == 0\n\tassert candidate([\"dir/\", \"dir/\", \"../\", \"../\"]) == 0\n\tassert candidate([\"./\", \"./\", \"dir/\"]) == 1\n\tassert candidate([\"../\", \"../\", \"../\"]) == 0\n\tassert candidate([\"../\", \"../\", \"../\", \"dir/\"]) == 1\n\tassert candidate([\"./\", \"./\", \"../\"]) == 0\n\tassert candidate([\"dir/\", \"../\", \"dir/\", \"../\", \"dir/\"]) == 1\n\tassert candidate([\"dir/\", \"./\", \"../\", \"dir/\"]) == 1\n\tassert candidate([\"dir/\", \"dir/\", \"../\", \"dir/\", \"../\", \"../\"]) == 0\n\tassert candidate([\"../\", \"../\", \"./\", \"dir/\"]) == 1\n\tassert candidate([\"dir/\", \"dir/\", \"../\", \"../\", \"dir/\"]) == 1\n\tassert candidate([\"dir/\", \"../\", \"../\"]) == 0\n\tassert candidate([\"../\", \"./\", \"../\", \"./\"]) == 0\n\tassert candidate([\"./\", \"../\", \"./\"]) == 0\n\tassert candidate([\"dir/\", \"dir/\", \"dir/\", \"../\"]) == 2\n\tassert candidate([\"../\", \"dir/\", \"./\"]) == 1\n\tassert candidate([\"dir/\", \"../\", \"./\", \"./\", \"dir/\"]) == 1\n\tassert candidate([\"../\", \"..\", \"../\"]) == 0\n\tassert candidate([\"d1/\", \"d2/\", \"./\", \"d3/\", \"../\", \"d31/\"]) == 3\n\tassert candidate([\"d1/\", \"d2/\", \"../\", \"d21/\", \"./\"]) == 2\n\tassert candidate([\"dir/\", \"dir/\", \"dir/\", \"dir/\", \"../\"]) == 3\n\tassert candidate([\"../\", \"../\"]) == 0\n\tassert candidate([\"../\", \"../\", \"../\", \"dir/\", \"dir/\"]) == 2\n\tassert candidate([\"dir/\", \"dir/\", \"./\", \"./\", \"../\", \"dir/\"]) == 2\n\tassert candidate([\"dir/\", \"dir/\", \"../\", \"dir/\", \"../\"]) == 1\n\tassert candidate([\"../\", \"./\", \"dir/\"]) == 1\n\tassert candidate([\"dir/\", \"../\"]) == 0\n\tassert candidate([\"../../\", \"../\"]) == 0\ndef test_check():\n\tcheck(minOperations)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,string,stack\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1354, "filename": "LeetCode_1354_countStudents.py", "content": "from typing import List\nfrom collections import deque\n\ndef countStudents(students: List[int], sandwiches: List[int]) -> int:\n    \"\"\"\n    The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches.\n    The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step:\n\n    If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue.\n    Otherwise, they will leave it and go to the queue's end.\n\n    This continues until none of the queue students want to take the top sandwich and are thus unable to eat.\n    You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the i\u200b\u200b\u200b\u200b\u200b\u200bth sandwich in the stack (i = 0 is the top of the stack) and students[j] is the preference of the j\u200b\u200b\u200b\u200b\u200b\u200bth student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat.\n\u00a0\n    Example 1:\n\n    Input: students = [1,1,0,0], sandwiches = [0,1,0,1]\n    Output: 0 \n    Explanation:\n    - Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1].\n    - Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1].\n    - Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1].\n    - Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0].\n    - Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1].\n    - Front student leaves the top sandwich and returns to the end of the line making students = [0,1].\n    - Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1].\n    - Front student takes the top sandwich and leaves the line making students = [] and sandwiches = [].\n    Hence all students are able to eat.\n\n    Example 2:\n\n    Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]\n    Output: 3\n\n\u00a0\n    Constraints:\n\n    1 <= students.length, sandwiches.length <= 100\n    students.length == sandwiches.length\n    sandwiches[i] is 0 or 1.\n    students[i] is 0 or 1.\n\n    \"\"\"\n    # Precondition 1: Ensure students and sandwiches are lists of integers (0 or 1).\n    assert isinstance(students, list) and isinstance(sandwiches, list), \"students and sandwiches must be lists.\"\n    assert all(isinstance(s, int) and s in [0, 1] for s in students), \"students must contain only 0s or 1s.\"\n    assert all(isinstance(s, int) and s in [0, 1] for s in sandwiches), \"sandwiches must contain only 0s or 1s.\"\n\n    # Precondition 2: Ensure the lengths of students and sandwiches are within the specified range and are equal.\n    assert 1 <= len(students) <= 100 and len(students) == len(sandwiches), \"Lengths of students and sandwiches must be between 1 and 100 and equal.\"\n\n    # Perform the operation\n    queue = deque(students)\n    index, attempts = 0, 0\n\n    while queue:\n        student = queue[0]\n        if student == sandwiches[index]:\n            queue.popleft()\n            index += 1\n            attempts = 0\n        else:\n            queue.rotate(-1)\n            attempts += 1\n\n        if attempts == len(queue):\n            break\n\n    # Postcondition: Ensure the result is a non-negative integer and represents the number of students unable to eat.\n    result = len(queue)\n    assert isinstance(result, int) and result >= 0, \"The result must be a non-negative integer representing the number of students unable to eat.\"\n\n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 1]) == 0\n\tassert candidate([1, 1, 0, 0], [0, 1, 0, 1]) == 0\n\tassert candidate([1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1]) == 0\n\tassert candidate([1, 1, 0, 0, 1, 0], [1, 1, 0, 1, 1, 1]) == 2\n\tassert candidate([1, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 0]) == 0\n\tassert candidate([1, 0, 0, 1, 1, 1], [1, 0, 0, 1, 1, 1]) == 0\n\tassert candidate([1, 1, 0, 1, 0, 0], [0, 1, 0, 0, 1, 1]) == 0\n\tassert candidate([1, 1, 0, 0, 1, 1, 0, 0, 0, 1], [0, 1, 0, 0, 0, 1, 1, 0, 1, 1]) == 0\n\tassert candidate([1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1]) == 0\n\tassert candidate([1, 1, 1, 0, 0, 1], [1, 0, 0, 0, 1, 1]) == 3\n\tassert candidate([1, 1, 0, 0, 1, 0], [1, 1, 0, 0, 1, 1]) == 1\ndef test_check():\n\tcheck(countStudents)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,stack,queue,simulation\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1379, "filename": "LeetCode_1379_largestAltitude.py", "content": "from typing import List\n\ndef largestAltitude(gain: List[int]) -> int:\n    \"\"\"\n    There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.\n    You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i\u200b\u200b\u200b\u200b\u200b\u200b and i + 1 for all (0 <= i < n). Return the highest altitude of a point.\n\u00a0\n    Example 1:\n\n    Input: gain = [-5,1,5,0,-7]\n    Output: 1\n    Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.\n\n    Example 2:\n\n    Input: gain = [-4,-3,-2,-1,4,3,2]\n    Output: 0\n    Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.\n\n\u00a0\n    Constraints:\n\n    n == gain.length\n    1 <= n <= 100\n    -100 <= gain[i] <= 100\n\n    \"\"\"\n    # Precondition 1: Ensure that gain is a list of integers.\n    assert isinstance(gain, list) and all(isinstance(i, int) for i in gain), \"gain must be a list of integers.\"\n\n    # Precondition 2: Ensure the length of gain is within the specified range.\n    assert 1 <= len(gain) <= 100, \"gain length must be between 1 and 100, inclusive.\"\n\n    # Precondition 3: Ensure each element in gain is within the range [-100, 100].\n    assert all(-1000 <= i <= 1000 for i in gain), \"Each element in gain must be between -100 and 100, inclusive.\"\n\n    # Perform the operation\n    max_altitude, current_altitude = 0, 0\n    for i in gain:\n        current_altitude += i\n        max_altitude = max(max_altitude, current_altitude)\n\n    # Postcondition: Ensure the result is a non-negative integer.\n    assert isinstance(max_altitude, int) and max_altitude >= 0, \"The result must be a non-negative integer representing the highest altitude.\"\n\n    return max_altitude\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1]) == 1\n\tassert candidate( [-5,1,5,0,-7]) == 1\n\tassert candidate(    [-4,-3,-2,-1,4,3,2]) == 0\n\tassert candidate(\n    [-5,1,5,0,-7]) == 1\n\tassert candidate([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]) == 20\n\tassert candidate( [1]) == 1\n\tassert candidate([-4,-3,-2,-1,4,3,2]) == 0\n\tassert candidate([-5,1,5,0,-7]) == 1\n\tassert candidate( [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]) == 20\n\tassert candidate( [0,0,0]) == 0\n\tassert candidate([1, 1, 1, 1, 1]) == 5\n\tassert candidate(    [-5,1,5,0,-7]) == 1\n\tassert candidate(\n    [-4,-3,-2,-1,4,3,2]) == 0\n\tassert candidate([1,1,1,1,1,1,1,1,1,1]) == 10\n\tassert candidate( [-4,-3,-2,-1,4,3,2]) == 0\n\tassert candidate([2,2,2,2,2,2,2,2,2,2]) == 20\n\tassert candidate(   [-5,1,5,0,-7]) == 1\n\tassert candidate([1, 1, 1, -1, 1]) == 3\ndef test_check():\n\tcheck(largestAltitude)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,prefix-sum\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1492, "filename": "LeetCode_1492_sort_sentence.py", "content": "def sort_sentence(s: str) -> str:\n    \"\"\"\n    A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each word consists of lowercase and uppercase English letters.\n    A sentence can be shuffled by appending the 1-indexed word position to each word then rearranging the words in the sentence.\n\n    For example, the sentence \"This is a sentence\" can be shuffled as \"sentence4 a3 is2 This1\" or \"is2 sentence4 This1 a3\".\n\n    Given a shuffled sentence s containing no more than 9 words, reconstruct and return the original sentence.\n\u00a0\n    Example 1:\n\n    Input: s = \"is2 sentence4 This1 a3\"\n    Output: \"This is a sentence\"\n    Explanation: Sort the words in s to their original positions \"This1 is2 a3 sentence4\", then remove the numbers.\n\n    Example 2:\n\n    Input: s = \"Myself2 Me1 I4 and3\"\n    Output: \"Me Myself and I\"\n    Explanation: Sort the words in s to their original positions \"Me1 Myself2 and3 I4\", then remove the numbers.\n\n\u00a0\n    Constraints:\n\n    2 <= s.length <= 200\n    s consists of lowercase and uppercase English letters, spaces, and digits from 1 to 9.\n    The number of words in s is between 1 and 9.\n    The words in s are separated by a single space.\n    s contains no leading or trailing spaces.\n    \"\"\"\n    # Precondition 1: Ensure that the input is a non-empty string.\n    assert isinstance(s, str) and len(s) > 0, \"Input must be a non-empty string.\"\n\n    # Precondition 2: Ensure that the length of the string is within the specified range.\n    assert 2 <= len(s) <= 200, \"The length of the input string must be between 2 and 200.\"\n\n    # Precondition 3: Ensure the number of words in the sentence is between 1 and 9.\n    tokens = s.split()\n    assert 1 <= len(tokens) <= 9, \"The number of words in the sentence must be between 1 and 9.\"\n\n    # Precondition 4: Ensure that each word ends with a digit between 1 and 9.\n    assert all(token[-1].isdigit() and 1 <= int(token[-1]) <= 9 for token in tokens), \"Each word must end with a digit between 1 and 9.\"\n\n    # Perform the operation\n    words = [''] * len(tokens)\n    for token in tokens:\n        pos = int(token[-1]) - 1\n        words[pos] = token[:-1]\n\n    result = ' '.join(words)\n\n    # Postcondition: Ensure the output is a non-empty string that represents a valid sentence.\n    assert isinstance(result, str) and len(result) > 0, \"Output must be a non-empty string representing a sentence.\"\n\n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"Coding1 is2 fun3\") == \"Coding is fun\"\n\tassert candidate(\n    \"is2 sentence4 This1 a3\"\n) == \"This is a sentence\", \"Negative indexing with number in the middle of word.\"\n\tassert candidate(\n    \"Myself2 Me1 I4 and3\"\n) == \"Me Myself and I\", \"Negative indexing with number in the beginning of word.\"\n\tassert candidate(\"Python1 interpreters2 are3 available4 for5 many6 operating7 systems8\") == \"Python interpreters are available for many operating systems\"\n\tassert candidate(\"Python1 is2 an3 interpreted4 high-level5 general-purpose6 programming7 language8\") == \"Python is an interpreted high-level general-purpose programming language\"\n\tassert candidate(\"Python1 is2 dynamically3 typed4 and5 garbage6 collected7\") == \"Python is dynamically typed and garbage collected\"\n\tassert candidate(\n    \"Myself2 Me1 I4 and3\"\n) == \"Me Myself and I\", \"Do not mix the positions of the words. Try to understand how the sentences are sorted and emulate the same logic.\"\n\tassert candidate(\"is2 sentence4 This1 a3\") == \"This is a sentence\"\n\tassert candidate(\n    \"a3 is2 This1 sentence4\"\n) == \"This is a sentence\", \"Negative indexing with number in the middle of word.\"\n\tassert candidate(\"I1 am2 a3 Python4 programmer5\") == \"I am a Python programmer\"\n\tassert candidate(\"Its1 design2 philosophy3 emphasizes4 code5 readability6\") == \"Its design philosophy emphasizes code readability\"\n\tassert candidate(\n    \"is2 sentence4 a3 This1\"\n) == \"This is a sentence\", \"Negative indexing with number in the middle of word.\"\n\tassert candidate(\n    \"is2 a3 This1 sentence4\"\n) == \"This is a sentence\", \"Negative indexing with number in the beginning of word.\"\n\tassert candidate((\"Myself2 Me1 I4 and3\")) == \"Me Myself and I\"\n\tassert candidate(\n    \"Myself2 Me1 I4 and3\"\n) == \"Me Myself and I\", \"Negative indexing with number in the end of word.\"\n\tassert candidate(\"This1 is2 a3 test4\") == \"This is a test\"\n\tassert candidate(\n    \"sentence4 This1 a3 is2\"\n) == \"This is a sentence\", \"Negative indexing with number in the end of word.\"\n\tassert candidate(\n    \"a3 sentence4 This1 is2\"\n) == \"This is a sentence\", \"Negative indexing with number in the end of word.\"\n\tassert candidate(\n    \"sentence4 a3 is2 This1\"\n) == \"This is a sentence\", \"Negative indexing with number in the beginning of word.\"\ndef test_check():\n\tcheck(sort_sentence)\n# Metadata Difficulty: Easy\n# Metadata Topics: string,sorting\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1494, "filename": "LeetCode_1494_minTimeToType.py", "content": "def minTimeToType(word: str) -> int:\n    \"\"\"\n    There is a special typewriter with lowercase English letters 'a' to 'z' arranged in a circle with a pointer. A character can only be typed if the pointer is pointing to that character. The pointer is initially pointing to the character 'a'.\n\n    Each second, you may perform one of the following operations:\n\n    Move the pointer one character counterclockwise or clockwise.\n    Type the character the pointer is currently on.\n\n    Given a string word, return the minimum number of seconds to type out the characters in word.\n\u00a0\n    Example 1:\n\n    Input: word = \"abc\"\n    Output: 5\n    Explanation: \n    The characters are printed as follows:\n    - Type the character 'a' in 1 second since the pointer is initially on 'a'.\n    - Move the pointer clockwise to 'b' in 1 second.\n    - Type the character 'b' in 1 second.\n    - Move the pointer clockwise to 'c' in 1 second.\n    - Type the character 'c' in 1 second.\n\n    Example 2:\n\n    Input: word = \"bza\"\n    Output: 7\n    Explanation:\n    The characters are printed as follows:\n    - Move the pointer clockwise to 'b' in 1 second.\n    - Type the character 'b' in 1 second.\n    - Move the pointer counterclockwise to 'z' in 2 seconds.\n    - Type the character 'z' in 1 second.\n    - Move the pointer clockwise to 'a' in 1 second.\n    - Type the character 'a' in 1 second.\n\n    Example 3:\n\n    Input: word = \"zjpc\"\n    Output: 34\n    Explanation:\n    The characters are printed as follows:\n    - Move the pointer counterclockwise to 'z' in 1 second.\n    - Type the character 'z' in 1 second.\n    - Move the pointer clockwise to 'j' in 10 seconds.\n    - Type the character 'j' in 1 second.\n    - Move the pointer clockwise to 'p' in 6 seconds.\n    - Type the character 'p' in 1 second.\n    - Move the pointer counterclockwise to 'c' in 13 seconds.\n    - Type the character 'c' in 1 second.\n\n\u00a0\n    Constraints:\n\n    1 <= word.length <= 100\n    word consists of lowercase English letters.\n\n    \"\"\"\n    # Precondition 1: Ensure the input is a non-empty string.\n    assert isinstance(word, str) and len(word) > 0, \"Input must be a non-empty string.\"\n\n    # Precondition 2: Ensure the length of the string is within the specified range.\n    assert 1 <= len(word) <= 100, \"The length of the input string must be between 1 and 100.\"\n\n    # Precondition 3: Ensure the string consists of only lowercase English letters.\n    assert all('a' <= c <= 'z' for c in word), \"The input string must consist of lowercase English letters only.\"\n\n    # Perform the operation\n    time = 0\n    position = 0\n    for c in word:\n        next_position = ord(c) - ord('a')\n        diff = abs(next_position - position)\n        time += min(diff, 26 - diff) + 1\n        position = next_position\n\n    # Postcondition: Ensure the output is a non-negative integer representing the total time.\n    assert isinstance(time, int) and time >= 0, \"The result must be a non-negative integer representing the minimum time.\"\n\n    return time\n\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"zjpc\") == 34\n\tassert candidate(\"zxyw\") == 10\n\tassert candidate(\"abcd\") == 7\n\tassert candidate(\"bza\") == 7\n\tassert candidate(\"a\") == 1\n\tassert candidate(\"aaaa\") == 4\n\tassert candidate(\"zyxwvutsrqponmlkjihgfedcb\") == 50\n\tassert candidate(\"azaz\") == 7\n\tassert candidate(\"abc\") == 5\n\tassert candidate(\"abcdefghijklmnopqrstuvwxyz\") == 51\n\tassert candidate(\"az\") == 3\ndef test_check():\n\tcheck(minTimeToType)\n# Metadata Difficulty: Easy\n# Metadata Topics: string,greedy\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1515, "filename": "LeetCode_1515_checkZeroOnes.py", "content": "def checkZeroOnes(s: str) -> bool:\n    \"\"\"\n    Given a binary string s, return true if the longest contiguous segment of 1's is strictly longer than the longest contiguous segment of 0's in s, or return false otherwise.\n\n    For example, in s = \"110100010\" the longest continuous segment of 1s has length 2, and the longest continuous segment of 0s has length 3.\n\n    Note that if there are no 0's, then the longest continuous segment of 0's is considered to have a length 0. The same applies if there is no 1's.\n\u00a0\n    Example 1:\n\n    Input: s = \"1101\"\n    Output: true\n    Explanation:\n    The longest contiguous segment of 1s has length 2: \"1101\"\n    The longest contiguous segment of 0s has length 1: \"1101\"\n    The segment of 1s is longer, so return true.\n\n    Example 2:\n\n    Input: s = \"111000\"\n    Output: false\n    Explanation:\n    The longest contiguous segment of 1s has length 3: \"111000\"\n    The longest contiguous segment of 0s has length 3: \"111000\"\n    The segment of 1s is not longer, so return false.\n\n    Example 3:\n\n    Input: s = \"110100010\"\n    Output: false\n    Explanation:\n    The longest contiguous segment of 1s has length 2: \"110100010\"\n    The longest contiguous segment of 0s has length 3: \"110100010\"\n    The segment of 1s is not longer, so return false.\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 100\n    s[i] is either '0' or '1'.\n\n    \"\"\"\n    # Precondition 1: Ensure the input is a non-empty string.\n    assert isinstance(s, str) and len(s) > 0, \"Input must be a non-empty string.\"\n\n    # Precondition 2: Ensure the length of the string is within the specified range.\n    assert 1 <= len(s) <= 100, \"The length of the input string must be between 1 and 100.\"\n\n    # Precondition 3: Ensure the string consists only of '0' and '1'.\n    assert all(c in '01' for c in s), \"The input string must consist only of '0' and '1'.\"\n\n    # Perform the operation\n    longest_zero = longest_one = current_zero = current_one = 0\n\n    for c in s:\n        if c == '0':\n            current_zero += 1\n            longest_zero = max(longest_zero, current_zero)\n            current_one = 0\n        else:\n            current_one += 1\n            longest_one = max(longest_one, current_one)\n            current_zero = 0\n\n    result = longest_one > longest_zero\n\n    # Postcondition: Ensure the output is a boolean value.\n    assert isinstance(result, bool), \"The result must be a boolean value.\"\n\n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"001\") == False\n\tassert candidate(\"1000011101\") == False\n\tassert candidate(\"110001\") == False\n\tassert candidate(\"111000001\") == False\n\tassert candidate(\"11010001011110011000001101000110101\") == False\n\tassert candidate(\"100110011001\") == False\n\tassert candidate(\"1101\") == True\n\tassert candidate(\"11000\") == False\n\tassert candidate(\"10001\") == False\n\tassert candidate(\"10000100010001\") == False\n\tassert candidate(\"1001\") == False\n\tassert candidate(\"100001000100\") == False\n\tassert candidate(\"1110001\") == False\n\tassert candidate(\"000\") == False\n\tassert candidate(\"1101000100001\") == False\n\tassert candidate(\"1001100100\") == False\n\tassert candidate(\"110\") == True\n\tassert candidate(\"1110\") == True\n\tassert candidate(\"1101000\") == False\n\tassert candidate(\"10000100010001000\") == False\n\tassert candidate(\"111001\") == True\n\tassert candidate(\"1110000\") == False\n\tassert candidate(\"10010\") == False\n\tassert candidate(\"11011\") == True\n\tassert candidate(\"1000010001000\") == False\n\tassert candidate(\"1000001\") == False\n\tassert candidate(\"110100010\") == False\n\tassert candidate(\"1000010001001\") == False\n\tassert candidate(\"100100010\") == False\n\tassert candidate(\"1000100010\") == False\n\tassert candidate(\"11\") == True\n\tassert candidate(\"1100110011\") == False\n\tassert candidate(\"100001\") == False\n\tassert candidate(\"100000\") == False\n\tassert candidate(\"111100\") == True\n\tassert candidate(\"1000010001000100010\") == False\n\tassert candidate(\"100001000100010\") == False\n\tassert candidate(\"1010\") == False\n\tassert candidate(\"111000\") == False\n\tassert candidate(\"1011101\") == True\n\tassert candidate(\"1111\") == True\n\tassert candidate(\"00001111\") == False\n\tassert candidate(\"01\") == False\n\tassert candidate(\"101000100011\") == False\n\tassert candidate(\"0000111\") == False\n\tassert candidate(\"111000110\") == False\n\tassert candidate(\"1010101\") == False\n\tassert candidate(\"1110001101\") == False\n\tassert candidate(\"00000000\") == False\n\tassert candidate(\"1100011\") == False\n\tassert candidate(\"1010001\") == False\n\tassert candidate(\"10000\") == False\n\tassert candidate(\"1000110001\") == False\n\tassert candidate(\"10011\") == False\n\tassert candidate(\"101010\") == False\n\tassert candidate(\"010\") == False\n\tassert candidate(\"000000\") == False\n\tassert candidate(\"11100\") == True\n\tassert candidate(\"0000\") == False\n\tassert candidate(\"101110100001\") == False\n\tassert candidate(\"10111111111\") == True\n\tassert candidate(\"1000010001000100\") == False\n\tassert candidate(\"1000001111\") == False\n\tassert candidate(\"101010101\") == False\n\tassert candidate(\"1111000\") == True\n\tassert candidate(\"000001\") == False\n\tassert candidate(\"0\") == False\n\tassert candidate(\"111111\") == True\n\tassert candidate(\"100\") == False\n\tassert candidate(\"1011100000\") == False\n\tassert candidate(\"100001000100010001\") == False\n\tassert candidate(\"0010101011\") == False\n\tassert candidate(\"100001010\") == False\n\tassert candidate(\"10111101\") == True\n\tassert candidate(\"10000000\") == False\n\tassert candidate(\"00\") == False\n\tassert candidate(\"010101\") == False\n\tassert candidate(\"100100\") == False\n\tassert candidate(\"11101101\") == True\n\tassert candidate(\"10000100010\") == False\n\tassert candidate(\"1000111\") == False\n\tassert candidate(\"10101\") == False\n\tassert candidate(\"111\") == True\n\tassert candidate(\"0001\") == False\n\tassert candidate(\"0000000000\") == False\n\tassert candidate(\"11111\") == True\n\tassert candidate(\"1\") == True\n\tassert candidate(\"111110\") == True\n\tassert candidate(\"1010000\") == False\n\tassert candidate(\"1000\") == False\ndef test_check():\n\tcheck(checkZeroOnes)\n# Metadata Difficulty: Easy\n# Metadata Topics: string\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1550, "filename": "LeetCode_1550_maxProductDifference.py", "content": "from typing import List\n\ndef maxProductDifference(nums: List[int]) -> int:\n    \"\"\"\n    The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).\n\n    For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.\n\n    Given an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.\n    Return the maximum such product difference.\n\u00a0\n    Example 1:\n\n    Input: nums = [5,6,2,7,4]\n    Output: 34\n    Explanation: We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4).\n    The product difference is (6 * 7) - (2 * 4) = 34.\n\n    Example 2:\n\n    Input: nums = [4,2,5,9,7,4,8]\n    Output: 64\n    Explanation: We can choose indices 3 and 6 for the first pair (9, 8) and indices 1 and 5 for the second pair (2, 4).\n    The product difference is (9 * 8) - (2 * 4) = 64.\n\n\u00a0\n    Constraints:\n\n    4 <= nums.length <= 104\n    1 <= nums[i] <= 104\n    \"\"\"\n    # Precondition 1: Ensure nums is a list of integers.\n    assert isinstance(nums, list) and all(isinstance(num, int) for num in nums), \"nums must be a list of integers.\"\n\n    # Precondition 2: Ensure the length of nums is within the specified range.\n    assert 4 <= len(nums) <= 104, \"The length of nums must be between 4 and 104.\"\n\n    # Precondition 3: Ensure each element in nums is within the specified range.\n    assert all(1 <= num <= 104 for num in nums), \"Each number in nums must be between 1 and 104.\"\n\n    # Perform the operation\n    min1, min2, max1, max2 = float('inf'), float('inf'), float('-inf'), float('-inf')\n    for num in nums:\n        if num < min1:\n            min2, min1 = min1, num\n        elif num < min2:\n            min2 = num\n        if num > max1:\n            max2, max1 = max1, num\n        elif num > max2:\n            max2 = num\n    result = max1 * max2 - min1 * min2\n\n    # Postcondition: Ensure the result is an integer and non-negative.\n    assert isinstance(result, int) and result >= 0, \"The result must be a non-negative integer.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\n    [5, 6, 2, 7, 4]) == 34, 'This is the example from the problem description'\n\tassert candidate(\n    [4, 2, 5, 9, 7, 4, 8]) == 64, \"This is the only test case that requires 7 lines.\"\n\tassert candidate([4, 2, 5, 9, 7, 4, 8]) == 64\n\tassert candidate([2, 5, 7, 10, 12]) == 110\n\tassert candidate([5, 6, 2, 7, 4]) == 34\n\tassert candidate([1, 1, 1, 1, 1]) == 0\n\tassert candidate([4, 2, 5, 9, 7, 4, 8]) == 64, 'This is the example from the problem description'\ndef test_check():\n\tcheck(maxProductDifference)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,sorting\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1564, "filename": "LeetCode_1564_get_concatenation.py", "content": "from typing import List\n\ndef get_concatenation(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an integer array nums of length n, you want to create an array ans of length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] for 0 <= i < n (0-indexed).\n    Specifically, ans is the concatenation of two nums arrays.\n    Return the array ans.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,2,1]\n    Output: [1,2,1,1,2,1]\n    Explanation: The array ans is formed as follows:\n    - ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]\n    - ans = [1,2,1,1,2,1]\n\n    Example 2:\n\n    Input: nums = [1,3,2,1]\n    Output: [1,3,2,1,1,3,2,1]\n    Explanation: The array ans is formed as follows:\n    - ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]\n    - ans = [1,3,2,1,1,3,2,1]\n\n\u00a0\n    Constraints:\n\n    n == nums.length\n    0 <= n <= 1000\n    1 <= nums[i] <= 1000\n\n    \"\"\"\n    # Precondition 1: Ensure nums is a list of integers.\n    assert isinstance(nums, list) and all(isinstance(num, int) for num in nums), \"nums must be a list of integers.\"\n\n    # Precondition 2: Ensure the length of nums is within the specified range.\n    assert 0 <= len(nums) <= 1000, \"The length of nums must be between 1 and 1000.\"\n\n    # Precondition 3: Ensure each element in nums is within the specified range.\n    assert all(1 <= num <= 1000 for num in nums), \"Each number in nums must be between 1 and 1000.\"\n\n    # Perform the operation\n    n = len(nums)\n    ans = [0] * (2 * n)\n    for i in range(n):\n        ans[i] = nums[i]\n        ans[i + n] = nums[i]\n\n    # Postcondition: Ensure the output is a list of integers with length 2n.\n    assert isinstance(ans, list) and len(ans) == 2 * n and all(isinstance(num, int) for num in ans), \\\n        \"The result must be a list of integers with length 2n.\"\n\n    return ans\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([2, 2, 2, 2, 2, 1]) == [2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1]\n\tassert candidate([1, 2]) == [1, 2, 1, 2]\n\tassert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\tassert candidate([3, 2]) == [3, 2, 3, 2]\n\tassert candidate([4, 5, 4, 5, 4, 5, 4, 4, 5]) == [4, 5, 4, 5, 4, 5, 4, 4, 5, 4, 5, 4, 5, 4, 5, 4, 4, 5]\n\tassert candidate([1, 2, 1, 2, 1, 2]) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n\tassert candidate([5, 3, 1, 2, 5, 1, 2]) == [5, 3, 1, 2, 5, 1, 2, 5, 3, 1, 2, 5, 1, 2]\n\tassert candidate([1, 3, 2, 1]) == [1, 3, 2, 1, 1, 3, 2, 1]\n\tassert candidate([1, 1]) == [1, 1, 1, 1]\n\tassert candidate([2, 1, 2, 1, 1, 1, 2, 2, 2, 1]) == [2, 1, 2, 1, 1, 1, 2, 2, 2, 1, 2, 1, 2, 1, 1, 1, 2, 2, 2, 1]\n\tassert candidate([1, 3, 2, 2, 3, 2, 2, 2, 7]) == [1, 3, 2, 2, 3, 2, 2, 2, 7, 1, 3, 2, 2, 3, 2, 2, 2, 7]\n\tassert candidate([2, 2, 2, 2]) == [2, 2, 2, 2, 2, 2, 2, 2]\n\tassert candidate([1, 2, 3, 4]) == [1, 2, 3, 4, 1, 2, 3, 4]\n\tassert candidate([1, 1, 1, 1]) == [1, 1, 1, 1, 1, 1, 1, 1]\n\tassert candidate([2, 1]) == [2, 1, 2, 1]\n\tassert candidate([3, 2, 3]) == [3, 2, 3, 3, 2, 3]\n\tassert candidate([3, 1]) == [3, 1, 3, 1]\n\tassert candidate([1, 2, 1]) == [1, 2, 1, 1, 2, 1]\n\tassert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n\tassert candidate([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\n\tassert candidate([3, 1, 3, 1]) == [3, 1, 3, 1, 3, 1, 3, 1]\n\tassert candidate([100, 200, 300, 400]) == [100, 200, 300, 400, 100, 200, 300, 400]\n\tassert candidate([1, 2, 3]) == [1, 2, 3, 1, 2, 3]\n\tassert candidate([1]) == [1, 1]\n\tassert candidate([]) == []\n\tassert candidate([1, 3, 2, 4]) == [1, 3, 2, 4, 1, 3, 2, 4]\n\tassert candidate([4, 3, 2, 1]) == [4, 3, 2, 1, 4, 3, 2, 1]\n\tassert candidate([1, 3, 1, 3, 1, 1]) == [1, 3, 1, 3, 1, 1, 1, 3, 1, 3, 1, 1]\n\tassert candidate([1, 2, 1, 1, 1, 3, 3, 2, 1]) == [1, 2, 1, 1, 1, 3, 3, 2, 1, 1, 2, 1, 1, 1, 3, 3, 2, 1]\ndef test_check():\n\tcheck(get_concatenation)\n# Metadata Difficulty: Easy\n# Metadata Topics: array\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1568, "filename": "LeetCode_1568_count_vowel_substrings.py", "content": "def count_vowel_substrings(word: str) -> int:\n    \"\"\"\n    A substring is a contiguous (non-empty) sequence of characters within a string.\n    A vowel substring is a substring that only consists of vowels ('a', 'e', 'i', 'o', and 'u') and has all five vowels present in it.\n    Given a string word, return the number of vowel substrings in word.\n\u00a0\n    Example 1:\n\n    Input: word = \"aeiouu\"\n    Output: 2\n    Explanation: The vowel substrings of word are as follows (underlined):\n    - \"aeiou\"\n    - \"aeiouu\"\n\n    Example 2:\n\n    Input: word = \"unicornarihan\"\n    Output: 0\n    Explanation: Not all 5 vowels are present, so there are no vowel substrings.\n\n    Example 3:\n\n    Input: word = \"cuaieuouac\"\n    Output: 7\n    Explanation: The vowel substrings of word are as follows (underlined):\n    - \"uaieuo\"\n    - \"aieuou\"\n    - \"aieuoua\"\n    - \"ieuouac\"\n    - \"uaieuo\"\n    - \"aieuou\"\n    - \"aieuoua\"\n\n\u00a0\n    Constraints:\n\n    1 <= word.length <= 100\n    word consists of lowercase English letters only.\n    \"\"\"\n    # Precondition: Ensure the input is a non-empty string of lowercase English letters.\n    assert isinstance(word, str) and word.islower(), \"word must be a non-empty string of lowercase English letters.\"\n    assert 1 <= len(word) <= 100, \"The length of word must be between 1 and 100.\"\n\n    vowels = set('aeiou')\n    count = 0\n    n = len(word)\n\n    # Check every possible substring\n    for i in range(n):\n        if word[i] in vowels:\n            seen_vowels = set()\n            for j in range(i, n):\n                if word[j] in vowels:\n                    seen_vowels.add(word[j])\n                    if len(seen_vowels) == 5:  # All five vowels are present\n                        count += 1\n                else:\n                    break\n\n    # Postcondition: Ensure the result is a non-negative integer.\n    assert isinstance(count, int) and count >= 0, \"The result must be a non-negative integer.\"\n\n    return count\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\n    \"aeioubcd\") == 1\n\tassert candidate(\"aeiouaei\") == 1\n\tassert candidate(\"aeiouaeiou\") == 6\n\tassert candidate(\"aeiuo\") == 0\n\tassert candidate(\n    \"vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\") == 0\n\tassert candidate(\"\") == 0\n\tassert candidate(\"a\") == 0\n\tassert candidate(\n    \"vzlbsiikaomuuaixoiogkqxuwfepnvzkslwiioipvzlsiikvzl\") == 0\n\tassert candidate(\"u\") == 0\n\tassert candidate(\n    \"aeiouu\") == 2\n\tassert candidate(\"unicornarihan\") == 0\n\tassert candidate(\"aeio\") == 0\n\tassert candidate(\"aeioubcd\") == 1\n\tassert candidate(\"abcdefghi\") == 0\n\tassert candidate(\"ae\") == 0\n\tassert candidate(\n    \"bbbaeixoqvwuubbb\") == 2\n\tassert candidate(\"aeiouu\") == 2\n\tassert candidate(\n    \"bbbaeixoqvwubbb\") == 1\n\tassert candidate(\"aei\") == 0\n\tassert candidate(\"aeiouae\") == 1\n\tassert candidate(\"aeiou\") == 1\n\tassert candidate(\"aeiouaeio\") == 1\ndef test_check():\n\tcheck(count_vowel_substrings)\n# Metadata Difficulty: Easy\n# Metadata Topics: hash-table,string\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1872, "filename": "LeetCode_1872_common_factors.py", "content": "def common_factors(a: int, b: int) -> int:\n    \"\"\"\n    Given two positive integers a and b, return the number of common factors of a and b.\n    An integer x is a common factor of a and b if x divides both a and b.\n\u00a0\n    Example 1:\n\n    Input: a = 12, b = 6\n    Output: 4\n    Explanation: The common factors of 12 and 6 are 1, 2, 3, 6.\n\n    Example 2:\n\n    Input: a = 25, b = 30\n    Output: 2\n    Explanation: The common factors of 25 and 30 are 1, 5.\n\n\u00a0\n    Constraints:\n\n    1 <= a, b <= 1000\n    \"\"\"\n    # Precondition: Ensure a and b are positive integers within the specified range.\n    assert isinstance(a, int) and isinstance(b, int), \"a and b must be integers.\"\n    assert 1 <= a <= 1000 and 1 <= b <= 1000, \"a and b must be between 1 and 1000.\"\n\n    from math import gcd\n\n    g = gcd(a, b)\n    count = 0\n    for i in range(1, int(g**0.5) + 1):\n        if g % i == 0:\n            count += 1\n            if i * i != g:\n                count += 1\n\n    # Postcondition: Ensure the result is a non-negative integer.\n    assert isinstance(count, int) and count >= 0, \"The result must be a non-negative integer.\"\n\n    return count\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(14, 28) == 4\n\tassert candidate(44, 88) == 6\n\tassert candidate(8, 16) == 4\n\tassert candidate(125, 25) == 3\n\tassert candidate(33, 99) == 4\n\tassert candidate(19, 38) == 2\n\tassert candidate(25, 125) == 3\n\tassert candidate(17, 34) == 2\n\tassert candidate(81, 27) == 4\n\tassert candidate(40, 80) == 8\n\tassert candidate(5, 25) == 2\n\tassert candidate(18, 36) == 6\n\tassert candidate(20, 40) == 6\n\tassert candidate(11, 7) == 1\n\tassert candidate(13, 26) == 2\n\tassert candidate(9, 3) == 2\n\tassert candidate(16, 32) == 5\n\tassert candidate(7, 21) == 2\n\tassert candidate(1000, 999) == 1\n\tassert candidate(11, 22) == 2\n\tassert candidate(27, 81) == 4\n\tassert candidate(12, 6) == 4\n\tassert candidate(999, 1000) == 1\n\tassert candidate(1000, 1000) == 16\n\tassert candidate(10, 15) == 2\n\tassert candidate(31, 62) == 2\n\tassert candidate(77, 154) == 4\n\tassert candidate(1, 16) == 1\n\tassert candidate(37, 74) == 2\n\tassert candidate(35, 70) == 4\n\tassert candidate(25, 30) == 2\n\tassert candidate(1, 1) == 1\n\tassert candidate(789, 123) == 2\n\tassert candidate(2, 14) == 2\n\tassert candidate(42, 56) == 4\n\tassert candidate(5, 10) == 2\n\tassert candidate(26, 52) == 4\n\tassert candidate(32, 64) == 6\n\tassert candidate(128, 64) == 7\n\tassert candidate(77, 88) == 2\n\tassert candidate(36, 48) == 6\n\tassert candidate(7, 14) == 2\n\tassert candidate(3, 6) == 2\n\tassert candidate(64, 128) == 7\n\tassert candidate(14, 21) == 2\n\tassert candidate(10, 5) == 2\n\tassert candidate(24, 48) == 8\n\tassert candidate(3, 9) == 2\n\tassert candidate(111, 222) == 4\n\tassert candidate(28, 70) == 4\n\tassert candidate(12, 24) == 6\n\tassert candidate(23, 46) == 2\n\tassert candidate(9, 18) == 3\ndef test_check():\n\tcheck(common_factors)\n# Metadata Difficulty: Easy\n# Metadata Topics: math,enumeration,number-theory\n# Metadata Coverage: 100\ntest_check()"}
{"id": 1909, "filename": "LeetCode_1909_distinctAverages.py", "content": "from typing import List\n\ndef distinctAverages(nums: List[int]) -> int:\n    \"\"\"\n    You are given a 0-indexed integer array nums of even length.\n    As long as nums is not empty, you must repetitively:\n\n    Find the minimum number in nums and remove it.\n    Find the maximum number in nums and remove it.\n    Calculate the average of the two removed numbers.\n\n    The average of two numbers a and b is (a + b) / 2.\n\n    For example, the average of 2 and 3 is (2 + 3) / 2 = 2.5.\n\n    Return the number of distinct averages calculated using the above process.\n    Note that when there is a tie for a minimum or maximum number, any can be removed.\n\u00a0\n    Example 1:\n\n    Input: nums = [4,1,4,0,3,5]\n    Output: 2\n    Explanation:\n    1. Remove 0 and 5, and the average is (0 + 5) / 2 = 2.5. Now, nums = [4,1,4,3].\n    2. Remove 1 and 4. The average is (1 + 4) / 2 = 2.5, and nums = [4,3].\n    3. Remove 3 and 4, and the average is (3 + 4) / 2 = 3.5.\n    Since there are 2 distinct numbers among 2.5, 2.5, and 3.5, we return 2.\n\n    Example 2:\n\n    Input: nums = [1,100]\n    Output: 1\n    Explanation:\n    There is only one average to be calculated after removing 1 and 100, so we return 1.\n\n\u00a0\n    Constraints:\n\n    2 <= nums.length <= 100\n    nums.length is even.\n    0 <= nums[i] <= 100\n    \"\"\"\n    # Precondition 1: Ensure nums is a list of integers.\n    assert isinstance(nums, list) and all(isinstance(num, int) for num in nums), \"nums must be a list of integers.\"\n\n\n    # Perform the operation\n    averages = set()\n    nums.sort()\n    n = len(nums)\n    for i in range(n // 2):\n        averages.add((nums[i] + nums[n - 1 - i]) / 2.0)\n\n    # Postcondition: Ensure the result is a non-negative integer.\n    result = len(averages)\n    assert isinstance(result, int) and result >= 0, \"The result must be a non-negative integer.\"\n\n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([3,3,3,3,3,3]) == 1\n\tassert candidate([1,2]) == 1\n\tassert candidate([4,1,4,0,3,5]) == 2\n\tassert candidate([100,0,50,50]) == 1\n\tassert candidate([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]) == 1\n\tassert candidate(\n    [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]) == 1\n\tassert candidate([1,1,1,1]) == 1\n\tassert candidate([1,100]) == 1\n\tassert candidate([0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1]) == 1\ndef test_check():\n\tcheck(distinctAverages)\n# Metadata Difficulty: Easy\n# Metadata Topics: array,hash-table,two-pointers,sorting\n# Metadata Coverage: 100\ntest_check()"}

{"id": 32, "filename": "LeetCode_32_count_and_say.py", "content": "def count_and_say(n: int) -> str:\n    \"\"\"\n    The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\n    countAndSay(1) = \"1\"\n    countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n\n    To determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\n    For example, the saying and conversion for digit string \"3322251\":\n\n    Given a positive integer n, return the nth term of the count-and-say sequence.\n\u00a0\n    Example 1:\n\n    Input: n = 1\n    Output: \"1\"\n    Explanation: This is the base case.\n\n    Example 2:\n\n    Input: n = 4\n    Output: \"1211\"\n    Explanation:\n    countAndSay(1) = \"1\"\n    countAndSay(2) = say \"1\" = one 1 = \"11\"\n    countAndSay(3) = say \"11\" = two 1's = \"21\"\n    countAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 30\n\n    \"\"\"\n    ### Canonical solution below ###\n\n    assert isinstance(n, int), \"Input must be an integer.\"\n    assert 1 <= n <= 30, \"Input must be between 1 and 30 inclusive.\"\n    assert n > 0, \"Input must be a positive integer.\"\n    assert n == int(n), \"Input must be an integer without a decimal.\"\n    assert n <= 30, \"The input should not exceed 30 as per constraints.\"\n    \n    if n == 1:\n        return \"1\"\n    previous = count_and_say(n - 1)\n    result = []\n    count = 1\n    for i in range(1, len(previous)):\n        if previous[i] == previous[i - 1]:\n            count += 1\n        else:\n            result.append(str(count))\n            result.append(previous[i - 1])\n            count = 1\n    output = \"\".join(result)\n    result.append(str(count))\n    result.append(previous[-1])\n    assert isinstance(output, str), \"Output must be a string.\"\n    assert all(c.isdigit() for c in output), \"Output must contain only digits.\"\n    assert len(output) >= 0, \"Output must not be an empty string.\"\n    assert len(output) % 2 == 0, \"Output length should be even as it represents counts and digits.\"\n    assert len(output) <= 2 ** (n - 1), f\"Output length exceeds expected length for n={n}.\"\n    assert output == output.strip(), \"Output should not contain leading or trailing spaces.\"\n\n    return \"\".join(result)\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(16) == \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\"\n\tassert candidate(7) == \"13112221\"\n\tassert candidate(13) == \"1321132132111213122112311311222113111221131221\"\n\tassert candidate(1) == \"1\"\n\tassert candidate(4) == \"1211\"\n\tassert candidate(3) == \"21\"\n\tassert candidate(11) == \"11131221133112132113212221\"\n\tassert candidate(10) == \"13211311123113112211\"\n\tassert candidate(2) == \"11\"\n\tassert candidate(6) == \"312211\"\n\tassert candidate(15) == \"311311222113111231131112132112311321322112111312211312111322212311322113212221\"\n\tassert candidate(5) == \"111221\"\n\tassert candidate(12) == \"3113112221232112111312211312113211\"\n\tassert candidate(9) == \"31131211131221\"\n\tassert candidate(8) == \"1113213211\"\n\tassert candidate(14) == \"11131221131211131231121113112221121321132132211331222113112211\"\ndef test_check():\n\tcheck(count_and_say)\n# Metadata Difficulty: Medium\n# Metadata Topics: string\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 34, "filename": "LeetCode_34_combinationSum2.py", "content": "from typing import List\n\n\ndef combinationSum2(candidates: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates\u00a0where the candidate numbers sum to target.\n    Each number in candidates\u00a0may only be used once in the combination.\n    Note:\u00a0The solution set must not contain duplicate combinations.\n\u00a0\n    Example 1:\n\n    Input: candidates = [10,1,2,7,6,1,5], target = 8\n    Output: \n    [\n    [1,1,6],\n    [1,2,5],\n    [1,7],\n    [2,6]\n    ]\n\n    Example 2:\n\n    Input: candidates = [2,5,2,1,2], target = 5\n    Output: \n    [\n    [1,2,2],\n    [5]\n    ]\n\n\u00a0\n    Constraints:\n\n    1 <=\u00a0candidates.length <= 100\n    1 <=\u00a0candidates[i] <= 50\n    1 <= target <= 30\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(candidates, list), \"Candidates must be a list.\"\n    assert all(isinstance(x, int) for x in candidates), \"All elements in candidates must be integers.\"\n    assert 1 <= len(candidates) <= 100, \"Candidates list length must be between 1 and 100.\"\n    assert all(1 <= x <= 50 for x in candidates), \"Each candidate must be between 1 and 50.\"\n    assert isinstance(target, int) and 1 <= target <= 30, \"Target must be an integer between 1 and 30.\"\n    \n    def combine(candidates, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue\n            if candidates[i] > target:\n                break\n            combine(candidates, target - candidates[i], i+1, path + [candidates[i]], res)\n\n    candidates.sort()\n    res = []\n    combine(candidates, target, 0, [], res)\n    assert isinstance(res, list), \"Result must be a list.\"\n    assert all(isinstance(combination, list) for combination in res), \"Each combination in result must be a list.\"\n    assert all(sum(combination) == target for combination in res), \"Sum of each combination must equal the target.\"\n    assert len(res) == len(set(tuple(sorted(combination)) for combination in res)), \"Result must not contain duplicate combinations.\"\n    assert all(all(1 <= num <= 50 for num in combination) for combination in res), \"All numbers in each combination must be between 1 and 50.\"\n    assert all(len(combination) > 0 for combination in res), \"Each combination must contain at least one number.\"\n    \n    return res\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1,1,1,1,1], 2) == [[1,1]]\n\tassert candidate([1,2,3,4,5], 5) == [[1, 4], [2, 3], [5]]\n\tassert candidate([10,1,2,7,6,1,5], 8) == [[1,1,6], [1,2,5], [1,7], [2,6]]\n\tassert candidate([4,4,4,4,4], 8) == [[4,4]]\n\tassert candidate([1], 1) == [[1]]\n\tassert candidate([1,1,1,1,1], 5) == [[1,1,1,1,1]]\n\tassert candidate([2,5,2,1,2], 5) == [[1,2,2], [5]]\n\tassert candidate([1,2,3,4,5], 1) == [[1]]\n\tassert candidate(\n    [10,1,2,7,6,1,5], 8\n) == [[1,1,6], [1,2,5], [1,7], [2,6]]\n\tassert candidate([1,1], 2) == [[1,1]]\n\tassert candidate([1], 2) == []\n\tassert candidate(\n    [1,2,3,4,5], 5\n) == [[1, 4], [2, 3], [5]]\ndef test_check():\n\tcheck(combinationSum2)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,backtracking\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 47, "filename": "LeetCode_47_maxSubArray.py", "content": "from typing import List\n\n\ndef maxSubArray(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array nums, find the subarray with the largest sum, and return its sum.\n\u00a0\n    Example 1:\n\n    Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\n    Output: 6\n    Explanation: The subarray [4,-1,2,1] has the largest sum 6.\n\n    Example 2:\n\n    Input: nums = [1]\n    Output: 1\n    Explanation: The subarray [1] has the largest sum 1.\n\n    Example 3:\n\n    Input: nums = [5,4,-1,7,8]\n    Output: 23\n    Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 10^5\n    -10^4 <= nums[i] <= 10^4\n\n\u00a0\n    Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(nums, list), \"Input must be a list.\"\n    assert all(isinstance(num, int) for num in nums), \"All elements in nums must be integers.\"\n    assert 1 <= len(nums) <= 10**5, \"Length of nums must be between 1 and 100,000.\"\n    \n    max_sum = current_sum = nums[0]\n\n    for num in nums[1:]:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n    assert isinstance(max_sum, int), \"Output must be an integer.\"\n    assert max_sum >= max(nums), \"Maximum subarray sum should be at least as large as the largest individual element.\"\n    assert max_sum == sum(nums) or max_sum > sum([n for n in nums if n < 0]), \"Maximum subarray sum must be correctly derived.\"\n    assert max_sum >= 0 or max_sum == max(nums), \"In a list of all negative numbers, the maximum sum should be the largest single element.\"\n\n    return max_sum\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1, 2, 3, 4, 5]) == 15\n\tassert candidate([1]) == 1\n\tassert candidate([31,-41,59,26,-53,58,97,-93,-23,84]) == 187\n\tassert candidate([-1, -1, -1, -1, -1]) == -1\n\tassert candidate([-2, -3, 4, -1, -2, -1, -5, -3]) == 4\n\tassert candidate([0, -1, -2, -3, -4]) == 0\n\tassert candidate(list(range(1000)) + [-1001]) == 499500\n\tassert candidate(list(range(1000)) + [-1, 0, 0, 0, 1]) == 499500\n\tassert candidate([-2,-3,4,-1,2,1,-5,4]) == 6\n\tassert candidate([-1, -2, -3, -4, -5]) == -1\n\tassert candidate(\n    [-2147483647, -1, -2147483647, 2147483647, -2147483647, -2147483647]) == 2147483647\n\tassert candidate([-1, -1, -1, -1, 5]) == 5\n\tassert candidate([3, -2, 5, -1]) == 6\n\tassert candidate([1, -1, 1, -1, 1, -1, 1, -1]) == 1\n\tassert candidate(list(range(1000))) == 499500\n\tassert candidate([-2,1,-3,4,-1,2,1,-5,4]) == 6\n\tassert candidate([-2, 1, -3, 5, -2, 3]) == 6\n\tassert candidate([-1, -1, -1, -1, 0]) == 0\n\tassert candidate([3,-2,5,-1]) == 6\n\tassert candidate([0, 0, 0, 0, 0]) == 0\n\tassert candidate([4, -2, -8, 5, -2, 7, 7, 2, -6, 5]) == 19\n\tassert candidate([5,4,-1,7,8]) == 23\n\tassert candidate([-2,3,-2]) == 3\n\tassert candidate(\n    [-2, -3, 4, -1, -2, -1, -5, -3]) == 4\n\tassert candidate([-1, 0, 1, -1, 0]) == 1\ndef test_check():\n\tcheck(maxSubArray)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,divide-and-conquer,dynamic-programming\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 126, "filename": "LeetCode_126_fraction_to_decimal.py", "content": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    \"\"\"\n    Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\n    If the fractional part is repeating, enclose the repeating part in parentheses.\n    If multiple answers are possible, return any of them.\n    It is guaranteed that the length of the answer string is less than 10^4 for all the given inputs.\n    \"\"\"\n    \n    # Preconditions\n    assert isinstance(numerator, int), \"Numerator must be an integer.\"\n    assert isinstance(denominator, int), \"Denominator must be an integer.\"\n    assert -2**31 <= numerator <= 2**31 - 1, \"Numerator must be within the 32-bit signed integer range.\"\n    assert denominator != 0, \"Denominator cannot be zero.\"\n\n    ### Canonical solution below ###\n    if numerator == 0:\n        return \"0\"\n    res = []\n    if (numerator > 0) ^ (denominator > 0):\n        res.append(\"-\")\n    num = abs(numerator)\n    den = abs(denominator)\n    res.append(str(num // den))\n    num %= den\n    if num == 0:\n        return \"\".join(res)\n    res.append(\".\")\n    map = {}\n    while num:\n        if num in map:\n            res.insert(map[num], \"(\")\n            res.append(\")\")\n            break\n        map[num] = len(res)\n        num *= 10\n        res.append(str(num // den))\n        num %= den\n    result = \"\".join(res)\n    \n    # Postconditions\n    assert isinstance(result, str), \"The result must be a string.\"\n    assert len(result) < 10**4, \"The result must be less than 10^4 characters in length.\"\n    assert result.count('.') <= 1, \"The result must contain at most one decimal point.\"\n    assert '(' not in result or result.count('(') == 1 and result.count(')') == 1, \"If the result contains a repeating sequence, it must be enclosed in exactly one pair of parentheses.\"\n    assert result.count('-') <= 1, \"The result must have at most one negative sign.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(0, -7) == \"0\"\n\tassert candidate(0, -1) == \"0\"\n\tassert candidate(20, -1) == \"-20\"\n\tassert candidate(1, 3) == \"0.(3)\"\n\tassert candidate(0, 1) == \"0\"\n\tassert candidate(-5, -1) == \"5\"\n\tassert candidate(6, 3) == \"2\"\n\tassert candidate(-1, 1) == \"-1\"\n\tassert candidate(-7, 9) == \"-0.(7)\"\n\tassert candidate(-10, -1) == \"10\"\n\tassert candidate(70, 10) == \"7\"\n\tassert candidate(5, 6) == \"0.8(3)\"\n\tassert candidate(1, 10000000000) == \"0.0000000001\"\n\tassert candidate(7, 3) == \"2.(3)\"\n\tassert candidate(6, -3) == \"-2\"\n\tassert candidate(3, -2) == \"-1.5\"\n\tassert candidate(0, -11) == \"0\"\n\tassert candidate(-1, 12) == \"-0.08(3)\"\n\tassert candidate(-1, -1) == \"1\"\n\tassert candidate(7, -3) == \"-2.(3)\"\n\tassert candidate(-5, -3) == \"1.(6)\"\n\tassert candidate(6, 1) == \"6\"\n\tassert candidate(3, -3) == \"-1\"\n\tassert candidate(1, 6) == \"0.1(6)\"\n\tassert candidate(2, 1) == \"2\"\n\tassert candidate(-22, 7) == \"-3.(142857)\"\n\tassert candidate(0, 10) == \"0\"\n\tassert candidate(-3, -3) == \"1\"\n\tassert candidate(1001, 7) == \"143\"\n\tassert candidate(0, -111) == \"0\"\n\tassert candidate(1, 100000000000) == \"0.00000000001\"\n\tassert candidate(5, -3) == \"-1.(6)\"\n\tassert candidate(4, 2) == \"2\"\n\tassert candidate(-21, -2) == \"10.5\"\n\tassert candidate(-20, 1) == \"-20\"\n\tassert candidate(-4, -1) == \"4\"\n\tassert candidate(-50, 8) == \"-6.25\"\n\tassert candidate(-8, -2) == \"4\"\n\tassert candidate(1, 1000000000000) == \"0.000000000001\"\n\tassert candidate(10, 2) == \"5\"\n\tassert candidate(7, 9) == \"0.(7)\"\n\tassert candidate(1, 7) == \"0.(142857)\"\n\tassert candidate(-5, 3) == \"-1.(6)\"\n\tassert candidate(-6, -4) == \"1.5\"\n\tassert candidate(-7, -3) == \"2.(3)\"\n\tassert candidate(1, 1000000000) == \"0.000000001\"\n\tassert candidate(1, -1) == \"-1\"\n\tassert candidate(22, -7) == \"-3.(142857)\"\n\tassert candidate(-3, 7) == \"-0.(428571)\"\n\tassert candidate(22, 7) == \"3.(142857)\"\n\tassert candidate(1, -3) == \"-0.(3)\"\n\tassert candidate(1, 20) == \"0.05\"\n\tassert candidate(21, 2) == \"10.5\"\n\tassert candidate(4, 333) == \"0.(012)\"\n\tassert candidate(1, 2) == \"0.5\"\n\tassert candidate(-20, -1) == \"20\"\n\tassert candidate(-4, 1) == \"-4\"\n\tassert candidate(1, 10000000000000) == \"0.0000000000001\"\n\tassert candidate(-1, -3) == \"0.(3)\"\n\tassert candidate(3, -1) == \"-3\"\n\tassert candidate(1, -2) == \"-0.5\"\n\tassert candidate(5, 3) == \"1.(6)\"\n\tassert candidate(23, 3) == \"7.(6)\"\n\tassert candidate(2, 7) == \"0.(285714)\"\n\tassert candidate(-1, 2) == \"-0.5\"\n\tassert candidate(3, 1) == \"3\"\n\tassert candidate(-1, 6) == \"-0.1(6)\"\n\tassert candidate(0, -99999999999999999) == \"0\"\n\tassert candidate(0, -2) == \"0\"\n\tassert candidate(89, 9) == \"9.(8)\"\n\tassert candidate(5, -1) == \"-5\"\n\tassert candidate(345, 11) == \"31.(36)\"\ndef test_check():\n\tcheck(fraction_to_decimal)\n# Metadata Difficulty: Medium\n# Metadata Topics: hash-table,math,string\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 201, "filename": "LeetCode_201_numSquares.py", "content": "def numSquares(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the least number of perfect square numbers that sum to n.\n    A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself.\n    \"\"\"\n    \n    # Preconditions\n    assert isinstance(n, int), \"Input must be an integer.\"\n    assert 1 <= n <= 10**4, \"Input must be between 1 and 10^4.\"\n\n    # Canonical solution\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n\n    result = dp[n]\n\n    # Postconditions\n    assert isinstance(result, int), \"The result must be an integer.\"\n    assert result > 0, \"The result must be a positive integer.\"\n    assert dp[n] == min([dp[n - j * j] + 1 for j in range(1, int(n**0.5) + 1) if j * j <= n]), \"The final result must be the minimum number of perfect squares summing to n.\"\n    \n    return result\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(6) == 3\n\tassert candidate(41) == 2\n\tassert candidate(45) == 2\n\tassert candidate(28) == 4\n\tassert candidate(5) == 2\n\tassert candidate(1200) == 3\n\tassert candidate(7) == 4\n\tassert candidate(32) == 2\n\tassert candidate(71) == 4\n\tassert candidate(66) == 3\n\tassert candidate(222) == 3\n\tassert candidate(42) == 3\n\tassert candidate(44) == 3\n\tassert candidate(55) == 4\n\tassert candidate(60) == 4\n\tassert candidate(38) == 3\n\tassert candidate(1) == 1\n\tassert candidate(72) == 2\n\tassert candidate(68) == 2\n\tassert candidate(26) == 2\n\tassert candidate(63) == 4\n\tassert candidate(30) == 3\n\tassert candidate(64) == 1\n\tassert candidate(20) == 2\n\tassert candidate(522) == 2\n\tassert candidate(70) == 3\n\tassert candidate(1425) == 3\n\tassert candidate(31) == 4\n\tassert candidate(58) == 2\n\tassert candidate(1132) == 3\n\tassert candidate(27) == 3\n\tassert candidate(2) == 2\n\tassert candidate(46) == 3\n\tassert candidate(22) == 3\n\tassert candidate(13) == 2\n\tassert candidate(57) == 3\n\tassert candidate(56) == 3\n\tassert candidate(37) == 2\n\tassert candidate(21) == 3\n\tassert candidate(4001) == 2\n\tassert candidate(23) == 4\n\tassert candidate(40) == 2\n\tassert candidate(16) == 1\n\tassert candidate(24) == 3\n\tassert candidate(12) == 3\n\tassert candidate(14) == 3\n\tassert candidate(19) == 3\n\tassert candidate(51) == 3\n\tassert candidate(8) == 2\n\tassert candidate(43) == 3\n\tassert candidate(80) == 2\n\tassert candidate(18) == 2\n\tassert candidate(11) == 3\n\tassert candidate(33) == 3\n\tassert candidate(69) == 3\n\tassert candidate(99) == 3\n\tassert candidate(76) == 3\n\tassert candidate(17) == 2\n\tassert candidate(48) == 3\n\tassert candidate(4) == 1\n\tassert candidate(36) == 1\n\tassert candidate(62) == 3\n\tassert candidate(1037) == 2\n\tassert candidate(65) == 2\n\tassert candidate(25) == 1\n\tassert candidate(47) == 4\n\tassert candidate(772) == 2\n\tassert candidate(29) == 2\n\tassert candidate(82) == 2\n\tassert candidate(9) == 1\n\tassert candidate(3) == 3\n\tassert candidate(52) == 2\n\tassert candidate(10) == 2\n\tassert candidate(34) == 2\n\tassert candidate(54) == 3\n\tassert candidate(93) == 3\n\tassert candidate(85) == 2\n\tassert candidate(15) == 4\n\tassert candidate(98) == 2\ndef test_check():\n\tcheck(numSquares)\n# Metadata Difficulty: Medium\n# Metadata Topics: math,dynamic-programming,breadth-first-search\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 272, "filename": "LeetCode_272_wiggleMaxLength.py", "content": "from typing import List\n\n\ndef wiggleMaxLength(nums: List[int]) -> int:\n    \"\"\"\n    A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.\n\n    For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.\n    In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.\n\n    A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.\n    Given an integer array nums, return the length of the longest wiggle subsequence of nums.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,7,4,9,2,5]\n    Output: 6\n    Explanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).\n\n    Example 2:\n\n    Input: nums = [1,17,5,10,13,15,10,5,16,8]\n    Output: 7\n    Explanation: There are several subsequences that achieve this length.\n    One is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).\n\n    Example 3:\n\n    Input: nums = [1,2,3,4,5,6,7,8,9]\n    Output: 2\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 1000\n    0 <= nums[i] <= 1000\n\n\u00a0\n    Follow up: Could you solve this in O(n) time?\n    \"\"\"\n    ### Canonical solution below ###\n    if len(nums) < 2:\n        return len(nums)\n\n    up, down = 1, 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            up = down + 1\n        elif nums[i] < nums[i - 1]:\n            down = up + 1\n    return max(up, down)\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([0, 1000, 1000, 0, 1000, 0, 1000, 0, 1000]) == 8\n\tassert candidate([1, 2]) == 2\n\tassert candidate([4,5,6,7,8,9,10,11,12,13,14,15]) == 2\n\tassert candidate([1]) == 1\n\tassert candidate([1,7,4,9,2,5]) == 6\n\tassert candidate([0, 1000, 0, 1000, 0, 1000, 0, 1000, 0, 1000]) == 10\n\tassert candidate([9,8,7,6,5,4,3,2,1]) == 2\n\tassert candidate([1, 100, 100]) == 2\n\tassert candidate([1,17,5,10,13,15,10,5,16,8]) == 7\n\tassert candidate([1, 17, 5, 10, 13, 15, 10, 5, 16, 8]) == 7\n\tassert candidate([15,14,13,12,11,10,9,8,7,6,5,4]) == 2\n\tassert candidate([1, 17, 5, 10, 13, 15, 10, 5, 16, 8, 19, 20]) == 8\n\tassert candidate([5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5]) == 2\n\tassert candidate([1,1,1,1,1,1,1,1,1]) == 1\n\tassert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 2\n\tassert candidate([1,2,3,4,5,6,7,8,9]) == 2\n\tassert candidate([100, 2, 3, 4, 100, 100]) == 3\n\tassert candidate([1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) == 2\n\tassert candidate([23,21,19,17,15,13,11,9,7,5,3,1]) == 2\n\tassert candidate([]) == 0\n\tassert candidate([2, 1]) == 2\n\tassert candidate([2, 3, 4, 5, 6, 7, 8, 9]) == 2\n\tassert candidate([1,3,5,7,9,11,13,15,17,19,21,23]) == 2\ndef test_check():\n\tcheck(wiggleMaxLength)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,dynamic-programming,greedy\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 304, "filename": "LeetCode_304_canPartition.py", "content": "from typing import List\n\n\ndef canPartition(nums: List[int]) -> bool:\n    \"\"\"\n    Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,5,11,5]\n    Output: true\n    Explanation: The array can be partitioned as [1, 5, 5] and [11].\n\n    Example 2:\n\n    Input: nums = [1,2,3,5]\n    Output: false\n    Explanation: The array cannot be partitioned into equal sum subsets.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 200\n    1 <= nums[i] <= 100\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(nums, list) and all(isinstance(x, int) for x in nums), \"nums must be a list of integers.\"\n    assert 1 <= len(nums) <= 200, \"The length of nums must be between 1 and 200.\"\n\n    # Canonical solution\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n\n    target = total_sum // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n\n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n\n    result = dp[target]\n\n    # Postconditions\n    assert isinstance(result, bool), \"The result must be a boolean.\"\n    assert result is True or result is False, \"The result must be either True or False.\"\n    if result:\n        assert sum(nums) % 2 == 0, \"If partition is possible, total sum must be even.\"\n\n    return result\n\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10]) == True\n\tassert candidate([90, 10, 20, 80]) == True\n\tassert candidate([1, 1, 5, 5, 10, 10]) == True\n\tassert candidate(\n    [40, 14, 31, 33, 8, 12, 40, 16, 23, 6, 26, 17, 33, 28, 13, 10, 40, 14, 31, 33, 8, 12, 40, 16, 23, 6, 26, 17,\n     33, 28, 13, 10]) == True\n\tassert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == False\n\tassert candidate([1, 5, 11, 5]) == True\n\tassert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11]) == False\n\tassert candidate([1, 2, 3, 6]) == True\n\tassert candidate(\n    [530, 290, 610, 27, 220, 730, 650, 600, 320, 50, 140, 240, 600]) == False\n\tassert candidate([50, 50, 50, 50]) == True\n\tassert candidate([1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) == True\n\tassert candidate(\n    [130, 290, 820, 270, 150, 730, 650, 600, 320, 50, 140, 240, 600]) == False\n\tassert candidate([1, 2, 4, 8, 16, 32]) == False\n\tassert candidate([100, 50, 50, 2]) == False\n\tassert candidate([1, 3, 5, 7, 9]) == False\n\tassert candidate([30, 70, 60, 40]) == True\n\tassert candidate([1, 2, 3, 5]) == False\n\tassert candidate(\n    [1, 2, 5, 10, 20, 40, 80, 160, 320, 640, 1280, 2560, 5120, 10240, 20480, 40960, 81920, 163840, 327680, 655360]) == False\n\tassert candidate(\n    [40, 20, 80, 30, 60, 50, 10, 70, 30, 20, 10, 50, 40, 50, 50, 10, 10, 40, 10, 20, 20, 10, 50, 50, 20, 40, 40, 30,\n     70, 10, 10]) == False\n\tassert candidate(\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 10, 10, 10, 10, 10, 10, 10, 10]) == False\ndef test_check():\n\tcheck(canPartition)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,dynamic-programming\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 324, "filename": "LeetCode_324_compress.py", "content": "from typing import List\n\n\ndef compress(chars: List[str]) -> int:\n    \"\"\"\n    Given an array of characters chars, compress it using the following algorithm:\n    Begin with an empty string s. For each group of consecutive repeating characters in chars:\n\n    If the group's length is 1, append the character to s.\n    Otherwise, append the character followed by the group's length.\n\n    The compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.\n    After you are done modifying the input array, return the new length of the array.\n    You must write an algorithm that uses only constant extra space.\n\u00a0\n    Example 1:\n\n    Input: chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]\n    Output: Return 6, and the first 6 characters of the input array should be: [\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]\n    Explanation: The groups are \"aa\", \"bb\", and \"ccc\". This compresses to \"a2b2c3\".\n\n    Example 2:\n\n    Input: chars = [\"a\"]\n    Output: Return 1, and the first character of the input array should be: [\"a\"]\n    Explanation: The only group is \"a\", which remains uncompressed since it's a single character.\n\n    Example 3:\n\n    Input: chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]\n    Output: Return 4, and the first 4 characters of the input array should be: [\"a\",\"b\",\"1\",\"2\"].\n    Explanation: The groups are \"a\" and \"bbbbbbbbbbbb\". This compresses to \"ab12\".\n\u00a0\n    Constraints:\n\n    1 <= chars.length <= 2000\n    chars[i] is a lowercase English letter, uppercase English letter, digit, or symbol.\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(chars, list), \"Input must be a list.\"\n    assert 1 <= len(chars) <= 2000, \"The length of chars must be between 1 and 2000.\"\n    assert all(isinstance(c, str) for c in chars), \"All elements in chars must be strings.\"\n    assert all(len(c) == 1 for c in chars), \"Each element in chars must be a single character.\"\n    assert all(c.isalnum() or not c.isalpha() for c in chars), \"Chars must contain only valid characters.\"\n\n    index, i = 0, 0\n\n    while i < len(chars):\n        count = 1\n        while i + count < len(chars) and chars[i] == chars[i + count]:\n            count += 1\n\n        chars[index] = chars[i]\n        index += 1\n\n        if count > 1:\n            count_str = str(count)\n            for c in count_str:\n                chars[index] = c\n                index += 1\n\n        i += count\n\n    # Postconditions\n    assert index <= len(chars), \"The new length should not exceed the original length.\"\n    assert all(isinstance(c, str) for c in chars[:index]), \"The result should contain only string characters.\"\n    assert index > 0, \"The result length should be greater than 0.\"\n    assert index == len(chars[:index]), \"The number of characters after compression should match the returned index.\"\n    assert ''.join(chars[:index]) == ''.join(chars[:index]), \"The compressed string should correctly represent the counts.\"\n\n    return index\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]) == 26\n\tassert candidate([\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"]) == 3\n\tassert candidate([\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"]) == 3\n\tassert candidate([\"a\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\"]) == 4\n\tassert candidate([\"a\"]) == 1\n\tassert candidate([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"0\"]) == 10\n\tassert candidate([\"a\", \"a\", \"b\", \"b\", \"c\", \"c\", \"c\"]) == 6\n\tassert candidate([\"!\", \"@\", \"#\", \"$\", \"%\", \"^\", \"&\", \"*\", \"(\", \")\", \"_\", \"+\"]) == 12\n\tassert candidate([\"1\", \"1\", \"1\", \"2\", \"2\", \"2\", \"3\", \"3\", \"3\"]) == 6\n\tassert candidate([\"a\", \"a\", \"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"b\", \"b\"]) == 4\ndef test_check():\n\tcheck(compress)\n# Metadata Difficulty: Medium\n# Metadata Topics: two-pointers,string\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 412, "filename": "LeetCode_412_optimal_division.py", "content": "from typing import List\n\n\ndef optimal_division(nums: List[int]) -> str:\n    \"\"\"\n    You are given an integer array nums. The adjacent integers in nums will perform the float division.\n\n    For example, for nums = [2,3,4], we will evaluate the expression \"2/3/4\".\n\n    However, you can add any number of parenthesis at any position to change the priority of operations. You want to add these parentheses such the value of the expression after the evaluation is maximum.\n    Return the corresponding expression that has the maximum value in string format.\n    Note: your expression should not contain redundant parenthesis.\n\u00a0\n    Example 1:\n\n    Input: nums = [1000,100,10,2]\n    Output: \"1000/(100/10/2)\"\n    Explanation: 1000/(100/10/2) = 1000/((100/10)/2) = 200\n    However, the bold parenthesis in \"1000/((100/10)/2)\" are redundant since they do not influence the operation priority.\n    So you should return \"1000/(100/10/2)\".\n    Other cases:\n    1000/(100/10)/2 = 50\n    1000/(100/(10/2)) = 50\n    1000/100/10/2 = 0.5\n    1000/100/(10/2) = 2\n\n    Example 2:\n\n    Input: nums = [2,3,4]\n    Output: \"2/(3/4)\"\n    Explanation: (2/(3/4)) = 8/3 = 2.667\n    It can be shown that after trying all possibilities, we cannot get an expression with evaluation greater than 2.667\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 10\n    2 <= nums[i] <= 1000\n    There is only one optimal division for the given input.\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(nums, list), \"Input must be a list.\"\n    assert all(isinstance(num, int) for num in nums), \"All elements in nums must be integers.\"\n\n    n = len(nums)\n    if n == 1:\n        return str(nums[0])\n    if n == 2:\n        return str(nums[0]) + '/' + str(nums[1])\n    res = str(nums[0]) + '/('\n    for i in range(1, n - 1):\n        res += str(nums[i]) + '/'\n    res += str(nums[n - 1]) + ')'\n\n    # Postconditions\n    assert isinstance(res, str), \"The result must be a string.\"\n    assert \"/\" in res, \"The result must contain at least one division.\"\n    assert res.count(\"(\") == res.count(\")\"), \"The parentheses in the result must be balanced.\"\n    assert res == res.replace(\"//\", \"/\"), \"The result must not contain redundant slashes.\"\n    assert res == res.replace(\"()\", \"\"), \"The result must not contain empty parentheses.\"\n    assert len(res) <= 100, \"The length of the result string must be less than or equal to 100.\"\n\n    return res\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([2,2,2,2,2,2,2,2,2,2,2]) == \"2/(2/2/2/2/2/2/2/2/2/2)\"\n\tassert candidate([1000,500,250,125,62]) == \"1000/(500/250/125/62)\"\n\tassert candidate([200,100,50,25]) == \"200/(100/50/25)\"\n\tassert candidate([2,2,2,2,2,2,2,2,2,2]) == \"2/(2/2/2/2/2/2/2/2/2)\"\n\tassert candidate([2000,1000,1000,500,250,125,62]) == \"2000/(1000/1000/500/250/125/62)\"\n\tassert candidate([500,30,6,2]) == \"500/(30/6/2)\"\n\tassert candidate([100,100,100]) == \"100/(100/100)\"\n\tassert candidate([100,10,2,2,2]) == \"100/(10/2/2/2)\"\n\tassert candidate([300,100,33,11,3]) == \"300/(100/33/11/3)\"\n\tassert candidate([1000,100,10,2,1]) == \"1000/(100/10/2/1)\"\n\tassert candidate([1000,100,10,2]) == \"1000/(100/10/2)\"\n\tassert candidate([5]) == \"5\"\n\tassert candidate([3,3,3,3]) == \"3/(3/3/3)\"\n\tassert candidate([20,10]) == \"20/10\"\n\tassert candidate([50,2,2]) == \"50/(2/2)\"\n\tassert candidate([2,3,4]) == \"2/(3/4)\"\n\tassert candidate([700,222,111,33,55,20]) == \"700/(222/111/33/55/20)\"\n\tassert candidate([100,50,62,12,5]) == \"100/(50/62/12/5)\"\n\tassert candidate([100,10,5,2]) == \"100/(10/5/2)\"\n\tassert candidate([10000000,100,10,2]) == \"10000000/(100/10/2)\"\n\tassert candidate([10,20,30,40,50]) == \"10/(20/30/40/50)\"\n\tassert candidate([100,2,2,2]) == \"100/(2/2/2)\"\n\tassert candidate([1,2,3,4,5]) == \"1/(2/3/4/5)\"\n\tassert candidate([9,3]) == \"9/3\"\n\tassert candidate([200,100,50,25,12]) == \"200/(100/50/25/12)\"\n\tassert candidate([200,10,50]) == \"200/(10/50)\"\n\tassert candidate([1000,500,100,10,2]) == \"1000/(500/100/10/2)\"\n\tassert candidate([100,200]) == \"100/200\"\n\tassert candidate([200,100,2,2]) == \"200/(100/2/2)\"\n\tassert candidate([666,222,111]) == \"666/(222/111)\"\n\tassert candidate([111,222,666]) == \"111/(222/666)\"\n\tassert candidate([2,3,4,5,6]) == \"2/(3/4/5/6)\"\n\tassert candidate([1000,500,250,25]) == \"1000/(500/250/25)\"\n\tassert candidate([10000,100,10,2]) == \"10000/(100/10/2)\"\n\tassert candidate([300,200,150,100,62]) == \"300/(200/150/100/62)\"\n\tassert candidate([100,10,1]) == \"100/(10/1)\"\ndef test_check():\n\tcheck(optimal_division)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,math,dynamic-programming\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 424, "filename": "LeetCode_424_checkInclusion.py", "content": "def checkInclusion(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n    In other words, return true if one of s1's permutations is the substring of s2.\n\u00a0\n    Example 1:\n\n    Input: s1 = \"ab\", s2 = \"eidbaooo\"\n    Output: true\n    Explanation: s2 contains one permutation of s1 (\"ba\").\n\n    Example 2:\n\n    Input: s1 = \"ab\", s2 = \"eidboaoo\"\n    Output: false\n\n\u00a0\n    Constraints:\n\n    1 <= s1.length, s2.length <= 104\n    s1 and s2 consist of lowercase English letters.\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(s1, str), \"s1 must be a string.\"\n    assert isinstance(s2, str), \"s2 must be a string.\"\n    assert 1 <= len(s2) <= 10**4, \"The length of s2 must be between 1 and 10,000.\"\n    assert all(c.islower() and c.isalpha() for c in s1), \"s1 must consist of lowercase English letters only.\"\n    assert all(c.islower() and c.isalpha() for c in s2), \"s2 must consist of lowercase English letters only.\"\n\n    if len(s1) > len(s2):\n        return False\n\n    s1_map = [0] * 26\n    s2_map = [0] * 26\n\n    for i in range(len(s1)):\n        s1_map[ord(s1[i]) - ord('a')] += 1\n        s2_map[ord(s2[i]) - ord('a')] += 1\n\n    for i in range(len(s2) - len(s1)):\n        if s1_map == s2_map:\n            return True\n\n        s2_map[ord(s2[i]) - ord('a')] -= 1\n        s2_map[ord(s2[i + len(s1)]) - ord('a')] += 1\n\n    result = s1_map == s2_map\n\n    # Postconditions\n    assert isinstance(result, bool), \"The result must be a boolean.\"\n    assert result == True or result == False, \"The result must be either True or False.\"\n    assert isinstance(result, bool), \"The result must be a boolean.\"\n    assert not (result and len(s1) > len(s2)), \"If result is True, the length of s1 must not exceed the length of s2.\"\n    assert not result or any(sorted(s1) == sorted(s2[i:i+len(s1)]) for i in range(len(s2) - len(s1) + 1)), \"If True, one of the permutations of s1 must be a substring of s2.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"ab\", \"eidbaooo\") == True\n\tassert candidate(\"abc\", \"bca\") == True\n\tassert candidate(\"bba\", \"abababaabb\") == True\n\tassert candidate(\"abc\", \"abcab\") == True\n\tassert candidate(\n    \"aaa\", \"abccaaccaaabaabcccaaaca\") == True\n\tassert candidate(\"ab\", \"eidboaoo\") == False\n\tassert candidate(\"\", \"baaa\") == True\n\tassert candidate(\"abc\", \"abca\") == True\n\tassert candidate(\"abc\", \"cba\") == True\n\tassert candidate(\"abc\", \"abac\") == True\n\tassert candidate(\"abc\", \"bac\") == True\n\tassert candidate(\"xyz\", \"yxz\") == True\n\tassert candidate(\n    \"aab\", \"aab\") == True\n\tassert candidate(\"abc\", \"cab\") == True\n\tassert candidate(\"ab\", \"lafb\") == False\n\tassert candidate(\"abc\", \"acb\") == True\n\tassert candidate(\"abcd\", \"abc\") == False\n\tassert candidate(\"a\", \"a\") == True\n\tassert candidate(\"a\", \"b\") == False\n\tassert candidate(\"ab\", \"alb\") == False\n\tassert candidate(\"xyz\", \"zyx\") == True\n\tassert candidate(\"abc\", \"def\") == False\n\tassert candidate(\"aa\", \"ba\") == False\n\tassert candidate(\"aaa\", \"aaa\") == True\n\tassert candidate(\"abc\", \"abcabcabc\") == True\n\tassert candidate(\"ab\", \"aab\") == True\n\tassert candidate(\"a\", \"aba\") == True\n\tassert candidate(\n    \"ab\", \"lalaefaklmncedddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddo\") == False\n\tassert candidate(\"abc\", \"abcd\") == True\n\tassert candidate(\"abc\", \"abcabc\") == True\ndef test_check():\n\tcheck(checkInclusion)\n# Metadata Difficulty: Medium\n# Metadata Topics: hash-table,two-pointers,string,sliding-window\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 434, "filename": "LeetCode_434_fractionAddition.py", "content": "def fractionAddition(expression: str) -> str:\n    \"\"\"\n    Given a string expression representing an expression of fraction addition and subtraction, return the calculation result in string format.\n    The final result should be an irreducible fraction. If your final result is an integer, change it to the format of a fraction that has a denominator 1. So in this case, 2 should be converted to 2/1.\n\u00a0\n    Example 1:\n\n    Input: expression = \"-1/2+1/2\"\n    Output: \"0/1\"\n\n    Example 2:\n\n    Input: expression = \"-1/2+1/2+1/3\"\n    Output: \"1/3\"\n\n    Example 3:\n\n    Input: expression = \"1/3-1/2\"\n    Output: \"-1/6\"\n\n\u00a0\n    Constraints:\n\n    The input string only contains '0' to '9', '/', '+' and '-'. So does the output.\n    Each fraction (input and output) has the format \u00b1numerator/denominator. If the first input fraction or the output is positive, then '+' will be omitted.\n    The input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1, 10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above.\n    The number of given fractions will be in the range [1, 10].\n    The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int.\n\n    \"\"\"\n    ### Canonical solution below ###\n    from fractions import Fraction\n    assert isinstance(expression, str), \"Input must be a string.\"\n    assert all(c in \"0123456789/+-\" for c in expression), \"Expression can only contain digits, '/', '+', and '-'.\"\n    assert 1 <= len(expression.split()) <= 10, \"The number of fractions in the expression must be between 1 and 10.\"\n\n    fractions = expression.replace('+', ' +').replace('-', ' -').split()\n    result = sum(Fraction(fraction) for fraction in fractions)\n\n    # Postconditions\n    assert isinstance(result, Fraction), \"Result must be a Fraction object.\"\n    assert result.denominator != 0, \"Denominator must not be zero.\"\n    assert abs(result.numerator) <= 2**31 - 1 and abs(result.denominator) <= 2**31 - 1, \"Numerator and denominator must be within 32-bit integer range.\"\n    assert Fraction(result.numerator, result.denominator) == result, \"Result must be in its simplest form.\"\n\n    return f\"{result.numerator}/{result.denominator}\"\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"-1/3-2/3\") == \"-1/1\"\n\tassert candidate(\"-1/12+1/12-1/24\") == \"-1/24\"\n\tassert candidate(\"5/6-2/3\") == \"1/6\"\n\tassert candidate(\"-1/2-1/2\") == \"-1/1\"\n\tassert candidate(\"-1/4-1/2-1/4\") == \"-1/1\"\n\tassert candidate(\"1/4+1/4+1/4+1/4\") == \"1/1\"\n\tassert candidate(\"1/2+1/4\") == \"3/4\"\n\tassert candidate(\"-1/3-1/3\") == \"-2/3\"\n\tassert candidate(\"-1/12+1/12\") == \"0/1\"\n\tassert candidate(\"-1/2-1/4\") == \"-3/4\"\n\tassert candidate(\"1/4+1/2-1/4\") == \"1/2\"\n\tassert candidate(\"1/3+2/3-1/3\") == \"2/3\"\n\tassert candidate(\"0/2+0/2\") == \"0/1\"\n\tassert candidate(\"2/3+4/6\") == \"4/3\"\n\tassert candidate(\"7/8+1/8\") == \"1/1\"\n\tassert candidate(\"1/3+1/2+1/6\") == \"1/1\"\n\tassert candidate(\"-5/6-1/6\") == \"-1/1\"\n\tassert candidate(\"-1/2-1/2-1/2-1/2\") == \"-2/1\"\n\tassert candidate(\"1/4+3/4\") == \"1/1\"\n\tassert candidate(\"1/2+1/2\") == \"1/1\"\n\tassert candidate(\"1/3-1/3+1/3\") == \"1/3\"\n\tassert candidate(\"1/3+1/3-2/3\") == \"0/1\"\n\tassert candidate(\"1/2-1/2\") == \"0/1\"\n\tassert candidate(\"1/3+1/2\") == \"5/6\"\n\tassert candidate(\"-1/2+1/2-1/4\") == \"-1/4\"\n\tassert candidate(\"-1/3+1/3-1/3\") == \"-1/3\"\n\tassert candidate(\"-1/2+1/2+1/2-1/6\") == \"1/3\"\n\tassert candidate(\"1/3+1/3+1/3\") == \"1/1\"\n\tassert candidate(\"1/1+1/1\") == \"2/1\"\n\tassert candidate(\"3/4-1/2\") == \"1/4\"\n\tassert candidate(\"1/2+1/2+1/2-1/6\") == \"4/3\"\n\tassert candidate(\"1/4-1/4\") == \"0/1\"\n\tassert candidate(\"-1/4-1/4\") == \"-1/2\"\n\tassert candidate(\"-1/2+1/2\") == \"0/1\"\n\tassert candidate(\"5/6-1/3\") == \"1/2\"\n\tassert candidate(\"1/3-1/2\") == \"-1/6\"\n\tassert candidate(\"-1/2+1/2+1/3\") == \"1/3\"\ndef test_check():\n\tcheck(fractionAddition)\n# Metadata Difficulty: Medium\n# Metadata Topics: math,string,simulation\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 482, "filename": "LeetCode_482_findNumberOfLIS.py", "content": "from typing import List\n\n\ndef findNumberOfLIS(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array\u00a0nums, return the number of longest increasing subsequences.\n    Notice that the sequence has to be strictly increasing.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,3,5,4,7]\n    Output: 2\n    Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].\n\n    Example 2:\n\n    Input: nums = [2,2,2,2,2]\n    Output: 5\n    Explanation: The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 2000\n    -106 <= nums[i] <= 106\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(nums, list), \"Input must be a list.\"\n    assert all(isinstance(num, int) for num in nums), \"All elements in nums must be integers.\"\n    assert 1 <= len(nums) <= 2000, \"The length of nums must be between 1 and 2000.\"\n    assert all(-10**6 <= num <= 10**6 for num in nums), \"Each number in nums must be between -10^6 and 10^6.\"\n    assert len(set(nums)) >= 1, \"The list must contain at least one unique element.\"\n\n    n = len(nums)\n    maxLength = ans = 0\n    length = [1] * n\n    count = [1] * n\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                if length[i] == length[j] + 1:\n                    count[i] += count[j]\n                elif length[i] < length[j] + 1:\n                    length[i] = length[j] + 1\n                    count[i] = count[j]\n        if maxLength == length[i]:\n            ans += count[i]\n        elif maxLength < length[i]:\n            maxLength = length[i]\n            ans = count[i]\n\n    # Postconditions\n    assert isinstance(ans, int), \"The result must be an integer.\"\n    assert ans >= 1, \"The number of longest increasing subsequences must be at least 1.\"\n    assert maxLength >= 1, \"The length of the longest increasing subsequence must be at least 1.\"\n    assert maxLength <= len(nums), \"The length of the longest increasing subsequence cannot exceed the length of nums.\"\n    assert all(x > 0 for x in count), \"All counts of subsequences must be positive.\"\n    assert all(l >= 1 for l in length), \"All lengths of subsequences must be at least 1.\"\n\n    return ans\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1,1,1,2,2,2,3,3,3]) == 27\n\tassert candidate([1]) == 1\n\tassert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 1\n\tassert candidate([1, 2, 4, 3, 5, 4, 7]) == 3\n\tassert candidate(\n    [3, 5, 6, 2, 5, 4, 19, 5, 6, 7, 12, 20, 13, 10, 14, 15, 2, 1, 1, 3, 11, 12, 13, 5, 6, 7, 11, 12, 13, 14, 15, 2, 3]) == 8\n\tassert candidate([10,9,2,5,3,7,101,18]) == 4\n\tassert candidate([1,2,4,3,5,4,7,2]) == 3\n\tassert candidate([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n\tassert candidate([3,1,2]) == 1\n\tassert candidate([11,12,13,14,15,16,17,18,19,20]) == 1\n\tassert candidate([2,2,2,2,2]) == 5\n\tassert candidate([1,3,5,4,7]) == 2\n\tassert candidate([1,2,3,4,5]) == 1\n\tassert candidate([1, 2, 4, 3, 5, 4, 7, 2]) == 3\ndef test_check():\n\tcheck(findNumberOfLIS)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,dynamic-programming,binary-indexed-tree,segment-tree\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 509, "filename": "LeetCode_509_minimumDeleteSum.py", "content": "def minimumDeleteSum(s1: str, s2: str) -> int:\n    \"\"\"\n    Given two strings s1 and\u00a0s2, return the lowest ASCII sum of deleted characters to make two strings equal.\n\u00a0\n    Example 1:\n\n    Input: s1 = \"sea\", s2 = \"eat\"\n    Output: 231\n    Explanation: Deleting \"s\" from \"sea\" adds the ASCII value of \"s\" (115) to the sum.\n    Deleting \"t\" from \"eat\" adds 116 to the sum.\n    At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.\n\n    Example 2:\n\n    Input: s1 = \"delete\", s2 = \"leet\"\n    Output: 403\n    Explanation: Deleting \"dee\" from \"delete\" to turn the string into \"let\",\n    adds 100[d] + 101[e] + 101[e] to the sum.\n    Deleting \"e\" from \"leet\" adds 101[e] to the sum.\n    At the end, both strings are equal to \"let\", and the answer is 100+101+101+101 = 403.\n    If instead we turned both strings into \"lee\" or \"eet\", we would get answers of 433 or 417, which are higher.\n\n\u00a0\n    Constraints:\n\n    1 <= s1.length, s2.length <= 1000\n    s1 and s2 consist of lowercase English letters.\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(s1, str) and isinstance(s2, str), \"Both inputs must be strings.\"\n    assert 0 <= len(s1) <= 1000 and 0 <= len(s2) <= 1000, \"String lengths must be between 1 and 1000.\"\n    assert all(c.islower() and c.isalpha() for c in s1), \"s1 must consist of lowercase English letters only.\"\n    assert all(c.islower() and c.isalpha() for c in s2), \"s2 must consist of lowercase English letters only.\"\n\n    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n    for i in range(1, len(s1) + 1):\n        dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])\n    for j in range(1, len(s2) + 1):\n        dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])\n    for i in range(1, len(s1) + 1):\n        for j in range(1, len(s2) + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j] + ord(s1[i - 1]), dp[i][j - 1] + ord(s2[j - 1]))\n\n    result = dp[len(s1)][len(s2)]\n\n    # Postconditions\n    assert isinstance(result, int), \"The result must be an integer.\"\n    assert result >= 0, \"The minimum delete sum must be non-negative.\"\n    assert result == 0 or s1 != s2, \"The result should be 0 only if the strings are already equal.\"\n    assert result >= abs(sum(map(ord, s1)) - sum(map(ord, s2))), \"The result should reflect a valid deletion sum.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"yx\", \"yx\") == 0\n\tassert candidate(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") == 0\n\tassert candidate(\"aaaaa\", \"aaaaa\") == 0\n\tassert candidate(\"aaaaaaaaaaa\", \"aaaaaaaaaaa\") == 0\n\tassert candidate(\"aba\", \"aba\") == 0\n\tassert candidate(\"ab\", \"dab\") == 100\n\tassert candidate(\"sea\", \"eat\") == 231\n\tassert candidate(\n    \"ab\", \"ab\"\n) == 0\n\tassert candidate(\n    \"a\", \"b\"\n) == 195\n\tassert candidate(\"aaaaaaaaaaaa\", \"aaaaaaaaaaaa\") == 0\n\tassert candidate(\"xyz\", \"xyz\") == 0\n\tassert candidate(\"helloworld\", \"helloworld\") == 0\n\tassert candidate(\"aaa\", \"aaa\") == 0\n\tassert candidate(\"zyxwvutsrqponmlkjihgfedcba\", \"zyxwvutsrqponmlkjihgfedcba\") == 0\n\tassert candidate(\"aaaaaaaaaa\", \"aaaaaaaaaa\") == 0\n\tassert candidate(\"zzzzzz\", \"zzzzzz\") == 0\n\tassert candidate(\"delete\", \"leet\") == 403\n\tassert candidate(\"\", \"x\") == 120\n\tassert candidate(\"abc\", \"abc\") == 0\n\tassert candidate(\"aaaaaaaa\", \"aaaaaaaa\") == 0\n\tassert candidate(\"aaaaaaaaaaaaaa\", \"aaaaaaaaaaaaaa\") == 0\n\tassert candidate(\"a\", \"\") == 97\n\tassert candidate(\n    \"abcdefghijklmnopqrstuvwxyz\", \"abcdefghijklmnopqrstuvwxyz\"\n) == 0\n\tassert candidate(\"aaaa\", \"aaaa\") == 0\n\tassert candidate(\"aaaaaaaaaaaaa\", \"aaaaaaaaaaaaa\") == 0\n\tassert candidate(\"a\", \"a\") == 0\n\tassert candidate(\"abcd\", \"bc\") == 197\n\tassert candidate(\"abcd\", \"abcd\") == 0\n\tassert candidate(\"y\", \"y\") == 0\n\tassert candidate(\"x\", \"\") == 120\n\tassert candidate(\"\", \"\") == 0\ndef test_check():\n\tcheck(minimumDeleteSum)\n# Metadata Difficulty: Medium\n# Metadata Topics: string,dynamic-programming\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 513, "filename": "LeetCode_513_findLength.py", "content": "from typing import List\n\ndef findLength(nums1: List[int], nums2: List[int]) -> int:\n    \"\"\"\n    Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.\n    \"\"\"\n\n    # Preconditions\n    assert all(isinstance(num, int) for num in nums1), \"All elements in nums1 must be integers.\"\n    assert all(isinstance(num, int) for num in nums2), \"All elements in nums2 must be integers.\"\n    assert 0 <= len(nums1) <= 1000, \"The length of nums1 must be between 1 and 1000.\"\n    assert 0 <= len(nums2) <= 1000, \"The length of nums2 must be between 1 and 1000.\"\n\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxLength = 0\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if nums1[i] == nums2[j]:\n                dp[i][j] = dp[i + 1][j + 1] + 1\n                maxLength = max(maxLength, dp[i][j])\n\n    result = maxLength\n\n    # Postconditions\n    assert isinstance(result, int), \"The result must be an integer.\"\n    assert result >= 0, \"The result must be a non-negative integer.\"\n    assert result <= min(len(nums1), len(nums2)), \"The result cannot be larger than the lengths of the input arrays.\"\n    assert all(dp[i][j] <= min(m - i, n - j) for i in range(m) for j in range(n)), \"Subarray lengths must be valid.\"\n\n    return result\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1, 2, 3, 4, 5, 6], [7, 8, 9]) == 0\n\tassert candidate([1,2,3,2,1], [3,2,1,4,7,1,2,3]) == 3\n\tassert candidate([1], [1]) == 1\n\tassert candidate( [2,1,1,2,2], [2,1,2,1]) == 2\n\tassert candidate([1,2,3,4,5], [1,2,3,2,1]) == 3\n\tassert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],\n                  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) == 19\n\tassert candidate([1,2,3,4], [0,1,1,1]) == 1\n\tassert candidate([1,1,1,1,1], [1,1,1,1,1]) == 5\n\tassert candidate([1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1, 7]) == 1\n\tassert candidate([1,2,3,4,5], []) == 0\n\tassert candidate([], []) == 0\n\tassert candidate([1,2,3,4,5], [5,4,3,2,1]) == 1\n\tassert candidate([1,2,3,4,5,6,7,8,9,10], [1,2,3,4,5,6,7,8,9,10]) == 10\n\tassert candidate([1, 2, 3], [4, 5, 6]) == 0\n\tassert candidate([0,0,0,0,0], [0,0,0,0,0]) == 5\n\tassert candidate([1] * 1000, [1] * 1000) == 1000\n\tassert candidate([1,2,3,2,1], [3,2,1,4,7,2,1]) == 3\n\tassert candidate([1,2,3,2,1], [2,1,2,1]) == 2\n\tassert candidate([1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]) == 1\n\tassert candidate([1,2,3,4,5], [1,2,3,4,5]) == 5\n\tassert candidate(range(1000), range(1000)) == 1000\n\tassert candidate(\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) == 20\n\tassert candidate([1]*20, [1]*20) == 20\n\tassert candidate([1,1,1,1,1], [2,2,2,2,2]) == 0\n\tassert candidate([1,2,3,2,1], [1,2,3,2,1]) == 5\n\tassert candidate([1,2,3,2,1], [3,2,1,4,7]) == 3\ndef test_check():\n\tcheck(findLength)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,binary-search,dynamic-programming,sliding-window,rolling-hash,hash-function\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 530, "filename": "LeetCode_530_daily_temperatures.py", "content": "from typing import List\n\n\ndef daily_temperatures(temperatures: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\n\u00a0\n    Example 1:\n    Input: temperatures = [73,74,75,71,69,72,76,73]\n    Output: [1,1,4,2,1,1,0,0]\n    Example 2:\n    Input: temperatures = [30,40,50,60]\n    Output: [1,1,1,0]\n    Example 3:\n    Input: temperatures = [30,60,90]\n    Output: [1,1,0]\n\n\u00a0\n    Constraints:\n\n    0 <=\u00a0temperatures.length <= 105\n    0 <=\u00a0temperatures[i] <= 100\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert all(isinstance(t, int) for t in temperatures), \"All elements in temperatures must be integers.\"\n    assert 0 <= len(temperatures) <= 105, \"The length of temperatures must be between 1 and 105.\"\n    assert all(0 <= t <= 100 for t in temperatures), \"All temperatures must be between 30 and 100.\"\n\n    result = [0] * len(temperatures)\n    stack = []\n\n    for i, temp in enumerate(temperatures):\n        while stack and temp > temperatures[stack[-1]]:\n            idx = stack.pop()\n            result[idx] = i - idx\n        stack.append(i)\n\n    # Postconditions\n    assert isinstance(result, list), \"The result must be a list.\"\n    assert len(result) == len(temperatures), \"The result list must have the same length as the input temperatures.\"\n    assert all(isinstance(r, int) for r in result), \"All elements in the result must be integers.\"\n    assert all(r >= 0 for r in result), \"All elements in the result must be non-negative integers.\"\n    assert all(0 <= r <= len(temperatures) - i - 1 for i, r in enumerate(result)), \"Each element must represent a valid number of days to wait.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([100]*105) == [0]*105\n\tassert candidate([90,80,70,60]) == [0,0,0,0]\n\tassert candidate([1]) == [0]\n\tassert candidate([]) == []\n\tassert candidate([30,40,50,60]) == [1,1,1,0]\n\tassert candidate([50,40,30,20,10]) == [0,0,0,0,0]\n\tassert candidate([30]*105) == [0]*105\n\tassert candidate([60]*100) == [0]*100\n\tassert candidate([60,70,80,90]) == [1,1,1,0]\n\tassert candidate(range(70, 60, -1)) == [0]*10\n\tassert candidate([100,90,80,70,60,50]) == [0,0,0,0,0,0]\n\tassert candidate([73,74,75,71,69,72,76,73]) == [1,1,4,2,1,1,0,0]\n\tassert candidate([70,70,70,70,70]) == [0,0,0,0,0]\n\tassert candidate([50,60,70,60,50,40]) == [1,1,0,0,0,0]\n\tassert candidate(\n    [73, 74, 75, 71, 69, 72, 76, 73]) == [1, 1, 4, 2, 1, 1, 0, 0]\n\tassert candidate([1,2]) == [1,0]\n\tassert candidate([40,50,60,70,60,50,40]) == [1,1,1,0,0,0,0]\n\tassert candidate([30,60,90]) == [1,1,0]\n\tassert candidate([50,60,70,80,90,100]) == [1,1,1,1,1,0]\ndef test_check():\n\tcheck(daily_temperatures)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,stack,monotonic-stack\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 542, "filename": "LeetCode_542_openLock.py", "content": "from typing import List\nfrom collections import deque\n\ndef openLock(deadends: List[str], target: str) -> int:\n    \"\"\"\n    You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.\n    The lock initially starts at '0000', a string representing the state of the 4 wheels.\n    You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\n    Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\n\u00a0\n    Example 1:\n\n    Input: deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\n    Output: 6\n    Explanation: \n    A sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\".\n    Note that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid,\n    because the wheels of the lock become stuck after the display becomes the dead end \"0102\".\n\n    Example 2:\n\n    Input: deadends = [\"8888\"], target = \"0009\"\n    Output: 1\n    Explanation: We can turn the last wheel in reverse to move from \"0000\" -> \"0009\".\n\n    Example 3:\n\n    Input: deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"\n    Output: -1\n    Explanation: We cannot reach the target without getting stuck.\n\n\u00a0\n    Constraints:\n\n    1 <= deadends.length <= 500\n    deadends[i].length == 4\n    target.length == 4\n    target will not be in the list deadends.\n    target and deadends[i] consist of digits only.\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(deadends, list) and all(isinstance(d, str) and len(d) == 4 and d.isdigit() for d in deadends), \"deadends must be a list of 4-digit strings.\"\n    assert isinstance(target, str) and len(target) == 4 and target.isdigit(), \"target must be a 4-digit string.\"\n    assert target not in deadends, \"Target must not be in the deadends list.\"\n    assert 1 <= len(deadends) <= 500, \"The length of deadends must be between 1 and 500.\"\n\n    dead = set(deadends)\n    visited = set()\n    q = deque([\"0000\"])\n\n    if \"0000\" in dead:\n        return -1\n\n    visited.add(\"0000\")\n    moves = 0\n\n    while q:\n        level_size = len(q)\n        for i in range(level_size):\n            cur = q.popleft()\n\n            if cur == target:\n                # Postconditions\n                assert isinstance(moves, int), \"The result must be an integer.\"\n                assert moves >= 0, \"The result must be a non-negative integer.\"\n                return moves\n\n            for j in range(4):\n                for k in [-1, 1]:\n                    next_val = cur[:j] + str((int(cur[j]) + k + 10) % 10) + cur[j + 1:]\n\n                    if next_val not in visited and next_val not in dead:\n                        visited.add(next_val)\n                        q.append(next_val)\n\n        moves += 1\n\n    # Postconditions\n    assert isinstance(moves, int), \"The result must be an integer.\"\n    assert moves == -1 or moves >= 0, \"The result must be -1 or a non-negative integer.\"\n    return -1\n\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([\"0001\", \"1112\", \"2223\", \"3334\", \"4445\"], \"1111\") == 4\n\tassert candidate([\"1111\", \"9999\", \"8888\", \"7777\", \"6666\"], \"0000\") == 0\n\tassert candidate([\"8887\", \"8889\", \"8878\", \"8898\", \"8788\", \"8988\", \"7888\", \"9888\"], \"8888\") == -1\n\tassert candidate([\"0001\", \"1112\", \"2223\", \"3334\", \"4445\"], \"3333\") == 12\n\tassert candidate([\"0001\", \"1112\", \"2223\", \"3334\", \"4445\"], \"2222\") == 8\n\tassert candidate([\"0001\", \"1112\", \"2223\", \"3334\", \"4445\"], \"0000\") == 0\n\tassert candidate([\"8888\"], \"0009\") == 1\n\tassert candidate([\"0000\", \"0002\", \"0003\", \"0004\", \"0005\"], \"0001\") == -1\n\tassert candidate([\"0201\", \"0101\", \"0102\", \"1212\", \"2002\"], \"0202\") == 6\n\tassert candidate(\n    [\"8887\", \"8889\", \"8878\", \"8898\", \"8788\", \"8988\", \"7888\", \"9888\"], \"8888\"\n) == -1\n\tassert candidate([\"0001\", \"1112\", \"2223\", \"3334\", \"4445\"], \"4444\") == 16\n\tassert candidate([\"0001\", \"0002\", \"0003\", \"0004\", \"0005\"], \"0000\") == 0\n\tassert candidate([\"0000\"], \"8888\") == -1\n\tassert candidate([\"1111\", \"9999\", \"8888\", \"7777\", \"6666\"], \"5555\") == 20\ndef test_check():\n\tcheck(openLock)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,hash-table,string,breadth-first-search\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 553, "filename": "LeetCode_553_partition_labels.py", "content": "from typing import List\n\n\ndef partition_labels(s: str) -> List[int]:\n    \"\"\"\n    You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\n    Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s.\n    Return a list of integers representing the size of these parts.\n\u00a0\n    Example 1:\n\n    Input: s = \"ababcbacadefegdehijhklij\"\n    Output: [9,7,8]\n    Explanation:\n    The partition is \"ababcbaca\", \"defegde\", \"hijhklij\".\n    This is a partition so that each letter appears in at most one part.\n    A partition like \"ababcbacadefegde\", \"hijhklij\" is incorrect, because it splits s into less parts.\n\n    Example 2:\n\n    Input: s = \"eccbbbbdec\"\n    Output: [10]\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 500\n    s consists of lowercase English letters.\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(s, str), \"Input must be a string.\"\n    assert 1 <= len(s) <= 500, \"Length of the string must be between 1 and 500.\"\n    assert all(c.islower() and c.isalpha() for c in s), \"The string must consist of lowercase English letters only.\"\n\n    last = {c: i for i, c in enumerate(s)}\n    ans = []\n    j = anchor = 0\n    for i, c in enumerate(s):\n        j = max(j, last[c])\n        if i == j:\n            ans.append(i - anchor + 1)\n            anchor = i + 1\n\n    # Postconditions\n    assert isinstance(ans, list), \"Output must be a list.\"\n    assert all(isinstance(x, int) and x > 0 for x in ans), \"All elements in the output list must be positive integers.\"\n    assert sum(ans) == len(s), \"The sum of the partitions must equal the length of the input string.\"\n    \n    return ans\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"eccbbbbdec\") == [10]\n\tassert candidate(\"abc\") == [1, 1, 1]\n\tassert candidate(\"abccba\") == [6]\n\tassert candidate(\"abcdefghijklmnopqrstuvwxy\") == [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n\tassert candidate(\"abca\") == [4]\n\tassert candidate(\"a\") == [1]\n\tassert candidate(\"ababcbacadefegdehijhklij\") == [9,7,8]\n\tassert candidate(\"ab\") == [1, 1]\ndef test_check():\n\tcheck(partition_labels)\n# Metadata Difficulty: Medium\n# Metadata Topics: hash-table,two-pointers,string,greedy\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 570, "filename": "LeetCode_570_is_ideal_permutation.py", "content": "from typing import List\n\n\ndef is_ideal_permutation(nums: List[int]) -> bool:\n    \"\"\"\n    You are given an integer array nums of length n which represents a permutation of all the integers in the range [0, n - 1].\n    The number of global inversions is the number of the different pairs (i, j) where:\n\n    0 <= i < j < n\n    nums[i] > nums[j]\n\n    The number of local inversions is the number of indices i where:\n\n    0 <= i < n - 1\n    nums[i] > nums[i + 1]\n\n    Return true if the number of global inversions is equal to the number of local inversions.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,0,2]\n    Output: true\n    Explanation: There is 1 global inversion and 1 local inversion.\n\n    Example 2:\n\n    Input: nums = [1,2,0]\n    Output: false\n    Explanation: There are 2 global inversions and 1 local inversion.\n\n\u00a0\n    Constraints:\n\n    n == nums.length\n    1 <= n <= 105\n    0 <= nums[i] < n\n    All the integers of nums are unique.\n    nums is a permutation of all the numbers in the range [0, n - 1].\n\n    \"\"\"\n    ### Canonical solution below ###\ndef is_ideal_permutation(nums: List[int]) -> bool:\n    \"\"\"\n    You are given an integer array nums of length n which represents a permutation of all the integers in the range [0, n - 1].\n    The number of global inversions is the number of the different pairs (i, j) where:\n    0 <= i < j < n\n    nums[i] > nums[j]\n    The number of local inversions is the number of indices i where:\n    0 <= i < n - 1\n    nums[i] > nums[i + 1]\n    Return true if the number of global inversions is equal to the number of local inversions.\n    \"\"\"\n\n    # Preconditions\n    assert isinstance(nums, list), \"nums must be a list.\"\n    assert 1 <= len(nums) <= 100000, \"Length of nums must be between 1 and 100,000.\"\n    assert all(isinstance(x, int) for x in nums), \"All elements in nums must be integers.\"\n\n    # Core logic\n    for i, num in enumerate(nums):\n        if abs(num - i) > 1:\n            return False\n    \n    # Postconditions\n    assert isinstance(nums, list) and len(nums) == len(set(nums)), \"nums must be a list with unique elements.\"\n    assert isinstance(True, bool), \"The return value must be a boolean.\"\n    \n    return True\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1, 2, 0]) == False\n\tassert candidate([0, 1, 2, 3]) == True\n\tassert candidate(\n    [9, 8, 4, 2, 1, 3, 6, 7, 5, 10, 11, 0]) == False\n\tassert candidate([0, 2, 1, 5, 4, 6, 7, 3, 8, 9, 10, 11]) == False\n\tassert candidate([0, 3, 1, 2]) == False\n\tassert candidate(\n    [0, 1, 3, 2, 5, 4, 6, 8, 9, 7, 11, 10, 12, 13, 15, 14, 16, 17, 18, 19]) == False\n\tassert candidate([2, 0, 1, 3]) == False\n\tassert candidate([0, 5, 2, 3, 4, 1, 6, 7, 8, 9, 10, 11]) == False\n\tassert candidate([8, 1, 0, 2]) == False\n\tassert candidate([3, 1, 2, 0]) == False\n\tassert candidate([1, 3, 0, 2]) == False\n\tassert candidate(\n    [0, 5, 2, 3, 4, 1, 6, 7, 8, 9, 10, 11]) == False\n\tassert candidate([1, 0, 2]) == True\n\tassert candidate([2, 3, 1, 5, 4, 0]) == False\n\tassert candidate(\n    [4, 1, 0, 3, 2, 7, 6, 5, 11, 10, 9, 12, 8, 13, 14, 15, 16]) == False\n\tassert candidate([0]) == True\n\tassert candidate([4, 3, 1, 5, 2, 0]) == False\n\tassert candidate(\n    [0, 2, 1, 5, 4, 6, 7, 3, 9, 11, 10, 8]) == False\n\tassert candidate([1, 2, 0, 3, 4, 5]) == False\n\tassert candidate(\n    [1, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) == True\n\tassert candidate([0, 1, 2]) == True\n\tassert candidate([0, 2, 3, 1]) == False\n\tassert candidate(\n    [0, 2, 1, 5, 4, 6, 7, 3, 9, 10, 11, 8]) == False\n\tassert candidate([2, 3, 1, 5, 0, 4]) == False\n\tassert candidate(\n    [0, 1, 3, 2, 5, 4, 7, 8, 9, 6, 11, 10, 12, 13, 15, 14, 16, 17, 18, 19]) == False\n\tassert candidate([1, 2, 0, 3]) == False\n\tassert candidate([1, 0, 3, 5, 2, 4]) == False\n\tassert candidate([1, 5, 0, 2, 4, 6, 3, 7, 8, 9, 10, 11]) == False\n\tassert candidate([1, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == True\n\tassert candidate([1, 0, 2, 3, 4, 5]) == True\n\tassert candidate([1, 4, 2, 5, 0, 3]) == False\n\tassert candidate(\n    [0, 1, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 13, 15, 14, 16, 17, 18, 19]) == True\n\tassert candidate([2, 0, 1]) == False\n\tassert candidate([0, 1, 2, 3, 4, 5]) == True\n\tassert candidate(\n    [4, 1, 0, 3, 2, 7, 6, 5, 11, 10, 9, 8, 12, 13, 14, 15, 16]) == False\n\tassert candidate(\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == True\n\tassert candidate([4, 1, 0, 3, 2, 7, 6, 5, 11, 10, 9, 8, 13, 14, 15, 16, 12]) == False\n\tassert candidate([1, 0]) == True\n\tassert candidate([3, 0, 1, 2]) == False\n\tassert candidate([1, 3, 2, 0]) == False\ndef test_check():\n\tcheck(is_ideal_permutation)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,math\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 580, "filename": "LeetCode_580_isBipartite.py", "content": "from typing import List\n\n\ndef isBipartite(graph: List[List[int]]) -> bool:\n    \"\"\"\n    There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:\n\n    There are no self-edges (graph[u] does not contain u).\n    There are no parallel edges (graph[u] does not contain duplicate values).\n    If v is in graph[u], then u is in graph[v] (the graph is undirected).\n    The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.\n\n    A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\n    Return true if and only if it is bipartite.\n\u00a0\n    Example 1:\n\n\n    Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\n    Output: false\n    Explanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.\n    Example 2:\n\n\n    Input: graph = [[1,3],[0,2],[1,3],[0,2]]\n    Output: true\n    Explanation: We can partition the nodes into two sets: {0, 2} and {1, 3}.\n\u00a0\n    Constraints:\n\n    graph.length == n\n    1 <= n <= 100\n    0 <= graph[u].length < n\n    0 <= graph[u][i] <= n - 1\n    graph[u]\u00a0does not contain\u00a0u.\n    All the values of graph[u] are unique.\n    If graph[u] contains v, then graph[v] contains u.\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(graph, list), \"Input graph must be a list.\"\n    assert all(isinstance(neighbors, list) for neighbors in graph), \"Each element in graph must be a list.\"\n    assert all(isinstance(node, int) for neighbors in graph for node in neighbors), \"All nodes in graph must be integers.\"\n    assert len(graph) >= 1, \"Graph must contain at least one node.\"\n    assert all(len(neighbors) < len(graph) for neighbors in graph), \"No node should have more neighbors than the total number of nodes.\"\n\n    from collections import deque\n    colors = [0] * len(graph)\n    for i in range(len(graph)):\n        if colors[i] != 0:\n            continue\n        colors[i] = 1\n        queue = deque([i])\n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if colors[neighbor] == 0:\n                    colors[neighbor] = -colors[node]\n                    queue.append(neighbor)\n                elif colors[neighbor] == colors[node]:\n                    return False\n\n    # Postconditions\n    assert isinstance(colors, list), \"The colors array must be a list.\"\n    assert all(color in [-1, 0, 1] for color in colors), \"Colors should only be -1, 0, or 1.\"\n    assert len(colors) == len(graph), \"The length of colors should match the number of nodes in the graph.\"\n    assert all(colors[i] != colors[j] for i in range(len(graph)) for j in graph[i] if colors[i] != 0), \"Adjacent nodes should not have the same color.\"\n    assert len(set(colors)) <= 3, \"There should be at most three distinct values in the colors array.\"\n    assert all(isinstance(node, int) for node in range(len(graph))), \"All nodes in the graph should have been visited.\"\n    assert sum(colors) == 0 or len(set(colors)) < 3, \"The graph should be bipartite if the result is True.\"\n\n    return True\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([[1,2],[0,2],[0,1]]) == False\n\tassert candidate([[1,3],[0,3],[0,2,3,5],[1,3,5],[0,2,5],[0,2,5]]) == False\n\tassert candidate([[1,2,3],[0,2,3],[0,1],[3],[2]]) == False\n\tassert candidate(\n    [[1,2,3,4,5],[0,2],[0,1,4,5],[0,2,3,4],[0,2,3],[2]]) == False\n\tassert candidate([[1],[0,2],[1,3],[0,1,3,4],[1,2,4],[2]]) == False\n\tassert candidate([[1],[0,2,3,4],[1,3],[0,2,3,4],[0,2,3,4]]) == False\n\tassert candidate([[1,2,3,4],[0,2],[0,1],[2,3,4],[1]]) == False\n\tassert candidate(\n    [[1,3],[0,2,3,4,5],[0,2,3,4,5],[0,2,3,4,5],[0,2,3,4,5],[0,2,3,4,5],[0,2,3,4,5]]) == False\n\tassert candidate([[1,2],[0,2,3,5],[4],[4,5],[0,1,3,5],[3],[3,4]]) == False\n\tassert candidate([[1],[0,2,3],[1,3],[1,2,4],[3,5],[4]]) == False\n\tassert candidate([[1],[0,3],[3],[1,2]]) == True\n\tassert candidate([[1,2,3],[0,2,3],[0,1,3],[0,1,2]]) == False\n\tassert candidate([[1,3],[0,2,3,4,5],[0,2,3,4,5],[0,2,3,4,5],[0,2,3,4,5],[0,2,3,4,5,6],[3]]) == False\n\tassert candidate([[1,2,3,4],[0,2,3,4],[0,2,1],[0,1],[2,3,4],[3]]) == False\n\tassert candidate([[1,2,3],[0,2,3],[0,1,3],[0,1,2,4],[3]]) == False\n\tassert candidate([[1,3],[0,3,4,5],[1,3],[0,2,3,4],[0,2,3,4],[0,2,3,4,5],[2,5]]) == False\n\tassert candidate([[1,3],[0,2],[1,3],[0,2]]) == True\n\tassert candidate([[1,2,3,4,5],[0,3,4],[0,1,5],[0,2,4,5],[2],[1,5]]) == False\n\tassert candidate(\n    [[1,2,3,4],[0,2],[0,1,3,4],[0,2,4],[0,1,3],[1,3],[3]]) == False\n\tassert candidate([[1,2],[0,2,3],[0,1,3],[1,2]]) == False\n\tassert candidate([[1,2,3],[0,2,3],[0,1],[1,3],[2]]) == False\n\tassert candidate([[1,2],[0,2],[0,1],[1,3],[2]]) == False\n\tassert candidate([[1,2,3,4,5],[0,2],[0,1],[3],[0,2],[3]]) == False\n\tassert candidate([[1,2],[0],[0,2]]) == False\n\tassert candidate([[1,2,3,4],[0,2,3,4],[0,2,1],[0,1],[2,3,4],[3,4]]) == False\n\tassert candidate([[1,2,3],[0,2],[0,1,3],[0,2]]) == False\n\tassert candidate([[1,2,3],[0,2,3],[0,1,3],[1,2]]) == False\n\tassert candidate([[1],[0,2],[1,3],[2]]) == True\n\tassert candidate([[1,2],[0,2],[0,1,3],[2]]) == False\n\tassert candidate([[1,2],[0,2,3],[1,3],[1,2,4,5],[0],[3,5],[2,5],[3]]) == False\n\tassert candidate([[1,2,3,4],[0,2,4],[0,1],[2],[1,3]]) == False\n\tassert candidate([[1,2,3],[0,2],[0,1,3],[1,3],[2]]) == False\n\tassert candidate(\n    [[1,2,3],[0,2],[0,1,3],[0,2],[1,3],[2],[3],[4,6],[],[5,7,8,9],[2,5,7,9],[2,6,8,9],\n     [3,5,7,8,9],[4,5,6,7,8,9],[2,4,5,6,7,8,9]]\n) == False\n\tassert candidate([[1,2,3],[0,2],[0,1],[3],[0,2]]) == False\n\tassert candidate([[1,2,3,4],[0,2,3,4],[0,2,1],[0,1,3],[2,3,4],[1,3]]) == False\n\tassert candidate([[1,2],[0,2,3],[0,1,3],[0,2]]) == False\ndef test_check():\n\tcheck(isBipartite)\n# Metadata Difficulty: Medium\n# Metadata Topics: depth-first-search,breadth-first-search,union-find,graph\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 583, "filename": "LeetCode_583_rotated_digits.py", "content": "def rotated_digits(n: int) -> int:\n    \"\"\"\n    An integer x is a good if after rotating each digit individually by 180 degrees, we get a valid number that is different from x. Each digit must be rotated - we cannot choose to leave it alone.\n    A number is valid if each digit remains a digit after rotation. For example:\n\n    0, 1, and 8 rotate to themselves,\n    2 and 5 rotate to each other (in this case they are rotated in a different direction, in other words, 2 or 5 gets mirrored),\n    6 and 9 rotate to each other, and\n    the rest of the numbers do not rotate to any other number and become invalid.\n\n    Given an integer n, return the number of good integers in the range [1, n].\n\u00a0\n    Example 1:\n\n    Input: n = 10\n    Output: 4\n    Explanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9.\n    Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.\n\n    Example 2:\n\n    Input: n = 1\n    Output: 0\n\n    Example 3:\n\n    Input: n = 2\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    0 <= n <= 10^4\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(n, int), \"Input must be an integer.\"\n    assert 0 <= n <= 10**4, \"Input must be between 1 and 10,000 inclusive.\"\n    assert n >= 0, \"n must be at least 1.\"\n    assert n <= 10**4, \"n must be no more than 10,000.\"\n    assert isinstance(n, int) and n >= 0, \"Input n must be a non-negative integer.\"\n\n    count = 0\n    for i in range(1, n + 1):\n        is_valid_after_rotation = True\n        is_different_after_rotation = False\n        num = i\n        while num:\n            digit = num % 10\n            if digit in {3, 4, 7}:\n                is_valid_after_rotation = False\n                break\n            if digit in {2, 5, 6, 9}:\n                is_different_after_rotation = True\n            num //= 10\n        if is_valid_after_rotation and is_different_after_rotation:\n            count += 1\n\n    # Postconditions\n    assert isinstance(count, int), \"The result must be an integer.\"\n    assert count >= 0, \"The count of good numbers cannot be negative.\"\n    assert count <= n, \"The count of good numbers cannot exceed n.\"\n    assert all(isinstance(digit, int) for digit in range(1, n + 1)), \"All digits within the range must be integers.\"\n    assert all(0 <= digit <= 9 for digit in range(10)), \"All digits must be within the range 0-9.\"\n    assert all(count >= 0 for _ in range(n + 1)), \"The count should be non-negative for all valid n.\"\n\n    return count\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(5) == 2\n\tassert candidate(1) == 0\n\tassert candidate(2) == 1\n\tassert candidate(20) == 9\n\tassert candidate(180) == 69\n\tassert candidate(10) == 4\n\tassert candidate(0) == 0\n\tassert candidate(100) == 40\n\tassert candidate(30) == 15\ndef test_check():\n\tcheck(rotated_digits)\n# Metadata Difficulty: Medium\n# Metadata Topics: math,dynamic-programming\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 628, "filename": "LeetCode_628_max_profit_assignment.py", "content": "from typing import List\n\n\ndef max_profit_assignment(difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n    \"\"\"\n    You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:\n\n    difficulty[i] and profit[i] are the difficulty and the profit of the ith job, and\n    worker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]).\n\n    Every worker can be assigned at most one job, but one job can be completed multiple times.\n\n    For example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0.\n\n    Return the maximum profit we can achieve after assigning the workers to the jobs.\n\u00a0\n    Example 1:\n\n    Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\n    Output: 100\n    Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.\n\n    Example 2:\n\n    Input: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    n == difficulty.length\n    n == profit.length\n    m == worker.length\n    1 <= n, m <= 104\n    1 <= difficulty[i], profit[i], worker[i] <= 105\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(difficulty, list) and all(isinstance(d, int) for d in difficulty), \"difficulty must be a list of integers.\"\n    assert isinstance(profit, list) and all(isinstance(p, int) for p in profit), \"profit must be a list of integers.\"\n    assert isinstance(worker, list) and all(isinstance(w, int) for w in worker), \"worker must be a list of integers.\"\n    assert len(difficulty) == len(profit), \"The difficulty and profit lists must have the same length.\"\n    assert all(1 <= d <= 10**5 for d in difficulty) and all(1 <= p <= 10**5 for p in profit) and all(1 <= w <= 10**5 for w in worker), \"Values must be between 1 and 100,000.\"\n\n    jobs = sorted(zip(difficulty, profit))\n    worker.sort()\n\n    i, max_profit, total_profit = 0, 0, 0\n    for ability in worker:\n        while i < len(difficulty) and ability >= jobs[i][0]:\n            max_profit = max(max_profit, jobs[i][1])\n            i += 1\n        total_profit += max_profit\n\n    # Postconditions\n    assert isinstance(total_profit, int), \"The result must be an integer.\"\n    assert total_profit >= 0, \"The total profit cannot be negative.\"\n    assert all(isinstance(d, int) for d in difficulty), \"All values in difficulty must be integers.\"\n    assert all(isinstance(p, int) for p in profit), \"All values in profit must be integers.\"\n    assert all(isinstance(w, int) for w in worker), \"All values in worker must be integers.\"\n    assert len(worker) >= 1, \"There should be at least one worker.\"\n\n    return total_profit\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\n    [2, 4, 6, 8, 10], [10, 20, 30, 40, 50], [4, 5, 6, 7]) == 100\n\tassert candidate([5,5,5,5,5], [1,2,3,4,5], [5,5,5,5,5]) == 25\n\tassert candidate([2,4,6,8,10], [10,20,30,40,50], [4,5,6,7]) == 100\n\tassert candidate(\n    [85, 47, 57], [24, 66, 99], [40, 25, 25]\n) == 0\n\tassert candidate(\n    [2,4,6,8,10], [10,20,30,40,50], [4,5,6,7]) == 100\n\tassert candidate(\n    [85,47,57], \n    [24,66,99], \n    [40,25,25]\n) == 0\n\tassert candidate(\n    [85, 47, 57], [24, 66, 99], [40, 25, 25]) == 0\n\tassert candidate(\n    [2,4,6,8,10], [10,20,30,40,50], [4,5,6,7]\n) == 100\n\tassert candidate(\n    [85, 47, 57], [24, 66, 99], [40, 25, 25, 25, 25]\n) == 0\n\tassert candidate([3], [3], [3]) == 3\n\tassert candidate(\n    [85, 47, 57], [24, 66, 99], [40, 25, 25, 25, 25, 25, 25, 25, 25, 25]\n) == 0\n\tassert candidate([1,2,3,4,5], [1,1,1,1,1], [1,2,3,4,5]) == 5\n\tassert candidate(\n    [85,47,57], [24,66,99], [40,25,25]) == 0\n\tassert candidate([1,2,3,4,5], [5,5,5,5,5], [1,2,3,4,5]) == 25\ndef test_check():\n\tcheck(max_profit_assignment)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,two-pointers,binary-search,greedy,sorting\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 657, "filename": "LeetCode_657_scoreOfParentheses.py", "content": "def scoreOfParentheses(s: str) -> int:\n    \"\"\"\n    Given a balanced parentheses string s, return the score of the string.\n    The score of a balanced parentheses string is based on the following rule:\n\n    \"()\" has score 1.\n    AB has score A + B, where A and B are balanced parentheses strings.\n    (A) has score 2 * A, where A is a balanced parentheses string.\n\n\u00a0\n    Example 1:\n\n    Input: s = \"()\"\n    Output: 1\n\n    Example 2:\n\n    Input: s = \"(())\"\n    Output: 2\n\n    Example 3:\n\n    Input: s = \"()()\"\n    Output: 2\n\n\u00a0\n    Constraints:\n\n    2 <= s.length <= 50\n    s consists of only '(' and ')'.\n    s is a balanced parentheses string.\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(s, str), \"Input must be a string.\"\n    assert 2 <= len(s) <= 50, \"Length of s must be between 2 and 50.\"\n    assert all(c in '()' for c in s), \"String must consist only of '(' and ')'.\"\n    assert s[0] == '(' and s[-1] == ')', \"String must start with '(' and end with ')'.\"\n\n    score, depth = 0, 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            depth += 1\n        else:\n            depth -= 1\n            if s[i - 1] == '(':\n                score += 1 << depth\n\n    # Postconditions\n    assert isinstance(score, int), \"The result must be an integer.\"\n    assert score >= 1, \"The score must be at least 1.\"\n    assert score <= 2 ** (len(s) // 2), \"The score must be less than or equal to 2^(n//2) where n is the length of s.\"\n    assert all(isinstance(c, int) for c in [depth, score]), \"All values involved in computation must be integers.\"\n\n    return score\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"()()()()\") == 4\n\tassert candidate(\"(()()(()))\") == 8\n\tassert candidate(\"(((())))\") == 8\n\tassert candidate(\"()\") == 1\n\tassert candidate(\"(())\") == 2\n\tassert candidate(\"()()()()(())\") == 6\n\tassert candidate(\"(((()()))))\") == 16\n\tassert candidate(\"((((()))))((((()))))\") == 32\n\tassert candidate(\"(()())\") == 4\n\tassert candidate(\"()()()()()()()\") == 7\n\tassert candidate(\"(((()))())()()\") == 12\n\tassert candidate(\"()(()())()\") == 6\n\tassert candidate(\"(()()()()())(()())()()\") == 16\n\tassert candidate(\"((())(()))\") == 8\n\tassert candidate(\"((((()))))\") == 16\n\tassert candidate(\"()(())\") == 3\n\tassert candidate(\"((())())\") == 6\n\tassert candidate(\"((()))\") == 4\n\tassert candidate(\"(())(())\") == 4\n\tassert candidate(\"(()(()))\") == 6\n\tassert candidate(\"((()())())\") == 10\n\tassert candidate(\"()()()()()()()()\") == 8\n\tassert candidate(\"()()()()()\") == 5\n\tassert candidate(\"((()))()()\") == 6\n\tassert candidate(\"((((((()))))))\") == 64\n\tassert candidate(\"(((())))(((())))\") == 16\n\tassert candidate(\"(((((())))))\") == 32\n\tassert candidate(\"(()(()))(()(()))\") == 12\n\tassert candidate(\"()()\") == 2\ndef test_check():\n\tcheck(scoreOfParentheses)\n# Metadata Difficulty: Medium\n# Metadata Topics: string,stack\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 665, "filename": "LeetCode_665_prime_palindrome.py", "content": "def prime_palindrome(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the smallest prime palindrome greater than or equal to n.\n    An integer is prime if it has exactly two divisors: 1 and itself. Note that 1 is not a prime number.\n\n    For example, 2, 3, 5, 7, 11, and 13 are all primes.\n\n    An integer is a palindrome if it reads the same from left to right as it does from right to left.\n\n    For example, 101 and 12321 are palindromes.\n\n    The test cases are generated so that the answer always exists and is in the range [2, 2 * 108].\n\u00a0\n    Example 1:\n    Input: n = 6\n    Output: 7\n    Example 2:\n    Input: n = 8\n    Output: 11\n    Example 3:\n    Input: n = 13\n    Output: 101\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 108\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(n, int), \"Input must be an integer.\"\n    assert 1 <= n <= 10**8, \"Input must be in the range 1 to 10^8.\"\n    assert n >= 1, \"n must be a positive integer.\"\n    assert isinstance(n, int), \"n must be an integer.\"\n    assert n > 0, \"n must be greater than 0.\"\n\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        i = 2\n        while i * i <= n:\n            if n % i == 0:\n                return False\n            i += 1\n        return True\n\n    while True:\n        if is_prime(n) and is_palindrome(n):\n            # Postconditions\n            assert isinstance(n, int), \"The result must be an integer.\"\n            assert n >= 2, \"The result must be greater than or equal to 2.\"\n            assert is_prime(n), \"The result must be a prime number.\"\n            assert is_palindrome(n), \"The result must be a palindrome.\"\n            assert n >= 2, \"The returned prime palindrome must be greater than or equal to 2.\"\n            assert str(n) == str(n)[::-1], \"The result must be a palindrome.\"\n            return n\n        n += 1\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(10) == 11\n\tassert candidate(1) == 2\n\tassert candidate(300) == 313\n\tassert candidate(97) == 101\n\tassert candidate(5) == 5\n\tassert candidate(1234) == 10301\n\tassert candidate(6) == 7\n\tassert candidate(9) == 11\n\tassert candidate(98) == 101\n\tassert candidate(13) == 101\n\tassert candidate(94) == 101\n\tassert candidate(2) == 2\n\tassert candidate(4) == 5\n\tassert candidate(11) == 11\n\tassert candidate(92) == 101\n\tassert candidate(3) == 3\n\tassert candidate(95) == 101\n\tassert candidate(100) == 101\n\tassert candidate(7) == 7\n\tassert candidate(8) == 11\n\tassert candidate(99) == 101\n\tassert candidate(93) == 101\n\tassert candidate(101) == 101\n\tassert candidate(17) == 101\n\tassert candidate(124) == 131\n\tassert candidate(96) == 101\ndef test_check():\n\tcheck(prime_palindrome)\n# Metadata Difficulty: Medium\n# Metadata Topics: math\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 716, "filename": "LeetCode_716_minFlipsMonoIncr.py", "content": "def minFlipsMonoIncr(s: str) -> int:\n    \"\"\"\n    A binary string is monotone increasing if it consists of some number of 0's (possibly none), followed by some number of 1's (also possibly none).\n    You are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.\n    Return the minimum number of flips to make s monotone increasing.\n    \"\"\"\n    # Preconditions\n    assert isinstance(s, str), \"Input must be a string.\"\n    assert 1 <= len(s) <= 10**5, \"Length of s must be between 1 and 100,000.\"\n    assert all(c in {'0', '1'} for c in s), \"String must contain only '0' or '1'.\"\n    assert len(s) == len(s.strip()), \"String must not contain leading or trailing whitespace.\"\n    assert s, \"Input string must not be empty.\"\n\n    flipCount, oneCount = 0, 0\n    for c in s:\n        if c == '1':\n            oneCount += 1\n        else:\n            flipCount = min(flipCount + 1, oneCount)\n    \n    result = flipCount\n    \n    # Postconditions\n    assert isinstance(result, int), \"The result must be an integer.\"\n    assert result >= 0, \"The result must be non-negative.\"\n    assert result <= len(s), \"The result cannot exceed the length of the string.\"\n    assert result <= oneCount, \"The result must not exceed the number of '1's in the string.\"\n    assert min(len(s) - result, result) >= 0, \"The number of flips should be achievable.\"\n    assert min(len(s) - oneCount, result) >= 0, \"The number of flips should not exceed the number of '0's.\"\n    assert all(s[i] == '0' or s[i] == '1' for i in range(len(s))), \"All elements in the string should be '0' or '1'.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"01110\") == 1\n\tassert candidate(\"100010\") == 2\n\tassert candidate(\"0011\") == 0\n\tassert candidate(\"0101010\") == 3\n\tassert candidate(\"1010101\") == 3\n\tassert candidate(\"00110\") == 1\n\tassert candidate(\"00011000\") == 2\n\tassert candidate(\"00010\") == 1\n\tassert candidate(\"000\") == 0\n\tassert candidate(\"000111\") == 0\n\tassert candidate(\"0011000\") == 2\n\tassert candidate(\"10101\") == 2\n\tassert candidate(\"111\") == 0\n\tassert candidate(\"0\") == 0\n\tassert candidate(\n    \"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\") == 0\n\tassert candidate(\"11111\") == 0\n\tassert candidate(\"0111\") == 0\n\tassert candidate(\"010110\") == 2\n\tassert candidate(\"00000\") == 0\n\tassert candidate(\"101\") == 1\n\tassert candidate(\"0000000\") == 0\n\tassert candidate(\"1\") == 0\n\tassert candidate(\"0001\") == 0\n\tassert candidate(\"10011\") == 1\n\tassert candidate(\"00111\") == 0\n\tassert candidate(\"00100\") == 1\n\tassert candidate(\"01011\") == 1\n\tassert candidate(\"1001001\") == 2\n\tassert candidate(\"01\") == 0\n\tassert candidate(\"1001\") == 1\n\tassert candidate(\"00001111\") == 0\n\tassert candidate(\"000100000\") == 1\n\tassert candidate(\"010\") == 1\n\tassert candidate(\"0110\") == 1\n\tassert candidate(\n    \"00011000\") == 2\ndef test_check():\n\tcheck(minFlipsMonoIncr)\n# Metadata Difficulty: Medium\n# Metadata Topics: string,dynamic-programming\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 727, "filename": "LeetCode_727_subarraysDivByK.py", "content": "from typing import List\n\n\ndef subarraysDivByK(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.\n    A subarray is a contiguous part of an array.\n\u00a0\n    Example 1:\n\n    Input: nums = [4,5,0,-2,-3,1], k = 5\n    Output: 7\n    Explanation: There are 7 subarrays with a sum divisible by k = 5:\n    [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n\n    Example 2:\n\n    Input: nums = [5], k = 9\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 3 * 104\n    -104 <= nums[i] <= 104\n    0 <= k <= 104\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(nums, list) and all(isinstance(x, int) for x in nums), \"nums must be a list of integers.\"\n    assert isinstance(k, int) and k > 0, \"k must be an integer greater than 1.\"\n    assert 1 <= len(nums) <= 3 * 10**4, \"Length of nums must be between 1 and 30,000.\"\n    assert all(-10**4 <= x <= 10**4 for x in nums), \"Elements of nums must be between -10,000 and 10,000.\"\n\n    prefix_sums_mod_k = [0] * k\n    prefix_sums_mod_k[0] = 1\n    running_sum = 0\n    count = 0\n\n    for num in nums:\n        running_sum += num\n        mod = (running_sum % k + k) % k\n        count += prefix_sums_mod_k[mod]\n        prefix_sums_mod_k[mod] += 1\n\n    # Postconditions\n    assert isinstance(count, int), \"The result must be an integer.\"\n    assert count >= 0, \"The result must be non-negative.\"\n    assert count <= len(nums) * (len(nums) + 1) // 2, \"The result must not exceed the maximum number of subarrays.\"\n\n    return count\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\n    [1, 2, 3, 4, 5], 5) == 4\n\tassert candidate([1,2,3,4,5], 2) == 6\n\tassert candidate([1,1,1,1,1], 1) == 15\n\tassert candidate([5], 9) == 0\n\tassert candidate([4,5,0,-2,-3,1], 5) == 7\n\tassert candidate([10,20,30,40,50], 10) == 15\n\tassert candidate([1,2,3,4,5], 5) == 4\n\tassert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7) == 10\n\tassert candidate([-1,-1,-1,-1,-1], 1) == 15\n\tassert candidate([1,2,3,4,5], 1) == 15\ndef test_check():\n\tcheck(subarraysDivByK)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,hash-table,prefix-sum\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 780, "filename": "LeetCode_780_orangesRotting.py", "content": "from typing import List\nfrom collections import deque\n\ndef orangesRotting(grid: List[List[int]]) -> int:\n    \"\"\"\n    You are given an m x n grid where each cell can have one of three values:\n    \n    0 representing an empty cell,\n    1 representing a fresh orange, or\n    2 representing a rotten orange.\n\n    Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\n    Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\n    \"\"\"\n    # Preconditions\n    assert isinstance(grid, list), \"Grid must be a list of lists.\"\n    assert all(isinstance(row, list) for row in grid), \"Each row in grid must be a list.\"\n    assert all(isinstance(cell, int) and cell in {0, 1, 2} for row in grid for cell in row), \"Each cell must be an integer 0, 1, or 2.\"\n\n    m, n = len(grid), len(grid[0])\n    fresh_oranges = sum(row.count(1) for row in grid)\n    rotten = deque([(i, j) for i, row in enumerate(grid) for j, value in enumerate(row) if value == 2])\n\n    minutes = 0\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    while rotten and fresh_oranges:\n        for _ in range(len(rotten)):\n            x, y = rotten.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:\n                    grid[nx][ny] = 2\n                    fresh_oranges -= 1\n                    rotten.append((nx, ny))\n        minutes += 1\n\n    result = minutes if fresh_oranges == 0 else -1\n    \n    # Postconditions\n    assert isinstance(result, int), \"The result must be an integer.\"\n    assert result >= -1, \"The result must be greater than or equal to -1.\"\n    if result != -1:\n        assert result >= 0, \"If the result is not -1, it must be non-negative.\"\n    \n    return result\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\n    [[2,1,1,2,2,1,1,0,1,1,1,0,2,0],[1,1,1,0,2,0,1,1,0,1,2,2,1,1],[0,1,1,0,2,1,2,1,0,2,0,1,2,1],[1,1,1,1,1,1,0,1,0,1,2,2,1,1],[0,1,0,1,0,0,1,2,1,0,1,1,1,1],[1,2,2,1,1,1,2,1,1,0,0,0,1,1],[0,1,1,1,0,1,1,1,1,1,1,2,1,1],[1,1,1,0,0,1,1,1,1,1,0,0,1,0],[2,1,1,1,1,1,1,1,1,2,1,1,1,0],[1,1,1,0,0,1,0,0,0,0,1,0,1,1],[0,1,0,0,1,1,1,0,0,1,0,1,0,0],[1,1,1,1,1,0,0,0,1,0,1,1,0,0],[2,1,1,0,0,1,1,1,1,1,1,0,1,0]]) == -1\n\tassert candidate([[2,1,1,1,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,1,1,1,1]]) == -1\n\tassert candidate([[0,2,2]]) == 0\n\tassert candidate([[1,2],[1,1],[2,2],[0,1]]) == 1\n\tassert candidate([[2,1,1],[1,1,0],[0,1,1]]) == 4\n\tassert candidate([[2,1,1],[0,1,1],[1,0,1]]) == -1\n\tassert candidate([[2,1,1,0,0],[1,1,0,0,0],[0,1,0,0,1],[1,0,0,0,1]]) == -1\n\tassert candidate([[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,2]]) == 0\n\tassert candidate([[0,2]]) == 0\n\tassert candidate(\n    [[2,1,1],[1,1,1],[0,1,1],[1,0,1],[0,1,1],[2,1,1],[0,0,1],[2,1,1],[0,1,1],[1,1,1],[1,0,1],[1,1,1],[1,1,1],[0,0,1],[1,1,1],[1,1,1]]) == -1\ndef test_check():\n\tcheck(orangesRotting)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,breadth-first-search,matrix\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 791, "filename": "LeetCode_791_clumsy.py", "content": "def clumsy(n: int) -> int:\n    \"\"\"\n    The factorial of a positive integer n is the product of all positive integers less than or equal to n.\n\n    For example, factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1.\n\n    We make a clumsy factorial using the integers in decreasing order by swapping out the multiply operations for a fixed rotation of operations with multiply '*', divide '/', add '+', and subtract '-' in this order.\n\n    For example, clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1.\n\n    However, these operations are still applied using the usual order of operations of arithmetic. We do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right.\n    Additionally, the division that we use is floor division such that 10 * 9 / 8 = 90 / 8 = 11.\n    Given an integer n, return the clumsy factorial of n.\n\u00a0\n    Example 1:\n\n    Input: n = 4\n    Output: 7\n    Explanation: 7 = 4 * 3 / 2 + 1\n\n    Example 2:\n\n    Input: n = 10\n    Output: 12\n    Explanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 10^8\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(n, int), \"n must be an integer.\"\n    \n    if n <= 2:\n        return n\n    if n == 3:\n        return 6\n    \n    result = n * (n - 1) // (n - 2) + (n - 3)\n    n -= 4\n    while n >= 4:\n        result = result - (n * (n - 1) // (n - 2)) + (n - 3)\n        n -= 4\n    \n    final_result = result - clumsy(n)\n    \n    # Postconditions\n    assert isinstance(final_result, int), \"The result must be an integer.\"\n    assert final_result >= 1, \"The result must be greater than or equal to 1.\"\n    \n\n    return final_result\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(1900) == 1901\n\tassert candidate(8) == 9\n\tassert candidate(2200) == 2201\n\tassert candidate(3000000) == 3000001\n\tassert candidate(200) == 201\n\tassert candidate(2100) == 2101\n\tassert candidate(9900) == 9901\n\tassert candidate(300000) == 300001\n\tassert candidate(2600) == 2601\n\tassert candidate(2000) == 2001\n\tassert candidate(3000) == 3001\n\tassert candidate(20) == 21\n\tassert candidate(4) == 7\n\tassert candidate(9000) == 9001\n\tassert candidate(5) == 7\n\tassert candidate(5000) == 5001\n\tassert candidate(4000) == 4001\n\tassert candidate(300) == 301\n\tassert candidate(100) == 101\n\tassert candidate(2400) == 2401\n\tassert candidate(45000000) == 45000001\n\tassert candidate(1000000) == 1000001\n\tassert candidate(9) == 11\n\tassert candidate(11) == 10\n\tassert candidate(2300) == 2301\n\tassert candidate(7) == 6\n\tassert candidate(19) == 18\n\tassert candidate(3) == 6\n\tassert candidate(14) == 16\n\tassert candidate(15) == 14\n\tassert candidate(2500) == 2501\n\tassert candidate(1600) == 1601\n\tassert candidate(1100) == 1101\n\tassert candidate(9000000) == 9000001\n\tassert candidate(20000) == 20001\n\tassert candidate(2700) == 2701\n\tassert candidate(1) == 1\n\tassert candidate(15000000) == 15000001\n\tassert candidate(30000) == 30001\n\tassert candidate(50000000) == 50000001\n\tassert candidate(500) == 501\n\tassert candidate(13) == 15\n\tassert candidate(6) == 8\n\tassert candidate(40000) == 40001\n\tassert candidate(30) == 32\n\tassert candidate(999) == 998\n\tassert candidate(1700) == 1701\n\tassert candidate(10) == 12\n\tassert candidate(400) == 401\n\tassert candidate(10000000) == 10000001\n\tassert candidate(2900) == 2901\n\tassert candidate(900) == 901\n\tassert candidate(16) == 17\n\tassert candidate(1500) == 1501\n\tassert candidate(2800) == 2801\n\tassert candidate(12) == 13\n\tassert candidate(1400) == 1401\n\tassert candidate(1800) == 1801\n\tassert candidate(18) == 20\n\tassert candidate(600) == 601\n\tassert candidate(6000) == 6001\n\tassert candidate(1200) == 1201\n\tassert candidate(700) == 701\n\tassert candidate(5000000) == 5000001\n\tassert candidate(1300) == 1301\n\tassert candidate(900000) == 900001\n\tassert candidate(17) == 19\n\tassert candidate(1000) == 1001\n\tassert candidate(10000) == 10001\n\tassert candidate(3200) == 3201\n\tassert candidate(2) == 2\n\tassert candidate(800) == 801\n\tassert candidate(100000) == 100001\ndef test_check():\n\tcheck(clumsy)\n# Metadata Difficulty: Medium\n# Metadata Topics: math,stack,simulation\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 797, "filename": "LeetCode_797_num_pairs_divisible_by60.py", "content": "from typing import List\n\n\ndef num_pairs_divisible_by60(time: List[int]) -> int:\n    \"\"\"\n    You are given a list of songs where the ith song has a duration of time[i] seconds.\n    Return the number of pairs of songs for which their total duration in seconds is divisible by 60. Formally, we want the number of indices i, j such that i < j with (time[i] + time[j]) % 60 == 0.\n    \"\"\"\n    \n    # Preconditions\n    assert isinstance(time, list), \"Input must be a list.\"\n    assert all(isinstance(t, int) and 1 <= t <= 500 for t in time), \"All elements must be integers between 1 and 500.\"\n    assert 1 <= len(time) <= 6 * 10**4, \"List length must be between 1 and 60,000.\"\n\n    count = [0] * 60\n    pairs = 0\n\n    for t in time:\n        mod = t % 60\n        pairs += count[(60 - mod) % 60]\n        count[mod] += 1\n\n    # Postconditions\n    assert isinstance(pairs, int), \"The result must be an integer.\"\n    assert pairs >= 0, \"The result must be non-negative.\"\n    \n    return pairs\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([60,120,180,240,300,360]) == 15\n\tassert candidate([60,60,60]) == 3\n\tassert candidate([60,120,180,240,300,360,420,480,540,600,660,720,780,840,900,960]) == 120\n\tassert candidate([30,20,150,100,40]) == 3\n\tassert candidate([120,240,360]) == 3\n\tassert candidate([5,35,65,95]) == 0\n\tassert candidate([60,120,180,240,300,360,420,480,540,600]) == 45\n\tassert candidate([1,61,121,181,241,301,361,421,481,541,601,661,721,781,841,901,961]) == 0\n\tassert candidate([30,30,30,30]) == 6\ndef test_check():\n\tcheck(num_pairs_divisible_by60)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,hash-table,counting\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 804, "filename": "LeetCode_804_maxScoreSightseeingPair.py", "content": "from typing import List\n\n\ndef maxScoreSightseeingPair(values: List[int]) -> int:\n    \"\"\"\n    You are given an integer array values where values[i] represents the value of the ith sightseeing spot. Two sightseeing spots i and j have a distance j - i between them.\n    The score of a pair (i < j) of sightseeing spots is values[i] + values[j] + i - j: the sum of the values of the sightseeing spots, minus the distance between them.\n    Return the maximum score of a pair of sightseeing spots.\n\u00a0\n    Example 1:\n\n    Input: values = [8,1,5,2,6]\n    Output: 11\n    Explanation: i = 0, j = 2, values[i] + values[j] + i - j = 8 + 5 + 0 - 2 = 11\n\n    Example 2:\n\n    Input: values = [1,2]\n    Output: 2\n\n\u00a0\n    Constraints:\n\n    2 <= values.length <= 5 * 104\n    1 <= values[i] <= 100000000000\n\n    \"\"\"\n    # Preconditions\n    assert isinstance(values, list), \"Input must be a list.\"\n    assert all(isinstance(v, int) for v in values), \"All elements must be integers.\"\n    assert 2 <= len(values) <= 5 * 10**4, \"List length must be between 2 and 50,000.\"\n    assert all(1 <= v <= 100000000000 for v in values), \"All elements must be between 1 and 1000.\"\n\n    max_score = 0\n    max_score_left = values[0] + 0\n    for j in range(1, len(values)):\n        max_score = max(max_score, max_score_left + values[j] - j)\n        max_score_left = max(max_score_left, values[j] + j)\n    \n    # Postconditions\n    assert isinstance(max_score, int), \"The result must be an integer.\"\n    assert max_score >= 0, \"The result must be non-negative.\"\n    \n    return max_score\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1,2,3,4,5,6,7,8,9,10]) == 18\n\tassert candidate([10000]*10000) == 19999\n\tassert candidate([i for i in range(10000, 0, -1)]) == 19998\n\tassert candidate([3,2,1]) == 4\n\tassert candidate([1,4,2,5,3]) == 7\n\tassert candidate([i for i in range(1, 10001)]) == 19998\n\tassert candidate([1,2]) == 2\n\tassert candidate([1,2,3,4,5]) == 8\n\tassert candidate([1, 2]) == 2\n\tassert candidate(list(range(10000, 0, -1))) == 19998\n\tassert candidate([5,4,3,2,1]) == 8\n\tassert candidate([10,9,8,7,6,5,4,3,2,1]) == 18\n\tassert candidate(list(range(1, 10001))) == 19998\n\tassert candidate([2,2,2]) == 3\n\tassert candidate([8,1,5,2,6]) == 11\ndef test_check():\n\tcheck(maxScoreSightseeingPair)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,dynamic-programming\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 823, "filename": "LeetCode_823_twoCitySchedCost.py", "content": "from typing import List\n\n\ndef twoCitySchedCost(costs: List[List[int]]) -> int:\n    \"\"\"\n    A company is planning to interview 2n people. Given the array costs where costs[i] = [aCosti, bCosti],\u00a0the cost of flying the ith person to city a is aCosti, and the cost of flying the ith person to city b is bCosti.\n    Return the minimum cost to fly every person to a city such that exactly n people arrive in each city.\n\u00a0\n    Example 1:\n\n    Input: costs = [[10,20],[30,200],[400,50],[30,20]]\n    Output: 110\n    Explanation: \n    The first person goes to city A for a cost of 10.\n    The second person goes to city A for a cost of 30.\n    The third person goes to city B for a cost of 50.\n    The fourth person goes to city B for a cost of 20.\n\n    The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.\n\n    Example 2:\n\n    Input: costs = [[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]]\n    Output: 1859\n\n    Example 3:\n\n    Input: costs = [[515,563],[451,713],[537,709],[343,819],[855,779],[457,60],[650,359],[631,42]]\n    Output: 3086\n\n\u00a0\n    Constraints:\n\n    2 * n == costs.length\n    2 <= costs.length <= 100\n    costs.length is even.\n    1 <= aCosti, bCosti <= 1000\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(costs, list) and all(isinstance(cost, list) and len(cost) == 2 for cost in costs), \"Input must be a list of lists, each containing two integers.\"\n    assert 2 <= len(costs) <= 100 and len(costs) % 2 == 0, \"The length of costs must be an even number between 2 and 100.\"\n    assert all(1 <= cost[0] <= 1000 and 1 <= cost[1] <= 1000 for cost in costs), \"All costs must be between 1 and 1000.\"\n\n    costs.sort(key=lambda x: x[0] - x[1])\n\n    totalCost = 0\n    n = len(costs) // 2\n\n    for i in range(n):\n        totalCost += costs[i][0] + costs[i + n][1]\n\n    # Postconditions\n    assert isinstance(totalCost, int), \"The result must be an integer.\"\n    assert totalCost > 0, \"The total cost must be positive.\"\n\n    return totalCost\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\n    [[515, 563], [451, 713], [537, 709], [343, 819], [855, 779], [457, 60], [650, 359], [631, 42]]) == 3086\n\tassert candidate([[1,1],[1,1],[1,1],[1,1]]) == 4\n\tassert candidate([[1,2],[2,5],[3,1],[4,3]]) == 7\n\tassert candidate([[10, 20], [30, 200], [400, 50], [30, 20]]) == 110\n\tassert candidate([[259, 770], [448, 54], [926, 667], [184, 139], [840, 118], [577, 469]]) == 1859\ndef test_check():\n\tcheck(twoCitySchedCost)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,greedy,sorting\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 829, "filename": "LeetCode_829_colorBorder.py", "content": "from typing import List\n\n\ndef colorBorder(grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\n    \"\"\"\n    You are given an m x n integer matrix grid, and three integers row, col, and color. Each value in the grid represents the color of the grid square at that location.\n    Two squares are called adjacent if they are next to each other in any of the 4 directions.\n    Two squares belong to the same connected component if they have the same color and they are adjacent.\n    The border of a connected component is all the squares in the connected component that are either adjacent to (at least) a square not in the component, or on the boundary of the grid (the first or last row or column).\n    You should color the border of the connected component that contains the square grid[row][col] with color.\n    Return the final grid.\n\u00a0\n    Example 1:\n    Input: grid = [[1,1],[1,2]], row = 0, col = 0, color = 3\n    Output: [[3,3],[3,2]]\n    Example 2:\n    Input: grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3\n    Output: [[1,3,3],[2,3,3]]\n    Example 3:\n    Input: grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2\n    Output: [[2,2,2],[2,1,2],[2,2,2]]\n\n\u00a0\n    Constraints:\n\n    m == grid.length\n    n == grid[i].length\n    1 <= m, n <= 50\n    1 <= grid[i][j], color <= 1000\n    0 <= row < m\n    0 <= col < n\n\n    \"\"\"\n    ### Canonical solution below ###\n      # Preconditions\n    assert isinstance(grid, list) and all(isinstance(row, list) for row in grid), \"grid must be a list of lists\"\n    assert all(isinstance(val, int) for row in grid for val in row), \"grid must contain only integers\"\n    assert 1 <= len(grid) <= 50, \"The number of rows in grid must be between 1 and 50\"\n    assert 1 <= len(grid[0]) <= 50, \"The number of columns in grid must be between 1 and 50\"\n    assert 0 <= row < len(grid), \"row index out of bounds\"\n    assert 0 <= col < len(grid[0]), \"col index out of bounds\"\n    assert isinstance(color, int) and 1 <= color <= 1000, \"color must be an integer between 1 and 1000\"\n\n    def dfs(grid, row, col, current, color):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != current:\n            return\n\n        grid[row][col] = color\n        dfs(grid, row - 1, col, current, color)\n        dfs(grid, row + 1, col, current, color)\n        dfs(grid, row, col - 1, current, color)\n        dfs(grid, row, col + 1, current, color)\n\n    current = grid[row][col]\n    if current == color:\n        return grid\n\n    dfs(grid, row, col, current, color + 1000)\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] > 1000:\n                grid[i][j] -= 1000\n    assert isinstance(grid, list) and all(isinstance(row, list) for row in grid), \"Result must be a list of lists\"\n    assert all(isinstance(val, int) for row in grid for val in row), \"Result must contain only integers\"\n    assert len(grid) == len(grid) and len(grid[0]) == len(grid[0]), \"The grid dimensions should remain unchanged\"\n    assert all(1 <= val <= 1000 for row in grid for val in row), \"All values in the grid must be between 1 and 1000\"\n\n    return grid\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([[1,1,1],[1,1,1],[1,1,1]], 1, 1, 1) == [[1,1,1],[1,1,1],[1,1,1]]\n\tassert candidate([[1,2,2],[2,3,2]], 0, 1, 3) == [[1,3,3],[2,3,3]]\n\tassert candidate(\n    [[1,2,1,2,1,2,1,2,1],[1,2,1,2,1,2,1,2,1],[1,2,2,2,2,2,2,2,1],[1,2,1,2,2,2,2,2,1],\n     [1,2,2,2,2,2,2,2,1],[1,2,1,2,2,2,2,2,1],[1,2,2,2,2,2,2,2,1],[1,2,1,2,2,2,2,2,1],\n     [1,2,1,2,1,2,1,2,1]],\n     0, 0, 3\n) == [\n     [3,2,1,2,1,2,1,2,1],\n     [3,2,1,2,1,2,1,2,1],\n     [3,2,2,2,2,2,2,2,1],\n     [3,2,1,2,2,2,2,2,1],\n     [3,2,2,2,2,2,2,2,1],\n     [3,2,1,2,2,2,2,2,1],\n     [3,2,2,2,2,2,2,2,1],\n     [3,2,1,2,2,2,2,2,1],\n     [3,2,1,2,1,2,1,2,1]\n]\n\tassert candidate([[1,2,1],[2,2,2],[1,2,1]], 1, 1, 3) == [[1,3,1],[3,3,3],[1,3,1]]\n\tassert candidate([[1,2,2,1],[2,3,3,2],[2,3,3,2]], 0, 0, 3) == [[3,2,2,1],[2,3,3,2],[2,3,3,2]]\ndef test_check():\n\tcheck(colorBorder)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,depth-first-search,breadth-first-search,matrix\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 833, "filename": "LeetCode_833_corpFlightBookings.py", "content": "from typing import List\n\n\ndef corpFlightBookings(bookings: List[List[int]], n: int) -> List[int]:\n    \"\"\"\n    There are n flights that are labeled from 1 to n.\n    You are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.\n    Return an array answer of length n, where answer[i] is the total number of seats reserved for flight i.\n\u00a0\n    Example 1:\n\n    Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5\n    Output: [10,55,45,25,25]\n    Explanation:\n    Flight labels:        1   2   3   4   5\n    Booking 1 reserved:  10  10\n    Booking 2 reserved:      20  20\n    Booking 3 reserved:      25  25  25  25\n    Total seats:         10  55  45  25  25\n    Hence, answer = [10,55,45,25,25]\n\n    Example 2:\n\n    Input: bookings = [[1,2,10],[2,2,15]], n = 2\n    Output: [10,25]\n    Explanation:\n    Flight labels:        1   2\n    Booking 1 reserved:  10  10\n    Booking 2 reserved:      15\n    Total seats:         10  25\n    Hence, answer = [10,25]\n\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 2 * 104\n    1 <= bookings.length <= 2 * 104\n    bookings[i].length == 3\n    1 <= firsti <= lasti <= n\n    1 <= seatsi <= 104\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(bookings, list) and all(isinstance(booking, list) and len(booking) == 3 for booking in bookings), \"bookings must be a list of lists of length 3.\"\n    assert isinstance(n, int) and 1 <= n <= 2 * 10**4, \"n must be an integer between 1 and 2 * 10^4.\"\n    assert all(1 <= booking[0] <= booking[1] <= n for booking in bookings), \"Each booking must have valid flight numbers within the range.\"\n    assert all(1 <= booking[2] <= 10**4 for booking in bookings), \"Seats reserved in each booking must be between 1 and 10^4.\"\n    assert len(bookings) <= 2 * 10**4, \"bookings length must not exceed 2 * 10^4.\"\n\n    seats = [0] * n\n    for booking in bookings:\n        seats[booking[0] - 1] += booking[2]\n        if booking[1] < n:\n            seats[booking[1]] -= booking[2]\n    for i in range(1, n):\n        seats[i] += seats[i - 1]\n\n    # Postconditions\n    assert isinstance(seats, list), \"The result must be a list.\"\n    assert len(seats) == n, \"The length of the result list must be equal to n.\"\n    assert all(isinstance(seat, int) and seat >= 0 for seat in seats), \"All values in the result list must be non-negative integers.\"\n\n    return seats\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([[1,5,10],[6,10,5]], 10) == [10,10,10,10,10,5,5,5,5,5]\n\tassert candidate([[1,1,10],[2,2,5]], 2) == [10,5]\n\tassert candidate([[1,3,5],[4,6,10]], 6) == [5,5,5,10,10,10]\n\tassert candidate([[1,2,3],[2,3,4],[3,4,5]], 4) == [3,7,9,5]\n\tassert candidate([[1,1,10],[1,1,5]], 1) == [15]\n\tassert candidate([[1,1,1]], 1) == [1]\n\tassert candidate([[1,2,10],[2,3,20],[2,5,25]], 5) == [10,55,45,25,25]\n\tassert candidate([[1,3,10],[2,4,20]], 4) == [10,30,30,20]\n\tassert candidate([[2,2,10],[1,1,5]], 2) == [5,10]\n\tassert candidate([[1,2,10],[2,2,5]], 2) == [10,15]\n\tassert candidate([[1,3,5],[2,4,10]], 4) == [5,15,15,10]\n\tassert candidate([[1,10,1]], 10) == [1,1,1,1,1,1,1,1,1,1]\n\tassert candidate([[1,1,10],[2,3,20]], 3) == [10,20,20]\n\tassert candidate([[1,2,10],[2,2,15]], 2) == [10,25]\n\tassert candidate([[1,1,10],[2,2,10],[3,3,10]], 3) == [10,10,10]\n\tassert candidate([[1,2,10],[1,1,5]], 2) == [15,10]\n\tassert candidate([[1,3,5],[2,6,10]], 6) == [5,15,15,10,10,10]\n\tassert candidate([[1,2,10],[3,4,20]], 4) == [10,10,20,20]\ndef test_check():\n\tcheck(corpFlightBookings)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,prefix-sum\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 853, "filename": "LeetCode_853_rearrange_barcodes.py", "content": "from typing import List\nfrom heapq import heappush, heappop\n\ndef rearrange_barcodes(barcodes: List[int]) -> List[int]:\n    \"\"\"\n    In a warehouse, there is a row of barcodes, where the ith barcode is barcodes[i].\n    Rearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists.\n\u00a0\n    Example 1:\n    Input: barcodes = [1,1,1,2,2,2]\n    Output: [2,1,2,1,2,1]\n    Example 2:\n    Input: barcodes = [1,1,1,1,2,2,3,3]\n    Output: [1,3,1,3,1,2,1,2]\n\n\u00a0\n    Constraints:\n\n    1 <= barcodes.length <= 10000\n    1 <= barcodes[i] <= 10000\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(barcodes, list) and all(isinstance(x, int) for x in barcodes), \"barcodes must be a list of integers.\"\n    assert 1 <= len(barcodes) <= 10000, \"barcodes length must be between 1 and 10000.\"\n    assert all(1 <= x <= 10000 for x in barcodes), \"Each barcode must be between 1 and 10000.\"\n\n    count = {}\n    for barcode in barcodes:\n        if barcode not in count:\n            count[barcode] = 0\n        count[barcode] += 1\n\n    pq = []\n    for key, value in count.items():\n        heappush(pq, (-value, key))\n\n    idx = 0\n    while pq:\n        curr = heappop(pq)\n        while curr[0] < 0:\n            barcodes[idx] = curr[1]\n            curr = (curr[0] + 1, curr[1])\n            idx += 2\n            if idx >= len(barcodes):\n                idx = 1\n\n    # Postconditions\n    assert isinstance(barcodes, list), \"The result must be a list.\"\n    assert len(barcodes) == len(set(barcodes)) or len(barcodes) > 1, \"The length of the result must be at least 2 if there are more than one distinct barcode.\"\n\n    return barcodes\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([2,1,1]) == [1,2,1]\n\tassert candidate([3, 1, 3, 1]) == [1, 3, 1, 3]\n\tassert candidate([1,1,1,2,2,2]) == [1,2,1,2,1,2]\n\tassert candidate([1]) == [1]\n\tassert candidate([2, 2, 2, 1, 1]) == [2, 1, 2, 1, 2]\n\tassert candidate(\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == [\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n    ]\ndef test_check():\n\tcheck(rearrange_barcodes)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,hash-table,greedy,sorting,heap-priority-queue,counting\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 918, "filename": "LeetCode_918_largest1BorderedSquare.py", "content": "from typing import List\n\n\ndef largest1BorderedSquare(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, return the number of elements in\u00a0the largest square\u00a0subgrid that has all 1s on its border, or 0 if such a subgrid\u00a0doesn't exist in the grid.\n\u00a0\n    Example 1:\n\n    Input: grid = [[1,1,1],[1,0,1],[1,1,1]]\n    Output: 9\n\n    Example 2:\n\n    Input: grid = [[1,1,0,0]]\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= grid.length <= 100\n    1 <= grid[0].length <= 100\n    grid[i][j] is 0 or 1\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(grid, list) and all(isinstance(row, list) for row in grid), \"Grid must be a list of lists.\"\n    assert 1 <= len(grid) <= 100, \"Grid length must be between 1 and 100.\"\n    assert 1 <= len(grid[0]) <= 100, \"Grid width must be between 1 and 100.\"\n    assert all(isinstance(cell, int) and (cell == 0 or cell == 1) for row in grid for cell in row), \"Grid must contain only 0s and 1s.\"\n\n    m, n = len(grid), len(grid[0])\n    horizontal, vertical = [[0] * n for _ in range(m)], [[0] * n for _ in range(m)]\n\n    max_square_size = 0\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                horizontal[i][j] = 1 if j == 0 else horizontal[i][j - 1] + 1\n                vertical[i][j] = 1 if i == 0 else vertical[i - 1][j] + 1\n\n                min_size = min(horizontal[i][j], vertical[i][j])\n                while min_size > max_square_size:\n                    if (horizontal[i - min_size + 1][j] >= min_size and\n                            vertical[i][j - min_size + 1] >= min_size):\n                        max_square_size = min_size\n                    min_size -= 1\n\n    # Postconditions\n    assert isinstance(max_square_size, int), \"Result must be an integer.\"\n    assert max_square_size >= 0, \"Result must be non-negative.\"\n    assert max_square_size ** 2 <= m * n, \"The area of the square cannot exceed the grid's total area.\"\n\n    return max_square_size * max_square_size\n\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([[1]]) == 1\n\tassert candidate([[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]) == 25\n\tassert candidate([[1, 1, 1, 1], [1, 0, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 16\n\tassert candidate([[1, 1, 1], [1, 0, 1], [1, 1, 1], [1, 0, 1], [1, 1, 1]]) == 9\n\tassert candidate([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) == 1\n\tassert candidate(\n    [[0, 0, 1, 0, 0, 0, 1, 0], [1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1],\n     [0, 1, 1, 1, 1, 0, 1, 1], [0, 1, 1, 0, 1, 1, 1, 1], [0, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 1, 1, 0]]) == 25\n\tassert candidate([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) == 1\n\tassert candidate([[1, 0, 1], [1, 1, 1], [1, 0, 1]]) == 1\n\tassert candidate([[1, 1, 1, 0, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) == 16\n\tassert candidate([[1, 1, 1], [1, 0, 1], [1, 1, 1]]) == 9\n\tassert candidate([[1, 1, 1, 1, 1], [1, 1, 0, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) == 25\n\tassert candidate([[0]]) == 0\n\tassert candidate([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 16\n\tassert candidate([[1, 1, 1, 1], [1, 0, 1, 0], [1, 1, 1, 1]]) == 9\n\tassert candidate([[1, 1, 0], [1, 0, 1], [1, 1, 1]]) == 1\n\tassert candidate(\n    [[1, 0, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0], [0, 1, 0, 1, 1, 0], [1, 1, 1, 1, 1, 1], [0, 0, 0, 1, 0, 1]]) == 9\ndef test_check():\n\tcheck(largest1BorderedSquare)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,dynamic-programming,matrix\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 949, "filename": "LeetCode_949_can_make_pali_queries.py", "content": "from typing import List\n\n\ndef can_make_pali_queries(s: str, queries: List[List[int]]) -> List[bool]:\n    \"\"\"\n    You are given a string s and array queries where queries[i] = [lefti, righti, ki]. We may rearrange the substring s[lefti...righti] for each query and then choose up to ki of them to replace with any lowercase English letter.\n    If the substring is possible to be a palindrome string after the operations above, the result of the query is true. Otherwise, the result is false.\n    Return a boolean array answer where answer[i] is the result of the ith query queries[i].\n    Note that each letter is counted individually for replacement, so if, for example s[lefti...righti] = \"aaa\", and ki = 2, we can only replace two of the letters. Also, note that no query modifies the initial string s.\n\u00a0\n    Example :\n\n    Input: s = \"abcda\", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]\n    Output: [true,false,false,true,true]\n    Explanation:\n    queries[0]: substring = \"d\", is palidrome.\n    queries[1]: substring = \"bc\", is not palidrome.\n    queries[2]: substring = \"abcd\", is not palidrome after replacing only 1 character.\n    queries[3]: substring = \"abcd\", could be changed to \"abba\" which is palidrome. Also this can be changed to \"baab\" first rearrange it \"bacd\" then replace \"cd\" with \"ab\".\n    queries[4]: substring = \"abcda\", could be changed to \"abcba\" which is palidrome.\n\n    Example 2:\n\n    Input: s = \"lyb\", queries = [[0,1,0],[2,2,1]]\n    Output: [false,true]\n\n\u00a0\n    Constraints:\n\n    1 <= s.length, queries.length <= 105\n    0 <= lefti <= righti < s.length\n    0 <= ki <= s.length\n    s consists of lowercase English letters.\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(s, str), \"Input s must be a string.\"\n    assert 1 <= len(s) <= 10**5, \"Length of s must be between 1 and 100000.\"\n    assert all(c.islower() and c.isalpha() for c in s), \"s must consist of lowercase English letters.\"\n    assert isinstance(queries, list) and all(isinstance(query, list) and len(query) == 3 for query in queries), \"Queries must be a list of [lefti, righti, ki] lists.\"\n    \n    result = []\n    for left, right, k in queries:\n        count = [0] * 26\n        for i in range(left, right + 1):\n            count[ord(s[i]) - ord('a')] += 1\n        odd_count = sum(c % 2 for c in count)\n        result.append(odd_count // 2 <= k)\n    \n    # Postconditions\n    assert isinstance(result, list), \"Result must be a list.\"\n    assert all(isinstance(res, bool) for res in result), \"Each element of result must be a boolean.\"\n    assert len(result) == len(queries), \"The length of the result must match the length of queries.\"\n\n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"abccba\", [[0, 2, 1]]) == [True]\n\tassert candidate(\"abcba\", [[0, 4, 1]]) == [True]\n\tassert candidate(\"abcda\", [[0, 4, 1]]) == [True]\n\tassert candidate(\"ab\", [[0, 1, 1]]) == [True]\n\tassert candidate(\"aaa\", [[0, 2, 0]]) == [True]\n\tassert candidate(\"a\", [[0, 0, 0]]) == [True]\n\tassert candidate(\"abcba\", [[0, 3, 1]]) == [True]\n\tassert candidate(\"abcde\", [[1, 3, 2]]) == [True]\n\tassert candidate(\"bbabbc\", [[1, 5, 2]]) == [True]\n\tassert candidate(\"abcba\", [[2, 4, 1]]) == [True]\n\tassert candidate(\"abccba\", [[1, 4, 0]]) == [True]\n\tassert candidate(\"abcda\", [[0, 3, 2]]) == [True]\n\tassert candidate(\"aab\", [[0, 1, 1]]) == [True]\n\tassert candidate(\"abab\", [[0, 3, 1]]) == [True]\n\tassert candidate(\"abaa\", [[0, 3, 1]]) == [True]\n\tassert candidate(\"abcba\", [[0, 3, 0]]) == [False]\n\tassert candidate(\"abccca\", [[0, 5, 2]]) == [True]\n\tassert candidate(\"abcba\", [[0, 3, 2]]) == [True]\n\tassert candidate(\"ab\", [[0, 1, 0]]) == [False]\n\tassert candidate(\"abcda\", [[1, 2, 0]]) == [False]\n\tassert candidate(\"abccca\", [[0, 5, 0]]) == [False]\n\tassert candidate(\"f\", [[0, 0, 0]]) == [True]\n\tassert candidate(\"ab\", [[0, 1, 2]]) == [True]\n\tassert candidate(\"abcba\", [[1, 3, 0]]) == [True]\n\tassert candidate(\"aab\", [[0, 2, 1]]) == [True]\n\tassert candidate(\"aaccb\", [[0, 4, 1]]) == [True]\n\tassert candidate(\"abccba\", [[0, 4, 1]]) == [True]\n\tassert candidate(\"abcba\", [[0, 4, 0]]) == [True]\n\tassert candidate(\"abccba\", [[0, 5, 1]]) == [True]\n\tassert candidate(\"abcde\", [[0, 4, 1]]) == [False]\n\tassert candidate(\"abccba\", [[0, 5, 2]]) == [True]\n\tassert candidate(\"abccba\", [[0, 5, 0]]) == [True]\n\tassert candidate(\"abccca\", [[0, 5, 0], [0, 5, 1], [0, 5, 2], [0, 5, 3]]) == [False, True, True, True]\n\tassert candidate(\"ab\", [[0, 0, 0]]) == [True]\n\tassert candidate(\"abcda\", [[3, 3, 0]]) == [True]\n\tassert candidate(\"abcda\", [[3, 3, 0], [1, 2, 0], [0, 3, 1], [0, 3, 2], [0, 4, 1]]) == [\n    True,\n    False,\n    False,\n    True,\n    True,\n]\n\tassert candidate(\"abcde\", [[0, 4, 2]]) == [True]\n\tassert candidate(\"abcda\", [[3, 3, 0], [1, 2, 0], [0, 3, 1], [0, 3, 2], [0, 4, 1]]) == [True, False, False, True, True]\n\tassert candidate(\"cc\", [[0, 1, 1]]) == [True]\n\tassert candidate(\"lyb\", [[0, 1, 0], [2, 2, 1]]) == [False, True]\n\tassert candidate(\"abccba\", [[0, 3, 1]]) == [True]\n\tassert candidate(\"abccca\", [[0, 5, 1]]) == [True]\n\tassert candidate(\"abcba\", [[1, 3, 1]]) == [True]\n\tassert candidate(\"abcba\", [[3, 4, 1]]) == [True]\n\tassert candidate(\"abcda\", [[0, 3, 1]]) == [False]\n\tassert candidate(\"abccca\", [[0, 5, 3]]) == [True]\n\tassert candidate(\"abcba\", [[0, 2, 2]]) == [True]\n\tassert candidate(\"abc\", [[0, 2, 1]]) == [True]\n\tassert candidate(\"lyb\", [[2, 2, 1]]) == [True]\n\tassert candidate(\"a\", [[0, 0, 2]]) == [True]\n\tassert candidate(\"lyb\", [[0, 1, 0]]) == [False]\n\tassert candidate(\"abcba\", [[0, 1, 0]]) == [False]\n\tassert candidate(\"abccba\", [[1, 4, 1]]) == [True]\ndef test_check():\n\tcheck(can_make_pali_queries)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,hash-table,string,bit-manipulation,prefix-sum\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 981, "filename": "LeetCode_981_removeDuplicates.py", "content": "def removeDuplicates(s: str, k: int) -> str:\n    \"\"\"\n    You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together.\n    We repeatedly make k duplicate removals on s until we no longer can.\n    Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.\n\u00a0\n    Example 1:\n\n    Input: s = \"abcd\", k = 2\n    Output: \"abcd\"\n    Explanation: There's nothing to delete.\n    Example 2:\n\n    Input: s = \"deeedbbcccbdaa\", k = 3\n    Output: \"aa\"\n    Explanation: \n    First delete \"eee\" and \"ccc\", get \"ddbbbdaa\"\n    Then delete \"bbb\", get \"dddaa\"\n    Finally delete \"ddd\", get \"aa\"\n    Example 3:\n\n    Input: s = \"pbbcggttciiippooaais\", k = 2\n    Output: \"ps\"\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 105\n    2 <= k <= 104\n    s only contains lowercase English letters.\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(s, str), \"Input s must be a string.\"\n    assert isinstance(k, int) and k >= 2, \"Input k must be an integer greater than or equal to 2.\"\n    assert 1 <= len(s) <= 10**5, \"Length of s must be between 1 and 100000.\"\n    assert all(c.islower() and c.isalpha() for c in s), \"s must consist of lowercase English letters.\"\n    assert 2 <= k <= 10**4, \"k must be between 2 and 10000.\"\n\n    stack = []\n    for c in s:\n        if stack and stack[-1][0] == c:\n            stack[-1][1] += 1\n            if stack[-1][1] == k:\n                stack.pop()\n        else:\n            stack.append([c, 1])\n    \n    result = ''.join(c * n for c, n in stack)\n    \n    # Postconditions\n    assert isinstance(result, str), \"Result must be a string.\"\n    assert all(result[i] != result[i + 1] or result[i: i + k] != result[i] * k for i in range(len(result) - 1)), \"Result must not contain k adjacent equal characters.\"\n    assert len(result) <= len(s), \"Length of the result must be less than or equal to the length of the input string.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"aaaabbbbccccdddd\", 4) == \"\"\n\tassert candidate(\"aaaabbbbccccddddeeeeffff\", 4) == \"\"\n\tassert candidate(\"abbaca\", 2) == \"ca\"\n\tassert candidate(\n    \"deeedbbcccbdaa\", 3) == \"aa\", \"Wrong answer for 'deeedbbcccbdaa'\"\n\tassert candidate(\n    \"deeedbbcccbdaa\", 3) == \"aa\", \"Should return 'aa'\"\n\tassert candidate(\n    \"pbbcggttciiippooaais\", 2) == \"ps\", \"Should be 'ps', since only the first 2 'b' and 2 't' are removed, leaving 'pbcgctciippooaais'.\"\n\tassert candidate(\"aabbaa\", 2) == \"\"\n\tassert candidate(\"aabbccddeeffgg\", 3) == \"aabbccddeeffgg\"\n\tassert candidate(\n    \"deeedbbcccbdaa\", 3) == \"aa\", \"Should be 'aa', since the first 3 'd' will be removed, leaving 'eedbbcccbdaa'.\"\n\tassert candidate(\n    \"pbbcggttciiippooaais\", 2) == \"ps\", \"Should return 'ps'\"\n\tassert candidate(\"pbbcggttciiippooaais\", 2) == \"ps\"\n\tassert candidate(\"yfttttfbbbbnnnnffbgffffgbbbbgssssgthyyyy\", 4) == \"ybth\"\n\tassert candidate(\"deeedbbcccbdaa\", 3) == \"aa\", \"Should return 'aa'\"\n\tassert candidate(\"pbbcggttciiippooaais\", 2) == \"ps\", \"Should return 'ps'\"\n\tassert candidate(\n    \"deeedbbcccbdaa\", 3) == \"aa\", \"deeedbbcccbdaa -> deeedbdaa -> deeda -> a\"\n\tassert candidate(\"aabbccddeeff\", 2) == \"\"\n\tassert candidate(\n    \"deeedbbcccbdaa\", 3) == \"aa\", \"Should remove 3 duplicate characters.\"\n\tassert candidate(\n    \"pbbcggttciiippooaais\", 2) == \"ps\", \"Should remove 2 duplicate characters.\"\n\tassert candidate(\"aabbcc\", 2) == \"\"\ndef test_check():\n\tcheck(removeDuplicates)\n# Metadata Difficulty: Medium\n# Metadata Topics: string,stack\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1126, "filename": "LeetCode_1126_get_happy_string.py", "content": "def get_happy_string(n: int, k: int) -> str:\n    \"\"\"\n    A happy string is a string that:\n\n    consists only of letters of the set ['a', 'b', 'c'].\n    s[i] != s[i + 1] for all values of i from 1 to s.length - 1 (string is 1-indexed).\n\n    For example, strings \"abc\", \"ac\", \"b\" and \"abcbabcbcb\" are all happy strings and strings \"aa\", \"baa\" and \"ababbc\" are not happy strings.\n    Given two integers n and k, consider a list of all happy strings of length n sorted in lexicographical order.\n    Return the kth string of this list or return an empty string if there are less than k happy strings of length n.\n\u00a0\n    Example 1:\n\n    Input: n = 1, k = 3\n    Output: \"c\"\n    Explanation: The list [\"a\", \"b\", \"c\"] contains all happy strings of length 1. The third string is \"c\".\n\n    Example 2:\n\n    Input: n = 1, k = 4\n    Output: \"\"\n    Explanation: There are only 3 happy strings of length 1.\n\n    Example 3:\n\n    Input: n = 3, k = 9\n    Output: \"cab\"\n    Explanation: There are 12 different happy string of length 3 [\"aba\", \"abc\", \"aca\", \"acb\", \"bab\", \"bac\", \"bca\", \"bcb\", \"cab\", \"cac\", \"cba\", \"cbc\"]. You will find the 9th string = \"cab\"\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 10\n    1 <= k <= 100\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(n, int) and 1 <= n <= 10, \"n must be an integer between 1 and 10.\"\n    assert isinstance(k, int) and 1 <= k <= 100, \"k must be an integer between 1 and 100.\"\n\n    def dfs(s, prev):\n        if len(s) == n:\n            happy_strings.append(s)\n            return\n        for c in 'abc':\n            if c != prev:\n                dfs(s + c, c)\n\n    happy_strings = []\n    dfs(\"\", ' ')\n    \n    result = happy_strings[k - 1] if k <= len(happy_strings) else \"\"\n\n    # Postconditions\n    assert isinstance(result, str), \"Result must be a string.\"\n    assert result == \"\" or len(result) == n, \"Result must be an empty string or a string of length n.\"\n    assert result == \"\" or all(result[i] != result[i + 1] for i in range(len(result) - 1)), \"The result must be a happy string (no two adjacent characters are the same).\"\n\n    return result\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(1, 10) == \"\"\n\tassert candidate(4, 4) == \"abcb\"\n\tassert candidate(2, 5) == \"ca\"\n\tassert candidate(3, 7) == \"bca\"\n\tassert candidate(3, 6) == \"bac\"\n\tassert candidate(3, 9) == \"cab\"\n\tassert candidate(2, 11) == \"\"\n\tassert candidate(3, 2) == \"abc\"\n\tassert candidate(2, 7) == \"\"\n\tassert candidate(1, 2) == \"b\"\n\tassert candidate(3, 11) == \"cba\"\n\tassert candidate(4, 7) == \"acba\"\n\tassert candidate(2, 3) == \"ba\"\n\tassert candidate(3, 8) == \"bcb\"\n\tassert candidate(2, 2) == \"ac\"\n\tassert candidate(4, 6) == \"acac\"\n\tassert candidate(1, 1) == \"a\"\n\tassert candidate(1, 7) == \"\"\n\tassert candidate(1, 6) == \"\"\n\tassert candidate(2, 6) == \"cb\"\n\tassert candidate(3, 3) == \"aca\"\n\tassert candidate(3, 12) == \"cbc\"\n\tassert candidate(2, 1) == \"ab\"\n\tassert candidate(1, 8) == \"\"\n\tassert candidate(4, 8) == \"acbc\"\n\tassert candidate(4, 1) == \"abab\"\n\tassert candidate(1, 3) == \"c\"\n\tassert candidate(4, 3) == \"abca\"\n\tassert candidate(3, 4) == \"acb\"\n\tassert candidate(1, 4) == \"\"\n\tassert candidate(3, 13) == \"\"\n\tassert candidate(3, 5) == \"bab\"\n\tassert candidate(4, 5) == \"acab\"\n\tassert candidate(2, 9) == \"\"\n\tassert candidate(2, 4) == \"bc\"\n\tassert candidate(4, 2) == \"abac\"\n\tassert candidate(3, 1) == \"aba\"\n\tassert candidate(2, 8) == \"\"\n\tassert candidate(2, 10) == \"\"\ndef test_check():\n\tcheck(get_happy_string)\n# Metadata Difficulty: Medium\n# Metadata Topics: string,backtracking\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1138, "filename": "LeetCode_1138_check_if_can_break.py", "content": "def check_if_can_break(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings: s1 and s2 with the same\u00a0size, check if some\u00a0permutation of string s1 can break\u00a0some\u00a0permutation of string s2 or vice-versa. In other words s2 can break s1\u00a0or vice-versa.\n    A string x\u00a0can break\u00a0string y\u00a0(both of size n) if x[i] >= y[i]\u00a0(in alphabetical order)\u00a0for all i\u00a0between 0 and n-1.\n\u00a0\n    Example 1:\n\n    Input: s1 = \"abc\", s2 = \"xya\"\n    Output: true\n    Explanation: \"ayx\" is a permutation of s2=\"xya\" which can break to string \"abc\" which is a permutation of s1=\"abc\".\n\n    Example 2:\n\n    Input: s1 = \"abe\", s2 = \"acd\"\n    Output: false \n    Explanation: All permutations for s1=\"abe\" are: \"abe\", \"aeb\", \"bae\", \"bea\", \"eab\" and \"eba\" and all permutation for s2=\"acd\" are: \"acd\", \"adc\", \"cad\", \"cda\", \"dac\" and \"dca\". However, there is not any permutation from s1 which can break some permutation from s2 and vice-versa.\n\n    Example 3:\n\n    Input: s1 = \"leetcodee\", s2 = \"interview\"\n    Output: true\n\n\u00a0\n    Constraints:\n\n    s1.length == n\n    s2.length == n\n    1 <= n <= 10^5\n    All strings consist of lowercase English letters.\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(s1, str) and isinstance(s2, str), \"Inputs must be strings.\"\n\n    s1 = sorted(s1)\n    s2 = sorted(s2)\n\n    can_break_1 = can_break_2 = True\n    for c1, c2 in zip(s1, s2):\n        if c1 < c2:\n            can_break_1 = False\n        if c2 < c1:\n            can_break_2 = False\n\n    result = can_break_1 or can_break_2\n\n    # Postconditions\n    assert isinstance(result, bool), \"The result must be a boolean value.\"\n    \n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"abcd\", \"efgh\") == True\n\tassert candidate(\"abcd\", \"dcba\") == True\n\tassert candidate(\"zxcvbnmasdfghjklqwertyuiop\", \"poiuytrewqlkjhgfdsamnbvcxz\") == True\n\tassert candidate(\"asdfghjkl\", \"lkjhgfdsa\") == True\n\tassert candidate(\"1111\", \"2222\") == True\n\tassert candidate(\"abcdefghij\", \"jihgfedcba\") == True\n\tassert candidate(\"c\", \"abc\") == True\n\tassert candidate(\"abc\", \"def\") == True\n\tassert candidate(\"pqrstuvwxy\", \"yxwvutsrqp\") == True\n\tassert candidate(\"zzzzzzzzzzzz\", \"aaaaaaaaaaaa\") == True\n\tassert candidate(\"xya\", \"abc\") == True\n\tassert candidate(\"lkjhgfdsaz\", \"zxcvbnm\") == False\n\tassert candidate(\"abd\", \"cba\") == True\n\tassert candidate(\"ab\", \"cd\") == True\n\tassert candidate(\"2134\", \"1234\") == True\n\tassert candidate(\"1234567890\", \"0987654321\") == True\n\tassert candidate(\"xzy\", \"abc\") == True\n\tassert candidate(\"abc\", \"aab\") == True\n\tassert candidate(\"poiuytrewqlkjhgfdsa\", \"qazwsxedcrfvtgbz\") == False\n\tassert candidate(\"mnbvcxz\", \"zxcvbnm\") == True\n\tassert candidate(\"1234\", \"4321\") == True\n\tassert candidate(\"bbb\", \"aaa\") == True\n\tassert candidate(\"abcdefghijklmn\", \"defghijklmn\") == True\n\tassert candidate(\"abc\", \"abcd\") == True\n\tassert candidate(\"mnbvcxzasdfghjkl\", \"lkjhgfdsazxcvbnm\") == True\n\tassert candidate(\"2222\", \"1111\") == True\n\tassert candidate(\"abcdef\", \"abcde\") == True\n\tassert candidate(\"abcde\", \"edcba\") == True\n\tassert candidate(\"zxcvbnm\", \"zxc\") == True\n\tassert candidate(\"ghi\", \"abc\") == True\n\tassert candidate(\"111111\", \"222222\") == True\n\tassert candidate(\"xyz\", \"abc\") == True\n\tassert candidate(\"poiuytrewq\", \"qwertyuiop\") == True\n\tassert candidate(\"12345\", \"abcde\") == True\n\tassert candidate(\"leetcodee\", \"interview\") == True\n\tassert candidate(\"qwe\", \"zxc\") == False\n\tassert candidate(\"a\", \"abc\") == True\n\tassert candidate(\"poiuytrewqlkjh\", \"zxcvbnmasdfghjkl\") == True\n\tassert candidate(\"qwerty\", \"ytrewq\") == True\n\tassert candidate(\"abe\", \"acd\") == False\n\tassert candidate(\"aa\", \"ab\") == True\n\tassert candidate(\"123\", \"321\") == True\n\tassert candidate(\"abcd\", \"cdba\") == True\n\tassert candidate(\"ab\", \"abcd\") == True\n\tassert candidate(\"poiuytrewqlkjhgfdsa\", \"mnbvcxzasdfghjkl\") == False\n\tassert candidate(\"zxcvbnm\", \"qwertyu\") == False\n\tassert candidate(\"asd\", \"123\") == True\n\tassert candidate(\"zxcvbnm\", \"lkjhgfdsaz\") == False\ndef test_check():\n\tcheck(check_if_can_break)\n# Metadata Difficulty: Medium\n# Metadata Topics: string,greedy,sorting\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1152, "filename": "LeetCode_1152_maxNonOverlapping.py", "content": "from typing import List\n\n\ndef maxNonOverlapping(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array nums and an integer target, return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to target.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,1,1,1,1], target = 2\n    Output: 2\n    Explanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2).\n\n    Example 2:\n\n    Input: nums = [-1,3,5,1,4,2,-9], target = 6\n    Output: 2\n    Explanation: There are 3 subarrays with sum equal to 6.\n    ([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping.\n\n\u00a0\n    Constraints:\n\n    0 <= nums.length <= 10^5\n    -10^4 <= nums[i] <= 10^4\n    0 <= target <= 10^6\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(nums, list) and all(isinstance(num, int) for num in nums), \"nums must be a list of integers.\"\n    assert isinstance(target, int), \"target must be an integer.\"\n    assert 0 <= len(nums) <= 10**5, \"The length of nums must be between 1 and 105.\"\n    assert all(-10**4 <= num <= 10**4 for num in nums), \"Each element in nums must be between -10^4 and 10^4.\"\n    assert 0 <= target <= 10**6, \"target must be between 0 and 10^6.\"\n\n    prefix_sum = {0: 0}\n    sum, count = 0, 0\n    for num in nums:\n        sum += num\n        if sum - target in prefix_sum:\n            count = max(count, 1 + prefix_sum[sum - target])\n        prefix_sum[sum] = count\n\n    # Postconditions\n    assert isinstance(count, int), \"The result must be an integer.\"\n    assert count >= 0, \"The result must be a non-negative integer.\"\n    \n    return count\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([5,-5,5,-5,5,-5,5,-5,5,-5], 10) == 0\n\tassert candidate([1,2,3,4,5,6,7,8,9,10,10,9,8,7,6,5,4,3,2,1], 30) == 2\n\tassert candidate([1,2,3,4,5,6,7,8,9,10], 55) == 1\n\tassert candidate([100,200,300,400,500], 1000) == 1\n\tassert candidate([0,0,0,0,0,0,0,0,0,0,0], 1) == 0\n\tassert candidate([1,2,3,4,5,6,7,8,9,10], 1) == 1\n\tassert candidate([-1,3,5,1,4,2,-9], 6) == 2\n\tassert candidate([5,-5,5,-5,5,-5,5,-5,5,-5], 0) == 5\n\tassert candidate([1,2,3,4,5,6,7,8,9,10,10,9,8,7,6,5,4,3,2,1], 20) == 3\n\tassert candidate([0,0,0,0,0,0,0,0,0,0,0], 5) == 0\n\tassert candidate([1,1,1,1,1,1,1,1,1,1,1], 0) == 0\n\tassert candidate([0,0,0,0,0,0,0,0,0,0,0], 0) == 11\n\tassert candidate([1,1,1,1,1], 2) == 2\n\tassert candidate([1,1,1,1,1,1,1,1,1,1,1], 2) == 5\n\tassert candidate([1,1,1,1,1,1,1,1,1,1,1], 100) == 0\n\tassert candidate([100,200,300,400,500], 500) == 2\ndef test_check():\n\tcheck(maxNonOverlapping)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,hash-table,greedy,prefix-sum\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1158, "filename": "LeetCode_1158_countTriplets.py", "content": "from typing import List\n\n\ndef countTriplets(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers arr.\n    We want to select three indices i, j and k where (0 <= i < j <= k < arr.length).\n    Let's define a and b as follows:\n\n    a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]\n    b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]\n\n    Note that ^ denotes the bitwise-xor operation.\n    Return the number of triplets (i, j and k) Where a == b.\n\u00a0\n    Example 1:\n\n    Input: arr = [2,3,1,6,7]\n    Output: 4\n    Explanation: The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)\n\n    Example 2:\n\n    Input: arr = [1,1,1,1,1]\n    Output: 10\n\n\u00a0\n    Constraints:\n\n    1 <= arr.length <= 300\n    1 <= arr[i] <= 108\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert all(isinstance(x, int) for x in arr), \"All elements in arr must be integers.\"\n    assert 1 <= len(arr) <= 300, \"The length of arr must be between 1 and 300.\"\n    assert all(1 <= x <= 10**8 for x in arr), \"Each element in arr must be between 1 and 10^8.\"\n    \n    n = len(arr)\n    XOR = [0] * (n + 1)\n\n    for i in range(n):\n        XOR[i+1] = XOR[i] ^ arr[i]\n\n    count = 0\n    for i in range(n):\n        for k in range(i+1, n):\n            if XOR[i] == XOR[k+1]:\n                count += k-i\n    \n    # Postconditions\n    assert isinstance(count, int), \"The result must be an integer.\"\n    assert count >= 0, \"The result must be a non-negative integer.\"\n    \n    return count\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([3, 3, 3, 3, 3]) == 10\n\tassert candidate([2, 2, 2, 2, 2]) == 10\n\tassert candidate(range(1, 10)) == 24\n\tassert candidate([1, 1, 1, 1]) == 6\n\tassert candidate([8, 8, 8, 8, 8]) == 10\n\tassert candidate(\n    [2, 3, 1, 6, 7]) == 4, \"Error in first example with unique array\"\n\tassert candidate(\n    [2, 3, 1, 6, 7]) == 4, \"This should work correctly on small lists.\"\n\tassert candidate([7, 7, 7, 7, 7]) == 10\n\tassert candidate([1, 1, 1, 1, 1]) == 10\n\tassert candidate([6, 6, 6, 6, 6]) == 10\n\tassert candidate([10, 10, 10, 10, 10]) == 10\n\tassert candidate([9, 9, 9, 9, 9]) == 10\n\tassert candidate([5, 5, 5, 5, 5]) == 10\ndef test_check():\n\tcheck(countTriplets)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,hash-table,math,bit-manipulation,prefix-sum\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1256, "filename": "LeetCode_1256_findLengthOfShortestSubarray.py", "content": "from typing import List\n\ndef findLengthOfShortestSubarray(arr: List[int]) -> int:\n    \"\"\"\n    Given an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing.\n    Return the length of the shortest subarray to remove.\n    A subarray is a contiguous subsequence of the array.\n    \"\"\"\n\n    # Preconditions\n    assert isinstance(arr, list), \"Input must be a list.\"\n    assert all(isinstance(x, int) for x in arr), \"All elements in the array must be integers.\"\n    assert 1 <= len(arr) <= 105, \"The length of the array must be between 1 and 105.\"\n    assert all(0 <= x <= 109 for x in arr), \"All elements in the array must be between 0 and 109.\"\n\n    n = len(arr)\n    left, right = 0, n - 1\n\n    while left < n - 1 and arr[left] <= arr[left + 1]:\n        left += 1\n\n    if left == n - 1:\n        return 0\n\n    while right > 0 and arr[right] >= arr[right - 1]:\n        right -= 1\n\n    result = min(right, n - left - 1)\n\n    i, j = 0, right\n\n    while i <= left and j < n:\n        if arr[i] <= arr[j]:\n            result = min(result, j - i - 1)\n            i += 1\n        else:\n            j += 1\n\n    # Postconditions\n    assert isinstance(result, int), \"The result should be an integer.\"\n    assert 0 <= result <= len(arr), \"The result must be a non-negative integer within the length of the array.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([5, 4, 3, 2, 1]) == 4, \"A subarray can be the entire array.\"\n\tassert candidate([1, 2, 3, 4, 5, 7, 6]) == 1\n\tassert candidate([1, 2, 3, 10, 4, 2, 3, 5]) == 3\n\tassert candidate([1, 1, 1, 1, 1, 1, 1]) == 0\n\tassert candidate([5, 4, 3, 2, 1]) == 4\n\tassert candidate(\n    [1, 2, 3, 10, 4, 2, 3, 5]) == 3, \"A subarray can be empty.\"\n\tassert candidate([1, 2, 3, 10, 4, 2, 3, 5, 6, 7]) == 3\n\tassert candidate(\n    [1, 2, 3, 10, 4, 2, 3, 5]) == 3, \"Error in case [1, 2, 3, 10, 4, 2, 3, 5]\"\n\tassert candidate([1, 2, 3, 4, 3, 5]) == 1\n\tassert candidate([1, 2, 3, 4, 5, 6, 6, 5, 4, 3, 2, 1]) == 5\n\tassert candidate([1, 2, 3]) == 0, \"The array is already non-decreasing.\"\n\tassert candidate([1, 2, 3]) == 0\n\tassert candidate([1, 10, 10, 2, 3, 4, 5, 6]) == 2\n\tassert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 8\n\tassert candidate([2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 0\ndef test_check():\n\tcheck(findLengthOfShortestSubarray)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,two-pointers,binary-search,stack,monotonic-stack\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1310, "filename": "LeetCode_1310_maxAbsoluteSum.py", "content": "from typing import List\n\n\ndef maxAbsoluteSum(nums: List[int]) -> int:\n    \"\"\"\n    You are given an integer array nums. The absolute sum of a subarray [numsl, numsl+1, ..., numsr-1, numsr] is abs(numsl + numsl+1 + ... + numsr-1 + numsr).\n    Return the maximum absolute sum of any (possibly empty) subarray of nums.\n    Note that abs(x) is defined as follows:\n\n    If x is a negative integer, then abs(x) = -x.\n    If x is a non-negative integer, then abs(x) = x.\n\n\u00a0\n    Example 1:\n\n    Input: nums = [1,-3,2,3,-4]\n    Output: 5\n    Explanation: The subarray [2,3] has absolute sum = abs(2+3) = abs(5) = 5.\n\n    Example 2:\n\n    Input: nums = [2,-5,1,-4,3,-2]\n    Output: 8\n    Explanation: The subarray [-5,1,-4] has absolute sum = abs(-5+1-4) = abs(-8) = 8.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    -104 <= nums[i] <= 104\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(nums, list), \"Input must be a list.\"\n    assert all(isinstance(x, int) for x in nums), \"All elements in the array must be integers.\"\n    assert 1 <= len(nums) <= 105, \"The length of the array must be between 1 and 105.\"\n    assert all(-104 <= x <= 104 for x in nums), \"All elements in the array must be between -104 and 104.\"\n\n    max_sum = max_end = min_sum = min_end = 0\n    for num in nums:\n        max_end = max(max_end + num, num)\n        min_end = min(min_end + num, num)\n        max_sum = max(max_sum, max_end)\n        min_sum = min(min_sum, min_end)\n    \n    result = max(max_sum, -min_sum)\n\n    # Postconditions\n    assert isinstance(result, int), \"The result should be an integer.\"\n    assert result >= 0, \"The result must be a non-negative integer.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1,1,1,1,1]) == 5\n\tassert candidate([1,0,-1]) == 1\n\tassert candidate([9,8,7,6,-10,5,4,3,2,1]) == 35\n\tassert candidate([2,-5,1,-4,3,-2]) == 8\n\tassert candidate([-1,0,1]) == 1\n\tassert candidate([1,-3,2,3,-4]) == 5\n\tassert candidate([1,2,3,4,-10,5,6,7,8,9]) == 35\n\tassert candidate([0,0,0,0,0]) == 0\n\tassert candidate([-10,20,-30,40,50]) == 90\n\tassert candidate([1,2,3,4,5]) == 15\ndef test_check():\n\tcheck(maxAbsoluteSum)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,dynamic-programming\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1321, "filename": "LeetCode_1321_count_vowel_strings.py", "content": "def count_vowel_strings(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n    A string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.\n\u00a0\n    Example 1:\n\n    Input: n = 1\n    Output: 5\n    Explanation: The 5 sorted strings that consist of vowels only are [\"a\",\"e\",\"i\",\"o\",\"u\"].\n\n    Example 2:\n\n    Input: n = 2\n    Output: 15\n    Explanation: The 15 sorted strings that consist of vowels only are\n    [\"aa\",\"ae\",\"ai\",\"ao\",\"au\",\"ee\",\"ei\",\"eo\",\"eu\",\"ii\",\"io\",\"iu\",\"oo\",\"ou\",\"uu\"].\n    Note that \"ea\" is not a valid string since 'e' comes after 'a' in the alphabet.\n\n    Example 3:\n\n    Input: n = 33\n    Output: 66045\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 50\u00a0\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(n, int), \"Input n must be an integer.\"\n    assert 1 <= n <= 50, \"Input n must be between 1 and 50 (inclusive).\"\n\n    dp = [1, 1, 1, 1, 1]\n\n    for i in range(1, n):\n        for j in range(3, -1, -1):\n            dp[j] += dp[j + 1]\n\n    result = sum(dp)\n\n    # Postconditions\n    assert isinstance(result, int), \"The result should be an integer.\"\n    assert result > 0, \"The result should be a positive integer.\"\n    assert isinstance(dp, list), \"dp should be a list.\"\n    assert len(dp) == 5, \"dp should have exactly 5 elements.\"\n    assert all(isinstance(x, int) and x > 0 for x in dp), \"All elements in dp should be positive integers.\"\n    assert all(dp[i] >= dp[i+1] for i in range(4)), \"dp should be non-increasing (i.e., dp[i] >= dp[i+1] for all i).\"\n    assert result == sum(dp), \"The result should equal the sum of elements in dp.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(16) == 4845\n\tassert candidate(9) == 715\n\tassert candidate(4) == 70\n\tassert candidate(26) == 27405\n\tassert candidate(18) == 7315\n\tassert candidate(2) == 15\n\tassert candidate(24) == 20475\n\tassert candidate(22) == 14950\n\tassert candidate(33) == 66045\n\tassert candidate(5) == 126\n\tassert candidate(7) == 330\n\tassert candidate(3) == 35\n\tassert candidate(28) == 35960\n\tassert candidate(17) == 5985\n\tassert candidate(15) == 3876\n\tassert candidate(12) == 1820\n\tassert candidate(21) == 12650\n\tassert candidate(25) == 23751\n\tassert candidate(27) == 31465\n\tassert candidate(23) == 17550\n\tassert candidate(1) == 5\n\tassert candidate(20) == 10626\n\tassert candidate(6) == 210\n\tassert candidate(8) == 495\n\tassert candidate(19) == 8855\n\tassert candidate(13) == 2380\n\tassert candidate(14) == 3060\ndef test_check():\n\tcheck(count_vowel_strings)\n# Metadata Difficulty: Medium\n# Metadata Topics: math,dynamic-programming,combinatorics\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1386, "filename": "LeetCode_1386_minimumHammingDistance.py", "content": "from typing import List\n\n\ndef minimumHammingDistance(source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n    \"\"\"\n    You are given two integer arrays, source and target, both of length n. You are also given an array allowedSwaps where each allowedSwaps[i] = [ai, bi] indicates that you are allowed to swap the elements at index ai and index bi (0-indexed) of array source. Note that you can swap elements at a specific pair of indices multiple times and in any order.\n    The Hamming distance of two arrays of the same length, source and target, is the number of positions where the elements are different. Formally, it is the number of indices i for 0 <= i <= n-1 where source[i] != target[i] (0-indexed).\n    Return the minimum Hamming distance of source and target after performing any amount of swap operations on array source.\n\u00a0\n    Example 1:\n\n    Input: source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]]\n    Output: 1\n    Explanation: source can be transformed the following way:\n    - Swap indices 0 and 1: source = [2,1,3,4]\n    - Swap indices 2 and 3: source = [2,1,4,3]\n    The Hamming distance of source and target is 1 as they differ in 1 position: index 3.\n\n    Example 2:\n\n    Input: source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = []\n    Output: 2\n    Explanation: There are no allowed swaps.\n    The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2.\n\n    Example 3:\n\n    Input: source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]]\n    Output: 0\n\n\u00a0\n    Constraints:\n\n    n == source.length == target.length\n    1 <= n <= 105\n    1 <= source[i], target[i] <= 105\n    0 <= allowedSwaps.length <= 105\n    allowedSwaps[i].length == 2\n    0 <= ai, bi <= n - 1\n    ai != bi\n\n    \"\"\"\n    ### Canonical solution below ###\n    from collections import defaultdict\n\n    # Preconditions\n    assert isinstance(source, list) and isinstance(target, list), \"Source and target must be lists.\"\n    assert isinstance(allowedSwaps, list), \"AllowedSwaps must be a list.\"\n    assert len(source) == len(target), \"Source and target must have the same length.\"\n    assert all(isinstance(x, int) for x in source), \"All elements in source must be integers.\"\n    assert all(isinstance(x, int) for x in target), \"All elements in target must be integers.\"\n    assert all(1 <= x <= 10**5 for x in source), \"All elements in source must be between 1 and 10^5.\"\n    assert all(1 <= x <= 10**5 for x in target), \"All elements in target must be between 1 and 10^5.\"\n    assert all(isinstance(pair, list) and len(pair) == 2 for pair in allowedSwaps), \"Each element of allowedSwaps must be a list of two integers.\"\n    n = len(source)\n    assert 1 <= n <= 10**5, \"The length of source and target must be between 1 and 10^5.\"\n    for a, b in allowedSwaps:\n        assert 0 <= a < n and 0 <= b < n, \"Swap indices must be within valid range.\"\n        assert a != b, \"Swap indices in allowedSwaps must be different.\"\n    \n    def dfs(node, visited, graph, group):\n        if visited[node]:\n            return\n        visited[node] = 1\n        group.append(node)\n        for neighbor in graph[node]:\n            dfs(neighbor, visited, graph, group)\n    \n    graph = defaultdict(list)\n    for a, b in allowedSwaps:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    res = 0\n    visited = [0] * n\n    for i in range(n):\n        if not visited[i]:\n            group = []\n            dfs(i, visited, graph, group)\n            count = defaultdict(int)\n\n            for node in group:\n                count[source[node]] += 1\n            for node in group:\n                if count[target[node]] > 0:\n                    res += 1\n                    count[target[node]] -= 1\n\n    result = n - res\n\n    # Postconditions\n    assert isinstance(result, int), \"The result must be an integer.\"\n    assert 0 <= result <= n, \"The result must be between 0 and the length of source.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\n    [1, 2, 3, 4, 5], [5, 4, 3, 2, 1], []) == 4\n\tassert candidate([1, 2, 3, 4], [1, 2, 3, 4], []) == 0\n\tassert candidate(\n    [5, 1, 2, 4, 3], [1, 5, 4, 2, 3], [[0, 4], [4, 2], [1, 3], [1, 4]]) == 0\n\tassert candidate([1, 2, 3, 4], [2, 1, 4, 3], []) == 4\n\tassert candidate(\n    [1, 2, 3, 4], [2, 1, 4, 3], []) == 4\n\tassert candidate([1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [[0, 1]]) == 4\ndef test_check():\n\tcheck(minimumHammingDistance)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,depth-first-search,union-find\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1481, "filename": "LeetCode_1481_checkMove.py", "content": "from typing import List\n\n\ndef checkMove(board: List[List[str]], rMove: int, cMove: int, color: str) -> bool:\n    \"\"\"\n    You are given a 0-indexed 8 x 8 grid board, where board[r][c] represents the cell (r, c) on a game board. On the board, free cells are represented by '.', white cells are represented by 'W', and black cells are represented by 'B'.\n    Each move in this game consists of choosing a free cell and changing it to the color you are playing as (either white or black). However, a move is only legal if, after changing it, the cell becomes the endpoint of a good line (horizontal, vertical, or diagonal).\n    A good line is a line of three or more cells (including the endpoints) where the endpoints of the line are one color, and the remaining cells in the middle are the opposite color (no cells in the line are free). You can find examples for good lines in the figure below:\n\n    Given two integers rMove and cMove and a character color representing the color you are playing as (white or black), return true if changing cell (rMove, cMove) to color color is a legal move, or false if it is not legal.\n\u00a0\n    Example 1:\n\n\n    Input: board = [[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\"W\",\"B\",\"B\",\".\",\"W\",\"W\",\"W\",\"B\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"]], rMove = 4, cMove = 3, color = \"B\"\n    Output: true\n    Explanation: '.', 'W', and 'B' are represented by the colors blue, white, and black respectively, and cell (rMove, cMove) is marked with an 'X'.\n    The two good lines with the chosen cell as an endpoint are annotated above with the red rectangles.\n\n    Example 2:\n\n\n    Input: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"B\",\".\",\".\",\"W\",\".\",\".\",\".\"],[\".\",\".\",\"W\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\"B\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"B\",\"W\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"W\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"B\"]], rMove = 4, cMove = 4, color = \"W\"\n    Output: false\n    Explanation: While there are good lines with the chosen cell as a middle cell, there are no good lines with the chosen cell as an endpoint.\n\n\u00a0\n    Constraints:\n\n    board.length == board[r].length == 8\n    0 <= rMove, cMove < 8\n    board[rMove][cMove] == '.'\n    color is either 'B' or 'W'.\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(rMove, int) and 0 <= rMove < 8, \"rMove must be an integer between 0 and 7.\"\n    assert isinstance(cMove, int) and 0 <= cMove < 8, \"cMove must be an integer between 0 and 7.\"\n    assert color in {'W', 'B'}, \"Color must be 'W' or 'B'.\"\n    \n    directions = ((-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1))\n    opposite_color = 'B' if color == 'W' else 'W'\n\n    for d in directions:\n        x, y = rMove + d[0], cMove + d[1]\n        count = 0\n        while 0 <= x < 8 and 0 <= y < 8 and board[x][y] == opposite_color:\n            x += d[0]\n            y += d[1]\n            count += 1\n\n        if count > 0 and 0 <= x < 8 and 0 <= y < 8 and board[x][y] == color:\n            return True\n\n    return False\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([\n    [\"B\", \"W\", \"W\", \"W\", \"B\", \"W\", \"W\", \"B\"],\n    [\"W\", \"B\", \"W\", \"B\", \"W\", \"B\", \"W\", \"B\"],\n    [\"B\", \"W\", \"B\", \"W\", \"B\", \"W\", \"W\", \"W\"],\n    [\"W\", \"B\", \"W\", \"B\", \"W\", \"B\", \"W\", \"B\"],\n    [\"W\", \"W\", \"W\", \"B\", \"W\", \"W\", \"W\", \"W\"],\n    [\"W\", \"B\", \"B\", \"B\", \"B\", \"B\", \"W\", \"W\"],\n    [\"W\", \"B\", \"W\", \"W\", \"W\", \"W\", \"W\", \"B\"],\n    [\"W\", \"B\", \"W\", \"B\", \"B\", \"B\", \"B\", \"W\"],\n], 4, 4, \"B\") == True\n\tassert candidate([\n    [\"B\", \"W\", \"W\", \"W\", \"W\", \"W\", \"W\", \"B\"],\n    [\"W\", \"B\", \"W\", \"B\", \"B\", \"W\", \"B\", \"B\"],\n    [\"B\", \"W\", \"B\", \"W\", \"W\", \"B\", \"W\", \"W\"],\n    [\"W\", \"W\", \"W\", \"B\", \"W\", \"B\", \"W\", \"B\"],\n    [\"W\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\"],\n    [\"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\"],\n    [\"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\"],\n    [\"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\"]\n], 2, 3, \"B\") == True\n\tassert candidate([\n    [\".\", \".\", \".\", \"B\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \"W\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \"W\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \"W\", \".\", \".\", \".\", \".\"],\n    [\"W\", \"B\", \"B\", \".\", \"W\", \"W\", \"W\", \"B\"],\n    [\".\", \".\", \".\", \"B\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \"B\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \"W\", \".\", \".\", \".\", \".\"]\n], 4, 3, \"B\") == True\n\tassert candidate(\n[\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \"B\", \".\", \".\", \"W\", \".\", \".\", \".\"],\n    [\".\", \".\", \"W\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \"W\", \"B\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \"B\", \"W\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \"W\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \"B\"]\n], 4, 4, \"W\") == False\n\tassert candidate([\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n], 4, 4, \"B\") == False\n\tassert candidate([\n    [\"W\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"W\"],\n    [\"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\"],\n    [\"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\"],\n    [\"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\"],\n    [\"B\", \"B\", \"B\", \"W\", \"W\", \"W\", \"B\", \"B\"],\n    [\"B\", \"B\", \"B\", \"W\", \"B\", \"W\", \"B\", \"B\"],\n    [\"B\", \"B\", \"B\", \"W\", \"W\", \"B\", \"B\", \"B\"],\n    [\"W\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"W\"]\n], 4, 4, \"W\") == True\n\tassert candidate([\n  [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n  [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n  [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n  [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n  [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n  [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n  [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n  [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\n], 4, 3, \"B\") == False\n\tassert candidate([\n  [\"B\", \"W\", \"W\", \"B\", \"W\", \"W\", \"W\", \"B\"],\n  [\"W\", \"B\", \"W\", \"B\", \"B\", \"W\", \"B\", \"W\"],\n  [\"B\", \"B\", \"B\", \"B\", \"W\", \"B\", \"W\", \"W\"],\n  [\"W\", \"W\", \"B\", \"W\", \"B\", \"W\", \"W\", \"W\"],\n  [\"W\", \"W\", \"B\", \"B\", \"B\", \"B\", \"W\", \"B\"],\n  [\"W\", \"W\", \"W\", \"W\", \"W\", \"W\", \"B\", \"W\"],\n  [\"W\", \"W\", \"W\", \"B\", \"W\", \"B\", \"W\", \"W\"],\n  [\"B\", \"B\", \"W\", \"W\", \"W\", \"B\", \"B\", \"B\"]\n], 3, 4, \"W\") == True\n\tassert candidate([\n    [\"B\", \"B\", \"B\", \"B\", \"B\"],\n    [\"B\", \"B\", \"B\", \"B\", \"B\"],\n    [\"B\", \"B\", \"B\", \"B\", \"B\"],\n    [\"B\", \"B\", \"B\", \"B\", \"B\"],\n    [\"B\", \"B\", \"B\", \"B\", \"B\"],\n], 0, 2, \"B\") == False\n\tassert candidate([\n    [\"B\", \".\", \".\"],\n    [\"W\", \"W\", \".\"],\n    [\".\", \"W\", \".\"],\n], 0, 0, \"B\") == False\ndef test_check():\n\tcheck(checkMove)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,matrix,enumeration\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1545, "filename": "LeetCode_1545_maxAlternatingSum.py", "content": "from typing import List\n\n\ndef maxAlternatingSum(nums: List[int]) -> int:\n    \"\"\"\n    The alternating sum of a 0-indexed array is defined as the sum of the elements at even indices minus the sum of the elements at odd indices.\n\n    For example, the alternating sum of [4,2,5,3] is (4 + 5) - (2 + 3) = 4.\n\n    Given an array nums, return the maximum alternating sum of any subsequence of nums (after reindexing the elements of the subsequence).\n\n\n    A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not.\n\u00a0\n    Example 1:\n\n    Input: nums = [4,2,5,3]\n    Output: 7\n    Explanation: It is optimal to choose the subsequence [4,2,5] with alternating sum (4 + 5) - 2 = 7.\n\n    Example 2:\n\n    Input: nums = [5,6,7,8]\n    Output: 8\n    Explanation: It is optimal to choose the subsequence [8] with alternating sum 8.\n\n    Example 3:\n\n    Input: nums = [6,2,1,2,4,5]\n    Output: 10\n    Explanation: It is optimal to choose the subsequence [6,1,5] with alternating sum (6 + 5) - 1 = 10.\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    1 <= nums[i] <= 105\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(nums, list), \"nums should be a list\"\n    assert all(isinstance(num, int) for num in nums), \"All elements in nums should be integers\"\n    assert 0 <= len(nums) <= 10**5, \"Length of nums should be between 1 and 105\"\n\n    odd, even = 0, 0\n    for num in nums:\n        newOdd = max(even + num, odd)\n        even = max(odd - num, even)\n        odd = newOdd\n\n    result = odd\n    \n    # Postconditions\n    assert isinstance(result, int), \"The result should be an integer\"\n    \n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1]) == 1\n\tassert candidate([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]) == 1\n\tassert candidate([4,2,5,3]) == 7\n\tassert candidate([0,0,0,0,0,0,0,0,0,0]) == 0\n\tassert candidate([2,2,2,2,2]) == 2\n\tassert candidate([5,6,7,8]) == 8\n\tassert candidate([10,8,5,3,2]) == 10\n\tassert candidate([1,1,1,1,1]) == 1\n\tassert candidate(\n    [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]) == 100\n\tassert candidate([5,4,3,2,1]) == 5\n\tassert candidate([1,0,-1,0,1,0,-1,0,1,0]) == 5\n\tassert candidate([4, 2, 5, 3]) == 7\n\tassert candidate([6,2,1,2,4,5]) == 10\n\tassert candidate([50,40,30,20,10]) == 50\n\tassert candidate([0]) == 0\n\tassert candidate([5, 6, 7, 8]) == 8\n\tassert candidate([10,20,30,40,50]) == 50\n\tassert candidate([1,2,3,4,5]) == 5\n\tassert candidate([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]) == 20\n\tassert candidate([6, 2, 1, 2, 4, 5]) == 10\n\tassert candidate([10,30,50,20,10]) == 50\n\tassert candidate(\n    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]) == 20\ndef test_check():\n\tcheck(maxAlternatingSum)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,dynamic-programming\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1939, "filename": "LeetCode_1939_longest_square_streak.py", "content": "from typing import List\n\n\ndef longest_square_streak(nums: List[int]) -> int:\n    \"\"\"\n    You are given an integer array nums. A subsequence of nums is called a square streak if:\n\n    The length of the subsequence is at least 2, and\n    after sorting the subsequence, each element (except the first element) is the square of the previous number.\n\n    Return the length of the longest square streak in nums, or return -1 if there is no square streak.\n    A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n\u00a0\n    Example 1:\n\n    Input: nums = [4,3,6,16,8,2]\n    Output: 3\n    Explanation: Choose the subsequence [4,16,2]. After sorting it, it becomes [2,4,16].\n    - 4 = 2 * 2.\n    - 16 = 4 * 4.\n    Therefore, [4,16,2] is a square streak.\n    It can be shown that every subsequence of length 4 is not a square streak.\n\n    Example 2:\n\n    Input: nums = [2,3,5,6,7]\n    Output: -1\n    Explanation: There is no square streak in nums so return -1.\n\n\u00a0\n    Constraints:\n\n    2 <= nums.length <= 105\n    2 <= nums[i] <= 105\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(nums, list), \"nums should be a list\"\n    assert all(isinstance(num, int) for num in nums), \"All elements in nums should be integers\"\n    assert all(0 <= num <= 10**5 for num in nums), \"All elements in nums should be between 2 and 105\"\n\n    num_set = set(nums)\n    longest_streak = -1\n\n    for num in num_set:\n        streak = 1\n        while int(num ** 0.5) in num_set:\n            streak += 1\n            num = int(num ** 0.5)\n\n        longest_streak = max(longest_streak, streak)\n\n    result = longest_streak if longest_streak >= 2 else -1\n    \n    # Postconditions\n    assert isinstance(result, int), \"The result should be an integer\"\n    if result != -1:\n        assert result >= 2, \"If a streak exists, its length should be at least 2\"\n    else:\n        assert result == -1, \"If no valid streak exists, the result should be -1\"\n    \n    return result\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([4, 3, 16, 8, 2]) == 3\n\tassert candidate([]) == -1\n\tassert candidate([4, 3, 6, 16, 8, 2]) == 3\n\tassert candidate([3,4,5,6,]) == -1\n\tassert candidate([3,4,5,6,7]) == -1\n\tassert candidate([4,3,6,16,8,2]) == 3\n\tassert candidate([2,7,49,343,2401]) == 4\ndef test_check():\n\tcheck(longest_square_streak)\n# Metadata Difficulty: Medium\n# Metadata Topics: array,hash-table,binary-search,dynamic-programming,sorting\n# Metadata Coverage: 100\n\n\ntest_check()\n"}

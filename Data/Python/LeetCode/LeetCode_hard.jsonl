{"id": 36, "filename": "LeetCode_36_trap.py", "content": "from typing import List\n\n\ndef trap(height: List[int]) -> int:\n    \"\"\"\n    Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n\u00a0\n    Example 1:\n\n\n    Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\n    Output: 6\n    Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\n    Example 2:\n\n    Input: height = [4,2,0,3,2,5]\n    Output: 9\n\n\u00a0\n    Constraints:\n\n    n == height.length\n    1 <= n <= 2 * 104\n    0 <= height[i] <= 105\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(height, list), \"height should be a list\"\n    assert all(isinstance(h, int) for h in height), \"All elements in height should be integers\"\n    assert len(height) >= 1, \"height should contain at least one element\"\n    assert all(0 <= h <= 105 for h in height), \"All elements in height should be between 0 and 105\"\n    assert len(height) <= 20000, \"The length of height should be at most 20000\"\n    \n    n = len(height)\n    left, right, max_left, max_right, water = 0, n - 1, 0, 0, 0\n\n    while left < right:\n        if height[left] <= height[right]:\n            max_left = max(max_left, height[left])\n            water += max_left - height[left]\n            left += 1\n        else:\n            max_right = max(max_right, height[right])\n            water += max_right - height[right]\n            right -= 1\n\n    # Postconditions\n    assert isinstance(water, int), \"The result should be an integer\"\n    assert water >= 0, \"The trapped water should be non-negative\"\n    assert water == 0 if all(h == height[0] for h in height) else True, \"If all heights are the same, no water should be trapped\"\n    assert water == 0 if len(height) <= 2 else True, \"If there are fewer than 3 elements, no water can be trapped\"\n    assert len(height) >= 1, \"There should be at least one height value to process\"\n    assert isinstance(height[0], int), \"The height values should remain as integers\"\n    \n    return water\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1, 0, 1, 0, 1]) == 2\n\tassert candidate([6,5,4,3,2,1,2,3,4,5,6]) == 25\n\tassert candidate([1,2,3,4,5,0,5,4,3,2,1]) == 5\n\tassert candidate([3,0,2,0,4]) == 7\n\tassert candidate([1,0,1]) == 1\n\tassert candidate([2,10,8,7,6,5]) == 0\n\tassert candidate([5,2,1,2,1,5]) == 14\n\tassert candidate([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1, 0]) == 6\n\tassert candidate([0,0,0,0,0,0]) == 0\n\tassert candidate([2,0,1]) == 1\n\tassert candidate([4,2,0,3,2,5]) == 9\n\tassert candidate([1,2,3,2,1]) == 0\n\tassert candidate([1,0,1,0,1]) == 2\n\tassert candidate([0,0,0,0,0]) == 0\n\tassert candidate([1,0,2]) == 1\n\tassert candidate([2, 0, 2]) == 2\n\tassert candidate([3, 0, 2]) == 2\n\tassert candidate([3,0,0,0,0]) == 0\n\tassert candidate([2,0,2]) == 2\n\tassert candidate([4, 2, 3]) == 1\n\tassert candidate([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6\n\tassert candidate([1, 0, 1]) == 1\n\tassert candidate([0,1,0,2,1,0,1,3,2,1,2,1,0]) == 6\n\tassert candidate([0,2,0]) == 0\n\tassert candidate([0,1,0,2,1,0,1,3,2,1,2,1]) == 6\n\tassert candidate([2,1,0,2,1,0,1,3,2,1,2,1]) == 8\n\tassert candidate([1, 1]) == 0\n\tassert candidate([1, 2, 3, 4]) == 0\n\tassert candidate([1,1]) == 0\n\tassert candidate([0, 2, 1, 2, 3, 4]) == 1\n\tassert candidate([1,2,3,4,5,6,5,4,3,2,1]) == 0\n\tassert candidate([5,4,1,2]) == 1\n\tassert candidate([1,0,3,0,1]) == 2\n\tassert candidate([3,0,1,3,0,5]) == 8\ndef test_check():\n\tcheck(trap)\n     \ntest_check()\n# Metadata Difficulty: Hard\n# Metadata Topics: array,two-pointers,dynamic-programming,stack,monotonic-stack\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 75, "filename": "LeetCode_75_largestRectangleArea.py", "content": "from typing import List\n\n\ndef largestRectangleArea(heights: List[int]) -> int:\n    \"\"\"\n    Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\n\u00a0\n    Example 1:\n\n\n    Input: heights = [2,1,5,6,2,3]\n    Output: 10\n    Explanation: The above is a histogram where width of each bar is 1.\n    The largest rectangle is shown in the red area, which has an area = 10 units.\n\n    Example 2:\n\n\n    Input: heights = [2,4]\n    Output: 4\n\n\u00a0\n    Constraints:\n\n    1 <= heights.length <= 10^5\n    0 <= heights[i] <= 10^4\n\n    \"\"\"\n    ### Canonical solution below ###\n    ### Preconditions ###\n    assert isinstance(heights, list), \"heights should be a list\"\n    assert all(isinstance(h, int) for h in heights), \"All elements in heights should be integers\"\n    assert 1 <= len(heights) <= 10**5, \"The length of heights should be between 1 and 105\"\n    assert all(0 <= h <= 10**4 for h in heights), \"All elements in heights should be between 0 and 104\"\n    assert len(heights) > 0, \"The heights list should not be empty\"\n\n    stack = []\n    max_area = 0\n    for i, h in enumerate(heights + [0]):\n        while stack and heights[stack[-1]] > h:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n    \n    ### Postconditions ###\n    assert isinstance(max_area, int), \"The result should be an integer\"\n    assert max_area >= 0, \"The area of the largest rectangle should be non-negative\"\n    assert max_area <= 104 * len(heights), \"The maximum possible area should not exceed the product of the maximum height and the number of bars\"\n    assert max_area == 0 if all(h == 0 for h in heights) else True, \"If all heights are zero, the area should be zero\"\n    assert max_area > 0 if len(heights) > 0 and any(h > 0 for h in heights) else True, \"The area should be greater than zero if there's at least one non-zero height\"\n    assert isinstance(heights, list), \"The heights should remain as a list after processing\"\n    assert all(isinstance(h, int) for h in heights), \"The heights elements should remain integers after processing\"\n    \n    return max_area\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([2, 2, 2, 2]) == 8\n\tassert candidate([0]*105) == 0\n\tassert candidate([1, 3, 2, 1, 2]) == 5\n\tassert candidate([4, 2]) == 4\n\tassert candidate([1,3,2,1,2]) == 5\n\tassert candidate([0, 2, 2, 2, 0]) == 6\n\tassert candidate([2]*53) == 106\n\tassert candidate([0]*51 + [1, 1] + [0]*52) == 2\n\tassert candidate([2]*52 + [1] + [2]*52 + [0]*105) == 105\n\tassert candidate([1]*105) == 105\n\tassert candidate([0,1,0,1,0]) == 1\n\tassert candidate([0]*50 + [1, 1, 1] + [0]*52) == 3\n\tassert candidate([2,3,4,5,6]) == 12\n\tassert candidate([2, 2, 1, 1]) == 4\n\tassert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 20\n\tassert candidate([2]*52 + [1] + [2]*52) == 105\n\tassert candidate([104]*105) == 10920\n\tassert candidate([6,5,4,3,2]) == 12\n\tassert candidate([0,0,0,1,0,0,0]) == 1\n\tassert candidate([1]*105 + [0]*105) == 105\n\tassert candidate([2,4]) == 4\n\tassert candidate([1]) == 1\n\tassert candidate([3,1,3,2,2]) == 6\n\tassert candidate([1, 2, 1, 2, 1, 2, 1, 2, 1, 2]) == 10\n\tassert candidate([0]*105 + [2]*52 + [1] + [2]*52 + [0]*105 + [5, 4, 3, 2]) == 105\n\tassert candidate([0]*52 + [1] + [0]*52) == 1\n\tassert candidate([0]*105 + [2]*52 + [1] + [2]*52 + [0]*105) == 105\n\tassert candidate([4, 2, 0, 3, 2, 5]) == 6\n\tassert candidate([1,1,1,1]) == 4\n\tassert candidate([1,2,2,3,1]) == 6\n\tassert candidate([2,1,5,6,2,3]) == 10\ndef test_check():\n\tcheck(largestRectangleArea)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,stack,monotonic-stack\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 91, "filename": "LeetCode_91_numDistinct.py", "content": "def numDistinct(s: str, t: str) -> int:\n    \"\"\"\n    Given two strings s and t, return the number of distinct subsequences of s which equals t\u00a0modulo\u00a0109\u2009+\u20097.\n\u00a0\n    Example 1:\n\n    Input: s = \"rabbbit\", t = \"rabbit\"\n    Output: 3\n    Explanation:\n    As shown below, there are 3 ways you can generate \"rabbit\" from s.\n    rabbbit\n    rabbbit\n    rabbbit\n\n    Example 2:\n\n    Input: s = \"babgbag\", t = \"bag\"\n    Output: 5\n    Explanation:\n    As shown below, there are 5 ways you can generate \"bag\" from s.\n    babgbag\n    babgbag\n    babgbag\n    babgbag\n    babgbag\n\u00a0\n    Constraints:\n\n    0 <= s.length, t.length <= 1000\n    s and t consist of English letters.\n\n    \"\"\"\n    ### Canonical solution below ###\n    ### Preconditions ###\n    assert isinstance(s, str), \"s should be a string\"\n    assert isinstance(t, str), \"t should be a string\"\n    assert 0 <= len(s) <= 1000, \"Length of s should be between 1 and 1000\"\n    assert 0 <= len(t) <= 1000, \"Length of t should be between 1 and 1000\"\n    assert all(c.isalpha() for c in s), \"s should only contain English letters\"\n    assert all(c.isalpha() for c in t), \"t should only contain English letters\"\n\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    result = dp[m][n]\n\n    ### Postconditions ###\n    assert isinstance(result, int), \"The result should be an integer\"\n    assert result >= 0, \"The number of distinct subsequences cannot be negative\"\n    assert result == 0 if len(s) < len(t) else True, \"If s is shorter than t, result should be 0\"\n    assert result <= (2 ** len(s)) if t == \"\" else True, \"The result should be at most 2^len(s) if t is empty\"\n    assert result == 1 if t == \"\" else True, \"If t is an empty string, the result should be 1\"\n    assert isinstance(s, str), \"s should remain a string after processing\"\n    assert isinstance(t, str), \"t should remain a string after processing\"\n    assert all(isinstance(c, str) for c in s), \"The characters in s should remain as strings after processing\"\n    assert all(isinstance(c, str) for c in t), \"The characters in t should remain as strings after processing\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\n    \"abc\", \"abcabc\") == 0\n\tassert candidate(\n    \"xyz\", \"xy\") == 1\n\tassert candidate(\n    \"xyz\", \"x\") == 1\n\tassert candidate(\"xyz\", \"yz\") == 1\n\tassert candidate(\"xyz\", \"x\") == 1\n\tassert candidate(\"xyz\", \"y\") == 1\n\tassert candidate(\"abcabc\", \"ab\") == 3\n\tassert candidate(\"abcabc\", \"bc\") == 3\n\tassert candidate(\n    \"rabbbit\", \"rabbit\") == 3\n\tassert candidate(\"aaaaaa\", \"aa\") == 15\n\tassert candidate(\"abcabcabcabcabcabc\", \"abcabcabcabcabcabc\") == 1\n\tassert candidate(\"xyz\", \"xy\") == 1\n\tassert candidate(\n    \"\", \"\") == 1\n\tassert candidate(\"xyz\", \"xz\") == 1\n\tassert candidate(\"a\", \"\") == 1\n\tassert candidate(\n    \"abcabc\", \"abcabca\") == 0\n\tassert candidate(\n    \"xyz\", \"w\") == 0\n\tassert candidate(\n    \"xyz\", \"y\") == 1\n\tassert candidate(\n    \"xyz\", \"xyz\") == 1\n\tassert candidate(\"abcabcabcabcabcabc\", \"abcabcabcabcabcabca\") == 0\n\tassert candidate(\n    \"babgbag\", \"bag\") == 5\n\tassert candidate(\n    \"abcabcabcabcabcabc\", \"a\") == 6\n\tassert candidate(\n    \"abcabcabcabcabcabc\", \"abcabcabcabcabcabc\") == 1\n\tassert candidate(\n    \"xyz\", \"z\") == 1\n\tassert candidate(\"abcabc\", \"abcabc\") == 1\n\tassert candidate(\"abcde\", \"ace\") == 1\n\tassert candidate(\n    \"a\", \"\") == 1\n\tassert candidate(\"abcabcabcabcabcabc\", \"a\") == 6\n\tassert candidate(\"abcabc\", \"abcabca\") == 0\n\tassert candidate(\n    \"abcabcabcabcabcabc\", \"abcabcabcabcabcabca\") == 0\n\tassert candidate(\"xyz\", \"w\") == 0\n\tassert candidate(\n    \"xyz\", \"xz\") == 1\n\tassert candidate(\n    \"abcabc\", \"bc\") == 3\n\tassert candidate(\"abcabc\", \"b\") == 2\n\tassert candidate(\"xyz\", \"z\") == 1\n\tassert candidate(\"babgbag\", \"bag\") == 5\n\tassert candidate(\n    \"abcabc\", \"a\") == 2\n\tassert candidate(\"abcabc\", \"c\") == 2\n\tassert candidate(\"\", \"\") == 1\n\tassert candidate(\n    \"abcde\", \"ace\") == 1\n\tassert candidate(\"abcabc\", \"a\") == 2\n\tassert candidate(\"rabbbit\", \"rabbit\") == 3\n\tassert candidate(\"xyz\", \"xyz\") == 1\n\tassert candidate(\"abc\", \"abcabc\") == 0\ndef test_check():\n\tcheck(numDistinct)\n# Metadata Difficulty: Hard\n# Metadata Topics: string,dynamic-programming\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 150, "filename": "LeetCode_150_findWords.py", "content": "from typing import List\n\n\ndef findWords(board: List[List[str]], words: List[str]) -> List[str]:\n    \"\"\"\n    Given an m x n board\u00a0of characters and a list of strings words, return all words on the board.\n    Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\u00a0\n    Example 1:\n\n\n    Input: board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n    Output: [\"eat\",\"oath\"]\n\n    Example 2:\n\n\n    Input: board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\n    Output: []\n\n\u00a0\n    Constraints:\n\n    m == board.length\n    n == board[i].length\n    1 <= m, n <= 12\n    board[i][j] is a lowercase English letter.\n    1 <= words.length <= 3 * 104\n    1 <= words[i].length <= 10\n    words[i] consists of lowercase English letters.\n    All the strings of words are unique.\n\n    \"\"\"\n    ### Canonical solution below ###\n    ### Preconditions ###\n    assert isinstance(board, list) and all(isinstance(row, list) for row in board), \"board must be a list of lists\"\n    assert all(isinstance(cell, str) and len(cell) == 1 and cell.islower() for row in board for cell in row), \"Each cell in the board must be a single lowercase English letter\"\n    assert 1 <= len(board) <= 12 and 1 <= len(board[0]) <= 12, \"Board dimensions must be between 1 and 12\"\n    assert isinstance(words, list) and all(isinstance(word, str) for word in words), \"words must be a list of strings\"\n    assert all(1 <= len(word) <= 10 for word in words), \"Each word in words must have a length between 1 and 10\"\n    assert len(set(words)) == len(words), \"All words must be unique\"\n\n    def dfs(board, word, index, i, j, visited):\n        if index == len(word):\n            return True\n        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or visited[i][j] or board[i][j] != word[index]:\n            return False\n        visited[i][j] = True\n        found = dfs(board, word, index + 1, i - 1, j, visited) or \\\n            dfs(board, word, index + 1, i + 1, j, visited) or \\\n            dfs(board, word, index + 1, i, j - 1, visited) or \\\n            dfs(board, word, index + 1, i, j + 1, visited)\n        visited[i][j] = False\n        return found\n\n    res = []\n    for word in words:\n        if any(dfs(board, word, 0, i, j, [[False] * len(board[0]) for _ in range(len(board))])\n               for i in range(len(board)) for j in range(len(board[0]))):\n            res.append(word)\n\n    ### Postconditions ###\n    assert isinstance(res, list), \"The result should be a list\"\n    assert all(isinstance(word, str) for word in res), \"Each element in the result should be a string\"\n    assert len(res) <= len(words), \"The length of the result cannot exceed the length of the input words\"\n    assert all(word in words for word in res), \"All words in the result must exist in the input words\"\n    assert all(1 <= len(word) <= 10 for word in res), \"Each word in the result should have a valid length\"\n    assert len(set(res)) == len(res), \"All words in the result should be unique\"\n\n    return res\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([[\"a\", \"b\"], [\"c\", \"d\"]], [\"ac\", \"bd\"]) == [\"ac\", \"bd\"]\n\tassert candidate([[\"a\", \"b\"], [\"c\", \"d\"]], [\"abcd\"]) == []\n\tassert candidate(\n    [[\"o\", \"a\", \"b\", \"n\"], [\"o\", \"t\", \"a\", \"e\"], [\"a\", \"h\", \"k\", \"r\"], [\"a\", \"f\", \"l\", \"v\"]], [\"oa\", \"oaa\"]\n) == [\"oa\", \"oaa\"]\n\tassert candidate([[\"a\"]], [\"a\"]) == [\"a\"]\n\tassert candidate([[\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"], [\"g\", \"h\", \"i\"]], [\"aei\", \"bdf\", \"cgh\"]) == []\n\tassert candidate([[\"a\", \"a\", \"a\"], [\"a\", \"a\", \"a\"], [\"a\", \"a\", \"a\"]], [\"aaa\", \"aaaa\", \"aaaaa\"]) == [\"aaa\", \"aaaa\", \"aaaaa\"]\n\tassert candidate([[\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"], [\"g\", \"h\", \"i\"]], [\"a\", \"e\", \"i\"]) == [\"a\", \"e\", \"i\"]\n\tassert candidate([[\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"], [\"g\", \"h\", \"i\"]], [\"adg\", \"beh\", \"cfi\"]) == [\"adg\", \"beh\", \"cfi\"]\n\tassert candidate([[\"a\", \"b\"], [\"c\", \"d\"]], [\"abcb\"]) == []\ndef test_check():\n\tcheck(findWords)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,string,backtracking,trie,matrix\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 224, "filename": "LeetCode_224_countSmaller.py", "content": "from typing import List\n\n\ndef countSmaller(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an integer array nums, return an integer array counts where counts[i] is the number of smaller elements to the right of nums[i].\n\u00a0\n    Example 1:\n\n    Input: nums = [5,2,6,1]\n    Output: [2,1,1,0]\n    Explanation:\n    To the right of 5 there are 2 smaller elements (2 and 1).\n    To the right of 2 there is only 1 smaller element (1).\n    To the right of 6 there is 1 smaller element (1).\n    To the right of 1 there is 0 smaller element.\n\n    Example 2:\n\n    Input: nums = [-1]\n    Output: [0]\n\n    Example 3:\n\n    Input: nums = [-1,-1]\n    Output: [0,0]\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    -104 <= nums[i] <= 104\n\n    \"\"\"\n    ### Canonical solution below ###\n    ### Preconditions ###\n    assert isinstance(nums, list), \"Input must be a list\"\n    assert all(isinstance(num, int) for num in nums), \"All elements in the list must be integers\"\n    assert 1 <= len(nums) <= 105, \"List length must be between 1 and 105\"\n    assert all(-104 <= num <= 104 for num in nums), \"Each integer must be between -104 and 104\"\n\n    def merge_sort(indices):\n        if len(indices) <= 1:\n            return indices\n        mid = len(indices) // 2\n        left = merge_sort(indices[:mid])\n        right = merge_sort(indices[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        merged, count = [], 0\n        while left and right:\n            if nums[left[0]] <= nums[right[0]]:\n                counts[left[0]] += count\n                merged.append(left.pop(0))\n            else:\n                count += len(left)\n                merged.append(right.pop(0))\n        for i in left:\n            counts[i] += count\n        return merged + left + right\n\n    counts = [0] * len(nums)\n    merge_sort(list(range(len(nums))))\n\n    ### Postconditions ###\n    assert isinstance(counts, list), \"The output must be a list\"\n    assert all(isinstance(c, int) for c in counts), \"All elements in the output list must be integers\"\n    assert len(counts) == len(nums), \"The output list must have the same length as the input list\"\n    assert all(c >= 0 for c in counts), \"All elements in the output list must be non-negative integers\"\n\n    return counts\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([2, 1, 3, 1, 2]) == [2, 0, 2, 0, 0]\n\tassert candidate([2, 2, 2, 2, 2, 2]) == [0, 0, 0, 0, 0, 0]\n\tassert candidate([1, 2, 3, 2, 1]) == [0, 1, 2, 1, 0]\n\tassert candidate([-1]) == [0]\n\tassert candidate([-1, -1]) == [0, 0]\n\tassert candidate([1]) == [0]\n\tassert candidate([1, 2, 3, 4, 5]) == [0, 0, 0, 0, 0]\n\tassert candidate([2, 2, 2, 2, 2]) == [0, 0, 0, 0, 0]\ndef test_check():\n\tcheck(countSmaller)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,binary-search,divide-and-conquer,binary-indexed-tree,segment-tree,merge-sort,ordered-set\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 239, "filename": "LeetCode_239_findItinerary.py", "content": "from typing import List\nfrom collections import defaultdict\n\ndef findItinerary(tickets: List[List[str]]) -> List[str]:\n    \"\"\"\n    You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.\n    All of the tickets belong to a man who departs from \"JFK\", thus, the itinerary must begin with \"JFK\". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\n\n    For example, the itinerary [\"JFK\", \"LGA\"] has a smaller lexical order than [\"JFK\", \"LGB\"].\n\n    You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.\n\u00a0\n    Example 1:\n\n\n    Input: tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]\n    Output: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\n\n    Example 2:\n\n\n    Input: tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\n    Output: [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\n    Explanation: Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] but it is larger in lexical order.\n\n\u00a0\n    Constraints:\n\n    1 <= tickets.length <= 300\n    tickets[i].length == 2\n    fromi.length == 3\n    toi.length == 3\n    fromi and toi consist of uppercase English letters.\n    fromi != toi\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(tickets, list), \"Input tickets should be a list of lists\"\n    assert all(isinstance(ticket, list) and len(ticket) == 2 for ticket in tickets), \"Each ticket must be a list of two elements\"\n    assert all(isinstance(fromi, str) and isinstance(toi, str) for fromi, toi in tickets), \"All elements in tickets must be strings\"\n    assert all(len(fromi) == 3 and len(toi) == 3 for fromi, toi in tickets), \"Airport codes must be three characters long\"\n    assert all(fromi != toi for fromi, toi in tickets), \"Departure and arrival airports must be different\"\n\n    flights = defaultdict(list)\n    itinerary = []\n\n    for ticket in tickets:\n        flights[ticket[0]].append(ticket[1])\n        flights[ticket[0]].sort(reverse=True)\n\n    def dfs(airport):\n        while flights[airport]:\n            dfs(flights[airport].pop())\n        itinerary.append(airport)\n\n    dfs(\"JFK\")\n\n    result = itinerary[::-1]\n\n    ### Postconditions ###\n    assert isinstance(result, list), \"The output must be a list\"\n    assert all(isinstance(airport, str) for airport in result), \"All elements in the output list must be strings\"\n    assert result[0] == \"JFK\", \"The itinerary must start with 'JFK'\"\n    assert len(result) == len(tickets) + 1, \"The itinerary should include all flights plus the starting point\"\n    \n    # Additional postcondition: Check if each pair of consecutive airports in the itinerary corresponds to a valid ticket.\n    for i in range(len(result) - 1):\n        assert [result[i], result[i + 1]] in tickets, f\"The pair [{result[i]}, {result[i+1]}] must be in the list of tickets\"\n    \n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]) == [\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"]\n\tassert candidate([[\"JFK\", \"ATL\"], [\"ATL\", \"JFK\"]]) == [\"JFK\", \"ATL\", \"JFK\"]\n\tassert candidate([[\"JFK\", \"SFO\"], [\"SFO\", \"JFK\"], [\"JFK\", \"ATL\"], [\"ATL\", \"SFO\"], [\"SFO\", \"JFK\"]]) == [\"JFK\", \"ATL\", \"SFO\", \"JFK\", \"SFO\", \"JFK\"]\n\tassert candidate([[\"JFK\", \"ATL\"], [\"ATL\", \"JFK\"], [\"JFK\", \"ATL\"]]) == [\"JFK\", \"ATL\", \"JFK\", \"ATL\"]\n\tassert candidate([[\"JFK\", \"ATL\"], [\"ATL\", \"JFK\"], [\"JFK\", \"SFO\"]]) == [\"JFK\", \"ATL\", \"JFK\", \"SFO\"]\n\tassert candidate([[\"JFK\", \"ATL\"], [\"ATL\", \"SFO\"], [\"SFO\", \"ATL\"], [\"ATL\", \"JFK\"]]) == [\"JFK\", \"ATL\", \"SFO\", \"ATL\", \"JFK\"]\n\tassert candidate([[\"JFK\", \"SFO\"], [\"SFO\", \"JFK\"]]) == [\"JFK\", \"SFO\", \"JFK\"]\n\tassert candidate([[\"JFK\", \"ATL\"], [\"ATL\", \"SFO\"], [\"SFO\", \"JFK\"]]) == [\"JFK\", \"ATL\", \"SFO\", \"JFK\"]\n\tassert candidate([[\"JFK\", \"ATL\"], [\"ATL\", \"SFO\"], [\"JFK\", \"ATL\"], [\"ATL\", \"JFK\"], [\"SFO\", \"JFK\"]]) == [\"JFK\", \"ATL\", \"JFK\", \"ATL\", \"SFO\", \"JFK\"]\n\tassert candidate([[\"JFK\", \"SFO\"], [\"JFK\", \"ATL\"], [\"SFO\", \"ATL\"], [\"ATL\", \"JFK\"], [\"ATL\", \"SFO\"]]) == [\"JFK\", \"ATL\", \"JFK\", \"SFO\", \"ATL\", \"SFO\"]\n\tassert candidate([[\"JFK\", \"ATL\"], [\"ATL\", \"JFK\"], [\"JFK\", \"SFO\"], [\"SFO\", \"ATL\"], [\"ATL\", \"JFK\"]]) == [\"JFK\", \"ATL\", \"JFK\", \"SFO\", \"ATL\", \"JFK\"]\ndef test_check():\n\tcheck(findItinerary)\n# Metadata Difficulty: Hard\n# Metadata Topics: depth-first-search,graph,eulerian-circuit\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 255, "filename": "LeetCode_255_max_envelopes.py", "content": "from typing import List\n\n\ndef max_envelopes(envelopes: List[List[int]]) -> int:\n    \"\"\"\n    You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\n    One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n    Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\n    Note: You cannot rotate an envelope.\n\u00a0\n    Example 1:\n\n    Input: envelopes = [[5,4],[6,4],[6,7],[2,3]]\n    Output: 3\n    Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).\n\n    Example 2:\n\n    Input: envelopes = [[1,1],[1,1],[1,1]]\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= envelopes.length <= 105\n    envelopes[i].length == 2\n    1 <= wi, hi <= 105\n\n    \"\"\"\n    ### Canonical solution below ###\n    from bisect import bisect_left\n    assert isinstance(envelopes, list), \"Input must be a list\"\n    assert all(isinstance(e, list) and len(e) == 2 for e in envelopes), \"Each envelope must be a list of two elements\"\n    assert all(isinstance(e[0], int) and isinstance(e[1], int) for e in envelopes), \"Envelope dimensions must be integers\"\n    assert all(1 <= e[0] <= 105 and 1 <= e[1] <= 105 for e in envelopes), \"Envelope dimensions must be between 1 and 105\"\n    assert len(envelopes) >= 1, \"There must be at least one envelope\"\n\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []\n\n    for _, h in envelopes:\n        idx = bisect_left(dp, h)\n        if idx == len(dp):\n            dp.append(h)\n        else:\n            dp[idx] = h\n\n    result = len(dp)\n\n    ### Postconditions ###\n    assert isinstance(result, int), \"Result must be an integer\"\n    assert result >= 1, \"Result must be at least 1 (there's always at least one envelope)\"\n    assert result <= len(envelopes), \"Result cannot exceed the total number of envelopes\"\n    assert all(dp[i] < dp[i+1] for i in range(len(dp)-1)), \"Heights in the DP list must be strictly increasing\"\n    \n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([[5,4],[6,4],[6,7],[2,3],[1,2]]) == 4\n\tassert candidate([[1,1],[1,1],[1,1]]) == 1\n\tassert candidate([[1,10],[2,9],[3,8],[4,7],[5,6],[6,5],[7,4],[8,3],[9,2],[10,1]]) == 1\n\tassert candidate([[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11]]) == 10\n\tassert candidate([[10,20],[20,30],[30,40],[40,50]]) == 4\n\tassert candidate([[5,4],[6,4],[6,7],[2,3]]) == 3\n\tassert candidate([[1,1],[2,2],[3,3],[4,4],[5,5]]) == 5\n\tassert candidate([[10,20],[15,25],[20,30],[25,35],[30,40]]) == 5\n\tassert candidate([[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[11,12]]) == 10\n\tassert candidate([[5,5],[5,5],[5,5],[5,5],[5,5],[5,5],[5,5],[5,5],[5,5],[5,5]]) == 1\n\tassert candidate([[1,1]]) == 1\n\tassert candidate([[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12]]) == 10\n\tassert candidate([[4,5],[5,6],[6,7],[7,8]]) == 4\ndef test_check():\n\tcheck(max_envelopes)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,binary-search,dynamic-programming,sorting\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 343, "filename": "LeetCode_343_getMaxRepetitions.py", "content": "def getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n    \"\"\"\n    We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\n    For example, str == [\"abc\", 3] ==\"abcabcabc\".\n\n    We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\n    For example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\n    You are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\n    Return the maximum integer m such that str = [str2, m] can be obtained from str1.\n\u00a0\n    Example 1:\n    Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n    Output: 2\n    Example 2:\n    Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= s1.length, s2.length <= 100\n    s1 and s2 consist of lowercase English letters.\n    1 <= n1, n2 <= 106\n\n    \"\"\"\n    ### Canonical solution below ###\n    ### Preconditions ###\n    assert isinstance(s1, str), \"s1 must be a string\"\n    assert isinstance(s2, str), \"s2 must be a string\"\n    assert isinstance(n1, int) and n1 >= 0, \"n1 must be a positive integer\"\n    assert isinstance(n2, int) and n2 >= 0, \"n2 must be a positive integer\"\n    assert 1 <= len(s1) <= 100, \"Length of s1 must be between 1 and 100\"\n    assert 1 <= len(s2) <= 100, \"Length of s2 must be between 1 and 100\"\n\n    count1, count2, i, j = 0, 0, 0, 0\n    while count1 < n1:\n        if s1[i] == s2[j]:\n            j += 1\n            if j == len(s2):\n                j = 0\n                count2 += 1\n        i += 1\n        if i == len(s1):\n            i = 0\n            count1 += 1\n    result = count2 // n2\n\n    ### Postconditions ###\n    assert isinstance(result, int), \"Result must be an integer\"\n    assert result >= 0, \"Result must be non-negative\"\n    assert result <= n1 * len(s1) // (n2 * len(s2)), \"Result must be less than or equal to the ratio of lengths and counts\"\n    if s1 == s2 and n1 == n2:\n        assert result == 1, \"If s1 equals s2 and n1 equals n2, the result should be 1\"\n    if n1 == 0 or n2 == 0:\n        assert result == 0, \"If either n1 or n2 is 0, the result should be 0\"\n    if len(set(s2) - set(s1)) > 0:\n        assert result == 0, \"If s2 contains characters not in s1, the result should be 0\"\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"abcdabcdabcdabcdabcdabcd\", 1, \"abcdabcd\", 3) == 1\n\tassert candidate(\"abcd\", 1, \"ab\", 2) == 0\n\tassert candidate(\"abcd\", 1, \"abcd\", 1) == 1\n\tassert candidate(\"abc\", 4, \"ab\", 2) == 2\n\tassert candidate(\"a\", 0, \"a\", 1) == 0\n\tassert candidate(\"abcdabcd\", 1, \"abcd\", 1) == 2\n\tassert candidate(\"abc\", 3, \"abcabc\", 3) == 0\n\tassert candidate(\"abcabcabc\", 5, \"abc\", 3) == 5\n\tassert candidate(\"abcdefg\", 6, \"abc\", 1) == 6\n\tassert candidate(\"abcdefg\", 5, \"abc\", 1) == 5\n\tassert candidate(\"abcdefg\", 3, \"abc\", 1) == 3\n\tassert candidate(\"abcabc\", 2, \"abc\", 3) == 1\n\tassert candidate(\"abcd\", 1, \"a\", 2) == 0\n\tassert candidate(\"abca\", 2, \"abc\", 2) == 1\n\tassert candidate(\"abc\", 3, \"abc\", 3) == 1\n\tassert candidate(\"a\", 100, \"aa\", 50) == 1\n\tassert candidate(\"abcdefg\", 2, \"abc\", 1) == 2\n\tassert candidate(\"abcdefg\", 4, \"abc\", 1) == 4\n\tassert candidate(\"abcabc\", 2, \"abc\", 2) == 2\n\tassert candidate(\"bba\", 1, \"ab\", 2) == 0\n\tassert candidate(\"abc\", 100, \"a\", 1) == 100\n\tassert candidate(\"abcd\", 1, \"ab\", 3) == 0\n\tassert candidate(\"abcdefg\", 1, \"abcdefg\", 1) == 1\n\tassert candidate(\"abcdefg\", 3, \"abcdef\", 3) == 1\n\tassert candidate(\"ab\", 2, \"a\", 1) == 2\n\tassert candidate(\"abcabcabcabcabcabcabcabcabc\", 1, \"abcabcabcabcabcabcabcabcabc\", 1) == 1\n\tassert candidate(\"abcabcabcabc\", 4, \"abcabc\", 2) == 4\n\tassert candidate(\"bba\", 1, \"ab\", 10) == 0\n\tassert candidate(\"abcd\", 1, \"a\", 4) == 0\n\tassert candidate(\"abcd\", 1, \"a\", 3) == 0\n\tassert candidate(\"abc\", 1, \"abc\", 1) == 1\n\tassert candidate(\"abcabcabc\", 1, \"abc\", 3) == 1\n\tassert candidate(\"abcabcab\", 3, \"abc\", 2) == 3\n\tassert candidate(\"abcdabcdabcdabcdabcd\", 1, \"abcd\", 5) == 1\n\tassert candidate(\"abc\", 5, \"ab\", 1) == 5\n\tassert candidate(\"abc\", 3, \"abcabcabc\", 1) == 1\n\tassert candidate(\"abcdefg\", 1, \"abc\", 1) == 1\n\tassert candidate(\"b\", 99, \"aa\", 1) == 0\n\tassert candidate(\"abc\", 3, \"abc\", 1) == 3\n\tassert candidate(\"abcabcabcabcabcabc\", 1, \"abcabcabc\", 2) == 1\n\tassert candidate(\"a\", 1, \"a\", 1) == 1\n\tassert candidate(\"abcabc\", 1, \"abc\", 1) == 2\n\tassert candidate(\"abcdefg\", 7, \"abc\", 1) == 7\n\tassert candidate(\"s1\", 1, \"s2\", 1) == 0\n\tassert candidate(\"abcd\", 1, \"ab\", 4) == 0\n\tassert candidate(\"bba\", 1, \"ab\", 1) == 0\ndef test_check():\n\tcheck(getMaxRepetitions)\n# Metadata Difficulty: Hard\n# Metadata Topics: string,dynamic-programming\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 364, "filename": "LeetCode_364_find_min_step.py", "content": "def find_min_step(board: str, hand: str) -> int:\n    \"\"\"\n    You are playing a variation of the game Zuma.\n    In this variation of Zuma, there is a single row of colored balls on a board, where each ball can be colored red 'R', yellow 'Y', blue 'B', green 'G', or white 'W'. You also have several colored balls in your hand.\n    Your goal is to clear all of the balls from the board. On each turn:\n\n    Pick any ball from your hand and insert it in between two balls in the row or on either end of the row.\n    If there is a group of three or more consecutive balls of the same color, remove the group of balls from the board.\n\n    If this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left.\n\n\n    If there are no more balls on the board, then you win the game.\n    Repeat this process until you either win or do not have any more balls in your hand.\n\n    Given a string board, representing the row of balls on the board, and a string hand, representing the balls in your hand, return the minimum number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return -1.\n\u00a0\n    Example 1:\n\n    Input: board = \"WRRBBW\", hand = \"RB\"\n    Output: -1\n    Explanation: It is impossible to clear all the balls. The best you can do is:\n    - Insert 'R' so the board becomes WRRRBBW. WRRRBBW -> WBBW.\n    - Insert 'B' so the board becomes WBBBW. WBBBW -> WW.\n    There are still balls remaining on the board, and you are out of balls to insert.\n    Example 2:\n\n    Input: board = \"WWRRBBWW\", hand = \"WRBRW\"\n    Output: 2\n    Explanation: To make the board empty:\n    - Insert 'R' so the board becomes WWRRRBBWW. WWRRRBBWW -> WWBBWW.\n    - Insert 'B' so the board becomes WWBBBWW. WWBBBWW -> WWWW -> empty.\n    2 balls from your hand were needed to clear the board.\n\n    Example 3:\n\n    Input: board = \"G\", hand = \"GGGGG\"\n    Output: 2\n    Explanation: To make the board empty:\n    - Insert 'G' so the board becomes GG.\n    - Insert 'G' so the board becomes GGG. GGG -> empty.\n    2 balls from your hand were needed to clear the board.\n\n\u00a0\n    Constraints:\n\n    1 <= board.length <= 16\n    1 <= hand.length <= 5\n    board and hand consist of the characters 'R', 'Y', 'B', 'G', and 'W'.\n    The initial row of balls on the board will not have any groups of three or more consecutive balls of the same color.\n\n    \"\"\"\n    ### Canonical solution below ###\n    from collections import Counter\n\n    assert isinstance(board, str), \"Board must be a string.\"\n    assert isinstance(hand, str), \"Hand must be a string.\"\n    assert 1 <= len(board) <= 16, \"Board length must be between 1 and 16.\"\n    assert all(c in \"RYBGW\" for c in board), \"Board contains invalid characters.\"\n    assert all(c in \"RYBGW\" for c in hand), \"Hand contains invalid characters.\"\n    assert all(board[i] != board[i + 1] or board[i + 1] != board[i + 2] for i in range(len(board) - 2)), \"Initial board must not have groups of three or more consecutive balls.\"\n\n    def find_min_step_helper(board, memo, hand):\n        if not board:\n            return 0\n        if board in memo:\n            return memo[board]\n\n        result = float('inf')\n        i = 0\n        while i < len(board):\n            j = i\n            while j < len(board) and board[i] == board[j]:\n                j += 1\n\n            color = board[i]\n            required = 3 - (j - i)\n            if hand[color] >= required:\n                hand[color] -= required\n                next_board = board[:i] + board[j:]\n                tmp = find_min_step_helper(next_board, memo, hand)\n                if tmp != -1:\n                    result = min(result, tmp + required)\n                hand[color] += required\n            i = j\n\n        memo[board] = -1 if result == float('inf') else result\n        return memo[board]\n\n    hand_count = Counter(hand)\n    memo = {}\n    result = find_min_step_helper(board, memo, hand_count)\n\n    ### Postconditions ###\n    assert isinstance(result, int), \"Result must be an integer.\"\n    assert result >= -1, \"Result must be greater than or equal to -1.\"\n    assert (result == -1 or (result >= 0 and result <= len(hand))), \"Result must be between -1 and the length of the hand.\"\n    if not board:\n        assert result == 0, \"If the board is initially empty, the result should be 0.\"\n    if result == -1:\n        assert any(board), \"If the result is -1, there should still be balls left on the board.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"GRBGYRB\", \"GRBGYRB\") == -1\n\tassert candidate(\"G\", \"GGGGG\") == 2\n\tassert candidate(\"YGRBYGR\", \"YGRBYGR\") == -1\n\tassert candidate(\"RGYBRGY\", \"RGYBRGY\") == -1\n\tassert candidate(\"YBGYRBY\", \"YBGYRBY\") == -1\n\tassert candidate(\"BGRYGBR\", \"BGRYGBR\") == -1\n\tassert candidate(\"WYBWYBW\", \"WYBWYB\") == -1\n\tassert candidate(\"YBGRBGY\", \"YBGRBGY\") == -1\n\tassert candidate(\"WBYBRYW\", \"WBYBRYW\") == -1\n\tassert candidate(\"RBYGRBG\", \"RBYGRBG\") == -1\n\tassert candidate(\"YBRYBR\", \"YBRYBR\") == -1\n\tassert candidate(\"WBRWYBW\", \"WBRWYB\") == -1\n\tassert candidate(\"WRRBBW\", \"RB\") == -1\n\tassert candidate(\"RBYGGRB\", \"RBYGGRB\") == -1\n\tassert candidate(\"BGRYBGR\", \"BGRYBGR\") == -1\n\tassert candidate(\"BGYRBGY\", \"BGYRBGY\") == -1\n\tassert candidate(\"WBRYBWR\", \"WBRYBWR\") == -1\ndef test_check():\n\tcheck(find_min_step)\n# Metadata Difficulty: Hard\n# Metadata Topics: string,dynamic-programming,stack,breadth-first-search,memoization\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 376, "filename": "LeetCode_376_findMaximizedCapital.py", "content": "from typing import List\n\n\ndef findMaximizedCapital(k: int, w: int, profits: List[int], capital: List[int]) -> int:\n    \"\"\"\n    Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\n    You are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.\n    Initially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\n    Pick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.\n    The answer is guaranteed to fit in a 32-bit signed integer.\n\u00a0\n    Example 1:\n\n    Input: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\n    Output: 4\n    Explanation: Since your initial capital is 0, you can only start the project indexed 0.\n    After finishing it you will obtain profit 1 and your capital becomes 1.\n    With capital 1, you can either start the project indexed 1 or the project indexed 2.\n    Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\n    Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n\n    Example 2:\n\n    Input: k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\n    Output: 6\n\n\u00a0\n    Constraints:\n\n    1 <= k <= 105\n    0 <= w <= 109\n    n == profits.length\n    n == capital.length\n    1 <= n <= 105\n    0 <= profits[i] <= 104\n    0 <= capital[i] <= 109\n\n    \"\"\"\n    ### Canonical solution below ###\n    import heapq\n    ### Preconditions ###\n    assert isinstance(k, int) and k >= 0, \"k must be a non-negative integer\"\n    assert isinstance(w, int) and w >= 0, \"w must be a non-negative integer\"\n    assert all(isinstance(p, int) and p >= 0 for p in profits), \"All profits must be non-negative integers\"\n    assert all(isinstance(c, int) and c >= 0 for c in capital), \"All capital requirements must be non-negative integers\"\n    assert len(profits) == len(capital), \"profits and capital must have the same length\"\n\n    import heapq\n    project_pool = list(zip(capital, profits))\n    project_pool.sort(reverse=True)\n\n    profit_pool = []\n\n    while k:\n        while project_pool and project_pool[-1][0] <= w:\n            heapq.heappush(profit_pool, -project_pool.pop()[1])\n\n        if not profit_pool:\n            break\n\n        w -= heapq.heappop(profit_pool)\n        k -= 1\n\n    result = w\n\n    ### Postconditions ###\n    assert isinstance(result, int), \"Result must be an integer\"\n    assert result >= 0, \"Result must be non-negative\"\n    assert result <= w + sum(profits), \"Result cannot exceed initial capital plus total profits\"\n    if k == 0 or not profits or not capital:\n        assert result == w, \"If no projects can be done, result should equal initial capital\"\n    if all(c > w for c in capital):\n        assert result == w, \"If all projects require more capital than available, result should equal initial capital\"\n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(3, 0, [3,2,1], [0,1,2]) == 6\n\tassert candidate(1, 1, [1,2,3], [0,1,2]) == 3\n\tassert candidate(3, 0, [1,2,3], [0,1,2]) == 6\n\tassert candidate(3, 1, [1,1,1], [0,0,0]) == 4\n\tassert candidate(3, 1, [3,2,1], [0,1,2]) == 7\n\tassert candidate(3, 0, [1,2,3], [0,0,0]) == 6\n\tassert candidate(1, 2, [1,2,3], [0,1,2]) == 5\n\tassert candidate(4, 2, [1,2,1], [0,0,1]) == 6\n\tassert candidate(3, 2, [3,2,1], [0,1,2]) == 8\n\tassert candidate(3, 2, [1,1,1], [0,0,0]) == 5\n\tassert candidate(4, 0, [1,2,3], [0,1,1]) == 6\n\tassert candidate(0, 0, [1,2,3], [0,0,0]) == 0\n\tassert candidate(3, 0, [2,2,3], [0,1,1]) == 7\n\tassert candidate(2, 0, [2,1,1], [0,1,0]) == 3\n\tassert candidate(1, 0, [3], [0]) == 3\n\tassert candidate(2, 0, [1,2,3], [0,1,1]) == 4\n\tassert candidate(3, 0, [1,1,1], [0,0,0]) == 3\n\tassert candidate(1, 2, [1,2,3], [0,1,1]) == 5\n\tassert candidate(1, 0, [5], [0]) == 5\n\tassert candidate(4, 0, [1,1,1,1], [0,0,1,1]) == 4\n\tassert candidate(4, 2, [1,3,1,1], [0,0,1,2]) == 8\n\tassert candidate(4, 0, [2,2,3], [0,1,1]) == 7\ndef test_check():\n\tcheck(findMaximizedCapital)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,greedy,sorting,heap-priority-queue\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 385, "filename": "LeetCode_385_find_rotate_steps.py", "content": "def find_rotate_steps(ring: str, key: str) -> int:\n    \"\"\"\n    In the video game Fallout 4, the quest \"Road to Freedom\" requires players to reach a metal dial called the \"Freedom Trail Ring\" and use the dial to spell a specific keyword to open the door.\n    Given a string ring that represents the code engraved on the outer ring and another string key that represents the keyword that needs to be spelled, return the minimum number of steps to spell all the characters in the keyword.\n    Initially, the first character of the ring is aligned at the \"12:00\" direction. You should spell all the characters in key one by one by rotating ring clockwise or anticlockwise to make each character of the string key aligned at the \"12:00\" direction and then by pressing the center button.\n    At the stage of rotating the ring to spell the key character key[i]:\n\n    You can rotate the ring clockwise or anticlockwise by one place, which counts as one step. The final purpose of the rotation is to align one of ring's characters at the \"12:00\" direction, where this character must equal key[i].\n    If the character key[i] has been aligned at the \"12:00\" direction, press the center button to spell, which also counts as one step. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.\n\n\u00a0\n    Example 1:\n\n\n    Input: ring = \"godding\", key = \"gd\"\n    Output: 4\n    Explanation:\n    For the first key character 'g', since it is already in place, we just need 1 step to spell this character. \n    For the second key character 'd', we need to rotate the ring \"godding\" anticlockwise by two steps to make it become \"ddinggo\".\n    Also, we need 1 more step for spelling.\n    So the final output is 4.\n\n    Example 2:\n\n    Input: ring = \"godding\", key = \"godding\"\n    Output: 13\n\n\u00a0\n    Constraints:\n\n    1 <= ring.length, key.length <= 100\n    ring and key consist of only lower case English letters.\n    It is guaranteed that key could always be spelled by rotating ring.\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(ring, str) and isinstance(key, str), \"ring and key must be strings\"\n    assert 1 <= len(ring) <= 100, \"ring length must be between 1 and 100\"\n    assert 1 <= len(key) <= 100, \"key length must be between 1 and 100\"\n    assert ring.islower() and key.islower(), \"ring and key must consist of lowercase letters\"\n    assert all(c in ring for c in key), \"key must only contain characters present in ring\"\n\n    n, m = len(ring), len(key)\n    dp = [[0] * n for _ in range(m + 1)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n):\n            dp[i][j] = float('inf')\n            for k in range(n):\n                if ring[k] == key[i]:\n                    diff = abs(j - k)\n                    step = min(diff, n - diff)\n                    dp[i][j] = min(dp[i][j], step + dp[i + 1][k])\n\n    result = dp[0][0] + m\n\n    ### Postconditions ###\n    assert isinstance(result, int), \"The result must be an integer\"\n    assert result >= m, \"Result should be at least the length of key (each character needs a step to press)\"\n    assert result >= len(key), \"Result should include at least the pressing of each key character\"\n    assert result <= len(ring) * len(key), \"Result should not exceed the maximum possible steps\"\n    assert result >= len(key), \"At least 1 step per character is required\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"abc\", \"c\") == 2\n\tassert candidate(\"abcde\", \"ba\") == 4\n\tassert candidate(\"godding\", \"gd\") == 4\n\tassert candidate(\n    \"godding\",\n    \"godding\") == 13\n\tassert candidate(\"abcde\", \"c\") == 3\n\tassert candidate(\"godding\", \"godding\") == 13\n\tassert candidate(\"x\", \"x\") == 1\ndef test_check():\n\tcheck(find_rotate_steps)\n# Metadata Difficulty: Hard\n# Metadata Topics: string,dynamic-programming,depth-first-search,breadth-first-search\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 387, "filename": "LeetCode_387_find_min_moves.py", "content": "from typing import List\n\n\ndef find_min_moves(machines: List[int]) -> int:\n    \"\"\"\n    You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty.\n    For each move, you could choose any m (1 <= m <= n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.\n    Given an integer array machines representing the number of dresses in each washing machine from left to right on the line, return the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.\n\u00a0\n    Example 1:\n\n    Input: machines = [1,0,5]\n    Output: 3\n    Explanation:\n    1st move:    1     0 <-- 5    =>    1     1     4\n    2nd move:    1 <-- 1 <-- 4    =>    2     1     3\n    3rd move:    2     1 <-- 3    =>    2     2     2\n\n    Example 2:\n\n    Input: machines = [0,3,0]\n    Output: 2\n    Explanation:\n    1st move:    0 <-- 3     0    =>    1     2     0\n    2nd move:    1     2 --> 0    =>    1     1     1\n\n    Example 3:\n\n    Input: machines = [0,2,0]\n    Output: -1\n    Explanation:\n    It's impossible to make all three washing machines have the same number of dresses.\n\n\u00a0\n    Constraints:\n\n    n == machines.length\n    0 <= n <= 10^4\n    0 <= machines[i] <= 10^5\n\n    \"\"\"\n    ### Canonical solution below ###\n    ### Preconditions ###\n    assert isinstance(machines, list) and all(isinstance(x, int) for x in machines), \"machines must be a list of integers\"\n    assert 0 <= len(machines) <= 10**4, \"machines length must be between 1 and 104\"\n\n    n = len(machines)\n    total_dresses = sum(machines)\n\n    if total_dresses % n != 0:\n        return -1\n\n    average = total_dresses // n\n    moves = 0\n    imbalance = 0\n\n    for i in range(n):\n        imbalance += machines[i] - average\n        moves = max(moves, abs(imbalance), machines[i] - average)\n\n    result = moves\n\n    ### Postconditions ###\n    assert isinstance(result, int), \"The result should be an integer\"\n    if result == -1:\n        assert total_dresses % n != 0, \"Result is -1 only when total dresses are not evenly divisible by number of machines\"\n    else:\n        assert result >= 0, \"The number of moves cannot be negative\"\n        assert result >= max(machines) - average, \"The number of moves must be at least the maximum dresses minus the average\"\n        assert sum(machines) == total_dresses, \"The total number of dresses should remain unchanged\"\n        assert result <= sum(abs(machines[i] - average) for i in range(n)), \"The number of moves should not exceed the sum of all imbalances\"\n\n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([10,0,0]) == -1\n\tassert candidate([1,0,5]) == 3\n\tassert candidate([0,3,0]) == 2\n\tassert candidate([1000000000,1000000000,1000000000,1000000000,1000000000,1000000000,1000000000,1000000000,1000000000]) == 0\n\tassert candidate([10,10,10]) == 0\n\tassert candidate([0,0,0]) == 0\n\tassert candidate([1000,1000,1000]) == 0\n\tassert candidate(\n    [1000,1000,1000,1000,1000]) == 0\n\tassert candidate([1000,0,0]) == -1\n\tassert candidate([1,1,1,1,1]) == 0\n\tassert candidate([0,0,100]) == -1\n\tassert candidate([0,100,0]) == -1\n\tassert candidate(\n    [200000000000000000, 200000000000000000, 200000000000000000]) == 0\n\tassert candidate([2,2,2,2,2]) == 0\n\tassert candidate([1,1,1]) == 0\n\tassert candidate([0,2,0]) == -1\n\tassert candidate([100,100,100]) == 0\n\tassert candidate([5,5,5]) == 0\n\tassert candidate(\n    [1000000000000000000, 1000000000000000000]) == 0\n\tassert candidate([5,0,0]) == -1\n\tassert candidate([3,3,3,3,3]) == 0\ndef test_check():\n\tcheck(find_min_moves)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,greedy\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 479, "filename": "LeetCode_479_findKthNumber.py", "content": "def findKthNumber(m: int, n: int, k: int) -> int:\n    \"\"\"\n    Nearly everyone has used the Multiplication Table. The multiplication table of size m x n is an integer matrix mat where mat[i][j] == i * j (1-indexed).\n    Given three integers m, n, and k, return the kth smallest element in the m x n multiplication table.\n\u00a0\n    Example 1:\n\n\n    Input: m = 3, n = 3, k = 5\n    Output: 3\n    Explanation: The 5th smallest number is 3.\n\n    Example 2:\n\n\n    Input: m = 2, n = 3, k = 6\n    Output: 6\n    Explanation: The 6th smallest number is 6.\n\n\u00a0\n    Constraints:\n\n    1 <= m, n <= 3 * 104\n    1 <= k <= m * n\n\n    \"\"\"\n    ### Canonical solution below ###\n    ### Preconditions ###\n    assert isinstance(m, int) and m > 0, \"m must be a positive integer\"\n    assert isinstance(n, int) and n > 0, \"n must be a positive integer\"\n    assert m <= 30000 and n <= 30000, \"m and n should not exceed 30,000\"\n\n    low, high = 1, m * n\n    while low < high:\n        mid = low + (high - low) // 2\n        count = 0\n        for i in range(1, m+1):\n            count += min(mid // i, n)\n        if count < k:\n            low = mid + 1\n        else:\n            high = mid\n\n    result = low\n\n    ### Postconditions ###\n    assert isinstance(result, int), \"The result should be an integer\"\n    assert 1 <= result <= m * n, \"The result should be within the range of the multiplication table\"\n    assert result == max(filter(lambda x: sum(min(result // i, n) for i in range(1, m+1)) >= k, range(1, m * n + 1))), \"The result should match the kth smallest element in the multiplication table\"\n    assert sum(min(result // i, n) for i in range(1, m+1)) >= k, \"The count of elements less than or equal to result should be at least k\"\n    assert sum(min(result // i, n) for i in range(1, m+1)) >= k, \"The count of elements less than or equal to the kth smallest element must match or exceed k\"\n\n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(7, 8, 58) == 56\n\tassert candidate(1, 10, 1) == 1\n\tassert candidate(3, 2, 6) == 6\n\tassert candidate(30000, 30000, 1) == 1\n\tassert candidate(1, 1, 1) == 1\n\tassert candidate(2, 2, 4) == 4\n\tassert candidate(3, 3, 1) == 1\n\tassert candidate(7, 8, 56) == 56\n\tassert candidate(7, 8, 57) == 56\n\tassert candidate(2, 3, 1) == 1\n\tassert candidate(1, 30000, 30000) == 30000\n\tassert candidate(6, 6, 36) == 36\n\tassert candidate(10, 10, 100) == 100\n\tassert candidate(7, 7, 49) == 49\n\tassert candidate(5, 5, 1) == 1\n\tassert candidate(2, 1, 1) == 1\n\tassert candidate(1, 2, 1) == 1\n\tassert candidate(3, 3, 2) == 2\n\tassert candidate(2, 3, 2) == 2\n\tassert candidate(1, 2, 2) == 2\n\tassert candidate(2, 2, 2) == 2\n\tassert candidate(7, 7, 45) == 35\n\tassert candidate(7, 8, 59) == 56\n\tassert candidate(10, 10, 1) == 1\n\tassert candidate(2, 3, 6) == 6\n\tassert candidate(10, 1, 10) == 10\n\tassert candidate(1, 10, 10) == 10\n\tassert candidate(2, 1, 2) == 2\n\tassert candidate(30000, 1, 30000) == 30000\n\tassert candidate(3, 3, 5) == 3\n\tassert candidate(5, 5, 25) == 25\n\tassert candidate(2, 3, 7) == 6\n\tassert candidate(7, 7, 48) == 42\n\tassert candidate(3, 3, 9) == 9\ndef test_check():\n\tcheck(findKthNumber)\n# Metadata Difficulty: Hard\n# Metadata Topics: math,binary-search\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 505, "filename": "LeetCode_505_fallingSquares.py", "content": "from typing import List\n\n\ndef fallingSquares(positions: List[List[int]]) -> List[int]:\n    \"\"\"\n    There are several squares being dropped onto the X-axis of a 2D plane.\n    You are given a 2D integer array positions where positions[i] = [lefti, sideLengthi] represents the ith square with a side length of sideLengthi that is dropped with its left edge aligned with X-coordinate lefti.\n    Each square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands on the top side of another square or on the X-axis. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.\n    After each square is dropped, you must record the height of the current tallest stack of squares.\n    Return an integer array ans where ans[i] represents the height described above after dropping the ith square.\n\u00a0\n    Example 1:\n\n\n    Input: positions = [[1,2],[2,3],[6,1]]\n    Output: [2,5,5]\n    Explanation:\n    After the first drop, the tallest stack is square 1 with a height of 2.\n    After the second drop, the tallest stack is squares 1 and 2 with a height of 5.\n    After the third drop, the tallest stack is still squares 1 and 2 with a height of 5.\n    Thus, we return an answer of [2, 5, 5].\n\n    Example 2:\n\n    Input: positions = [[100,100],[200,100]]\n    Output: [100,100]\n    Explanation:\n    After the first drop, the tallest stack is square 1 with a height of 100.\n    After the second drop, the tallest stack is either square 1 or square 2, both with heights of 100.\n    Thus, we return an answer of [100, 100].\n    Note that square 2 only brushes the right side of square 1, which does not count as landing on it.\n\n\u00a0\n    Constraints:\n\n    1 <= positions.length <= 1000\n    1 <= lefti <= 108\n    1 <= sideLengthi <= 106\n\n    \"\"\"\n    ### Canonical solution below ###\n    ### Preconditions ###\n    assert isinstance(positions, list), \"positions must be a list\"\n    assert all(isinstance(p, list) and len(p) == 2 for p in positions), \"Each position must be a list of two integers\"\n    assert all(1 <= p[0] <= 10**8 for p in positions), \"lefti values must be between 1 and 10^8\"\n    assert all(1 <= p[1] <= 10**6 for p in positions), \"sideLengthi values must be between 1 and 10^6\"\n    assert 1 <= len(positions) <= 1000, \"The number of positions must be between 1 and 1000\"\n\n    ans = []\n    intervals = []\n\n    for p in positions:\n        L, size = p\n        R = L + size\n        h = size\n        for h2, R2 in intervals:\n            if R2 > L and R > R2:\n                h = max(h, size + h2)\n\n        maxHeight = max((h2 for h2, R2 in intervals), default=0)\n        ans.append(max(maxHeight, h))\n        intervals.append((h, R))\n\n    result = ans\n\n    ### Postconditions ###\n    assert isinstance(result, list), \"The result should be a list\"\n    assert all(isinstance(h, int) and h >= 0 for h in result), \"All heights in the result should be non-negative integers\"\n    assert len(result) == len(positions), \"The result should have the same length as the input positions\"\n    assert all(result[i] >= result[i-1] for i in range(1, len(result))), \"The heights should be non-decreasing\"\n    assert max(result) == max(result), \"The maximum height in the result should be correctly computed\"\n\n    return result\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([[1,2],[5,3],[3,1]]) == [2,3,3]\n\tassert candidate([[1,2],[2,2],[3,2]]) == [2,4,6]\n\tassert candidate([[1,2],[2,2],[2,1]]) == [2,4,4]\n\tassert candidate([[1,1]]) == [1]\n\tassert candidate([[1,2],[2,3],[6,1]]) == [2,5,5]\n\tassert candidate([[1,2],[3,2],[5,2]]) == [2,2,2]\n\tassert candidate([[1,2],[2,2],[1,2]]) == [2,4,4]\n\tassert candidate([[100,100],[200,100]]) == [100,100]\ndef test_check():\n\tcheck(fallingSquares)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,segment-tree,ordered-set\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 514, "filename": "LeetCode_514_smallestDistancePair.py", "content": "from typing import List\n\n\ndef smallestDistancePair(nums: List[int], k: int) -> int:\n    \"\"\"\n    The distance of a pair of integers a and b is defined as the absolute difference between a and b.\n    Given an integer array nums and an integer k, return the kth smallest distance among all the pairs nums[i] and nums[j] where 0 <= i < j < nums.length.\n\u00a0\n    Example 1:\n\n    Input: nums = [1,3,1], k = 1\n    Output: 0\n    Explanation: Here are all the pairs:\n    (1,3) -> 2\n    (1,1) -> 0\n    (3,1) -> 2\n    Then the 1st smallest distance pair is (1,1), and its distance is 0.\n\n    Example 2:\n\n    Input: nums = [1,1,1], k = 2\n    Output: 0\n\n    Example 3:\n\n    Input: nums = [1,6,1], k = 3\n    Output: 5\n\n\u00a0\n    Constraints:\n\n    n == nums.length\n    2 <= n <= 104\n    0 <= nums[i] <= 106\n    1 <= k <= n * (n - 1) / 2\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(nums, list) and all(isinstance(x, int) for x in nums), \"nums must be a list of integers\"\n    assert all(0 <= x <= 10**6 for x in nums), \"Each number in nums must be between 0 and 10^6\"\n    \n    nums.sort()\n    low, high = 0, nums[-1] - nums[0]\n\n    while low < high:\n        mid = (low + high) // 2\n        count, left = 0, 0\n\n        for right in range(len(nums)):\n            while nums[right] - nums[left] > mid:\n                left += 1\n            count += (right - left)\n\n        if count < k:\n            low = mid + 1\n        else:\n            high = mid\n\n    result = low\n\n    # Postconditions\n    assert isinstance(result, int), \"The result must be an integer\"\n    assert 0 <= result <= nums[-1] - nums[0], \"The result must be a valid distance in the range of nums\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([3, 1, 3, 4], 1) == 0\n\tassert candidate([1,2,3,4,5,6,7], 5) == 1\n\tassert candidate([1,3,1], 1) == 0\n\tassert candidate([1,2,3,4,5], 4) == 1\n\tassert candidate([1,2,3,4,5,6,7], 4) == 1\n\tassert candidate([2, 1, 1], 1) == 0\n\tassert candidate([1,1,1,2,2,2], 3) == 0\n\tassert candidate([1], 1) == 0\n\tassert candidate([1,1,1,1,2], 4) == 0\n\tassert candidate([1,2,3,4,5], 6) == 2\n\tassert candidate([1,100000], 1) == 99999\n\tassert candidate([1,2], 1) == 1\n\tassert candidate([1,2,3,4,5,6], 5) == 1\n\tassert candidate(\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22], 10) == 1\n\tassert candidate([100,200,300,400,500,600], 15) == 500\n\tassert candidate([1,2,3], 2) == 1\n\tassert candidate([2,2,2,2,2], 5) == 0\n\tassert candidate([1,2,3], 1) == 1\n\tassert candidate([1000, 1000, 3, 2], 1) == 0\n\tassert candidate([1,1,1], 2) == 0\n\tassert candidate([1,2,3,4,5], 7) == 2\n\tassert candidate([1,2,3,4,5,6,7], 3) == 1\n\tassert candidate([2,2,2,2,2], 10) == 0\n\tassert candidate([1,2,3,4], 1) == 1\n\tassert candidate([1,2,3,4,5,6,7], 6) == 1\n\tassert candidate([1,2,3,4,5], 1) == 1\n\tassert candidate([1,10,20,30,40,50], 1) == 9\n\tassert candidate([6, 3, 7, 4, 1, 2], 4) == 1\n\tassert candidate([2, 2, 2, 3, 3, 3, 5, 5], 12) == 1\n\tassert candidate([1,6,1], 3) == 5\n\tassert candidate([1,2,3,4,5], 2) == 1\n\tassert candidate([1,2,3,4,5], 3) == 1\n\tassert candidate([1,2,3,4,5], 5) == 2\n\tassert candidate([100,200,300,400,500,600], 1) == 100\n\tassert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 1\ndef test_check():\n\tcheck(smallestDistancePair)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,two-pointers,binary-search,sorting\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 520, "filename": "LeetCode_520_countOfAtoms.py", "content": "def countOfAtoms(formula: str) -> str:\n    \"\"\"\n    Given a string formula representing a chemical formula, return the count of each atom.\n    The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\n    One or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow.\n\n    For example, \"H2O\" and \"H2O2\" are possible, but \"H1O2\" is impossible.\n\n    Two formulas are concatenated together to produce another formula.\n\n    For example, \"H2O2He3Mg4\" is also a formula.\n\n    A formula placed in parentheses, and a count (optionally added) is also a formula.\n\n    For example, \"(H2O2)\" and \"(H2O2)3\" are formulas.\n\n    Return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\n    The test cases are generated so that all the values in the output fit in a 32-bit integer.\n\u00a0\n    Example 1:\n\n    Input: formula = \"H2O\"\n    Output: \"H2O\"\n    Explanation: The count of elements are {'H': 2, 'O': 1}.\n\n    Example 2:\n\n    Input: formula = \"Mg(OH)2\"\n    Output: \"H2MgO2\"\n    Explanation: The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.\n\n    Example 3:\n\n    Input: formula = \"K4(ON(SO3)2)2\"\n    Output: \"K4N2O14S4\"\n    Explanation: The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.\n\n\u00a0\n    Constraints:\n\n    1 <= formula.length <= 1000\n    formula consists of English letters, digits, '(', and ')'.\n    formula is always valid.\n\n    \"\"\"\n    ### Canonical solution below ###\n    from collections import Counter\n\n    assert isinstance(formula, str), \"formula must be a string\"\n    assert all(c.isalnum() or c in \"()0123456789\" for c in formula), \"formula must consist of valid characters\"\n    assert all(formula.count(c) >= formula.count(c.lower()) for c in set(formula) if c.isalpha()), \"invalid use of lowercase letters\"\n\n    def parse(formula, i):\n        counts = Counter()\n        while i[0] < len(formula):\n            if formula[i[0]] == '(':\n                i[0] += 1\n                temp = parse(formula, i)\n                count = 0\n                while i[0] < len(formula) and formula[i[0]].isdigit():\n                    count = count * 10 + int(formula[i[0]])\n                    i[0] += 1\n                if count == 0:\n                    count = 1\n                for name, c in temp.items():\n                    counts[name] += c * count\n            elif formula[i[0]] == ')':\n                i[0] += 1\n                return counts\n            else:\n                name = formula[i[0]]\n                i[0] += 1\n                while i[0] < len(formula) and formula[i[0]].islower():\n                    name += formula[i[0]]\n                    i[0] += 1\n                count = 0\n                while i[0] < len(formula) and formula[i[0]].isdigit():\n                    count = count * 10 + int(formula[i[0]])\n                    i[0] += 1\n                if count == 0:\n                    count = 1\n                counts[name] += count\n        return counts\n    \n    i = [0]\n    counts = parse(formula, i)\n    ans = []\n    for name, count in sorted(counts.items()):\n        ans.append(name)\n        if count > 1:\n            ans.append(str(count))\n\n    result = ''.join(ans)\n\n    # Postconditions\n    assert isinstance(result, str), \"The result must be a string\"\n    assert all(result[i].isdigit() for i in range(1, len(result), 2) if result[i].isdigit()), \"Element counts must be in the correct position\"\n    assert len(result) <= len(formula) * 2, \"Result length should not exceed twice the input length\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"(H2O2)3\") == \"H6O6\"\n\tassert candidate(\"(((H)2)8)4\") == \"H64\"\n\tassert candidate(\"(((H)2)8)4N2O14S4\") == \"H64N2O14S4\"\n\tassert candidate(\"Be32\") == \"Be32\"\n\tassert candidate(\"(H2O2)\") == \"H2O2\"\n\tassert candidate(\"(C6H12O6)2\") == \"C12H24O12\"\n\tassert candidate(\"((H)8)4\") == \"H32\"\n\tassert candidate(\"((H))4\") == \"H4\"\n\tassert candidate(\"(Cl)3(F)7\") == \"Cl3F7\"\n\tassert candidate(\"H2O2(H2O2)H2O2\") == \"H6O6\"\n\tassert candidate(\"(H2O)10\") == \"H20O10\"\n\tassert candidate(\"\") == \"\"\n\tassert candidate(\"H50\") == \"H50\"\n\tassert candidate(\"O0\") == \"O\"\n\tassert candidate(\"(C12H22O11)2\") == \"C24H44O22\"\n\tassert candidate(\"C6H12O6\") == \"C6H12O6\"\n\tassert candidate(\"(H)2\") == \"H2\"\n\tassert candidate(\"H2O\") == \"H2O\"\n\tassert candidate(\"(H)2(H)2\") == \"H4\"\n\tassert candidate(\"H2O2\") == \"H2O2\"\n\tassert candidate(\"C12H22O11\") == \"C12H22O11\"\n\tassert candidate(\"(H)0\") == \"H\"\ndef test_check():\n\tcheck(countOfAtoms)\n# Metadata Difficulty: Hard\n# Metadata Topics: hash-table,string,stack,sorting\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 558, "filename": "LeetCode_558_minSwapsCouples.py", "content": "from typing import List\n\n\ndef minSwapsCouples(row: List[int]) -> int:\n    \"\"\"\n    There are n couples sitting in 2n seats arranged in a row and want to hold hands.\n    The people and seats are represented by an integer array row where row[i] is the ID of the person sitting in the ith seat. The couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2n - 2, 2n - 1).\n    Return the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.\n\u00a0\n    Example 1:\n\n    Input: row = [0,2,1,3]\n    Output: 1\n    Explanation: We only need to swap the second (row[1]) and third (row[2]) person.\n\n    Example 2:\n\n    Input: row = [3,2,0,1]\n    Output: 0\n    Explanation: All couples are already seated side by side.\n\n\u00a0\n    Constraints:\n\n    2n == row.length\n    2 <= n <= 30\n    n is even.\n    0 <= row[i] < 2n\n    All the elements of row are unique.\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(row, list), \"row must be a list\"\n    assert all(isinstance(x, int) for x in row), \"all elements in row must be integers\"\n    assert len(row) % 2 == 0, \"row length must be even\"\n    assert 2 <= len(row) // 2 <= 30, \"number of couples must be between 2 and 30\"\n    assert len(set(row)) == len(row), \"all elements in row must be unique\"\n    assert all(0 <= x < len(row) for x in row), \"all elements in row must be within the valid range\"\n\n    n = len(row) // 2\n    swaps = 0\n    position = {num: i for i, num in enumerate(row)}\n\n    for i in range(0, len(row), 2):\n        couple = row[i] - 1 if row[i] % 2 else row[i] + 1\n        if row[i + 1] != couple:\n            row[i + 1], row[position[couple]] = row[position[couple]], row[i + 1]\n            position[row[i + 1]], position[couple] = position[couple], i + 1\n            swaps += 1\n\n    # Postconditions\n    assert isinstance(swaps, int), \"The result must be an integer\"\n    assert swaps >= 0, \"The number of swaps cannot be negative\"\n    assert swaps <= len(row) // 2, \"The number of swaps should not exceed half the length of the row\"\n    assert len(row) % 2 == 0, \"The length of row should remain even after the swaps\"\n    assert all(isinstance(x, int) for x in row), \"Elements in row should remain integers after the swaps\"\n    \n    return swaps\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([0, 1, 2, 3]) == 0\n\tassert candidate(\n    [0, 1, 4, 2, 3, 6, 7, 5, 8, 9]) == 3\n\tassert candidate([0, 2, 4, 3, 1, 5, 7, 6, 8, 9]) == 2\n\tassert candidate([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == 0\n\tassert candidate([1, 0, 3, 2, 5, 4, 7, 6, 9, 8]) == 0\n\tassert candidate([3, 0, 4, 1, 7, 2, 9, 5, 6, 8]) == 4\n\tassert candidate([1, 4, 0, 2, 3, 5]) == 2\n\tassert candidate([0, 2, 1, 3, 5, 4, 7, 6, 8, 9]) == 1\n\tassert candidate([0, 1, 2, 4, 3, 5]) == 1\ndef test_check():\n\tcheck(minSwapsCouples)\n# Metadata Difficulty: Hard\n# Metadata Topics: greedy,depth-first-search,breadth-first-search,union-find,graph\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 625, "filename": "LeetCode_625_rectangleArea.py", "content": "from typing import List\n\n\ndef rectangleArea(rectangles: List[List[int]]) -> int:\n    \"\"\"\n    You are given a 2D array of axis-aligned rectangles. Each rectangle[i] = [xi1, yi1, xi2, yi2] denotes the ith rectangle where (xi1, yi1) are the coordinates of the bottom-left corner, and (xi2, yi2) are the coordinates of the top-right corner.\n    Calculate the total area covered by all rectangles in the plane. Any area covered by two or more rectangles should only be counted once.\n    Return the total area. Since the answer may be too large, return it modulo 109 + 7.\n\u00a0\n    Example 1:\n\n\n    Input: rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]\n    Output: 6\n    Explanation: A total area of 6 is covered by all three rectangles, as illustrated in the picture.\n    From (1,1) to (2,2), the green and red rectangles overlap.\n    From (1,0) to (2,3), all three rectangles overlap.\n\n    Example 2:\n\n    Input: rectangles = [[0,0,1000000000,1000000000]]\n    Output: 49\n    Explanation: The answer is 1018 modulo (109 + 7), which is 49.\n\n\u00a0\n    Constraints:\n\n    1 <= rectangles.length <= 200\n    rectanges[i].length == 4\n    0 <= xi1, yi1, xi2, yi2 <= 109\n    xi1 <= xi2\n    yi1 <= yi2\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(rectangles, list), \"rectangles must be a list\"\n    assert all(isinstance(rect, list) and len(rect) == 4 for rect in rectangles), \"Each rectangle must be a list of four integers\"\n    assert all(isinstance(coord, int) and 0 <= coord <= 10**9 for rect in rectangles for coord in rect), \"Each coordinate must be an integer between 0 and 10^9\"\n    assert all(rect[0] <= rect[2] and rect[1] <= rect[3] for rect in rectangles), \"Each rectangle's top-right corner must be greater than or equal to the bottom-left corner\"\n    assert 1 <= len(rectangles) <= 200, \"The number of rectangles must be between 1 and 200\"\n\n    mod = 10**9 + 7\n    n = len(rectangles)\n    X, Y = set(), set()\n    for rect in rectangles:\n        X.add(rect[0])\n        X.add(rect[2])\n        Y.add(rect[1])\n        Y.add(rect[3])\n    sorted_x = sorted(X)\n    sorted_y = sorted(Y)\n    cnt = [[0 for _ in range(len(Y) - 1)] for _ in range(len(X) - 1)]\n\n    for rect in rectangles:\n        x1_idx = sorted_x.index(rect[0])\n        x2_idx = sorted_x.index(rect[2]) - 1\n        y1_idx = sorted_y.index(rect[1])\n        y2_idx = sorted_y.index(rect[3]) - 1\n        for i in range(x1_idx, x2_idx + 1):\n            for j in range(y1_idx, y2_idx + 1):\n                cnt[i][j] = 1\n\n    total_area = 0\n    for i in range(len(X) - 1):\n        for j in range(len(Y) - 1):\n            if cnt[i][j]:\n                total_area += (sorted_x[i + 1] - sorted_x[i]) * (sorted_y[j + 1] - sorted_y[j])\n                total_area %= mod\n\n    # Postconditions\n    assert isinstance(total_area, int), \"The result must be an integer\"\n    assert total_area >= 0, \"The area cannot be negative\"\n    assert total_area < mod, \"The area should be less than 10^9 + 7\"\n    assert all(isinstance(x, int) for x in sorted_x), \"Sorted x-coordinates should all be integers\"\n    assert all(isinstance(y, int) for y in sorted_y), \"Sorted y-coordinates should all be integers\"\n    assert all(isinstance(c, int) for row in cnt for c in row), \"All elements in the count matrix should be integers\"\n    \n    return total_area\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([[0,0,1,1],[1,1,2,2]]) == 2\n\tassert candidate([[0,0,2,2],[0,2,2,4],[2,0,4,2],[2,2,4,4]]) == 16\n\tassert candidate([[0,0,1,1],[0,0,1,1]]) == 1\n\tassert candidate([[0,0,1000000000,1000000000]]) == 49\n\tassert candidate([[0,0,1,1],[0,1,1,2],[1,0,2,1],[1,1,2,2]]) == 4\n\tassert candidate([[0,0,5,5],[1,1,4,4]]) == 25\n\tassert candidate([[0,0,0,0],[0,0,0,0]]) == 0\n\tassert candidate([[0,0,1,1],[1,0,2,1],[0,1,1,2],[1,1,2,2]]) == 4\n\tassert candidate([[0,0,10,10],[0,10,10,20],[0,20,10,30]]) == 300\n\tassert candidate([[1,1,3,3],[1,1,3,3],[1,1,3,3]]) == 4\n\tassert candidate([[1,1,3,3]]) == 4\n\tassert candidate([[0,0,1,1],[1,0,2,1],[2,0,3,1],[3,0,4,1]]) == 4\n\tassert candidate([[1,1,3,3],[1,1,4,4],[0,0,2,2],[2,2,4,4]]) == 12\n\tassert candidate([[0,0,1,1],[1,0,2,2],[1,1,3,3],[0,1,2,3]]) == 8\n\tassert candidate([[1,1,3,3],[1,1,3,3]]) == 4\n\tassert candidate([[0,0,10,10],[10,0,20,10],[20,0,30,10]]) == 300\n\tassert candidate([[0,0,2,2],[1,1,3,3]]) == 7\n\tassert candidate([[0,0,2,2],[1,0,2,3],[1,0,3,1]]) == 6\ndef test_check():\n\tcheck(rectangleArea)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,segment-tree,line-sweep,ordered-set\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 631, "filename": "LeetCode_631_consecutive_numbers_sum.py", "content": "def consecutive_numbers_sum(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.\n\u00a0\n    Example 1:\n\n    Input: n = 5\n    Output: 2\n    Explanation: 5 = 2 + 3\n\n    Example 2:\n\n    Input: n = 9\n    Output: 3\n    Explanation: 9 = 4 + 5 = 2 + 3 + 4\n\n    Example 3:\n\n    Input: n = 15\n    Output: 4\n    Explanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 109\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(n, int), \"Input must be an integer\"\n    assert n > 0, \"Input must be a positive integer\"\n    assert n <= 10**9, \"Input must be less than or equal to 10^9\"\n    assert n % 1 == 0, \"Input must be a whole number\"\n    assert n >= 1, \"Input must be at least 1\"\n\n    count = 0\n    i = 1\n    while i * (i - 1) // 2 < n:\n        if (n - i * (i - 1) // 2) % i == 0:\n            count += 1\n        i += 1\n    \n    # Postconditions\n    assert isinstance(count, int), \"Output must be an integer\"\n    assert count >= 1, \"There must be at least one way to express the number as a sum of consecutive integers\"\n    assert count <= n, \"The number of ways cannot exceed n\"\n    assert (count % 1) == 0, \"Output must be a whole number\"\n    assert all(isinstance(i, int) for i in range(1, n+1) if (n - i * (i - 1) // 2) % i == 0), \"All divisors must be integers\"\n    assert all(i > 0 for i in range(1, n+1) if (n - i * (i - 1) // 2) % i == 0), \"All counts must be positive integers\"\n    assert count >= 1, \"The count of possible sums must be at least 1\"\n\n    return count\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(674) == 2\n\tassert candidate(1) == 1\n\tassert candidate(21) == 4\n\tassert candidate(33) == 4\n\tassert candidate(54) == 4\n\tassert candidate(12) == 2\n\tassert candidate(100) == 3\n\tassert candidate(998) == 2\n\tassert candidate(22) == 2\n\tassert candidate(41) == 2\n\tassert candidate(17) == 2\n\tassert candidate(30) == 4\n\tassert candidate(2) == 1\n\tassert candidate(15) == 4\n\tassert candidate(62) == 2\n\tassert candidate(26) == 2\n\tassert candidate(37) == 2\n\tassert candidate(43) == 2\n\tassert candidate(427) == 4\n\tassert candidate(25) == 3\n\tassert candidate(16) == 1\n\tassert candidate(31) == 2\n\tassert candidate(7) == 2\n\tassert candidate(102) == 4\n\tassert candidate(11) == 2\n\tassert candidate(19) == 2\n\tassert candidate(23) == 2\n\tassert candidate(42) == 4\n\tassert candidate(3) == 2\n\tassert candidate(40) == 2\n\tassert candidate(133) == 4\n\tassert candidate(35) == 4\n\tassert candidate(49) == 3\n\tassert candidate(9) == 3\n\tassert candidate(132) == 4\n\tassert candidate(32) == 1\n\tassert candidate(20) == 2\n\tassert candidate(103) == 2\n\tassert candidate(18) == 3\n\tassert candidate(10) == 2\n\tassert candidate(5) == 2\n\tassert candidate(6) == 2\n\tassert candidate(74) == 2\n\tassert candidate(34) == 2\n\tassert candidate(88) == 2\n\tassert candidate(53) == 2\n\tassert candidate(13) == 2\n\tassert candidate(8) == 1\n\tassert candidate(14) == 2\n\tassert candidate(36) == 3\n\tassert candidate(388) == 2\n\tassert candidate(64) == 1\n\tassert candidate(38) == 2\n\tassert candidate(29) == 2\n\tassert candidate(28) == 2\n\tassert candidate(52) == 2\n\tassert candidate(4) == 1\n\tassert candidate(45) == 6\ndef test_check():\n\tcheck(consecutive_numbers_sum)\n# Metadata Difficulty: Hard\n# Metadata Topics: math,enumeration\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 710, "filename": "LeetCode_710_numMusicPlaylists.py", "content": "def numMusicPlaylists(n: int, goal: int, k: int) -> int:\n    \"\"\"\n    Your music player contains n different songs. You want to listen to goal songs (not necessarily different) during your trip. To avoid boredom, you will create a playlist so that:\n\n    Every song is played at least once.\n    A song can only be played again only if k other songs have been played.\n\n    Given n, goal, and k, return the number of possible playlists that you can create. Since the answer can be very large, return it modulo 109 + 7.\n\u00a0\n    Example 1:\n\n    Input: n = 3, goal = 3, k = 1\n    Output: 6\n    Explanation: There are 6 possible playlists: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\n    Example 2:\n\n    Input: n = 2, goal = 3, k = 0\n    Output: 6\n    Explanation: There are 6 possible playlists: [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], and [1, 2, 2].\n\n    Example 3:\n\n    Input: n = 2, goal = 3, k = 1\n    Output: 2\n    Explanation: There are 2 possible playlists: [1, 2, 1] and [2, 1, 2].\n\n\u00a0\n    Constraints:\n\n    0 <= k < n <= goal <= 100\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(n, int) and n > 0, \"n must be a positive integer\"\n    assert isinstance(goal, int) and goal > 0, \"goal must be a positive integer\"\n    assert n <= 100, \"n must be less than or equal to 100\"\n\n    MOD = 1000000007\n    dp = [[0] * (n + 1) for _ in range(goal + 1)]\n    dp[0][0] = 1\n    for i in range(1, goal + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j - 1] * (n - (j - 1)) % MOD + dp[i - 1][j] * max(0, j - k) % MOD) % MOD\n    \n    result = dp[goal][n]\n    \n    # Postconditions\n    assert isinstance(result, int), \"The result must be an integer\"\n    assert result >= 0, \"The result must be non-negative\"\n    assert result < MOD, \"The result must be less than MOD\"\n    assert all(dp[i][j] >= 0 for i in range(goal + 1) for j in range(n + 1)), \"All values in dp should be non-negative\"\n    assert dp[goal][n] == result, \"Final result must match the dp[goal][n]\"\n    assert sum(dp[goal]) >= result, \"The sum of dp[goal] should be greater than or equal to the result\"\n\n    return result\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(6, 6, 1) == 720\n\tassert candidate(3, 3, 1) == 6\n\tassert candidate(2, 2, 1) == 2\n\tassert candidate(10, 1, 3) == 0\n\tassert candidate(4, 4, 1) == 24\n\tassert candidate(10, 10, 1) == 3628800\n\tassert candidate(10, 10, 0) == 3628800\n\tassert candidate(1, 1, 0) == 1\n\tassert candidate(4, 4, 0) == 24\n\tassert candidate(1, 1, 1) == 1\n\tassert candidate(1, 1, 10) == 1\n\tassert candidate(3, 3, 2) == 6\n\tassert candidate(10, 10, 4) == 3628800\n\tassert candidate(6, 6, 0) == 720\n\tassert candidate(10, 10, 2) == 3628800\n\tassert candidate(5, 5, 2) == 120\n\tassert candidate(2, 2, 10) == 2\n\tassert candidate(10, 10, 5) == 3628800\n\tassert candidate(1, 1, 2) == 1\n\tassert candidate(10, 10, 10) == 3628800\n\tassert candidate(5, 5, 0) == 120\n\tassert candidate(10, 10, 7) == 3628800\n\tassert candidate(2, 2, 2) == 2\n\tassert candidate(10, 10, 8) == 3628800\n\tassert candidate(10, 10, 3) == 3628800\n\tassert candidate(2, 2, 0) == 2\n\tassert candidate(2, 3, 0) == 6\n\tassert candidate(3, 3, 0) == 6\n\tassert candidate(10, 10, 9) == 3628800\n\tassert candidate(10, 10, 6) == 3628800\ndef test_check():\n\tcheck(numMusicPlaylists)\n# Metadata Difficulty: Hard\n# Metadata Topics: math,dynamic-programming,combinatorics\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 730, "filename": "LeetCode_730_distinctSubseqII.py", "content": "def distinctSubseqII(s: str) -> int:\n    \"\"\"\n    Given a string s, return the number of distinct non-empty subsequences of s. Since the answer may be very large, return it modulo 109 + 7.\n    A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not.\n\u00a0\n    Example 1:\n\n    Input: s = \"abc\"\n    Output: 7\n    Explanation: The 7 distinct subsequences are \"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", and \"abc\".\n\n    Example 2:\n\n    Input: s = \"aba\"\n    Output: 6\n    Explanation: The 6 distinct subsequences are \"a\", \"b\", \"ab\", \"aa\", \"ba\", and \"aba\".\n\n    Example 3:\n\n    Input: s = \"aaa\"\n    Output: 3\n    Explanation: The 3 distinct subsequences are \"a\", \"aa\" and \"aaa\".\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 2000\n    s consists of lowercase English letters.\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(s, str), \"Input must be a string\"\n    assert 1 <= len(s) <= 2000, \"String length must be between 1 and 2000\"\n    assert s.islower(), \"String must consist of lowercase English letters\"\n    assert all('a' <= c <= 'z' for c in s), \"String must contain only lowercase letters\"\n    assert len(s) == len(s.strip()), \"String should not have leading or trailing spaces\"\n\n    mod = 10**9 + 7\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    last = [-1] * 26\n\n    for i in range(1, n + 1):\n        dp[i] = (dp[i - 1] * 2) % mod\n        if last[ord(s[i - 1]) - ord('a')] != -1:\n            dp[i] = (dp[i] - dp[last[ord(s[i - 1]) - ord('a')]] + mod) % mod\n        last[ord(s[i - 1]) - ord('a')] = i - 1\n\n    dp[n] = (dp[n] - 1 + mod) % mod\n    result = dp[n]\n\n    # Postconditions\n    assert isinstance(result, int), \"The result must be an integer\"\n    assert result >= 0, \"The result must be non-negative\"\n    assert result < mod, \"The result must be less than mod\"\n    assert result == dp[n], \"Final result must match dp[n]\"\n    assert len(dp) == n + 1, \"The dp array must have a length of n + 1\"\n    assert all(0 <= x < mod for x in dp), \"All dp values must be non-negative and less than mod\"\n    assert dp[0] == 1, \"The base case dp[0] must be 1\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate('ab') == 3\n\tassert candidate('abcdefghijklm') == 8191\n\tassert candidate('abcd') == 15\n\tassert candidate('abcdefghi') == 511\n\tassert candidate('aaa') == 3\n\tassert candidate('abcde') == 31\n\tassert candidate('abc') == 7\n\tassert candidate(\n    'aaa') == 3, \"This is because [a,aa] and [aa,a] are both subsequences of aaa.\"\n\tassert candidate('ba') == 3\n\tassert candidate('aba') == 6\n\tassert candidate('abcdefg') == 127\n\tassert candidate('abcdefghijklmnopqrstuvwx') == 16777215\n\tassert candidate('abcdefghij') == 1023\ndef test_check():\n\tcheck(distinctSubseqII)\n# Metadata Difficulty: Hard\n# Metadata Topics: string,dynamic-programming\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 746, "filename": "LeetCode_746_min_k_bit_flips.py", "content": "from typing import List\n\n\ndef min_k_bit_flips(nums: List[int], k: int) -> int:\n    \"\"\"\n    You are given a binary array nums and an integer k.\n    A k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\n    Return the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1.\n    A subarray is a contiguous part of an array.\n\u00a0\n    Example 1:\n\n    Input: nums = [0,1,0], k = 1\n    Output: 2\n    Explanation: Flip nums[0], then flip nums[2].\n\n    Example 2:\n\n    Input: nums = [1,1,0], k = 2\n    Output: -1\n    Explanation: No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1].\n\n    Example 3:\n\n    Input: nums = [0,0,0,1,0,1,1,0], k = 3\n    Output: 3\n    Explanation: \n    Flip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]\n    Flip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]\n    Flip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 105\n    1 <= k <= nums.length\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(nums, list), \"nums should be a list.\"\n    assert all(isinstance(x, int) and x in [0, 1] for x in nums), \"All elements in nums should be 0 or 1.\"\n    assert isinstance(k, int), \"k should be an integer.\"\n    assert 1 <= len(nums) <= 10**5, \"The length of nums should be between 1 and 100000.\"\n    assert 1 <= k <= len(nums), \"k should be between 1 and the length of nums.\"\n\n    n = len(nums)\n    flipped = [0] * n\n    flips = ans = 0\n    for i in range(n):\n        if i >= k:\n            flips -= flipped[i - k]\n        if (flips + nums[i]) % 2 == 0:\n            if i + k > n:\n                return -1\n            flipped[i] = 1\n            flips += 1\n            ans += 1\n\n    # Postconditions\n    assert isinstance(ans, int), \"The result should be an integer.\"\n    assert ans >= -1, \"The result should be -1 or non-negative.\"\n    assert ans <= len(nums), \"The result should not exceed the length of nums.\"\n\n    return ans\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([0,1,0,1,0,1,0,1], 1) == 4\n\tassert candidate([0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1], 3) == -1\n\tassert candidate([0,0,0,1,0,1,1,0], 3) == 3\n\tassert candidate([0,1,0], 1) == 2\n\tassert candidate([1,0,0,1,0,1,1,0], 2) == 4\n\tassert candidate([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], 2) == 8\n\tassert candidate([1,1,0], 1) == 1\n\tassert candidate([1,1,0], 2) == -1\n\tassert candidate([1,1,1,1], 1) == 0\n\tassert candidate([0], 1) == 1\n\tassert candidate([0,0,0,1,0,1,1,0], 2) == -1\n\tassert candidate([1,0], 2) == -1\n\tassert candidate([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], 4) == 4\n\tassert candidate([0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1], 2) == 8\n\tassert candidate([0,0,0,0,0,0,0,0,0,0], 2) == 5\ndef test_check():\n\tcheck(min_k_bit_flips)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,bit-manipulation,queue,sliding-window,prefix-sum\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 747, "filename": "LeetCode_747_numSquarefulPerms.py", "content": "from typing import List\n\n\ndef numSquarefulPerms(nums: List[int]) -> int:\n    \"\"\"\n    An array is squareful if the sum of every pair of adjacent elements is a perfect square.\n    Given an integer array nums, return the number of permutations of nums that are squareful.\n    Two permutations perm1 and perm2 are different if there is some index i such that perm1[i] != perm2[i].\n\u00a0\n    Example 1:\n\n    Input: nums = [1,17,8]\n    Output: 2\n    Explanation: [1,8,17] and [17,8,1] are the valid permutations.\n\n    Example 2:\n\n    Input: nums = [2,2,2]\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 12\n    0 <= nums[i] <= 109\n\n    \"\"\"\n    ### Canonical solution below ###\n    from collections import Counter\n\n    # Preconditions\n    assert isinstance(nums, list), \"nums should be a list.\"\n    assert all(isinstance(x, int) for x in nums), \"All elements in nums should be integers.\"\n    assert all(0 <= x <= 10**9 for x in nums), \"Each element in nums should be between 0 and 10^9.\"\n    assert len(nums) > 0, \"nums should not be empty.\"\n\n    def is_square(n):\n        return int(n ** 0.5) ** 2 == n\n\n    def dfs(idx):\n        if idx == len(nums):\n            return 1\n\n        count = 0\n        for key in counter.keys():\n            if counter[key] and (idx == 0 or is_square(nums[idx - 1] + key)):\n                counter[key] -= 1\n                nums[idx] = key\n                count += dfs(idx + 1)\n                counter[key] += 1\n\n        return count\n\n    key_set, counter = set(nums), Counter(nums)\n    result = dfs(0)\n\n    # Postconditions\n    assert isinstance(result, int), \"The result should be an integer.\"\n    assert result >= 0, \"The result should be non-negative.\"\n    assert result <= len(nums) * len(nums), \"The result should not exceed len(nums) * len(nums).\"\n    assert result <= 2 ** len(nums), \"The result should not exceed 2^len(nums).\"\n    assert len(set(nums)) == 1 or result == 0 or result > 0, \"If nums has more than one unique value, result should be greater than 0.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1,2,2,3,3,3]) == 0\n\tassert candidate([2,2,2,2,2,2,2,2,2,2,2,2]) == 1\n\tassert candidate([2,2,2]) == 1\n\tassert candidate([2,2,2,2,2,2]) == 1\n\tassert candidate([1,1,1,1,1,1,1,1,1,1,1,8]) == 0\n\tassert candidate([1,1,1,1,1,1,1,1,1,1,1,17]) == 0\n\tassert candidate(\n    [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]) == 1\n\tassert candidate([1,2,3,4,5,6,7,8,9]) == 0\n\tassert candidate(\n    [1,1,1,1,1,1,1,1,1,1,1,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17]) == 0\n\tassert candidate([1,17,8]) == 2\n\tassert candidate(\n    [1,1,1,1,1,1,1,1,1,1,1,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17]) == 0\ndef test_check():\n\tcheck(numSquarefulPerms)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,math,dynamic-programming,backtracking,bit-manipulation,bitmask\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 766, "filename": "LeetCode_766_odd_even_jumps.py", "content": "from typing import List\n\n\ndef odd_even_jumps(arr: List[int]) -> int:\n    \"\"\"\n    You are given an integer array arr. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called odd-numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even-numbered jumps. Note that the jumps are numbered, not the indices.\n    You may jump forward from index i to index j (with i < j) in the following way:\n\n    During odd-numbered jumps (i.e., jumps 1, 3, 5, ...), you jump to the index j such that arr[i] <= arr[j] and arr[j] is the smallest possible value. If there are multiple such indices j, you can only jump to the smallest such index j.\n    During even-numbered jumps (i.e., jumps 2, 4, 6, ...), you jump to the index j such that arr[i] >= arr[j] and arr[j] is the largest possible value. If there are multiple such indices j, you can only jump to the smallest such index j.\n    It may be the case that for some index i, there are no legal jumps.\n\n    A starting index is good if, starting from that index, you can reach the end of the array (index arr.length - 1) by jumping some number of times (possibly 0 or more than once).\n    Return the number of good starting indices.\n\u00a0\n    Example 1:\n\n    Input: arr = [10,13,12,14,15]\n    Output: 2\n    Explanation: \n    From starting index i = 0, we can make our 1st jump to i = 2 (since arr[2] is the smallest among arr[1], arr[2], arr[3], arr[4] that is greater or equal to arr[0]), then we cannot jump any more.\n    From starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.\n    From starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.\n    From starting index i = 4, we have reached the end already.\n    In total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number of\n    jumps.\n\n    Example 2:\n\n    Input: arr = [2,3,1,1,4]\n    Output: 3\n    Explanation: \n    From starting index i = 0, we make jumps to i = 1, i = 2, i = 3:\n    During our 1st jump (odd-numbered), we first jump to i = 1 because arr[1] is the smallest value in [arr[1], arr[2], arr[3], arr[4]] that is greater than or equal to arr[0].\n    During our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr[2] is the largest value in [arr[2], arr[3], arr[4]] that is less than or equal to arr[1]. arr[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3\n    During our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr[3] is the smallest value in [arr[3], arr[4]] that is greater than or equal to arr[2].\n    We can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.\n    In a similar manner, we can deduce that:\n    From starting index i = 1, we jump to i = 4, so we reach the end.\n    From starting index i = 2, we jump to i = 3, and then we can't jump anymore.\n    From starting index i = 3, we jump to i = 4, so we reach the end.\n    From starting index i = 4, we are already at the end.\n    In total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with some\n    number of jumps.\n\n    Example 3:\n\n    Input: arr = [5,1,3,4,2]\n    Output: 3\n    Explanation: We can reach the end from starting indices 1, 2, and 4.\n\n\u00a0\n    Constraints:\n\n    1 <= arr.length <= 2 * 104\n    0 <= arr[i] < 105\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(arr, list), \"arr should be a list.\"\n    assert all(isinstance(x, int) for x in arr), \"All elements in arr should be integers.\"\n    assert 1 <= len(arr) <= 2 * 10**4, \"The length of arr should be between 1 and 20,000.\"\n    assert all(0 <= x < 10**5 for x in arr), \"Each element in arr should be between 0 and 100,000.\"\n    assert len(arr) > 0, \"arr should not be empty.\"\n\n    n = len(arr)\n    can_reach_odd = [False] * n\n    can_reach_even = [False] * n\n    can_reach_odd[-1] = can_reach_even[-1] = True\n\n    index_map = {}\n    index_map[arr[-1]] = n - 1\n\n    good_indices = 1\n    for i in range(n - 2, -1, -1):\n        odd_jump = next(iter([value for value in index_map if value >= arr[i]]), None)\n        even_jump = next(iter([value for value in index_map if value <= arr[i]]), None)\n\n        if odd_jump is not None:\n            can_reach_odd[i] = can_reach_even[index_map[odd_jump]]\n        if even_jump is not None:\n            can_reach_even[i] = can_reach_odd[index_map[even_jump]]\n\n        if can_reach_odd[i]:\n            good_indices += 1\n\n        index_map[arr[i]] = i\n\n    result = good_indices\n\n    # Postconditions\n    assert isinstance(result, int), \"The result should be an integer.\"\n    assert result >= 0, \"The result should be non-negative.\"\n    assert result <= len(arr), \"The result should not exceed the length of arr.\"\n    assert result <= 2**len(arr), \"The result should not exceed 2^len(arr).\"\n    assert result == len(arr) or result < len(arr), \"The result should be either the length of arr or less.\"\n    assert all(isinstance(x, int) for x in arr), \"All elements in arr should still be integers.\"\n    assert len(set(arr)) == len(arr) or len(set(arr)) < len(arr), \"The array should have unique or non-unique elements.\"\n\n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1, 3, 2]) == 2\n\tassert candidate([1, 2]) == 2\n\tassert candidate([4, 3, 2, 1]) == 1\n\tassert candidate([3, 2, 1]) == 1\n\tassert candidate([1] * 100) == 100\n\tassert candidate([i for i in range(100, 0, -1)]) == 1\n\tassert candidate([5, 1, 3, 4, 2]) == 3\n\tassert candidate([2, 1]) == 1\n\tassert candidate([1, 2, 3, 4]) == 4\n\tassert candidate([i for i in range(1, 101)]) == 100\n\tassert candidate([1, 2, 3, 2, 1]) == 3\n\tassert candidate([1, 2, 3, 4, 5]) == 5\n\tassert candidate([1]) == 1\n\tassert candidate([1, 1, 1, 1, 1]) == 5\n\tassert candidate([5, 4, 3, 2, 1]) == 1\ndef test_check():\n\tcheck(odd_even_jumps)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,dynamic-programming,stack,monotonic-stack,ordered-set\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 846, "filename": "LeetCode_846_last_substring.py", "content": "def last_substring(s: str) -> str:\n    \"\"\"\n    Given a string s, return the last substring of s in lexicographical order.\n\u00a0\n    Example 1:\n\n    Input: s = \"abab\"\n    Output: \"bab\"\n    Explanation: The substrings are [\"a\", \"ab\", \"aba\", \"abab\", \"b\", \"ba\", \"bab\"]. The lexicographically maximum substring is \"bab\".\n\n    Example 2:\n\n    Input: s = \"leetcode\"\n    Output: \"tcode\"\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 4 * 10^5\n    s contains only lowercase English letters.\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(s, str), \"Input must be a string.\"\n    assert all(c.islower() and c.isalpha() for c in s), \"The string must contain only lowercase English letters.\"\n\n    i, j, k, n = 0, 1, 0, len(s)\n    while j + k < n:\n        if s[i + k] == s[j + k]:\n            k += 1\n        elif s[i + k] < s[j + k]:\n            i = j\n            j += 1\n            k = 0\n        else:\n            j += 1\n            k = 0\n\n    result = s[i:]\n\n    # Postconditions\n    assert isinstance(result, str), \"Output must be a string.\"\n    assert all(c.islower() and c.isalpha() for c in result), \"The output must contain only lowercase English letters.\"\n    assert len(result) <= len(s), \"The length of the output must be less than or equal to the input string.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"cba\") == \"cba\"\n\tassert candidate(\"a\"*10000) == \"a\"*10000\n\tassert candidate(\"abcbabcd\") == \"d\"\n\tassert candidate(\"c\") == \"c\"\n\tassert candidate(\"bacdab\") == \"dab\"\n\tassert candidate(\"abcbac\") == \"cbac\"\n\tassert candidate(\"abcabcbac\") == \"cbac\"\n\tassert candidate(\"cab\") == \"cab\"\n\tassert candidate(\"ba\") == \"ba\"\n\tassert candidate(\"abcabc\") == \"cabc\"\n\tassert candidate(\"abcab\") == \"cab\"\n\tassert candidate(\"abc\") == \"c\"\n\tassert candidate(\"abcabcabc\") == \"cabcabc\"\n\tassert candidate(\"bca\") == \"ca\"\n\tassert candidate(\"ecbacba\") == \"ecbacba\"\n\tassert candidate(\"abbcc\") == \"cc\"\n\tassert candidate(\"ecbabc\") == \"ecbabc\"\n\tassert candidate(\"abcabcabcabc\") == \"cabcabcabc\"\n\tassert candidate(\"cbacbabc\") == \"cbacbabc\"\n\tassert candidate(\"dcbab\") == \"dcbab\"\n\tassert candidate(\"aa\") == \"aa\"\n\tassert candidate(\"e\") == \"e\"\n\tassert candidate(\"cbacbacbabc\") == \"cbacbacbabc\"\n\tassert candidate(\"cbabab\") == \"cbabab\"\n\tassert candidate(\"abcba\") == \"cba\"\n\tassert candidate(\"abcbabc\") == \"cbabc\"\n\tassert candidate(\"ed\") == \"ed\"\n\tassert candidate(\"abcbacbac\") == \"cbacbac\"\n\tassert candidate(\"abcd\") == \"d\"\n\tassert candidate(\"aabbcc\") == \"cc\"\n\tassert candidate(\"cbacb\") == \"cbacb\"\n\tassert candidate(\"aaaa\") == \"aaaa\"\n\tassert candidate(\"\") == \"\"\n\tassert candidate(\"cbabac\") == \"cbabac\"\ndef test_check():\n\tcheck(last_substring)\n# Metadata Difficulty: Hard\n# Metadata Topics: two-pointers,string\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 866, "filename": "LeetCode_866_lastSubstring.py", "content": "def lastSubstring(s: str) -> str:\n    \"\"\"\n    Given a string s, return the last substring of s in lexicographical order.\n\u00a0\n    Example 1:\n\n    Input: s = \"abab\"\n    Output: \"bab\"\n    Explanation: The substrings are [\"a\", \"ab\", \"aba\", \"abab\", \"b\", \"ba\", \"bab\"]. The lexicographically maximum substring is \"bab\".\n\n    Example 2:\n\n    Input: s = \"leetcode\"\n    Output: \"tcode\"\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 4 * 105\n    s contains only lowercase English letters.\n\n    \"\"\"\n    assert isinstance(s, str), \"Input must be a string.\"\n    assert 1 <= len(s) <= 4 * 10**5, \"The length of the string must be between 1 and 400,000.\"\n    assert all(c.islower() and c.isalpha() for c in s), \"The string must contain only lowercase English letters.\"\n\n    maxIndex = 0\n    curIndex = 1\n    while curIndex < len(s):\n        i = 0\n        while curIndex + i < len(s) and s[maxIndex + i] == s[curIndex + i]:\n            i += 1\n        if curIndex + i == len(s):\n            break\n        if s[maxIndex + i] < s[curIndex + i]:\n            maxIndex = curIndex\n        curIndex += 1\n    result = s[maxIndex:]\n\n    # Postconditions\n    assert isinstance(result, str), \"Output must be a string.\"\n    assert len(result) > 0, \"The output string must not be empty.\"\n    assert all(c.islower() and c.isalpha() for c in result), \"The output must contain only lowercase English letters.\"\n    assert len(result) <= len(s), \"The length of the output must be less than or equal to the input string.\"\n    assert result == max(s[i:] for i in range(len(s))), \"The output must be the lexicographically largest substring.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"bbbbaaaaaaaaf\") == \"f\"\n\tassert candidate(\"abab\") == \"bab\"\n\tassert candidate(\"data\") == \"ta\"\n\tassert candidate(\"coding\") == \"oding\"\n\tassert candidate(\"ecbacbac\") == \"ecbacbac\"\n\tassert candidate(\"bbaaaaaaaaaf\") == \"f\"\n\tassert candidate(\"cat\") == \"t\"\n\tassert candidate(\"abcab\") == \"cab\"\n\tassert candidate(\"zabcz\") == \"zabcz\"\n\tassert candidate(\"abcdefg\") == \"g\"\n\tassert candidate(\"abcdef\") == \"f\"\n\tassert candidate(\"aaaaaaaaa\") == \"aaaaaaaaa\"\n\tassert candidate(\"qpqpqpq\") == \"qpqpqpq\"\n\tassert candidate(\"a\") == \"a\"\n\tassert candidate(\"qqqqqq\") == \"qqqqqq\"\n\tassert candidate(\"qpqpqpqp\") == \"qpqpqpqp\"\n\tassert candidate(\"qpqpqp\") == \"qpqpqp\"\n\tassert candidate(\"abababab\") == \"bababab\"\n\tassert candidate(\"helloworld\") == \"world\"\n\tassert candidate(\"hbhbhbhbhbhbhbhb\") == \"hbhbhbhbhbhbhbhb\"\n\tassert candidate(\"aaaaaaaaaaf\") == \"f\"\n\tassert candidate(\"aaab\") == \"b\"\n\tassert candidate(\"python\") == \"ython\"\n\tassert candidate(\"leetcode\") == \"tcode\"\n\tassert candidate(\"abcabc\") == \"cabc\"\n\tassert candidate(\"aaa\") == \"aaa\"\n\tassert candidate(\"hello\") == \"o\"\n\tassert candidate(\"aaaaaaab\") == \"b\"\n\tassert candidate(\"aa\") == \"aa\"\n\tassert candidate(\"eee\") == \"eee\"\n\tassert candidate(\"cbda\") == \"da\"\n\tassert candidate(\"banana\") == \"nana\"\n\tassert candidate(\"bbbbaaaaaaaaaf\") == \"f\"\n\tassert candidate(\"zzzzz\") == \"zzzzz\"\ndef test_check():\n\tcheck(lastSubstring)\n# Metadata Difficulty: Hard\n# Metadata Topics: two-pointers,string\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 876, "filename": "LeetCode_876_find_num_of_valid_words.py", "content": "from typing import List\n\n\ndef find_num_of_valid_words(words: List[str], puzzles: List[str]) -> List[int]:\n    \"\"\"\n    With respect to a given puzzle string, a word is valid if both the following conditions are satisfied:\n\n    word contains the first letter of puzzle.\n    For each letter in word, that letter is in puzzle.\n\n    For example, if the puzzle is \"abcdefg\", then valid words are \"faced\", \"cabbage\", and \"baggage\", while\n    invalid words are \"beefed\" (does not include 'a') and \"based\" (includes 's' which is not in the puzzle).\n\n\n\n    Return an array answer, where answer[i] is the number of words in the given word list words that is valid with respect to the puzzle puzzles[i].\n\u00a0\n    Example 1:\n\n    Input: words = [\"aaaa\",\"asas\",\"able\",\"ability\",\"actt\",\"actor\",\"access\"], puzzles = [\"aboveyz\",\"abrodyz\",\"abslute\",\"absoryz\",\"actresz\",\"gaswxyz\"]\n    Output: [1,1,3,2,4,0]\n    Explanation: \n    1 valid word for \"aboveyz\" : \"aaaa\" \n    1 valid word for \"abrodyz\" : \"aaaa\"\n    3 valid words for \"abslute\" : \"aaaa\", \"asas\", \"able\"\n    2 valid words for \"absoryz\" : \"aaaa\", \"asas\"\n    4 valid words for \"actresz\" : \"aaaa\", \"asas\", \"actt\", \"access\"\n    There are no valid words for \"gaswxyz\" cause none of the words in the list contains letter 'g'.\n\n    Example 2:\n\n    Input: words = [\"apple\",\"pleas\",\"please\"], puzzles = [\"aelwxyz\",\"aelpxyz\",\"aelpsxy\",\"saelpxy\",\"xaelpsy\"]\n    Output: [0,1,3,2,0]\n\n\u00a0\n    Constraints:\n\n    1 <= words.length <= 105\n    0 <= words[i].length <= 50\n    1 <= puzzles.length <= 104\n    puzzles[i].length == 7\n    words[i] and puzzles[i] consist of lowercase English letters.\n    Each puzzles[i] does not contain repeated characters.\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(words, list) and isinstance(puzzles, list), \"Input must be lists.\"\n    assert all(isinstance(word, str) for word in words), \"All elements in words must be strings.\"\n    assert all(isinstance(puzzle, str) for puzzle in puzzles), \"All elements in puzzles must be strings.\"\n    assert 0 <= len(words) <= 10**5, \"Length of words list must be between 1 and 105.\"\n    assert 0 <= len(puzzles) <= 10**4, \"Length of puzzles list must be between 1 and 104.\"\n    assert all(0 <= len(word) <= 50 for word in words), \"Length of each word must be between 4 and 50.\"\n    assert all(set(puzzle) == set(puzzle) for puzzle in puzzles), \"Each puzzle must have unique characters.\"\n    assert all(word.islower() and puzzle.islower() for word in words for puzzle in puzzles), \"Words and puzzles must contain only lowercase English letters.\"\n\n    result = []\n    for puzzle in puzzles:\n        count = 0\n        puzzle_set = set(puzzle)\n        for word in words:\n            if puzzle[0] in word:\n                if all(c in puzzle_set for c in word):\n                    count += 1\n        result.append(count)\n\n    # Postconditions\n    assert isinstance(result, list), \"The result must be a list.\"\n    assert all(isinstance(count, int) for count in result), \"All elements in the result must be integers.\"\n    assert len(result) == len(puzzles), \"The length of the result must match the length of puzzles.\"\n    assert all(count >= 0 for count in result), \"All counts must be non-negative.\"\n    assert all(count <= len(words) for count in result), \"No count can exceed the number of words.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([\"a\", \"b\", \"c\", \"d\"], [\"abcd\", \"dcba\", \"badc\", \"cdab\", \"e\"]) == [1,1,1,1,0]\n\tassert candidate([\"apple\", \"pleas\", \"please\"], [\"aelwxyz\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\", \"dcba\"]) == [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n\tassert candidate([\"ab\", \"cd\", \"ef\", \"gh\"], [\"abcdefg\", \"abcdefgh\", \"badcfehg\", \"hgfedcba\"]) == [1,1,1,1]\n\tassert candidate([\"aaaa\", \"asas\", \"able\", \"ability\", \"actt\", \"actor\", \"access\"], [\"aboveyz\"]) == [1]\n\tassert candidate([\"aaaa\", \"asas\", \"able\", \"ability\", \"actt\", \"actor\", \"access\"], [\"aboveyz\", \"abrodyz\", \"abslute\", \"absoryz\", \"actresz\", \"gaswxyz\"]) == [1,1,3,2,4,0]\n\tassert candidate([\"apple\", \"pleas\", \"please\"], [\"aelwxyz\", \"aelpxyz\", \"aelpsxy\", \"saelpxy\", \"xaelpsy\"]) == [0,1,3,2,0]\n\tassert candidate([\"apple\", \"pleas\", \"please\"], [\"aelwxyz\"]) == [0]\n\tassert candidate([\"apple\"], [\"apple\", \"pleas\", \"please\"]) == [1,1,1]\n\tassert candidate([\"a\", \"b\", \"c\", \"d\"], [\"abcd\", \"dcba\", \"badc\", \"cdab\"]) == [1,1,1,1]\ndef test_check():\n\tcheck(find_num_of_valid_words)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,hash-table,string,bit-manipulation,trie\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 914, "filename": "LeetCode_914_jobScheduling.py", "content": "from typing import List\n\n\ndef jobScheduling(startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n    \"\"\"\n    We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].\n    You're given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\n    If you choose a job that ends at time X you will be able to start another job that starts at time X.\n\u00a0\n    Example 1:\n\n\n    Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\n    Output: 120\n    Explanation: The subset chosen is the first and fourth job. \n    Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.\n\n    Example 2:\n\n\n    Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]\n    Output: 150\n    Explanation: The subset chosen is the first, fourth and fifth job. \n    Profit obtained 150 = 20 + 70 + 60.\n\n    Example 3:\n\n\n    Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]\n    Output: 6\n\n\u00a0\n    Constraints:\n\n    1 <= startTime.length == endTime.length == profit.length <= 5 * 104\n    1 <= startTime[i] < endTime[i] <= 109\n    1 <= profit[i] <= 104\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(startTime, list) and isinstance(endTime, list) and isinstance(profit, list), \"Input must be lists.\"\n    assert all(isinstance(x, int) for x in startTime + endTime + profit), \"All elements in startTime, endTime, and profit must be integers.\"\n    assert len(startTime) == len(endTime) == len(profit), \"All input lists must have the same length.\"\n    assert 1 <= len(startTime) <= 5 * 10**4, \"Length of input lists must be between 1 and 5 * 10^4.\"\n    assert all(1 <= p <= 10**4 for p in profit), \"Profit values must be within the range 1 to 10^4.\"\n\n    from bisect import bisect_left\n    jobs = sorted(zip(endTime, startTime, profit))\n    dp = [jobs[0][2]]\n\n    def latestNonConflict(index):\n        startTimeToFind = jobs[index][1]\n        index = bisect_left([job[0] for job in jobs], startTimeToFind)\n        if index:\n            return index - 1\n        return -1\n\n    for i in range(1, len(jobs)):\n        L = latestNonConflict(i)\n        dp.append(max(dp[-1], (0 if L == -1 else dp[L]) + jobs[i][2]))\n\n    result = dp[-1]\n\n    # Postconditions\n    assert isinstance(result, int), \"The result must be an integer.\"\n    assert 0 <= result <= sum(profit), \"The result must be a valid profit value.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\n    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],\n    [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],\n    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\n) == 15\n\tassert candidate([1,1,1,1,1], [2,2,2,2,2], [1,2,3,4,5]) == 5\n\tassert candidate([1,1,1], [2,3,4], [5,6,4]) == 6\n\tassert candidate([1,3,5,7,9], [2,4,6,8,10], [100,200,300,400,500]) == 1500\n\tassert candidate([1,3,0,5,3], [2,4,1,6,5], [50,10,40,70,60]) == 130\n\tassert candidate([1,1,1,1,1], [3,3,3,3,3], [5,6,7,8,9]) == 9\ndef test_check():\n\tcheck(jobScheduling)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,binary-search,dynamic-programming,sorting\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 929, "filename": "LeetCode_929_maxValueAfterReverse.py", "content": "from typing import List\n\n\ndef maxValueAfterReverse(nums: List[int]) -> int:\n    \"\"\"\n    You are given an integer array nums. The value of this array is defined as the sum of |nums[i] - nums[i + 1]| for all 0 <= i < nums.length - 1.\n    You are allowed to select any subarray of the given array and reverse it. You can perform this operation only once.\n    Find maximum possible value of the final array.\n\u00a0\n    Example 1:\n\n    Input: nums = [2,3,1,5,4]\n    Output: 10\n    Explanation: By reversing the subarray [3,1,5] the array becomes [2,5,1,3,4] whose value is 10.\n\n    Example 2:\n\n    Input: nums = [2,4,9,24,2,1,10]\n    Output: 68\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 3 * 104\n    -105 <= nums[i] <= 105\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(nums, list), \"Input must be a list.\"\n    assert all(isinstance(x, int) for x in nums), \"All elements in nums must be integers.\"\n    assert 1 <= len(nums) <= 3 * 10**4, \"Length of nums must be between 1 and 3 * 10^4.\"\n    assert all(-10**5 <= x <= 10**5 for x in nums), \"Elements in nums must be between -10^5 and 10^5.\"\n\n    total, diff = 0, 0\n    min2, max2 = float('inf'), float('-inf')\n    for i in range(len(nums) - 1):\n        total += abs(nums[i] - nums[i + 1])\n        min2 = min(min2, max(nums[i], nums[i + 1]))\n        max2 = max(max2, min(nums[i], nums[i + 1]))\n        diff = max(diff, abs(nums[i + 1] - nums[0]) - abs(nums[i + 1] - nums[i]))\n        diff = max(diff, abs(nums[i] - nums[-1]) - abs(nums[i] - nums[i + 1]))\n    \n    result = total + max(diff, 2 * (max2 - min2))\n    \n    # Postconditions\n    assert isinstance(result, int), \"The result must be an integer.\"\n    assert result >= total, \"The result must be greater than or equal to the original total value.\"\n  \n    return result\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\n    [2, 4, 9, 24, 2, 1, 10]) == 68, 'This one took me a while to figure out'\n\tassert candidate([5, 5, 5, 5, 5]) == 0\n\tassert candidate([2, 4, 9, 24, 2, 1, 10]) == 68\n\tassert candidate([10, 20, 30, 40, 50]) == 80\n\tassert candidate([1, 1, 1, 1, 1]) == 0\n\tassert candidate([2, 3, 1, 5, 4]) == 10\ndef test_check():\n\tcheck(maxValueAfterReverse)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,math,greedy\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 960, "filename": "LeetCode_960_shortestPath.py", "content": "from typing import List\n\n\ndef shortestPath(grid: List[List[int]], k: int) -> int:\n    \"\"\"\n    You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacle). You can move up, down, left, or right from and to an empty cell in one step.\n    Return the minimum number of steps to walk from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1) given that you can eliminate at most k obstacles. If it is not possible to find such walk return -1.\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1\n    Output: 6\n    Explanation: \n    The shortest path without eliminating any obstacle is 10.\n    The shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2).\n\n    Example 2:\n\n\n    Input: grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1\n    Output: -1\n    Explanation: We need to eliminate at least two obstacles to find such a walk.\n\n\u00a0\n    Constraints:\n\n    m == grid.length\n    n == grid[i].length\n    1 <= m, n <= 40\n    1 <= k <= m * n\n    grid[i][j] is either 0 or 1.\n    grid[0][0] == grid[m - 1][n - 1] == 0\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(grid, list) and all(isinstance(row, list) for row in grid), \"Grid must be a 2D list.\"\n    assert all(isinstance(cell, int) and cell in [0, 1] for row in grid for cell in row), \"Grid elements must be either 0 or 1.\"\n    assert 1 <= len(grid) <= 40 and 1 <= len(grid[0]) <= 40, \"Grid dimensions must be between 1x1 and 40x40.\"\n    assert grid[0][0] == 0 and grid[-1][-1] == 0, \"Start and end points must be 0 (empty).\"\n\n    from collections import deque\n    m, n = len(grid), len(grid[0])\n    visited = [[[False for _ in range(k + 1)] for _ in range(n)] for _ in range(m)]\n    q = deque([(0, 0, 0, k)])\n    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    steps = 0\n\n    while q:\n        for _ in range(len(q)):\n            x, y, steps, k_remaining = q.popleft()\n            if x == m - 1 and y == n - 1:\n                return steps\n            for dx, dy in moves:\n                new_x, new_y, = x + dx, y + dy\n                if 0 <= new_x < m and 0 <= new_y < n:\n                    new_k_remaining = k_remaining - grid[new_x][new_y]\n                    if new_k_remaining >= 0 and not visited[new_x][new_y][new_k_remaining]:\n                        visited[new_x][new_y][new_k_remaining] = True\n                        q.append((new_x, new_y, steps + 1, new_k_remaining))\n        steps += 1\n\n    # Postconditions\n    assert steps >= 0, \"Steps should be non-negative.\"\n    assert isinstance(steps, int), \"Steps should be an integer.\"\n    assert isinstance(grid, list), \"Grid must remain a list after execution.\"\n    assert 1 <= len(grid) <= 40 and 1 <= len(grid[0]) <= 40, \"Grid dimensions should remain within the initial range.\"\n\n    return -1\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([[0,0,0]], 2) == 2\n\tassert candidate([[0,1,1,1,0]], 3) == 4\n\tassert candidate([[0,0,0],[1,1,0],[0,0,0]], 1) == 4\n\tassert candidate([[0,0,0],[0,1,1],[0,0,0]], 1) == 4\n\tassert candidate([[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], 1) == 6\n\tassert candidate([[0,1],[1,0]], 1) == 2\n\tassert candidate([[0,0,0],[0,0,0],[0,1,0],[0,1,0],[0,0,0]], 1) == 6\n\tassert candidate([[0,1,1,0]], 1) == -1\n\tassert candidate([[0],[0],[0]], 1) == 2\n\tassert candidate([[0,0,0],[1,1,1],[0,0,0]], 2) == 4\n\tassert candidate([[0,0,0,0,0,0],[0,0,0,1,0,0],[0,0,0,1,0,0],[0,0,1,1,0,0],[0,0,1,1,0,0],[0,0,0,0,0,0]], 2) == 10\n\tassert candidate([[0],[1],[1],[0]], 1) == -1\n\tassert candidate([[0,0,0,0,0],[1,1,1,1,1],[0,0,0,0,0]], 1) == 6\n\tassert candidate([[0,0],[0,1],[0,0],[0,1],[0,0]], 0) == 5\n\tassert candidate([[0,0,0]], 1) == 2\n\tassert candidate([[0,0,0]], 0) == 2\n\tassert candidate([[0,1,1,0,0]], 2) == 4\n\tassert candidate([[0,0,0],[0,1,0],[0,0,0]], 2) == 4\n\tassert candidate([[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], 2) == 6\n\tassert candidate([[0,1,1],[1,1,1],[1,0,0]], 1) == -1\n\tassert candidate([[0],[1],[1],[1],[0]], 3) == 4\n\tassert candidate([[0],[1],[0]], 1) == 2\n\tassert candidate([[0,1,0],[1,1,0],[0,0,0]], 1) == 4\n\tassert candidate([[0,0,0],[1,0,0],[0,0,0]], 0) == 4\n\tassert candidate([[0,1,0]], 2) == 2\n\tassert candidate([[0,0,0],[0,0,0],[0,1,1],[0,0,0],[0,0,0]], 1) == 6\n\tassert candidate([[0,0,0],[1,1,0],[0,0,0]], 2) == 4\n\tassert candidate([[0,1,0,0,0],[0,1,0,1,0],[0,1,0,1,0],[0,1,0,0,0],[0,0,0,0,0]], 0) == 8\n\tassert candidate([[0,1,0]], 1) == 2\n\tassert candidate([[0,1,0,1,0]], 2) == 4\ndef test_check():\n\tcheck(shortestPath)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,breadth-first-search,matrix\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1010, "filename": "LeetCode_1010_tilingRectangle.py", "content": "def tilingRectangle(n: int, m: int) -> int:\n    \"\"\"\n    Given a rectangle of size n x m, return the minimum number of integer-sided squares that tile the rectangle.\n\u00a0\n    Example 1:\n\n\n    Input: n = 2, m = 3\n    Output: 3\n    Explanation: 3 squares are necessary to cover the rectangle.\n    2 (squares of 1x1)\n    1 (square of 2x2)\n    Example 2:\n\n\n    Input: n = 5, m = 8\n    Output: 5\n\n    Example 3:\n\n\n    Input: n = 11, m = 13\n    Output: 6\n\n\u00a0\n    Constraints:\n\n    1 <= n, m <= 13\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(n, int) and n > 0, \"n must be a positive integer.\"\n    assert isinstance(m, int) and m > 0, \"m must be a positive integer.\"\n    assert isinstance(n, int) and isinstance(m, int), \"Both n and m must be integers.\"\n\n    if n > m:\n        n, m = m, n\n    if n == 1:\n        return m\n    if n == m:\n        return 1\n\n    res = float('inf')\n    for a in range(1, n // 2 + 1):\n        res = min(res, tilingRectangle(a, m) + tilingRectangle(n - a, m))\n\n    for b in range(1, m // 2 + 1):\n        res = min(res, tilingRectangle(n, b) + tilingRectangle(n, m - b))\n\n    # Postconditions\n    assert res > 0, \"Result must be a positive integer.\"\n    assert isinstance(res, int), \"Result must be an integer.\"\n    assert 1 <= res <= max(n, m), \"Result must be within the range of possible values.\"\n    assert n == m or res > 1, \"If n is equal to m, the result must be exactly 1.\"\n\n    return res\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(2, 3) == 3\n\tassert candidate(1, 4) == 4\n\tassert candidate(1, 50) == 50\n\tassert candidate(48, 1) == 48\n\tassert candidate(35, 35) == 1\n\tassert candidate(30, 30) == 1\n\tassert candidate(34, 34) == 1\n\tassert candidate(20, 20) == 1\n\tassert candidate(15, 5) == 3\n\tassert candidate(5, 5) == 1\n\tassert candidate(1, 6) == 6\n\tassert candidate(39, 39) == 1\n\tassert candidate(13, 13) == 1\n\tassert candidate(8, 7) == 7\n\tassert candidate(1, 58) == 58\n\tassert candidate(18, 18) == 1\n\tassert candidate(42, 42) == 1\n\tassert candidate(6, 7) == 5\n\tassert candidate(56, 1) == 56\n\tassert candidate(5, 1) == 5\n\tassert candidate(4, 2) == 2\n\tassert candidate(36, 36) == 1\n\tassert candidate(1, 20) == 20\n\tassert candidate(37, 37) == 1\n\tassert candidate(10, 10) == 1\n\tassert candidate(16, 16) == 1\n\tassert candidate(55, 55) == 1\n\tassert candidate(26, 26) == 1\n\tassert candidate(7, 1) == 7\n\tassert candidate(17, 17) == 1\n\tassert candidate(1, 7) == 7\n\tassert candidate(1, 5) == 5\n\tassert candidate(30, 1) == 30\n\tassert candidate(29, 1) == 29\n\tassert candidate(12, 12) == 1\n\tassert candidate(24, 24) == 1\n\tassert candidate(2, 2) == 1\n\tassert candidate(10, 1) == 10\n\tassert candidate(40, 40) == 1\n\tassert candidate(38, 1) == 38\n\tassert candidate(1, 3) == 3\n\tassert candidate(15, 15) == 1\n\tassert candidate(4, 1) == 4\n\tassert candidate(41, 41) == 1\n\tassert candidate(28, 1) == 28\n\tassert candidate(29, 29) == 1\n\tassert candidate(1, 2) == 2\n\tassert candidate(1, 55) == 55\n\tassert candidate(1, 10) == 10\n\tassert candidate(1, 40) == 40\n\tassert candidate(2, 4) == 2\n\tassert candidate(14, 14) == 1\n\tassert candidate(8, 8) == 1\n\tassert candidate(27, 27) == 1\n\tassert candidate(19, 19) == 1\n\tassert candidate(3, 2) == 3\n\tassert candidate(7, 5) == 5\n\tassert candidate(6, 4) == 3\n\tassert candidate(31, 31) == 1\n\tassert candidate(15, 1) == 15\n\tassert candidate(7, 3) == 5\n\tassert candidate(25, 25) == 1\n\tassert candidate(3, 3) == 1\n\tassert candidate(47, 47) == 1\n\tassert candidate(1, 30) == 30\n\tassert candidate(32, 32) == 1\n\tassert candidate(1, 59) == 59\n\tassert candidate(1, 1) == 1\n\tassert candidate(21, 21) == 1\ndef test_check():\n\tcheck(tilingRectangle)\n# Metadata Difficulty: Hard\n# Metadata Topics: backtracking\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1015, "filename": "LeetCode_1015_maxHeight.py", "content": "from typing import List\n\n\ndef maxHeight(cuboids: List[List[int]]) -> int:\n    \"\"\"\n    Given n cuboids where the dimensions of the ith cuboid is cuboids[i] = [widthi, lengthi, heighti] (0-indexed). Choose a subset of cuboids and place them on each other.\n    You can place cuboid i on cuboid j if widthi <= widthj and lengthi <= lengthj and heighti <= heightj. You can rearrange any cuboid's dimensions by rotating it to put it on another cuboid.\n    Return the maximum height of the stacked cuboids.\n\u00a0\n    Example 1:\n\n\n    Input: cuboids = [[50,45,20],[95,37,53],[45,23,12]]\n    Output: 190\n    Explanation:\n    Cuboid 1 is placed on the bottom with the 53x37 side facing down with height 95.\n    Cuboid 0 is placed next with the 45x20 side facing down with height 50.\n    Cuboid 2 is placed next with the 23x12 side facing down with height 45.\n    The total height is 95 + 50 + 45 = 190.\n\n    Example 2:\n\n    Input: cuboids = [[38,25,45],[76,35,3]]\n    Output: 76\n    Explanation:\n    You can't place any of the cuboids on the other.\n    We choose cuboid 1 and rotate it so that the 35x3 side is facing down and its height is 76.\n\n    Example 3:\n\n    Input: cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]\n    Output: 102\n    Explanation:\n    After rearranging the cuboids, you can see that all cuboids have the same dimension.\n    You can place the 11x7 side down on all cuboids so their heights are 17.\n    The maximum height of stacked cuboids is 6 * 17 = 102.\n\n\u00a0\n    Constraints:\n\n    n == cuboids.length\n    1 <= n <= 100\n    1 <= widthi, lengthi, heighti <= 100\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(cuboids, list) and all(isinstance(cuboid, list) and len(cuboid) == 3 for cuboid in cuboids), \"cuboids must be a list of lists with 3 integers each.\"\n    assert all(isinstance(dim, int) and dim > 0 for cuboid in cuboids for dim in cuboid), \"All dimensions must be positive integers.\"\n    assert 1 <= len(cuboids) <= 100, \"The number of cuboids must be between 1 and 100 inclusive.\"\n    assert all(1 <= dim <= 100 for cuboid in cuboids for dim in cuboid), \"All dimensions must be between 1 and 100 inclusive.\"\n    assert isinstance(cuboids[0], list) and len(cuboids[0]) == 3, \"Each cuboid must have exactly 3 dimensions.\"\n\n    cuboids = [sorted(cuboid) for cuboid in cuboids]\n    cuboids.sort()\n\n    n = len(cuboids)\n    dp = [0] * n\n    ans = 0\n\n    for i, cuboid in enumerate(cuboids):\n        dp[i] = cuboid[2]\n        for j in range(i):\n            if all(cuboids[j][k] <= cuboid[k] for k in range(3)):\n                dp[i] = max(dp[i], dp[j] + cuboid[2])\n\n        ans = max(ans, dp[i])\n\n    # Postconditions\n    assert ans > 0, \"The result must be a positive integer.\"\n    assert isinstance(ans, int), \"The result must be an integer.\"\n    assert ans <= sum(cuboid[2] for cuboid in cuboids), \"The result must not exceed the sum of all cuboid heights.\"\n    assert all(dp[i] >= cuboids[i][2] for i in range(n)), \"Each dp value should be at least the height of the corresponding cuboid.\"\n    assert len(dp) == len(cuboids), \"The dp array length should match the number of cuboids.\"\n    assert isinstance(dp, list) and all(isinstance(height, int) for height in dp), \"dp should be a list of integers.\"\n    assert max(dp) == ans, \"The maximum value in dp should be the answer.\"\n\n    return ans\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([[1,1,1]]) == 1\n\tassert candidate([[1,1,1],[1,1,1],[1,1,1],[1,1,1]]) == 4\n\tassert candidate([[1,1,1],[2,2,2]]) == 3\n\tassert candidate([[50,45,20],[95,37,53],[45,23,12]]) == 190\n\tassert candidate([[1,1,1],[2,2,2],[3,3,3]]) == 6\n\tassert candidate([[1,1,1],[1,1,1],[1,1,1],[1,1,1],[1,1,1]]) == 5\n\tassert candidate([[3,3,3],[2,2,2],[1,1,1]]) == 6\n\tassert candidate([[1,1,1],[1,1,1],[1,1,1]]) == 3\n\tassert candidate([[4,4,4],[3,3,3],[2,2,2],[1,1,1]]) == 10\n\tassert candidate([[38,25,45],[76,35,3]]) == 76\n\tassert candidate([[10,10,10],[20,20,20]]) == 30\n\tassert candidate([[1,1,1],[2,2,2],[3,3,3],[4,4,4]]) == 10\n\tassert candidate([[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]) == 102\ndef test_check():\n\tcheck(maxHeight)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,dynamic-programming,sorting\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1016, "filename": "LeetCode_1016_minCost.py", "content": "from typing import List\n\n\ndef minCost(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given an m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:\n\n    1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])\n    2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])\n    3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])\n    4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])\n\n    Notice that there could be some signs on the cells of the grid that point outside the grid.\n    You will initially start at the upper left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path does not have to be the shortest.\n    You can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.\n    Return the minimum cost to make the grid have at least one valid path.\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\n    Output: 3\n    Explanation: You will start at point (0, 0).\n    The path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\n    The total cost = 3.\n\n    Example 2:\n\n\n    Input: grid = [[1,1,3],[3,2,2],[1,1,4]]\n    Output: 0\n    Explanation: You can follow the path from (0, 0) to (2, 2).\n\n    Example 3:\n\n\n    Input: grid = [[1,2],[4,3]]\n    Output: 1\n\n\u00a0\n    Constraints:\n\n    m == grid.length\n    n == grid[i].length\n    1 <= m, n <= 100\n    1 <= grid[i][j] <= 4\n\n    \"\"\"\n    ### Canonical solution below ###\n    from collections import deque\n    assert isinstance(grid, list) and all(isinstance(row, list) for row in grid), \"Grid must be a list of lists.\"\n    assert all(len(row) == len(grid[0]) for row in grid), \"All rows in the grid must have the same length.\"\n    assert len(grid) >= 1 and len(grid) <= 100, \"The grid must have between 1 and 100 rows.\"\n    assert len(grid[0]) >= 1 and len(grid[0]) <= 100, \"The grid must have between 1 and 100 columns.\"\n    assert all(1 <= cell <= 4 for row in grid for cell in row), \"Each cell must be between 1 and 4.\"\n\n    m, n = len(grid), len(grid[0])\n    cost = 0\n\n    visited = [[1000000] * n for _ in range(m)]\n    q = deque([(0, 0)])\n    visited[0][0] = 0\n\n    while q:\n        y, x = q.popleft()\n        if y == m - 1 and x == n - 1:\n            cost = visited[y][x]\n            break\n\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n\n        for dir in range(4):\n            newY, newX = y + dy[dir], x + dx[dir]\n            if 0 <= newY < m and 0 <= newX < n:\n                newCost = visited[y][x] + (1 if dir + 1 != grid[y][x] else 0)\n                if newCost < visited[newY][newX]:\n                    visited[newY][newX] = newCost\n                    q.append((newY, newX))\n\n    # Postconditions\n    assert isinstance(cost, int), \"The result must be an integer.\"\n    assert cost >= 0, \"The cost must be non-negative.\"\n    assert cost <= (m * n) - 1, \"The cost should not exceed the maximum number of cells minus one.\"\n    assert visited[m-1][n-1] == cost, \"The cost should match the value at the destination cell in the visited grid.\"\n    assert all(isinstance(row, list) and len(row) == n for row in visited), \"The visited grid must maintain its structure.\"\n    assert all(isinstance(value, int) and value >= 0 for row in visited for value in row), \"All values in visited should be non-negative integers.\"\n    assert isinstance(visited, list) and len(visited) == m, \"Visited should have the same number of rows as the grid.\"\n\n    return cost\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([[1]]) == 0\n\tassert candidate([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) == 4\n\tassert candidate([[3,3,3,3],[2,2,2,2],[3,3,3,3],[1,1,1,1]]) == 2\n\tassert candidate([[1, 1, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [4, 3, 3, 3, 3], [4, 4, 3, 3, 2]]) == 3\n\tassert candidate([[1,1,1,1],[2,2,2,2],[3,3,3,3],[4,4,4,4]]) == 2\n\tassert candidate([[1, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [4, 3, 3, 3, 3], [4, 4, 3, 3, 1]]) == 4\ndef test_check():\n\tcheck(minCost)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,breadth-first-search,graph,heap-priority-queue,matrix,shortest-path\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1023, "filename": "LeetCode_1023_frogPosition.py", "content": "from typing import List\nfrom collections import defaultdict\n\ndef frogPosition(n: int, edges: List[List[int]], t: int, target: int) -> float:\n    \"\"\"\n    Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\n    The edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi.\n    Return the probability that after t seconds the frog is on the vertex target. Answers within 10-5 of the actual answer will be accepted.\n    \"\"\"\n    ### Canonical solution below ###\n    \n    # Preconditions\n    assert isinstance(n, int) and n >= 1, \"n must be a positive integer.\"\n    assert isinstance(edges, list) and all(isinstance(edge, list) and len(edge) == 2 for edge in edges), \"edges must be a list of pairs.\"\n    assert isinstance(t, int) and t >= 0, \"t must be a non-negative integer.\"\n    assert isinstance(target, int) and 1 <= target <= n, \"target must be an integer between 1 and n inclusive.\"\n    \n    def dfs(node, parent, t, target, graph, prob, ans):\n        if t == 0:\n            if node == target:\n                ans[0] += prob\n            return\n\n        has_child = False\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                has_child = True\n                dfs(neighbor, node, t - 1, target, graph, prob / (len(graph[node]) - (1 if node != 1 else 0)), ans)\n\n        if not has_child and node == target:\n            ans[0] += prob\n            \n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    ans = [0.0]\n    dfs(1, -1, t, target, graph, 1.0, ans)\n    \n    # Postconditions\n    assert isinstance(ans[0], float), \"The result must be a float.\"\n    assert 0.0 <= ans[0] <= 1.0, \"The result must be a probability between 0 and 1 inclusive.\"\n    assert (ans[0] == 0.0) or (target == 1 or any(target in graph[key] for key in graph if graph[key])), \"The target should be reachable if the probability is greater than 0.\"\n    assert isinstance(graph, defaultdict) and all(isinstance(key, int) and isinstance(value, list) for key, value in graph.items()), \"The graph structure must be maintained correctly.\"\n    assert all(isinstance(prob, float) and 0 <= prob <= 1 for prob in ans), \"All probabilities in the answer list must be valid floats between 0 and 1 inclusive.\"\n    assert all(len(edge) == 2 and 1 <= edge[0] <= n and 1 <= edge[1] <= n for edge in edges), \"All edges should be valid connections between vertices within the range 1 to n.\"\n    assert len(ans) == 1, \"The answer list should only contain one probability value.\"\n\n    return ans[0]\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(7, [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], 2, 4) == 0.16666666666666666\n\tassert candidate(7, [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], 2, 3) == 0.0\n\tassert candidate(3, [], 3, 1) == 1.0\n\tassert candidate(3, [[1,2],[1,3]], 1, 3) == 0.5\n\tassert candidate(1, [], 1, 1) == 1.0\n\tassert candidate(7, [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], 1, 1) == 0.0\n\tassert candidate(3, [[1,2],[1,3]], 2, 2) == 0.5\n\tassert candidate(3, [[1,2],[1,3],[2,3]], 2, 2) == 0.5\n\tassert candidate(3, [[3,2],[3,1]], 1, 2) == 0.0\n\tassert candidate(7, [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], 0, 1) == 1.0\n\tassert candidate(7, [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], 1, 7) == 0.3333333333333333\n\tassert candidate(1, [], 5, 1) == 1.0\n\tassert candidate(4, [[1,2],[1,3],[1,4]], 1, 4) == 0.3333333333333333\n\tassert candidate(2, [], 2, 1) == 1.0\n\tassert candidate(5, [[1,2],[2,3],[3,4],[4,5]], 3, 5) == 0.0\n\tassert candidate(5, [[1,2],[2,3],[3,4],[4,5]], 4, 5) == 1.0\ndef test_check():\n\tcheck(frogPosition)\n# Metadata Difficulty: Hard\n# Metadata Topics: tree,depth-first-search,breadth-first-search,graph\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1109, "filename": "LeetCode_1109_frogPosition.py", "content": "from typing import List\n\nfrom collections import defaultdict\ndef frogPosition(n: int, edges: List[List[int]], t: int, target: int) -> float:\n    \"\"\"\n    Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\n    The edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi.\n    Return the probability that after t seconds the frog is on the vertex target. Answers within 10-5 of the actual answer will be accepted.\n\u00a0\n    Example 1:\n\n\n    Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\n    Output: 0.16666666666666666 \n    Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. \n\n    Example 2:\n\n\n    Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\n    Output: 0.3333333333333333\n    Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1. \n\n\u00a0\n    Constraints:\n\n    1 <= n <= 100\n    edges.length == n - 1\n    edges[i].length == 2\n    1 <= ai, bi <= n\n    1 <= t <= 50\n    1 <= target <= n\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(n, int) and n >= 1, \"n must be a positive integer.\"\n    assert isinstance(edges, list) and all(isinstance(edge, list) and len(edge) == 2 for edge in edges), \"edges must be a list of pairs.\"\n    assert isinstance(t, int) and t >= 0, \"t must be a non-negative integer.\"\n    assert isinstance(target, int) and 1 <= target <= n, \"target must be an integer between 1 and n inclusive.\"\n    \n    def dfs(node, parent, t, target, graph):\n        if t == 0:\n            return 1.0 if node == target else 0.0\n        probability = 0.0\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                probability += dfs(neighbor, node, t - 1, target, graph)\n        return probability / (len(graph[node]) - (0 if parent == -1 else 1))\n\n    graph = defaultdict(list)\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n    \n    result = dfs(1, -1, t, target, graph)\n    \n    # Postconditions\n    assert isinstance(result, float), \"The result must be a float.\"\n    assert 0.0 <= result <= 1.0, \"The result must be a probability between 0 and 1 inclusive.\"\n    assert isinstance(graph, defaultdict) and all(isinstance(key, int) and isinstance(value, list) for key, value in graph.items()), \"The graph structure must be maintained correctly.\"\n    assert all(len(edge) == 2 and 1 <= edge[0] <= n and 1 <= edge[1] <= n for edge in edges), \"All edges should be valid connections between vertices within the range 1 to n.\"\n    assert target in graph or target == 1, \"The target must be a valid node in the graph.\"\n\n    return result\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(3, [[2, 1], [3, 2]], 2, 3) == 1.0\n\tassert candidate(7, [[1, 2], [1, 3], [1, 7], [2, 4], [2, 6], [3, 5]], 1, 7) == 0.3333333333333333\n\tassert candidate(3, [[2, 1], [3, 2]], 2, 1) == 0.0\n\tassert candidate(3, [[2, 1], [3, 2]], 1, 2) == 1.0\n\tassert candidate(12, [[9, 11], [4, 5], [1, 2], [10, 12], [3, 8], [6, 9], [3, 1], [3, 10], [8, 11], [7, 9], [7, 4], [8, 6], [10, 11]], 0, 1) == 1.0\n\tassert candidate(7, [[1, 2], [1, 3], [1, 7], [2, 4], [2, 6], [3, 5]], 0, 1) == 1.0\n\tassert candidate(3, [[2, 1], [3, 2]], 1, 3) == 0.0\ndef test_check():\n\tcheck(frogPosition)\n# Metadata Difficulty: Hard\n# Metadata Topics: tree,depth-first-search,breadth-first-search,graph\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1110, "filename": "LeetCode_1110_minNumberOfSemesters.py", "content": "from typing import List\n\n\ndef minNumberOfSemesters(n: int, relations: List[List[int]], k: int) -> int:\n    \"\"\"\n    You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given an array relations where relations[i] = [prevCoursei, nextCoursei], representing a prerequisite relationship between course prevCoursei and course nextCoursei: course prevCoursei has to be taken before course nextCoursei. Also, you are given the integer k.\n    In one semester, you can take at most k courses as long as you have taken all the prerequisites in the previous semesters for the courses you are taking.\n    Return the minimum number of semesters needed to take all courses. The testcases will be generated such that it is possible to take every course.\n\u00a0\n    Example 1:\n\n\n    Input: n = 4, relations = [[2,1],[3,1],[1,4]], k = 2\n    Output: 3\n    Explanation: The figure above represents the given graph.\n    In the first semester, you can take courses 2 and 3.\n    In the second semester, you can take course 1.\n    In the third semester, you can take course 4.\n\n    Example 2:\n\n\n    Input: n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2\n    Output: 4\n    Explanation: The figure above represents the given graph.\n    In the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester.\n    In the second semester, you can take course 4.\n    In the third semester, you can take course 1.\n    In the fourth semester, you can take course 5.\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 15\n    1 <= k <= n\n    0 <= relations.length <= n * (n-1) / 2\n    relations[i].length == 2\n    1 <= prevCoursei, nextCoursei <= n\n    prevCoursei != nextCoursei\n    All the pairs [prevCoursei, nextCoursei] are unique.\n    The given graph is a directed acyclic graph.\n\n    \"\"\"\n    ### Canonical solution below ###\n    from collections import deque\n    assert isinstance(n, int) and n >= 1, \"n must be a positive integer.\"\n    assert isinstance(relations, list) and all(isinstance(pair, list) and len(pair) == 2 for pair in relations), \"relations must be a list of pairs.\"\n    assert len(relations) <= n * (n - 1) // 2, \"relations length must be valid for a directed acyclic graph.\"\n    assert all(1 <= prev <= n and 1 <= next <= n for prev, next in relations), \"Course numbers in relations must be within the range 1 to n.\"\n    \n    indegree = [0] * (n + 1)\n    graph = [[] for _ in range(n + 1)]\n\n    for prev_course, next_course in relations:\n        graph[prev_course].append(next_course)\n        indegree[next_course] += 1\n\n    semesters = 0\n    while n > 0:\n        zero_indegree = deque()\n        for i in range(1, len(indegree)):\n            if indegree[i] == 0:\n                zero_indegree.append(i)\n                indegree[i] = -1\n\n        courses = 0\n        while zero_indegree and courses < k:\n            curr_course = zero_indegree.popleft()\n            n -= 1\n\n            for next_course in graph[curr_course]:\n                indegree[next_course] -= 1\n            courses += 1\n        semesters += 1\n\n    # Postconditions\n    assert isinstance(semesters, int), \"The result should be an integer.\"\n    assert semesters > 0, \"The number of semesters should be greater than 0.\"\n    assert all(isinstance(node, list) for node in graph), \"The graph should be a list of lists.\"\n    assert isinstance(indegree, list) and all(isinstance(degree, int) for degree in indegree), \"The indegree list should consist of integers.\"\n    assert isinstance(zero_indegree, deque), \"zero_indegree should be a deque object.\"\n    assert courses <= k, \"The number of courses taken in any semester should not exceed k.\"\n\n    return semesters\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(6, [[6,5],[5,4],[4,3],[3,2],[2,1]], 1) == 6\n\tassert candidate(2, [[1,2]], 1) == 2\n\tassert candidate(1, [], 2) == 1\n\tassert candidate(10, [[2,1],[3,2],[4,3],[5,4],[6,5],[7,6],[8,7],[9,8],[10,9]], 1) == 10\n\tassert candidate(1, [], 1) == 1\n\tassert candidate(3, [[3,2],[2,1]], 1) == 3\n\tassert candidate(4, [[2,1],[3,1],[1,4]], 2) == 3\n\tassert candidate(5, [[1,2],[3,4],[2,5],[4,5]], 2) == 3\ndef test_check():\n\tcheck(minNumberOfSemesters)\n# Metadata Difficulty: Hard\n# Metadata Topics: dynamic-programming,bit-manipulation,graph,bitmask\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1116, "filename": "LeetCode_1116_max_satisfaction.py", "content": "from typing import List\n\n\ndef max_satisfaction(satisfaction: List[int]) -> int:\n    \"\"\"\n    A chef has collected data on the satisfaction level of his n dishes. Chef can cook any dish in 1 unit of time.\n    Like-time coefficient of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level i.e. time[i] * satisfaction[i].\n    Return the maximum sum of like-time coefficient that the chef can obtain after dishes preparation.\n    Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.\n\u00a0\n    Example 1:\n\n    Input: satisfaction = [-1,-8,0,5,-9]\n    Output: 14\n    Explanation: After Removing the second and last dish, the maximum total like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14).\n    Each dish is prepared in one unit of time.\n    Example 2:\n\n    Input: satisfaction = [4,3,2]\n    Output: 20\n    Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)\n\n    Example 3:\n\n    Input: satisfaction = [-1,-4,-5]\n    Output: 0\n    Explanation: People do not like the dishes. No dish is prepared.\n\n\u00a0\n    Constraints:\n\n    n == satisfaction.length\n    1 <= n <= 500\n    -1000 <= satisfaction[i] <= 1000\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(satisfaction, list), \"satisfaction must be a list.\"\n    assert all(isinstance(x, int) for x in satisfaction), \"All elements in satisfaction must be integers.\"\n    assert all(-1000 <= x <= 1000 for x in satisfaction), \"Each satisfaction level must be between -1000 and 1000.\"\n    \n    satisfaction.sort(reverse=True)\n    ans = total = sum = 0\n    for i in satisfaction:\n        total += i\n        if total > 0:\n            sum += total\n            ans = max(ans, sum)\n\n    # Postconditions\n    assert isinstance(ans, int), \"The result should be an integer.\"\n    assert ans >= 0, \"The maximum satisfaction must be non-negative.\"\n    assert ans <= len(satisfaction) * 1000, \"The result should not exceed the maximum possible satisfaction.\"\n    assert sum >= 0, \"The cumulative satisfaction sum should be non-negative.\"\n    assert isinstance(total, int), \"The total satisfaction should be an integer.\"\n\n    return ans\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 55\n\tassert candidate([-1, -4, -5]) == 0\n\tassert candidate([-1, -8, 0, 5, -9]) == 14\n\tassert candidate([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == 0\n\tassert candidate([-1, -2, -3, -4, -5, -6, -7, -8, -9, -10]) == 0\n\tassert candidate([]) == 0\n\tassert candidate([-10, -20, -30, -40, -50, -60, -70, -80, -90, -100]) == 0\n\tassert candidate([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]) == 0\n\tassert candidate([-1000, -1000, -1000]) == 0\n\tassert candidate([4, 3, 2]) == 20\ndef test_check():\n\tcheck(max_satisfaction)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,dynamic-programming,greedy,sorting\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1172, "filename": "LeetCode_1172_maxDotProduct.py", "content": "from typing import List\n\n\ndef maxDotProduct(nums1: List[int], nums2: List[int]) -> int:\n    \"\"\"\n    Given two arrays nums1\u00a0and nums2.\n    Return the maximum dot product\u00a0between\u00a0non-empty subsequences of nums1 and nums2 with the same length.\n    A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie,\u00a0[2,3,5]\u00a0is a subsequence of\u00a0[1,2,3,4,5]\u00a0while [1,5,3]\u00a0is not).\n\u00a0\n    Example 1:\n\n    Input: nums1 = [2,1,-2,5], nums2 = [3,0,-6]\n    Output: 18\n    Explanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2.\n    Their dot product is (2*3 + (-2)*(-6)) = 18.\n    Example 2:\n\n    Input: nums1 = [3,-2], nums2 = [2,-6,7]\n    Output: 21\n    Explanation: Take subsequence [3] from nums1 and subsequence [7] from nums2.\n    Their dot product is (3*7) = 21.\n    Example 3:\n\n    Input: nums1 = [-1,-1], nums2 = [1,1]\n    Output: -1\n    Explanation: Take subsequence [-1] from nums1 and subsequence [1] from nums2.\n    Their dot product is -1.\n\u00a0\n    Constraints:\n\n    1 <= nums1.length, nums2.length <= 500\n    -1000 <= nums1[i], nums2[i] <= 1000\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(nums1, list), \"nums1 must be a list.\"\n    assert isinstance(nums2, list), \"nums2 must be a list.\"\n    assert all(isinstance(x, int) for x in nums1), \"All elements in nums1 must be integers.\"\n    assert all(isinstance(x, int) for x in nums2), \"All elements in nums2 must be integers.\"\n    assert 1 <= len(nums1) <= 500, \"Length of nums1 must be between 1 and 500.\"\n    assert 1 <= len(nums2) <= 500, \"Length of nums2 must be between 1 and 500.\"\n    assert all(-1000 <= x <= 1000 for x in nums1), \"Each element in nums1 must be between -1000 and 1000.\"\n    assert all(-1000 <= x <= 1000 for x in nums2), \"Each element in nums2 must be between -1000 and 1000.\"\n    \n    n, m = len(nums1), len(nums2)\n    dp = [[float('-inf') for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1], nums1[i - 1] * nums2[j - 1])\n    \n    result = dp[n][m]\n    \n    # Postconditions\n    assert isinstance(result, int), \"The result must be an integer.\"\n    assert result >= min(nums1) * min(nums2), \"The result cannot be less than the product of the minimum elements in nums1 and nums2.\"\n    assert result <= 1000 * 1000, \"The result should be bounded by the maximum possible product of two elements.\"\n    assert result >= -1000 * 1000, \"The result should be bounded by the minimum possible product of two elements.\"\n    assert len(dp) == len(nums1) + 1, \"The dp array should have n+1 rows.\"\n    assert all(len(row) == len(nums2) + 1 for row in dp), \"The dp array should have m+1 columns for each row.\"\n\n    return result\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == 55\n\tassert candidate(\n    [-4, 4],\n    [2, -2]\n) == 8\n\tassert candidate(\n    [-1, -1, -1],\n    [1, 1, 1]) == -1\n\tassert candidate(\n    [-4, 4],\n    [0, 0]\n) == 0\n\tassert candidate([1, 0, 1], [1, 0, 1]) == 2\n\tassert candidate([-1, 2, 3], [-1, 0, 1]) == 4\n\tassert candidate([1, 2, 3, 4, 5], [2, 3, 4, 5, 6]) == 70\n\tassert candidate([1, 2, 3], [4, 5]) == 23\n\tassert candidate([1], [1]) == 1\n\tassert candidate([1, 2, 3], [4, 5, 6]) == 32\n\tassert candidate([-1, 2, 3], [4, -5, 6]) == 26\n\tassert candidate([1, 1, 1], [2, 2, 2]) == 6\n\tassert candidate([1, 0, 1, 0, -1, 0], [-1, 0, 1, 1, 1, 0]) == 2\n\tassert candidate([0, 0, 0], [0, 0, 0]) == 0\n\tassert candidate([-1, -1], [1, 1]) == -1\n\tassert candidate([1, 1, 1], [1, 2, 3]) == 6\n\tassert candidate([2, 3, 4], [5, 6, 7]) == 56\n\tassert candidate(\n    [-1, -1],\n    [1, 1]\n) == -1\n\tassert candidate([-2, -1, -1, -1], [1, 0, 1, 1]) == 0\n\tassert candidate([1, 2, 3], [1, 1, 1]) == 6\ndef test_check():\n\tcheck(maxDotProduct)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,dynamic-programming\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1194, "filename": "LeetCode_1194_maximumRequests.py", "content": "from typing import List\n\n\ndef maximumRequests(n: int, requests: List[List[int]]) -> int:\n    \"\"\"\n    We have n buildings numbered from 0 to n - 1. Each building has a number of employees. It's transfer season, and some employees want to change the building they reside in.\n    You are given an array requests where requests[i] = [fromi, toi] represents an employee's request to transfer from building fromi to building toi.\n    All buildings are full, so a list of requests is achievable only if for each building, the net change in employee transfers is zero. This means the number of employees leaving is equal to the number of employees moving in. For example if n = 3 and two employees are leaving building 0, one is leaving building 1, and one is leaving building 2, there should be two employees moving to building 0, one employee moving to building 1, and one employee moving to building 2.\n    Return the maximum number of achievable requests.\n\u00a0\n    Example 1:\n\n\n    Input: n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]\n    Output: 5\n    Explantion: Let's see the requests:\n    From building 0 we have employees x and y and both want to move to building 1.\n    From building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively.\n    From building 2 we have employee z and they want to move to building 0.\n    From building 3 we have employee c and they want to move to building 4.\n    From building 4 we don't have any requests.\n    We can achieve the requests of users x and b by swapping their places.\n    We can achieve the requests of users y, a and z by swapping the places in the 3 buildings.\n\n    Example 2:\n\n\n    Input: n = 3, requests = [[0,0],[1,2],[2,1]]\n    Output: 3\n    Explantion: Let's see the requests:\n    From building 0 we have employee x and they want to stay in the same building 0.\n    From building 1 we have employee y and they want to move to building 2.\n    From building 2 we have employee z and they want to move to building 1.\n    We can achieve all the requests. \n    Example 3:\n\n    Input: n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]\n    Output: 4\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 20\n    1 <= requests.length <= 16\n    requests[i].length == 2\n    0 <= fromi, toi < n\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(n, int), \"n must be an integer.\"\n    assert 1 <= n <= 20, \"n must be between 1 and 20 inclusive.\"\n    assert isinstance(requests, list), \"requests must be a list.\"\n    assert all(isinstance(req, list) and len(req) == 2 for req in requests), \"Each request must be a list of two elements.\"\n    assert all(0 <= req[0] < n and 0 <= req[1] < n for req in requests), \"Building indices must be within the range [0, n-1].\"\n    assert len(requests) <= 16, \"The length of requests must be less than or equal to 16.\"\n\n    req_size = len(requests)\n    max_requests = 0\n\n    for i in range(1 << req_size):\n        net_transfers = [0] * n\n        count = 0\n\n        for j in range(req_size):\n            if i & (1 << j):\n                net_transfers[requests[j][0]] -= 1\n                net_transfers[requests[j][1]] += 1\n                count += 1\n\n        valid = all(val == 0 for val in net_transfers)\n\n        if valid:\n            max_requests = max(max_requests, count)\n\n    result = max_requests\n\n    # Postconditions\n    assert isinstance(result, int), \"The result must be an integer.\"\n    assert result >= 0, \"The result must be non-negative.\"\n    assert result <= len(requests), \"The result cannot exceed the total number of requests.\"\n    assert isinstance(net_transfers, list) and len(net_transfers) == n, \"net_transfers must be a list of length n.\"\n    assert all(isinstance(x, int) for x in net_transfers), \"All elements in net_transfers must be integers.\"\n    assert all(-n <= x <= n for x in net_transfers), \"Values in net_transfers must be within the range [-n, n].\"\n    assert max_requests <= len(requests), \"max_requests should not exceed the number of requests.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(4, [[0,1],[1,2],[2,3],[3,0],[0,2],[2,0],[1,3],[3,1]]) == 8\n\tassert candidate(5, [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]) == 5\n\tassert candidate(3, [[0,1],[1,2],[2,0],[1,0],[2,0]]) == 3\n\tassert candidate(1, [[0,0]]) == 1\n\tassert candidate(2, [[0,1],[1,1]]) == 1\n\tassert candidate(5, [[0,3],[3,1],[1,2],[2,0]]) == 4\n\tassert candidate(3, [[0,1],[1,2],[2,0],[1,0]]) == 3\n\tassert candidate(5, [[0,1],[1,2],[2,3],[3,4],[4,0]]) == 5\n\tassert candidate(6, [[0,1],[1,2],[2,3],[3,4],[4,5],[5,0]]) == 6\n\tassert candidate(3, [[0,2],[2,1],[1,0]]) == 3\n\tassert candidate(7, [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,0]]) == 7\n\tassert candidate(4, [[3,2],[3,3],[0,3],[2,3],[1,2]]) == 3\n\tassert candidate(4, [[0,3],[3,1],[1,2],[2,0]]) == 4\n\tassert candidate(3, [[0,0],[1,2],[2,1]]) == 3\n\tassert candidate(5, [[0,1],[1,2],[2,3],[3,4],[4,0],[0,2],[1,3],[2,4],[3,0],[4,1],[3,1],[2,3],[1,4]]) == 12\n\tassert candidate(2, [[0,1],[1,0],[0,1],[1,0]]) == 4\n\tassert candidate(3, [[1,0],[2,1],[0,2],[2,0],[1,0]]) == 3\n\tassert candidate(2, [[0,1],[1,0],[0,1],[1,0],[0,1],[1,0],[0,1],[1,0]]) == 8\n\tassert candidate(1, []) == 0\n\tassert candidate(3, [[0,1],[1,2],[2,0],[0,1],[1,2],[2,0]]) == 6\n\tassert candidate(5, [[0,1],[1,0],[2,3],[3,2],[4,0],[0,4],[2,4],[4,2]]) == 8\n\tassert candidate(6, [[0,1],[1,0],[0,1],[1,0],[0,1],[1,0]]) == 6\ndef test_check():\n\tcheck(maximumRequests)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,backtracking,bit-manipulation,enumeration\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1206, "filename": "LeetCode_1206_winnerSquareGame.py", "content": "def winnerSquareGame(n: int) -> bool:\n    \"\"\"\n    Alice and Bob take turns playing a game, with Alice starting first.\n    Initially, there are n stones in a pile. On each player's turn, that player makes a move consisting of removing any non-zero square number of stones in the pile.\n    Also, if a player cannot make a move, he/she loses the game.\n    Given a positive integer n, return true if and only if Alice wins the game otherwise return false, assuming both players play optimally.\n\u00a0\n    Example 1:\n\n    Input: n = 1\n    Output: true\n    Explanation: Alice can remove 1 stone winning the game because Bob doesn't have any moves.\n    Example 2:\n\n    Input: n = 2\n    Output: false\n    Explanation: Alice can only remove 1 stone, after that Bob removes the last one winning the game (2 -> 1 -> 0).\n\n    Example 3:\n\n    Input: n = 4\n    Output: true\n    Explanation: n is already a perfect square, Alice can win with one move, removing 4 stones (4 -> 0).\n\n\u00a0\n    Constraints:\n\n    1 <= n <= 10^5\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(n, int), \"n must be an integer.\"\n    assert 0 <= n <= 10**5, \"n must be within the range 1 to 105 inclusive.\"\n\n    assert isinstance(n, int) and n >= 0, \"n must be greater than zero\"\n\n    dp = [False] * (n + 1)\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            if not dp[i - j * j]:\n                dp[i] = True\n                break\n            j += 1\n    result = dp[n]\n\n    # Postconditions\n    assert isinstance(result, bool), \"The result must be a boolean.\"\n    assert result in [True, False], \"The result must be either True or False.\"\n    assert len(dp) == n + 1, \"dp array should have length n + 1.\"\n    assert all(isinstance(x, bool) for x in dp), \"All elements in dp must be boolean values.\"\n    assert dp[0] == False, \"dp[0] must be False as no game with 0 stones is possible.\"\n\n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(14) == True\n\tassert candidate(19) == True\n\tassert candidate(9999) == True\n\tassert candidate(7684) == True\n\tassert candidate(28) == True\n\tassert candidate(31) == True\n\tassert candidate(7) == False\n\tassert candidate(29) == True\n\tassert candidate(16) == True\n\tassert candidate(9) == True\n\tassert candidate(27) == True\n\tassert candidate(160) == True\n\tassert candidate(4) == True\n\tassert candidate(63) == True\n\tassert candidate(22) == False\n\tassert candidate(13) == True\n\tassert candidate(9997) == True\n\tassert candidate(1000) == True\n\tassert candidate(1) == True\n\tassert candidate(8) == True\n\tassert candidate(81) == True\n\tassert candidate(21) == True\n\tassert candidate(11) == True\n\tassert candidate(18) == True\n\tassert candidate(2685) == False\n\tassert candidate(2469) == True\n\tassert candidate(15) == False\n\tassert candidate(30) == True\n\tassert candidate(32) == True\n\tassert candidate(23) == True\n\tassert candidate(33) == True\n\tassert candidate(0) == False\n\tassert candidate(5) == False\n\tassert candidate(6) == True\n\tassert candidate(85868) == True\n\tassert candidate(24) == True\n\tassert candidate(17) == False\n\tassert candidate(3) == True\n\tassert candidate(2) == False\n\tassert candidate(26) == True\n\tassert candidate(25) == True\n\tassert candidate(3456) == True\n\tassert candidate(8876) == True\ndef test_check():\n\tcheck(winnerSquareGame)\n# Metadata Difficulty: Hard\n# Metadata Topics: math,dynamic-programming,game-theory\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1283, "filename": "LeetCode_1283_minOperations.py", "content": "from typing import List\n\n\ndef minOperations(target: List[int], arr: List[int]) -> int:\n    \"\"\"\n    You are given an array target that consists of distinct integers and another integer array arr that can have duplicates.\n    In one operation, you can insert any integer at any position in arr. For example, if arr = [1,4,1,2], you can add 3 in the middle and make it [1,4,3,1,2]. Note that you can insert the integer at the very beginning or end of the array.\n    Return the minimum number of operations needed to make target a subsequence of arr.\n    A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not.\n\u00a0\n    Example 1:\n\n    Input: target = [5,1,3], arr = [9,4,2,3,4]\n    Output: 2\n    Explanation: You can add 5 and 1 in such a way that makes arr = [5,9,4,1,2,3,4], then target will be a subsequence of arr.\n\n    Example 2:\n\n    Input: target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]\n    Output: 3\n\n\u00a0\n    Constraints:\n\n    1 <= target.length, arr.length <= 105\n    1 <= target[i], arr[i] <= 109\n    target contains no duplicates.\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(target, list), \"target must be a list.\"\n    assert isinstance(arr, list), \"arr must be a list.\"\n    assert all(isinstance(x, int) for x in target), \"All elements in target must be integers.\"\n    assert all(isinstance(x, int) for x in arr), \"All elements in arr must be integers.\"\n    assert len(target) > 0 and len(arr) > 0, \"Both target and arr must have at least one element.\"\n\n    from bisect import bisect_left\n    pos = {x: i for i, x in enumerate(target)}\n\n    dp = []\n    for a in arr:\n        if a in pos:\n            idx = bisect_left(dp, pos[a])\n            if idx == len(dp):\n                dp.append(pos[a])\n            else:\n                dp[idx] = pos[a]\n    result = len(target) - len(dp)\n\n    # Postconditions\n    assert isinstance(result, int), \"The result must be an integer.\"\n    assert result >= 0, \"The result must be non-negative.\"\n    assert result <= len(target), \"The result cannot exceed the length of the target list.\"\n    assert isinstance(dp, list), \"dp must be a list.\"\n    assert all(isinstance(x, int) for x in dp), \"All elements in dp must be integers.\"\n    assert all(0 <= x < len(target) for x in dp), \"All elements in dp must be valid indices within the target list.\"\n    assert len(dp) <= len(target), \"dp's length cannot exceed the length of the target list.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1,2,3,4,5], [5,4,3,2,1]) == 4\n\tassert candidate([1,2,3,4,5,6,7,8,9,10], [10,9,8,7,6,5,4,3,2,1]) == 9\n\tassert candidate([1,2,3], [1,2,3]) == 0\n\tassert candidate([100,200,300,400,500], [500,400,300,200,100]) == 4\n\tassert candidate([5,1,3], [9,4,2,3,4]) == 2\n\tassert candidate([1,2,3], [2,3,1]) == 1\n\tassert candidate([1,2,3,4,5], [3,4,5,1,2]) == 2\n\tassert candidate([1,2,3,4,5], [2,3,4,5,1]) == 1\n\tassert candidate([1,2,3,4,5,6,7,8,9,10], [2,4,6,8,10,1,3,5,7,9]) == 5\n\tassert candidate([1,2,3], [3,2,1]) == 2\n\tassert candidate([6,4,8,1,3,2], [4,7,6,2,3,8,6,1]) == 3\n\tassert candidate([1,2,3,4,5,6,7,8,9,10], [5,6,7,8,9,10,4,3,2,1]) == 4\ndef test_check():\n\tcheck(minOperations)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,hash-table,binary-search,greedy\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1307, "filename": "LeetCode_1307_check_partitioning.py", "content": "def check_partitioning(s: str) -> bool:\n    \"\"\"\n    Given a string s, return true if it is possible to split the string s into three non-empty palindromic substrings. Otherwise, return false.\u200b\u200b\u200b\u200b\u200b\n    A string is said to be palindrome if it the same string when reversed.\n\u00a0\n    Example 1:\n\n    Input: s = \"abcbdd\"\n    Output: true\n    Explanation: \"abcbdd\" = \"a\" + \"bcb\" + \"dd\", and all three substrings are palindromes.\n\n    Example 2:\n\n    Input: s = \"bcbddxy\"\n    Output: false\n    Explanation: s cannot be split into 3 palindromes.\n\n\u00a0\n    Constraints:\n\n    3 <= s.length <= 2000\n    s\u200b\u200b\u200b\u200b\u200b\u200b consists only of lowercase English letters.\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(s, str), \"Input must be a string.\"\n    assert len(s) >= 3, \"Input string must have at least 3 characters.\"\n    assert len(s) <= 2000, \"Input string must have at most 2000 characters.\"\n    assert all(c.islower() and c.isalpha() for c in s), \"String must consist only of lowercase English letters.\"\n    assert s == s.strip(), \"String should not have leading or trailing whitespace.\"\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    n = len(s)\n    for i in range(0, n - 2):\n        if is_palindrome(s, 0, i):\n            for j in range(i + 1, n - 1):\n                if is_palindrome(s, i + 1, j) and is_palindrome(s, j + 1, n - 1):\n                    result = True\n\n\n                    return result\n\n    result = False\n\n    # Postconditions\n    assert isinstance(result, bool), \"Result must be a boolean.\"\n    assert len(s) >= 3, \"The input string length must be at least 3.\"\n    assert result == False, \"If no valid partition is found, the result must be False.\"\n    assert all(s == s[::-1] for s in [s[:i + 1], s[i + 1:j + 1], s[j + 1:]]) if result else True, \"Each partition must be a palindrome if the result is True.\"\n\n    return result\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\n    \"abcdddddcbcbbbbabbbbbabbbbbabbbbbbabcddddddddd\") == False\n\tassert candidate(\"abcdedcbaefggefg\") == False\n\tassert candidate(\"abcbddxyzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzabcbaabcbaabcba\") == False\n\tassert candidate(\"abcbdd\") == True\n\tassert candidate(\"aabaaba\") == True\n\tassert candidate(\"abcdefghihgfedcbaabcbaabcbaabcba\") == True\n\tassert candidate(\n    \"abcdefedcbazzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzabcbaabcbaabcba\") == True\n\tassert candidate(\n    \"abcbddxyzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzabcbaabcbaabcba\") == False\n\tassert candidate(\"abcbaabcbaabcba\") == True\n\tassert candidate(\"abcdefghihgfedcbaabcba\") == False\n\tassert candidate(\n    \"bcbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxy\"\n) == False\n\tassert candidate(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbcccc\") == True\n\tassert candidate(\"abcdefghijklmnoponmlkjihgfedcbaabcbaabcbaabcbaabcba\") == True\n\tassert candidate(\"aaabbbccc\") == True\n\tassert candidate(\"abcdefedcbazzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzabcbaabcbaabcba\") == True\n\tassert candidate(\n    \"aabaaaabbbbbaababbbbbbbababaabbbbabababbaaabbbabbbaaaabaaaaababaaababbbbababababbbaabaaababaaaabaaababbbbababababbbabbbaaaabbbbabbbbaabbababbbbbabbabababaababaabbbabbbbaabbbaabababaaaaabbbbbabbbaabbaabbaabbababbbbaabbaabbaabbbaabbaabababaaabababbbabababbbabbbabbbbbb\") == False\n\tassert candidate(\n    \"abcbddxyabcdddcbaabcddabcabcddeabcdddabcddcbaabcddd\") == False\n\tassert candidate(\"bcbddxy\") == False\n\tassert candidate(\"aabbcc\") == True\n\tassert candidate(\"aaabbbbcccc\") == True\n\tassert candidate(\"abcbddxy\") == False\n\tassert candidate(\n    \"aabaabaaaabbbbbabbbbbaabaabaaabaabaaaabaaaaababaa\") == False\n\tassert candidate(\"abcdefedcbaabcba\") == False\ndef test_check():\n\tcheck(check_partitioning)\n# Metadata Difficulty: Hard\n# Metadata Topics: string,dynamic-programming\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1425, "filename": "LeetCode_1425_min_trio_degree.py", "content": "from typing import List\n\n\ndef min_trio_degree(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    You are given an undirected graph. You are given an integer n which is the number of nodes in the graph and an array edges, where each edges[i] = [ui, vi] indicates that there is an undirected edge between ui and vi.\n    A connected trio is a set of three nodes where there is an edge between every pair of them.\n    The degree of a connected trio is the number of edges where one endpoint is in the trio, and the other is not.\n    Return the minimum degree of a connected trio in the graph, or -1 if the graph has no connected trios.\n\u00a0\n    Example 1:\n\n\n    Input: n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]\n    Output: 3\n    Explanation: There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above.\n\n    Example 2:\n\n\n    Input: n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]\n    Output: 0\n    Explanation: There are exactly three trios:\n    1) [1,4,3] with degree 0.\n    2) [2,5,6] with degree 2.\n    3) [5,6,7] with degree 2.\n\n\u00a0\n    Constraints:\n\n    2 <= n <= 400\n    edges[i].length == 2\n    1 <= edges.length <= n * (n-1) / 2\n    1 <= ui, vi <= n\n    ui != vi\n    There are no repeated edges.\n\n    \"\"\"\n    ### Canonical solution below ###\n    from collections import defaultdict\n    # Preconditions\n    assert isinstance(n, int) and n >= 2, \"n must be an integer greater than or equal to 2.\"\n    assert all(isinstance(edge, list) and len(edge) == 2 for edge in edges), \"Each edge must be a list of two integers.\"\n    assert all(1 <= ui <= n and 1 <= vi <= n for edge in edges for ui, vi in [edge]), \"Each node in edges must be between 1 and n.\"\n    assert all(ui != vi for ui, vi in edges), \"There should be no self-loops in the edges.\"\n    assert len(edges) <= n * (n - 1) // 2, \"There should be at most n*(n-1)/2 edges.\"\n\n    graph = defaultdict(dict)\n    degree = [0] * (n + 1)\n\n    for u, v in edges:\n        graph[u][v] = graph[v][u] = True\n        degree[u] += 1\n        degree[v] += 1\n\n    min_degree = float('inf')\n    for u, v in edges:\n        for w in range(1, n + 1):\n            if graph[u].get(w) and graph[v].get(w):\n                min_degree = min(min_degree, degree[u] + degree[v] + degree[w] - 6)\n\n    result = min_degree if min_degree != float('inf') else -1\n\n    # Postconditions\n    assert isinstance(result, int), \"Result must be an integer.\"\n    assert result >= -1, \"Result must be -1 or greater.\"\n    assert result == -1 or result >= 0, \"If a trio exists, result must be a non-negative integer.\"\n    assert result == -1 or any(result == (degree[u] + degree[v] + degree[w] - 6) for u, v in edges for w in range(1, n + 1) if graph[u].get(w) and graph[v].get(w)), \"Result should correspond to the minimum trio degree.\"\n    assert result == -1 or n >= 3, \"If a trio exists, n must be at least 3.\"\n    assert result == -1 or any(graph[u].get(w) and graph[v].get(w) for u, v in edges for w in range(1, n + 1)), \"If a trio exists, the graph must have connected trios.\"\n\n    return result\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(7, [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]) == 0\n\tassert candidate(7, [[1, 3], [4, 1], [4, 3], [2, 5], [5, 6], [6, 7], [7, 5], [2, 6]]) == 0\n\tassert candidate(6, [[1,2], [1,3], [3,2], [4,1], [5,2], [3,6]]) == 3\n\tassert candidate(6, [[1,2], [1,3], [2,4], [2,5], [3,6]]) == -1\n\tassert candidate(7, [[1,3], [4,1], [4,3], [2,5], [5,6], [6,7], [7,5], [2,6]]) == 0\n\tassert candidate(7, [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6],[4,6]]) == 3\ndef test_check():\n\tcheck(min_trio_degree)\n# Metadata Difficulty: Hard\n# Metadata Topics: graph\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1468, "filename": "LeetCode_1468_make_string_sorted.py", "content": "def make_string_sorted(s: str) -> int:\n    \"\"\"\n    You are given a string s (0-indexed)\u200b\u200b\u200b\u200b\u200b\u200b. You are asked to perform the following operation on s\u200b\u200b\u200b\u200b\u200b\u200b until you get a sorted string:\n\n    Find the largest index i such that 1 <= i < s.length and s[i] < s[i - 1].\n    Find the largest index j such that i <= j < s.length and s[k] < s[i - 1] for all the possible values of k in the range [i, j] inclusive.\n    Swap the two characters at indices i - 1\u200b\u200b\u200b\u200b and j\u200b\u200b\u200b\u200b\u200b.\n    Reverse the suffix starting at index i\u200b\u200b\u200b\u200b\u200b\u200b.\n\n    Return the number of operations needed to make the string sorted. Since the answer can be too large, return it modulo 109 + 7.\n\u00a0\n    Example 1:\n\n    Input: s = \"cba\"\n    Output: 5\n    Explanation: The simulation goes as follows:\n    Operation 1: i=2, j=2. Swap s[1] and s[2] to get s=\"cab\", then reverse the suffix starting at 2. Now, s=\"cab\".\n    Operation 2: i=1, j=2. Swap s[0] and s[2] to get s=\"bac\", then reverse the suffix starting at 1. Now, s=\"bca\".\n    Operation 3: i=2, j=2. Swap s[1] and s[2] to get s=\"bac\", then reverse the suffix starting at 2. Now, s=\"bac\".\n    Operation 4: i=1, j=1. Swap s[0] and s[1] to get s=\"abc\", then reverse the suffix starting at 1. Now, s=\"acb\".\n    Operation 5: i=2, j=2. Swap s[1] and s[2] to get s=\"abc\", then reverse the suffix starting at 2. Now, s=\"abc\".\n\n    Example 2:\n\n    Input: s = \"aabaa\"\n    Output: 2\n    Explanation: The simulation goes as follows:\n    Operation 1: i=3, j=4. Swap s[2] and s[4] to get s=\"aaaab\", then reverse the substring starting at 3. Now, s=\"aaaba\".\n    Operation 2: i=4, j=4. Swap s[3] and s[4] to get s=\"aaaab\", then reverse the substring starting at 4. Now, s=\"aaaab\".\n\n\u00a0\n    Constraints:\n\n    1 <= s.length <= 3000\n    s\u200b\u200b\u200b\u200b\u200b\u200b consists only of lowercase English letters.\n\n    \"\"\"\n    ### Canonical solution below ###\n    # Preconditions\n    assert isinstance(s, str), \"Input s must be a string.\"\n    assert all('a' <= ch <= 'z' for ch in s), \"String must consist only of lowercase English letters.\"\n    assert 1 <= len(s) <= 3000, \"Length of string s must be between 1 and 3000.\"\n    assert len(set(s)) == len(s) or len(s) != 1, \"All characters in s should not be identical.\"\n    \n    mod = 1000000007\n    n = len(s)\n    fact = [1] * (n + 1)\n    inv = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n        inv[i] = inv[i - 1] * (mod - mod // i) % mod\n\n    ans = 0\n    for i in range(n):\n        less_than = 0\n        for j in range(i + 1, n):\n            if s[j] < s[i]:\n                less_than += 1\n        ans = (ans + less_than * fact[n - i - 1]) % mod\n    \n    # Postconditions\n    assert isinstance(ans, int), \"The result should be an integer.\"\n    assert 0 <= ans < mod, f\"Result should be in the range [0, {mod-1}].\"\n    assert ans >= 0, \"Result cannot be negative.\"\n    assert len(s) > 1 or ans == 0, \"For single character strings, the result must be 0.\"\n    assert ans == 0 or any(s[i] > s[i+1] for i in range(len(s) - 1)), \"If the result is non-zero, the string must have decreasing elements.\"\n    assert ans == 0 or s != ''.join(sorted(s)), \"If the string is already sorted, the result should be 0.\"\n    \n    return ans\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\n    \"cba\"\n) == 5\n\tassert candidate(\n    \"a\"*3000\n) == 0\n\tassert candidate(\"aaa\") == 0\n\tassert candidate(\"a\"*1000) == 0\n\tassert candidate(\"abc\") == 0\n\tassert candidate(\n    \"aaaabbbb\"\n) == 0\n\tassert candidate(\"cdcd\") == 2\n\tassert candidate(\n    \"ccccccccccccccc\"\n) == 0\n\tassert candidate(\"abba\") == 3\n\tassert candidate(\n    \"abcd\"\n) == 0\n\tassert candidate(\"cba\") == 5\n\tassert candidate(\"abcdefg\") == 0\ndef test_check():\n\tcheck(make_string_sorted)\n# Metadata Difficulty: Hard\n# Metadata Topics: math,string,combinatorics\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1528, "filename": "LeetCode_1528_longestSubsequenceRepeatedK.py", "content": "def longestSubsequenceRepeatedK(s: str, k: int) -> str:\n    \"\"\"\n    You are given a string s of length n, and an integer k. You are tasked to find the longest subsequence repeated k times in string s.\n    A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n    A subsequence seq is repeated k times in the string s if seq * k is a subsequence of s, where seq * k represents a string constructed by concatenating seq k times.\n\n    For example, \"bba\" is repeated 2 times in the string \"bababcba\", because the string \"bbabba\", constructed by concatenating \"bba\" 2 times, is a subsequence of the string \"bababcba\".\n\n    Return the longest subsequence repeated k times in string s. If multiple such subsequences are found, return the lexicographically largest one. If there is no such subsequence, return an empty string.\n\u00a0\n    Example 1:\n\n\n    Input: s = \"letsleetcode\", k = 2\n    Output: \"let\"\n    Explanation: There are two longest subsequences repeated 2 times: \"let\" and \"ete\".\n    \"let\" is the lexicographically largest one.\n\n    Example 2:\n\n    Input: s = \"bb\", k = 2\n    Output: \"b\"\n    Explanation: The longest subsequence repeated 2 times is \"b\".\n\n    Example 3:\n\n    Input: s = \"ab\", k = 2\n    Output: \"\"\n    Explanation: There is no subsequence repeated 2 times. Empty string is returned.\n\n\u00a0\n    Constraints:\n\n    n == s.length\n    2 <= n, k <= 2000\n    2 <= n < k * 8\n    s consists of lowercase English letters.\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(s, str), \"Input s must be a string.\"\n    assert isinstance(k, int) and k > 0, \"Input k must be a positive integer.\"\n    assert all('a' <= c <= 'z' for c in s), \"String s must contain only lowercase English letters.\"\n\n    count = [0] * 26\n    for c in s:\n        count[ord(c) - ord('a')] += 1\n    seq = \"\".join(chr(i + ord('a')) * (count[i] // k) for i in range(26) if count[i] >= k)\n\n    def dp(i, j):\n        if (i, j) in memo:\n            return memo[(i, j)]\n        if i >= len(seq) or j >= len(seq):\n            return 0\n        if seq[i] == seq[j]:\n            res = 1 + dp(i + 1, j + 1)\n        else:\n            res = max(dp(i + 1, j), dp(i, j + 1))\n        memo[(i, j)] = res\n        return res\n\n    memo = {}\n    res = []\n    i, j = 0, 0\n    while j < len(seq) and len(res) < len(seq) // k:\n        if not res or seq[j] > res[-1]:\n            if dp(i, j) >= (len(seq) // k - len(res)) * 2:\n                res.append(seq[j])\n                i = j + 1\n        j += 1\n\n    result = \"\".join(res)\n\n    # Postconditions\n    assert isinstance(result, str), \"The result must be a string.\"\n    assert len(result) <= len(s), \"The result string should not be longer than the input string s.\"\n    assert all(c in s for c in result), \"All characters in the result must exist in the input string s.\"\n    assert len(result) == 0 or s.count(result) >= k, \"The result subsequence must appear at least k times in s.\"\n    assert result == \"\".join(sorted(result)) or result == max(\"\".join(sorted(result)), key=lambda x: (s.find(x), x)), \"The result should be the lexicographically largest valid subsequence.\"\n\n    return result\n\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"ab\", 2) == \"\"\n\tassert candidate(\"\", 1) == \"\"\n\tassert candidate(\n    \"ab\", 2) == \"\"\n\tassert candidate(\"abcde\", 1) == \"\"\n\tassert candidate(\"bbcbbabcba\", 6) == \"\"\n\tassert candidate(\"bbcbbabcba\", 4) == \"\"\n\tassert candidate(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", 1001) == \"\"\n\tassert candidate(\"\", 2) == \"\"\n\tassert candidate(\"\", 1001) == \"\"\n\tassert candidate(\"bbcbbabcba\", 7) == \"\"\n\tassert candidate(\"abcde\", 3) == \"\"\n\tassert candidate(\n    \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", 3) == \"a\"\n\tassert candidate(\"abacadaeafagahaijj\", 2) == \"a\"\n\tassert candidate(\"aabbccddeeffgghhiijj\", 3) == \"\"\n\tassert candidate(\"bbcbbabcba\", 5) == \"\"\n\tassert candidate(\"abacadaeafagahaiaj\", 2) == \"a\"\n\tassert candidate(\"abababab\", 2) == \"ab\"\n\tassert candidate(\"ab\", 2) == \"\", \"Longest subsequence should be: ''\"\n\tassert candidate(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", 1000) == \"\"\ndef test_check():\n\tcheck(longestSubsequenceRepeatedK)\n# Metadata Difficulty: Hard\n# Metadata Topics: string,backtracking,greedy,counting,enumeration\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1635, "filename": "LeetCode_1635_longest_subsequence_repeated_k.py", "content": "def longest_subsequence_repeated_k(s: str, k: int) -> str:\n    \"\"\"\n    You are given a string s of length n, and an integer k. You are tasked to find the longest subsequence repeated k times in string s.\n    A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n    A subsequence seq is repeated k times in the string s if seq * k is a subsequence of s, where seq * k represents a string constructed by concatenating seq k times.\n\n    For example, \"bba\" is repeated 2 times in the string \"bababcba\", because the string \"bbabba\", constructed by concatenating \"bba\" 2 times, is a subsequence of the string \"bababcba\".\n\n    Return the longest subsequence repeated k times in string s. If multiple such subsequences are found, return the lexicographically largest one. If there is no such subsequence, return an empty string.\n\u00a0\n    Example 1:\n\n\n    Input: s = \"letsleetcode\", k = 2\n    Output: \"let\"\n    Explanation: There are two longest subsequences repeated 2 times: \"let\" and \"ete\".\n    \"let\" is the lexicographically largest one.\n\n    Example 2:\n\n    Input: s = \"bb\", k = 2\n    Output: \"b\"\n    Explanation: The longest subsequence repeated 2 times is \"b\".\n\n    Example 3:\n\n    Input: s = \"ab\", k = 2\n    Output: \"\"\n    Explanation: There is no subsequence repeated 2 times. Empty string is returned.\n\n\u00a0\n    Constraints:\n\n    n == s.length\n    2 <= n, k <= 2000\n    2 <= n < k * 8\n    s consists of lowercase English letters.\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(s, str), \"Input s must be a string.\"\n    assert isinstance(k, int) and k > 0, \"Input k must be a positive integer.\"\n    assert all('a' <= c <= 'z' for c in s), \"String s must contain only lowercase English letters.\"\n\n    counts = [0] * 26\n    for c in s:\n        counts[ord(c) - ord('a')] += 1\n    seq = ''.join([chr(i + ord('a')) * (counts[i] // k) for i in range(25, -1, -1)])\n\n    # Postconditions\n    assert isinstance(seq, str), \"The result must be a string.\"\n    assert len(seq) <= len(s), \"The result string should not be longer than the input string s.\"\n    assert all(c in s for c in seq), \"All characters in the result must exist in the input string s.\"\n    assert seq == \"\".join(sorted(seq, reverse=True)), \"The result should be the lexicographically largest valid subsequence.\"\n\n    return seq\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate(\"aaaa\", 1) == \"aaaa\"\n\tassert candidate(\"aabbccddeeff\", 3) == \"\"\n\tassert candidate(\"abcdef\", 3) == \"\"\n\tassert candidate(\n    \"ab\", 2) == \"\"\n\tassert candidate(\n    \"bb\", 2) == \"b\"\n\tassert candidate(\"abcdef\", 1) == \"fedcba\"\n\tassert candidate(\"abacadaea\", 2) == \"aa\"\n\tassert candidate(\"ab\", 2) == \"\"\n\tassert candidate(\"bb\", 2) == \"b\"\n\tassert candidate(\"aaaaaa\", 3) == \"aa\"\n\tassert candidate(\"bb\", 1) == \"bb\"\n\tassert candidate(\"\", 2) == \"\"\n\tassert candidate(\"abcdef\", 2) == \"\"\n\tassert candidate(\n    \"bba\", 2) == \"b\"\n\tassert candidate(\"abbb\", 4) == \"\"\n\tassert candidate(\"zzzzzzzzzzzzz\", 1) == \"zzzzzzzzzzzzz\"\n\tassert candidate(\"aaaaaa\", 7) == \"\"\n\tassert candidate(\"fdaebc\", 1) == \"fedcba\"\ndef test_check():\n\tcheck(longest_subsequence_repeated_k)\n# Metadata Difficulty: Hard\n# Metadata Topics: string,backtracking,greedy,counting,enumeration\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1677, "filename": "LeetCode_1677_count_pyramids.py", "content": "from typing import List\n\n\ndef count_pyramids(grid: List[List[int]]) -> int:\n    \"\"\"\n    A farmer has a rectangular grid of land with m rows and n columns that can be divided into unit cells. Each cell is either fertile (represented by a 1) or barren (represented by a 0). All cells outside the grid are considered barren.\n    A pyramidal plot of land can be defined as a set of cells with the following criteria:\n\n    The number of cells in the set has to be greater than 1 and all cells must be fertile.\n    The apex of a pyramid is the topmost cell of the pyramid. The height of a pyramid is the number of rows it covers. Let (r, c) be the apex of the pyramid, and its height be h. Then, the plot comprises of cells (i, j) where r <= i <= r + h - 1 and c - (i - r) <= j <= c + (i - r).\n\n    An inverse pyramidal plot of land can be defined as a set of cells with similar criteria:\n\n    The number of cells in the set has to be greater than 1 and all cells must be fertile.\n    The apex of an inverse pyramid is the bottommost cell of the inverse pyramid. The height of an inverse pyramid is the number of rows it covers. Let (r, c) be the apex of the pyramid, and its height be h. Then, the plot comprises of cells (i, j) where r - h + 1 <= i <= r and c - (r - i) <= j <= c + (r - i).\n\n    Some examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells.\n\n    Given a 0-indexed m x n binary matrix grid representing the farmland, return the total number of pyramidal and inverse pyramidal plots that can be found in grid.\n\u00a0\n    Example 1:\n\n\n    Input: grid = [[0,1,1,0],[1,1,1,1]]\n    Output: 2\n    Explanation: The 2 possible pyramidal plots are shown in blue and red respectively.\n    There are no inverse pyramidal plots in this grid. \n    Hence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2.\n\n    Example 2:\n\n\n    Input: grid = [[1,1,1],[1,1,1]]\n    Output: 2\n    Explanation: The pyramidal plot is shown in blue, and the inverse pyramidal plot is shown in red. \n    Hence the total number of plots is 1 + 1 = 2.\n\n    Example 3:\n\n\n    Input: grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]\n    Output: 13\n    Explanation: There are 7 pyramidal plots, 3 of which are shown in the 2nd and 3rd figures.\n    There are 6 inverse pyramidal plots, 2 of which are shown in the last figure.\n    The total number of plots is 7 + 6 = 13.\n\n\u00a0\n    Constraints:\n\n    m == grid.length\n    n == grid[i].length\n    1 <= m, n <= 1000\n    1 <= m * n <= 105\n    grid[i][j] is either 0 or 1.\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(grid, list), \"grid must be a list\"\n    assert all(isinstance(row, list) for row in grid), \"each row in grid must be a list\"\n    assert len(grid) >= 1 and len(grid) <= 1000, \"grid must have between 1 and 1000 rows\"\n    assert all(1 <= len(row) <= 1000 for row in grid), \"each row in grid must have between 1 and 1000 columns\"\n\n    m, n, count = len(grid), len(grid[0]), 0\n    for i in range(1, m - 1):\n        for j in range(1, n - 1):\n            if grid[i][j] == grid[i - 1][j] + grid[i][j - 1] - grid[i - 1][j - 1] \\\n                    and grid[i][j] == grid[i + 1][j] + grid[i][j + 1] - grid[i + 1][j + 1]:\n                count += grid[i][j]\n    assert isinstance(count, int), \"count must be an integer\"\n    assert count >= 0, \"count must be non-negative\"\n    assert count <= (m * n * (min(m, n) // 2)), \"count should not exceed the theoretical maximum based on grid size\"\n    assert all(isinstance(row, list) for row in grid), \"grid should remain a list of lists\"\n    assert isinstance(grid, list), \"grid should remain unchanged in type\"\n\n    return count\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([[0,0,0],[0,0,0],[0,0,0]]) == 0\n\tassert candidate([[0,1,0],[1,2,1],[0,1,0]]) == 2\n\tassert candidate([[2,2,2],[2,2,2],[2,2,2]]) == 2\n\tassert candidate([[1,2,3],[4,0,6],[7,8,9]]) == 0\ndef test_check():\n\tcheck(count_pyramids)\n# Metadata Difficulty: Hard\n# Metadata Topics: array,dynamic-programming,matrix\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1917, "filename": "LeetCode_1917_countTriplets.py", "content": "from typing import List\n\n\ndef countTriplets(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array nums, return the number of AND triples.\n    An AND triple is a triple of indices (i, j, k) such that:\n\n    0 <= i < nums.length\n    0 <= j < nums.length\n    0 <= k < nums.length\n    nums[i] & nums[j] & nums[k] == 0, where & represents the bitwise-AND operator.\n\n\u00a0\n    Example 1:\n\n    Input: nums = [2,1,3]\n    Output: 12\n    Explanation: We could choose the following i, j, k triples:\n    (i=0, j=0, k=1) : 2 & 2 & 1\n    (i=0, j=1, k=0) : 2 & 1 & 2\n    (i=0, j=1, k=1) : 2 & 1 & 1\n    (i=0, j=1, k=2) : 2 & 1 & 3\n    (i=0, j=2, k=1) : 2 & 3 & 1\n    (i=1, j=0, k=0) : 1 & 2 & 2\n    (i=1, j=0, k=1) : 1 & 2 & 1\n    (i=1, j=0, k=2) : 1 & 2 & 3\n    (i=1, j=1, k=0) : 1 & 1 & 2\n    (i=1, j=2, k=0) : 1 & 3 & 2\n    (i=2, j=0, k=1) : 3 & 2 & 1\n    (i=2, j=1, k=0) : 3 & 1 & 2\n\n    Example 2:\n\n    Input: nums = [0,0,0]\n    Output: 27\n\n\u00a0\n    Constraints:\n\n    1 <= nums.length <= 1000\n    0 <= nums[i] < 216\n\n    \"\"\"\n    ### Canonical solution below ###\n    assert isinstance(nums, list), \"nums should be a list\"\n    assert all(isinstance(x, int) for x in nums), \"All elements in nums should be integers\"\n    assert all(0 <= x < 2**16 for x in nums), \"Elements should be within the range 0 <= x < 2^16\"\n    assert len(nums) > 0, \"nums should not be empty\"\n    assert len(nums) <= 1000, \"nums length should not exceed 1000\"\n\n    count = 0\n    n = len(nums)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\n                    count += 1\n\n    # Postconditions\n    assert isinstance(count, int), \"Result should be an integer\"\n    assert count >= 0, \"Result should not be negative\"\n    assert count <= n**3, \"Result should not exceed the total number of possible triples\"\n    assert isinstance(nums, list), \"nums should still be a list\"\n    assert all(isinstance(x, int) for x in nums), \"All elements in nums should still be integers\"\n    assert len(nums) > 0, \"nums should not have changed to empty\"\n    assert len(nums) <= 1000, \"nums length should still not exceed 1000\"\n\n    return count\n\n\n\n### Unit tests below ###\ndef check(candidate):\n\tassert candidate([1,2,3,4,5,6]) == 20\n\tassert candidate([1,2,3,4,5,6,7,8,9,10]) == 120\n\tassert candidate([1,1,1,1,1]) == 0\n\tassert candidate([10,20,30,40,50,60,70,80,90,100]) == 120\n\tassert candidate([1,2,3]) == 1\n\tassert candidate([5,4,3,2,1]) == 10\n\tassert candidate([2,2,2,2,2,2,2]) == 0\n\tassert candidate([4,4,2,4,3]) == 3\n\tassert candidate([1,1,1,4,4,4]) == 0\n\tassert candidate([1,2,3,4,5]) == 10\ndef test_check():\n\tcheck(countTriplets)\n     \n\ntest_check()\n# Metadata Difficulty: Hard\n# Metadata Topics: array,hash-table,bit-manipulation\n# Metadata Coverage: 100\n\n\ntest_check()\n"}
{"id": 1953, "filename": "LeetCode_1953_countPartitions.py", "content": "from typing import List\nimport unittest\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    \n    assert isinstance(numbers, list)\n    assert isinstance(threshold, float)\n\n    sorted_numbers = sorted(numbers)\n    assert isinstance(sorted_numbers, list)\n    assert all(isinstance(num, float) for num in sorted_numbers)\n    assert all(abs(num - threshold) >= 0 for num in sorted_numbers)\n\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False\n\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\ndef test_check():\n    check(has_close_elements)\n\ntest_check()\n"}
